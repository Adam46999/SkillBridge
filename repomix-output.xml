This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.VSCodeCounter/2025-12-10_22-45-17/details.md
.VSCodeCounter/2025-12-10_22-45-17/diff-details.md
.VSCodeCounter/2025-12-10_22-45-17/diff.csv
.VSCodeCounter/2025-12-10_22-45-17/diff.md
.VSCodeCounter/2025-12-10_22-45-17/diff.txt
.VSCodeCounter/2025-12-10_22-45-17/results.csv
.VSCodeCounter/2025-12-10_22-45-17/results.json
.VSCodeCounter/2025-12-10_22-45-17/results.md
.VSCodeCounter/2025-12-10_22-45-17/results.txt
all_mobile_paths.txt
app.json
app/_layout.tsx
app/(auth)/_layout.tsx
app/(auth)/login/index.tsx
app/(auth)/shared/AuthButton.tsx
app/(auth)/shared/AuthHeader.tsx
app/(auth)/shared/AuthTextField.tsx
app/(auth)/shared/InlineError.tsx
app/(auth)/shared/mapApiError.ts
app/(auth)/shared/PasswordField.tsx
app/(auth)/shared/styles.ts
app/(auth)/shared/useAuthFieldFocus.ts
app/(auth)/shared/useAuthRedirect.ts
app/(auth)/shared/validators.ts
app/(auth)/signup/index.tsx
app/(tabs)/_layout.tsx
app/(tabs)/chats/(components)/ChatHeader.tsx
app/(tabs)/chats/(components)/ChatInput.tsx
app/(tabs)/chats/(components)/MessageBubble.tsx
app/(tabs)/chats/(components)/MessagesList.tsx
app/(tabs)/chats/(components)/TopLoadingHint.tsx
app/(tabs)/chats/[conversationId].tsx
app/(tabs)/chats/index.tsx
app/(tabs)/explore.tsx
app/(tabs)/index.tsx
app/find-mentor.tsx
app/index.tsx
app/login.tsx
app/manage-skills-to-learn/AddSkillToLearnForm.tsx
app/manage-skills-to-learn/CategorySelector.tsx
app/manage-skills-to-learn/index.tsx
app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
app/manage-skills-to-learn/SkillChip.tsx
app/manage-skills-to-learn/skillData.ts
app/manage-skills-to-learn/SkillsToLearnList.tsx
app/manage-skills-to-learn/SubCategorySelector.tsx
app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
app/manage-skills-to-learn/types.ts
app/manage-skills-to-learn/useManageSkillsToLearn.ts
app/manage-skills-to-teach/AddSkillToTeachForm.tsx
app/manage-skills-to-teach/index.tsx
app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
app/manage-skills-to-teach/SkillsToTeachList.tsx
app/manage-skills-to-teach/types.ts
app/manage-skills-to-teach/useManageSkillsToTeach.ts
app/mentor/[id].tsx
app/modal.tsx
app/profile.tsx
app/screens/components/MatchReadinessStrip.tsx
app/screens/components/PillButton.tsx
app/screens/components/ProfileStatusCard.tsx
app/screens/components/QuickEditBar.tsx
app/screens/components/SkeletonCard.tsx
app/screens/components/ViewProfileCTA.tsx
app/screens/home/components/CollapsibleCard.tsx
app/screens/home/components/home.helpers.ts
app/screens/home/components/HomeEmptyState.tsx
app/screens/home/components/HomeHero.tsx
app/screens/home/components/InboxPreview.tsx
app/screens/home/components/MiniStatsRow.tsx
app/screens/home/components/NextBestActionCard.tsx
app/screens/home/components/SectionHeader.tsx
app/screens/home/components/SetupProgressHeader.tsx
app/screens/home/components/StickyPrimaryCTA.tsx
app/screens/homescreen.styles.ts
app/screens/HomeScreen.tsx
app/sessions/api/sessionsApi.ts
app/sessions/components/SessionCard.tsx
app/sessions/index.tsx
app/sessions/request.tsx
app/sessions/room/[id]/components/ChatPanel.tsx
app/sessions/room/[id]/components/FilesPanel.tsx
app/sessions/room/[id]/components/MessageBubble.tsx
app/sessions/room/[id]/components/RoomHeader.tsx
app/sessions/room/[id]/hooks/useSessionChat.ts
app/sessions/room/[id]/hooks/useSessionFiles.ts
app/sessions/room/[id]/hooks/useSessionRoom.ts
app/sessions/room/[id]/index.tsx
app/sessions/room/[id]/utils/presence.ts
app/sessions/room/[id]/utils/zoom.ts
app/sessions/room/[id]old.tsx
app/sessions/screens/(components)/SessionsEmptyState.tsx
app/sessions/screens/(components)/SessionsHeader.tsx
app/sessions/screens/(components)/SessionsRowRenderer.tsx
app/sessions/screens/(components)/SessionsRows.tsx
app/sessions/screens/(components)/SessionsSummaryBar.tsx
app/sessions/screens/(hooks)/useSessionsData.ts
app/sessions/screens/request/(hooks)/useRequestSessionForm.ts
app/sessions/screens/request/components/MentorCard.tsx
app/sessions/screens/request/components/RequestTopBar.tsx
app/sessions/screens/request/components/StepNote.tsx
app/sessions/screens/request/components/StepPills.tsx
app/sessions/screens/request/components/StepSchedule.tsx
app/sessions/screens/request/components/StepSkillLevel.tsx
app/sessions/screens/request/components/StickyFooter.tsx
app/sessions/screens/request/components/UI.tsx
app/sessions/screens/request/RequestSessionScreen.tsx
app/sessions/screens/request/styles.ts
app/sessions/screens/SessionsScreen.tsx
app/sessions/utils/formatSession.ts
app/shared/levels.ts
app/shared/profileCompletion.ts
app/signup.tsx
app/weekly-availability/components.tsx
app/weekly-availability/index.tsx
app/weekly-availability/SaveBar.tsx
app/weekly-availability/styles.ts
app/weekly-availability/TimeField.tsx
app/weekly-availability/useWeeklyAvailability.ts
components/external-link.tsx
components/haptic-tab.tsx
components/hello-wave.tsx
components/parallax-scroll-view.tsx
components/themed-text.tsx
components/themed-view.tsx
components/ui/collapsible.tsx
components/ui/icon-symbol.ios.tsx
components/ui/icon-symbol.tsx
constants/theme.ts
eslint.config.js
filetree_mobile.txt
hooks/use-color-scheme.ts
hooks/use-color-scheme.web.ts
hooks/use-theme-color.ts
lib/api.ts
lib/availabilityStorage.ts
lib/chat/api.ts
lib/chat/socket.ts
lib/profileCompletion.ts
lib/sectionStatus.ts
o -20
package.json
README.md
scripts/reset-project.js
server/.env
server/matching/embeddingService.js
server/matching/index.js
server/matching/localMatcher.js
server/matching/normalize.js
server/matching/openaiMatcher.js
server/matching/scoreUtils.js
server/models/Conversation.js
server/models/Message.js
server/models/PointTransaction.js
server/models/Rating.js
server/models/Session.js
server/models/User.js
server/package.json
server/routes/chat.js
server/routes/points.routes.js
server/routes/ratings.js
server/routes/sessions.js
server/routes/users.js
server/server.js
server/services/gamificationRules.js
server/services/matchingService.js
server/services/pointsService.js
server/services/ratingsService.js
tracked_files.txt
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

# generated native folders
/ios
/android
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/details.md">
# Details

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 60 files,  21684 codes, 260 comments, 805 blanks, all 22749 lines

[Summary](results.md) / Details / [Diff Summary](diff.md) / [Diff Details](diff-details.md)

## Files
| filename | language | code | comment | blank | total |
| :--- | :--- | ---: | ---: | ---: | ---: |
| [README.md](/README.md) | Markdown | 31 | 0 | 20 | 51 |
| [app.json](/app.json) | JSON with Comments | 48 | 0 | 1 | 49 |
| [app/(tabs)/\_layout.tsx](/app/(tabs)/_layout.tsx) | TypeScript JSX | 4 | 0 | 2 | 6 |
| [app/(tabs)/explore.tsx](/app/(tabs)/explore.tsx) | TypeScript JSX | 28 | 0 | 3 | 31 |
| [app/(tabs)/index.tsx](/app/(tabs)/index.tsx) | TypeScript JSX | 4 | 0 | 2 | 6 |
| [app/\_layout.tsx](/app/_layout.tsx) | TypeScript JSX | 20 | 0 | 5 | 25 |
| [app/find-mentor.tsx](/app/find-mentor.tsx) | TypeScript JSX | 420 | 8 | 32 | 460 |
| [app/index.tsx](/app/index.tsx) | TypeScript JSX | 4 | 0 | 2 | 6 |
| [app/login.tsx](/app/login.tsx) | TypeScript JSX | 202 | 4 | 17 | 223 |
| [app/manage-skills-to-learn/AddSkillToLearnForm.tsx](/app/manage-skills-to-learn/AddSkillToLearnForm.tsx) | TypeScript JSX | 195 | 1 | 21 | 217 |
| [app/manage-skills-to-learn/CategorySelector.tsx](/app/manage-skills-to-learn/CategorySelector.tsx) | TypeScript JSX | 90 | 1 | 5 | 96 |
| [app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx](/app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx) | TypeScript JSX | 483 | 21 | 47 | 551 |
| [app/manage-skills-to-learn/SkillChip.tsx](/app/manage-skills-to-learn/SkillChip.tsx) | TypeScript JSX | 126 | 1 | 12 | 139 |
| [app/manage-skills-to-learn/SkillsToLearnList.tsx](/app/manage-skills-to-learn/SkillsToLearnList.tsx) | TypeScript JSX | 241 | 2 | 14 | 257 |
| [app/manage-skills-to-learn/SubCategorySelector.tsx](/app/manage-skills-to-learn/SubCategorySelector.tsx) | TypeScript JSX | 97 | 1 | 6 | 104 |
| [app/manage-skills-to-learn/SuggestedSkillsGrid.tsx](/app/manage-skills-to-learn/SuggestedSkillsGrid.tsx) | TypeScript JSX | 121 | 1 | 11 | 133 |
| [app/manage-skills-to-learn/index.tsx](/app/manage-skills-to-learn/index.tsx) | TypeScript JSX | 390 | 8 | 30 | 428 |
| [app/manage-skills-to-learn/skillData.ts](/app/manage-skills-to-learn/skillData.ts) | TypeScript | 160 | 2 | 6 | 168 |
| [app/manage-skills-to-learn/styles.ts](/app/manage-skills-to-learn/styles.ts) | TypeScript | 0 | 0 | 1 | 1 |
| [app/manage-skills-to-learn/types.ts](/app/manage-skills-to-learn/types.ts) | TypeScript | 0 | 0 | 1 | 1 |
| [app/manage-skills-to-learn/useManageSkillsToLearn.ts](/app/manage-skills-to-learn/useManageSkillsToLearn.ts) | TypeScript | 245 | 19 | 53 | 317 |
| [app/manage-skills-to-teach/AddSkillToTeachForm.tsx](/app/manage-skills-to-teach/AddSkillToTeachForm.tsx) | TypeScript JSX | 196 | 1 | 21 | 218 |
| [app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx](/app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx) | TypeScript JSX | 487 | 21 | 49 | 557 |
| [app/manage-skills-to-teach/SkillsToTeachList.tsx](/app/manage-skills-to-teach/SkillsToTeachList.tsx) | TypeScript JSX | 242 | 2 | 14 | 258 |
| [app/manage-skills-to-teach/index.tsx](/app/manage-skills-to-teach/index.tsx) | TypeScript JSX | 5 | 1 | 2 | 8 |
| [app/manage-skills-to-teach/useManageSkillsToTeach.ts](/app/manage-skills-to-teach/useManageSkillsToTeach.ts) | TypeScript | 251 | 17 | 53 | 321 |
| [app/modal.tsx](/app/modal.tsx) | TypeScript JSX | 26 | 0 | 4 | 30 |
| [app/screens/homescreen.tsx](/app/screens/homescreen.tsx) | TypeScript JSX | 674 | 12 | 38 | 724 |
| [app/sessions.tsx](/app/sessions.tsx) | TypeScript JSX | 0 | 0 | 1 | 1 |
| [app/signup.tsx](/app/signup.tsx) | TypeScript JSX | 235 | 1 | 21 | 257 |
| [app/weekly-availability/TimeField.tsx](/app/weekly-availability/TimeField.tsx) | TypeScript JSX | 110 | 4 | 15 | 129 |
| [app/weekly-availability/components.tsx](/app/weekly-availability/components.tsx) | TypeScript JSX | 115 | 1 | 10 | 126 |
| [app/weekly-availability/index.tsx](/app/weekly-availability/index.tsx) | TypeScript JSX | 256 | 12 | 37 | 305 |
| [app/weekly-availability/styles.ts](/app/weekly-availability/styles.ts) | TypeScript | 287 | 9 | 14 | 310 |
| [app/weekly-availability/useWeeklyAvailability.ts](/app/weekly-availability/useWeeklyAvailability.ts) | TypeScript | 119 | 1 | 18 | 138 |
| [components/external-link.tsx](/components/external-link.tsx) | TypeScript JSX | 21 | 2 | 3 | 26 |
| [components/haptic-tab.tsx](/components/haptic-tab.tsx) | TypeScript JSX | 16 | 1 | 2 | 19 |
| [components/hello-wave.tsx](/components/hello-wave.tsx) | TypeScript JSX | 18 | 0 | 2 | 20 |
| [components/parallax-scroll-view.tsx](/components/parallax-scroll-view.tsx) | TypeScript JSX | 73 | 0 | 7 | 80 |
| [components/themed-text.tsx](/components/themed-text.tsx) | TypeScript JSX | 55 | 0 | 6 | 61 |
| [components/themed-view.tsx](/components/themed-view.tsx) | TypeScript JSX | 10 | 0 | 5 | 15 |
| [components/ui/collapsible.tsx](/components/ui/collapsible.tsx) | TypeScript JSX | 40 | 0 | 6 | 46 |
| [components/ui/icon-symbol.ios.tsx](/components/ui/icon-symbol.ios.tsx) | TypeScript JSX | 31 | 0 | 2 | 33 |
| [components/ui/icon-symbol.tsx](/components/ui/icon-symbol.tsx) | TypeScript JSX | 26 | 11 | 5 | 42 |
| [constants/theme.ts](/constants/theme.ts) | TypeScript | 41 | 8 | 5 | 54 |
| [eslint.config.js](/eslint.config.js) | JavaScript JSX | 8 | 1 | 2 | 11 |
| [hooks/use-color-scheme.ts](/hooks/use-color-scheme.ts) | TypeScript | 1 | 0 | 1 | 2 |
| [hooks/use-color-scheme.web.ts](/hooks/use-color-scheme.web.ts) | TypeScript | 13 | 3 | 6 | 22 |
| [hooks/use-theme-color.ts](/hooks/use-theme-color.ts) | TypeScript | 14 | 4 | 4 | 22 |
| [lib/api.ts](/lib/api.ts) | TypeScript | 157 | 31 | 32 | 220 |
| [package-lock.json](/package-lock.json) | JSON | 13,421 | 0 | 1 | 13,422 |
| [package.json](/package.json) | JSON | 49 | 0 | 1 | 50 |
| [scripts/reset-project.js](/scripts/reset-project.js) | JavaScript JSX | 89 | 10 | 14 | 113 |
| [server/.env](/server/.env) | Dotenv | 3 | 0 | 1 | 4 |
| [server/models/User.js](/server/models/User.js) | JavaScript JSX | 37 | 1 | 10 | 48 |
| [server/package-lock.json](/server/package-lock.json) | JSON | 1,203 | 0 | 1 | 1,204 |
| [server/package.json](/server/package.json) | JSON | 6 | 0 | 1 | 7 |
| [server/server.js](/server/server.js) | JavaScript JSX | 297 | 19 | 65 | 381 |
| [server/services/matchingService.js](/server/services/matchingService.js) | JavaScript JSX | 126 | 18 | 34 | 178 |
| [tsconfig.json](/tsconfig.json) | JSON with Comments | 17 | 0 | 1 | 18 |

[Summary](results.md) / Details / [Diff Summary](diff.md) / [Diff Details](diff-details.md)
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff-details.md">
# Diff Details

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 0 files,  0 codes, 0 comments, 0 blanks, all 0 lines

[Summary](results.md) / [Details](details.md) / [Diff Summary](diff.md) / Diff Details

## Files
| filename | language | code | comment | blank | total |
| :--- | :--- | ---: | ---: | ---: | ---: |

[Summary](results.md) / [Details](details.md) / [Diff Summary](diff.md) / Diff Details
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff.csv">
"filename", "language", "", "comment", "blank", "total"
"Total", "-", , 0, 0, 0
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff.md">
# Diff Summary

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 0 files,  0 codes, 0 comments, 0 blanks, all 0 lines

[Summary](results.md) / [Details](details.md) / Diff Summary / [Diff Details](diff-details.md)

## Languages
| language | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |

## Directories
| path | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |

[Summary](results.md) / [Details](details.md) / Diff Summary / [Diff Details](diff-details.md)
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff.txt">
Date : 2025-12-10 22:45:17
Directory : c:\Users\shet_\our-final-app
Total : 0 files,  0 codes, 0 comments, 0 blanks, all 0 lines

Languages
+----------+------------+------------+------------+------------+------------+
| language | files      | code       | comment    | blank      | total      |
+----------+------------+------------+------------+------------+------------+
+----------+------------+------------+------------+------------+------------+

Directories
+------+------------+------------+------------+------------+------------+
| path | files      | code       | comment    | blank      | total      |
+------+------------+------------+------------+------------+------------+
+------+------------+------------+------------+------------+------------+

Files
+----------+----------+------------+------------+------------+------------+
| filename | language | code       | comment    | blank      | total      |
+----------+----------+------------+------------+------------+------------+
| Total    |          |          0 |          0 |          0 |          0 |
+----------+----------+------------+------------+------------+------------+
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.csv">
"filename", "language", "JSON", "JSON with Comments", "JavaScript JSX", "TypeScript", "Dotenv", "Markdown", "TypeScript JSX", "comment", "blank", "total"
"c:\Users\shet_\our-final-app\README.md", "Markdown", 0, 0, 0, 0, 0, 31, 0, 0, 20, 51
"c:\Users\shet_\our-final-app\app.json", "JSON with Comments", 0, 48, 0, 0, 0, 0, 0, 0, 1, 49
"c:\Users\shet_\our-final-app\app\(tabs)\_layout.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 4, 0, 2, 6
"c:\Users\shet_\our-final-app\app\(tabs)\explore.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 28, 0, 3, 31
"c:\Users\shet_\our-final-app\app\(tabs)\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 4, 0, 2, 6
"c:\Users\shet_\our-final-app\app\_layout.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 20, 0, 5, 25
"c:\Users\shet_\our-final-app\app\find-mentor.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 420, 8, 32, 460
"c:\Users\shet_\our-final-app\app\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 4, 0, 2, 6
"c:\Users\shet_\our-final-app\app\login.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 202, 4, 17, 223
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\AddSkillToLearnForm.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 195, 1, 21, 217
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\CategorySelector.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 90, 1, 5, 96
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\ManageSkillsToLearnScreen.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 483, 21, 47, 551
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillChip.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 126, 1, 12, 139
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillsToLearnList.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 241, 2, 14, 257
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SubCategorySelector.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 97, 1, 6, 104
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SuggestedSkillsGrid.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 121, 1, 11, 133
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 390, 8, 30, 428
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\skillData.ts", "TypeScript", 0, 0, 0, 160, 0, 0, 0, 2, 6, 168
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\styles.ts", "TypeScript", 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\types.ts", "TypeScript", 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\useManageSkillsToLearn.ts", "TypeScript", 0, 0, 0, 245, 0, 0, 0, 19, 53, 317
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\AddSkillToTeachForm.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 196, 1, 21, 218
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\ManageSkillsToTeachScreen.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 487, 21, 49, 557
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\SkillsToTeachList.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 242, 2, 14, 258
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 5, 1, 2, 8
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\useManageSkillsToTeach.ts", "TypeScript", 0, 0, 0, 251, 0, 0, 0, 17, 53, 321
"c:\Users\shet_\our-final-app\app\modal.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 26, 0, 4, 30
"c:\Users\shet_\our-final-app\app\screens\homescreen.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 674, 12, 38, 724
"c:\Users\shet_\our-final-app\app\sessions.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
"c:\Users\shet_\our-final-app\app\signup.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 235, 1, 21, 257
"c:\Users\shet_\our-final-app\app\weekly-availability\TimeField.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 110, 4, 15, 129
"c:\Users\shet_\our-final-app\app\weekly-availability\components.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 115, 1, 10, 126
"c:\Users\shet_\our-final-app\app\weekly-availability\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 256, 12, 37, 305
"c:\Users\shet_\our-final-app\app\weekly-availability\styles.ts", "TypeScript", 0, 0, 0, 287, 0, 0, 0, 9, 14, 310
"c:\Users\shet_\our-final-app\app\weekly-availability\useWeeklyAvailability.ts", "TypeScript", 0, 0, 0, 119, 0, 0, 0, 1, 18, 138
"c:\Users\shet_\our-final-app\components\external-link.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 21, 2, 3, 26
"c:\Users\shet_\our-final-app\components\haptic-tab.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 16, 1, 2, 19
"c:\Users\shet_\our-final-app\components\hello-wave.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 18, 0, 2, 20
"c:\Users\shet_\our-final-app\components\parallax-scroll-view.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 73, 0, 7, 80
"c:\Users\shet_\our-final-app\components\themed-text.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 55, 0, 6, 61
"c:\Users\shet_\our-final-app\components\themed-view.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 10, 0, 5, 15
"c:\Users\shet_\our-final-app\components\ui\collapsible.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 40, 0, 6, 46
"c:\Users\shet_\our-final-app\components\ui\icon-symbol.ios.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 31, 0, 2, 33
"c:\Users\shet_\our-final-app\components\ui\icon-symbol.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 26, 11, 5, 42
"c:\Users\shet_\our-final-app\constants\theme.ts", "TypeScript", 0, 0, 0, 41, 0, 0, 0, 8, 5, 54
"c:\Users\shet_\our-final-app\eslint.config.js", "JavaScript JSX", 0, 0, 8, 0, 0, 0, 0, 1, 2, 11
"c:\Users\shet_\our-final-app\hooks\use-color-scheme.ts", "TypeScript", 0, 0, 0, 1, 0, 0, 0, 0, 1, 2
"c:\Users\shet_\our-final-app\hooks\use-color-scheme.web.ts", "TypeScript", 0, 0, 0, 13, 0, 0, 0, 3, 6, 22
"c:\Users\shet_\our-final-app\hooks\use-theme-color.ts", "TypeScript", 0, 0, 0, 14, 0, 0, 0, 4, 4, 22
"c:\Users\shet_\our-final-app\lib\api.ts", "TypeScript", 0, 0, 0, 157, 0, 0, 0, 31, 32, 220
"c:\Users\shet_\our-final-app\package-lock.json", "JSON", 13421, 0, 0, 0, 0, 0, 0, 0, 1, 13422
"c:\Users\shet_\our-final-app\package.json", "JSON", 49, 0, 0, 0, 0, 0, 0, 0, 1, 50
"c:\Users\shet_\our-final-app\scripts\reset-project.js", "JavaScript JSX", 0, 0, 89, 0, 0, 0, 0, 10, 14, 113
"c:\Users\shet_\our-final-app\server\.env", "Dotenv", 0, 0, 0, 0, 3, 0, 0, 0, 1, 4
"c:\Users\shet_\our-final-app\server\models\User.js", "JavaScript JSX", 0, 0, 37, 0, 0, 0, 0, 1, 10, 48
"c:\Users\shet_\our-final-app\server\package-lock.json", "JSON", 1203, 0, 0, 0, 0, 0, 0, 0, 1, 1204
"c:\Users\shet_\our-final-app\server\package.json", "JSON", 6, 0, 0, 0, 0, 0, 0, 0, 1, 7
"c:\Users\shet_\our-final-app\server\server.js", "JavaScript JSX", 0, 0, 297, 0, 0, 0, 0, 19, 65, 381
"c:\Users\shet_\our-final-app\server\services\matchingService.js", "JavaScript JSX", 0, 0, 126, 0, 0, 0, 0, 18, 34, 178
"c:\Users\shet_\our-final-app\tsconfig.json", "JSON with Comments", 0, 17, 0, 0, 0, 0, 0, 0, 1, 18
"Total", "-", 14679, 65, 557, 1288, 3, 31, 5061, 260, 805, 22749
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.json">
{"file:///c%3A/Users/shet_/our-final-app/server/package.json":{"language":"JSON","code":6,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/tsconfig.json":{"language":"JSON with Comments","code":17,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/server/package-lock.json":{"language":"JSON","code":1203,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/server/server.js":{"language":"JavaScript JSX","code":297,"comment":19,"blank":65},"file:///c%3A/Users/shet_/our-final-app/lib/api.ts":{"language":"TypeScript","code":157,"comment":31,"blank":32},"file:///c%3A/Users/shet_/our-final-app/server/services/matchingService.js":{"language":"JavaScript JSX","code":126,"comment":18,"blank":34},"file:///c%3A/Users/shet_/our-final-app/server/models/User.js":{"language":"JavaScript JSX","code":37,"comment":1,"blank":10},"file:///c%3A/Users/shet_/our-final-app/package.json":{"language":"JSON","code":49,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/server/.env":{"language":"Dotenv","code":3,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/scripts/reset-project.js":{"language":"JavaScript JSX","code":89,"comment":10,"blank":14},"file:///c%3A/Users/shet_/our-final-app/README.md":{"language":"Markdown","code":31,"comment":0,"blank":20},"file:///c%3A/Users/shet_/our-final-app/eslint.config.js":{"language":"JavaScript JSX","code":8,"comment":1,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app.json":{"language":"JSON with Comments","code":48,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/hooks/use-theme-color.ts":{"language":"TypeScript","code":14,"comment":4,"blank":4},"file:///c%3A/Users/shet_/our-final-app/hooks/use-color-scheme.web.ts":{"language":"TypeScript","code":13,"comment":3,"blank":6},"file:///c%3A/Users/shet_/our-final-app/components/external-link.tsx":{"language":"TypeScript JSX","code":21,"comment":2,"blank":3},"file:///c%3A/Users/shet_/our-final-app/components/ui/collapsible.tsx":{"language":"TypeScript JSX","code":40,"comment":0,"blank":6},"file:///c%3A/Users/shet_/our-final-app/components/parallax-scroll-view.tsx":{"language":"TypeScript JSX","code":73,"comment":0,"blank":7},"file:///c%3A/Users/shet_/our-final-app/components/themed-view.tsx":{"language":"TypeScript JSX","code":10,"comment":0,"blank":5},"file:///c%3A/Users/shet_/our-final-app/components/themed-text.tsx":{"language":"TypeScript JSX","code":55,"comment":0,"blank":6},"file:///c%3A/Users/shet_/our-final-app/app/_layout.tsx":{"language":"TypeScript JSX","code":20,"comment":0,"blank":5},"file:///c%3A/Users/shet_/our-final-app/components/hello-wave.tsx":{"language":"TypeScript JSX","code":18,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/components/haptic-tab.tsx":{"language":"TypeScript JSX","code":16,"comment":1,"blank":2},"file:///c%3A/Users/shet_/our-final-app/hooks/use-color-scheme.ts":{"language":"TypeScript","code":1,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/sessions.tsx":{"language":"TypeScript JSX","code":0,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/components/ui/icon-symbol.ios.tsx":{"language":"TypeScript JSX","code":31,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/constants/theme.ts":{"language":"TypeScript","code":41,"comment":8,"blank":5},"file:///c%3A/Users/shet_/our-final-app/components/ui/icon-symbol.tsx":{"language":"TypeScript JSX","code":26,"comment":11,"blank":5},"file:///c%3A/Users/shet_/our-final-app/app/modal.tsx":{"language":"TypeScript JSX","code":26,"comment":0,"blank":4},"file:///c%3A/Users/shet_/our-final-app/app/signup.tsx":{"language":"TypeScript JSX","code":235,"comment":1,"blank":21},"file:///c%3A/Users/shet_/our-final-app/app/login.tsx":{"language":"TypeScript JSX","code":202,"comment":4,"blank":17},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/useWeeklyAvailability.ts":{"language":"TypeScript","code":119,"comment":1,"blank":18},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/styles.ts":{"language":"TypeScript","code":287,"comment":9,"blank":14},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/TimeField.tsx":{"language":"TypeScript JSX","code":110,"comment":4,"blank":15},"file:///c%3A/Users/shet_/our-final-app/app/index.tsx":{"language":"TypeScript JSX","code":4,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/index.tsx":{"language":"TypeScript JSX","code":256,"comment":12,"blank":37},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/components.tsx":{"language":"TypeScript JSX","code":115,"comment":1,"blank":10},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx":{"language":"TypeScript JSX","code":487,"comment":21,"blank":49},"file:///c%3A/Users/shet_/our-final-app/app/find-mentor.tsx":{"language":"TypeScript JSX","code":420,"comment":8,"blank":32},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/index.tsx":{"language":"TypeScript JSX","code":5,"comment":1,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/AddSkillToLearnForm.tsx":{"language":"TypeScript JSX","code":195,"comment":1,"blank":21},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/useManageSkillsToTeach.ts":{"language":"TypeScript","code":251,"comment":17,"blank":53},"file:///c%3A/Users/shet_/our-final-app/app/screens/homescreen.tsx":{"language":"TypeScript JSX","code":674,"comment":12,"blank":38},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/AddSkillToTeachForm.tsx":{"language":"TypeScript JSX","code":196,"comment":1,"blank":21},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx":{"language":"TypeScript JSX","code":483,"comment":21,"blank":47},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/SkillsToTeachList.tsx":{"language":"TypeScript JSX","code":242,"comment":2,"blank":14},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/skillData.ts":{"language":"TypeScript","code":160,"comment":2,"blank":6},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/useManageSkillsToLearn.ts":{"language":"TypeScript","code":245,"comment":19,"blank":53},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SkillChip.tsx":{"language":"TypeScript JSX","code":126,"comment":1,"blank":12},"file:///c%3A/Users/shet_/our-final-app/app/%28tabs%29/explore.tsx":{"language":"TypeScript JSX","code":28,"comment":0,"blank":3},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/CategorySelector.tsx":{"language":"TypeScript JSX","code":90,"comment":1,"blank":5},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/types.ts":{"language":"TypeScript","code":0,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/styles.ts":{"language":"TypeScript","code":0,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/index.tsx":{"language":"TypeScript JSX","code":390,"comment":8,"blank":30},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SubCategorySelector.tsx":{"language":"TypeScript JSX","code":97,"comment":1,"blank":6},"file:///c%3A/Users/shet_/our-final-app/app/%28tabs%29/index.tsx":{"language":"TypeScript JSX","code":4,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/package-lock.json":{"language":"JSON","code":13421,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SuggestedSkillsGrid.tsx":{"language":"TypeScript JSX","code":121,"comment":1,"blank":11},"file:///c%3A/Users/shet_/our-final-app/app/%28tabs%29/_layout.tsx":{"language":"TypeScript JSX","code":4,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SkillsToLearnList.tsx":{"language":"TypeScript JSX","code":241,"comment":2,"blank":14}}
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.md">
# Summary

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 60 files,  21684 codes, 260 comments, 805 blanks, all 22749 lines

Summary / [Details](details.md) / [Diff Summary](diff.md) / [Diff Details](diff-details.md)

## Languages
| language | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |
| JSON | 4 | 14,679 | 0 | 4 | 14,683 |
| TypeScript JSX | 35 | 5,061 | 117 | 459 | 5,637 |
| TypeScript | 12 | 1,288 | 94 | 194 | 1,576 |
| JavaScript JSX | 5 | 557 | 49 | 125 | 731 |
| JSON with Comments | 2 | 65 | 0 | 2 | 67 |
| Markdown | 1 | 31 | 0 | 20 | 51 |
| Dotenv | 1 | 3 | 0 | 1 | 4 |

## Directories
| path | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |
| . | 60 | 21,684 | 260 | 805 | 22,749 |
| . (Files) | 6 | 13,574 | 1 | 26 | 13,601 |
| app | 33 | 5,833 | 151 | 567 | 6,551 |
| app (Files) | 7 | 907 | 13 | 82 | 1,002 |
| app\\(tabs) | 3 | 36 | 0 | 7 | 43 |
| app\\manage-skills-to-learn | 12 | 2,148 | 57 | 207 | 2,412 |
| app\\manage-skills-to-teach | 5 | 1,181 | 42 | 139 | 1,362 |
| app\\screens | 1 | 674 | 12 | 38 | 724 |
| app\\weekly-availability | 5 | 887 | 27 | 94 | 1,008 |
| components | 9 | 290 | 14 | 38 | 342 |
| components (Files) | 6 | 193 | 3 | 25 | 221 |
| components\\ui | 3 | 97 | 11 | 13 | 121 |
| constants | 1 | 41 | 8 | 5 | 54 |
| hooks | 3 | 28 | 7 | 11 | 46 |
| lib | 1 | 157 | 31 | 32 | 220 |
| scripts | 1 | 89 | 10 | 14 | 113 |
| server | 6 | 1,672 | 38 | 112 | 1,822 |
| server (Files) | 4 | 1,509 | 19 | 68 | 1,596 |
| server\\models | 1 | 37 | 1 | 10 | 48 |
| server\\services | 1 | 126 | 18 | 34 | 178 |

Summary / [Details](details.md) / [Diff Summary](diff.md) / [Diff Details](diff-details.md)
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.txt">
Date : 2025-12-10 22:45:17
Directory : c:\Users\shet_\our-final-app
Total : 60 files,  21684 codes, 260 comments, 805 blanks, all 22749 lines

Languages
+--------------------+------------+------------+------------+------------+------------+
| language           | files      | code       | comment    | blank      | total      |
+--------------------+------------+------------+------------+------------+------------+
| JSON               |          4 |     14,679 |          0 |          4 |     14,683 |
| TypeScript JSX     |         35 |      5,061 |        117 |        459 |      5,637 |
| TypeScript         |         12 |      1,288 |         94 |        194 |      1,576 |
| JavaScript JSX     |          5 |        557 |         49 |        125 |        731 |
| JSON with Comments |          2 |         65 |          0 |          2 |         67 |
| Markdown           |          1 |         31 |          0 |         20 |         51 |
| Dotenv             |          1 |          3 |          0 |          1 |          4 |
+--------------------+------------+------------+------------+------------+------------+

Directories
+---------------------------------------------------------------------------------------+------------+------------+------------+------------+------------+
| path                                                                                  | files      | code       | comment    | blank      | total      |
+---------------------------------------------------------------------------------------+------------+------------+------------+------------+------------+
| .                                                                                     |         60 |     21,684 |        260 |        805 |     22,749 |
| . (Files)                                                                             |          6 |     13,574 |          1 |         26 |     13,601 |
| app                                                                                   |         33 |      5,833 |        151 |        567 |      6,551 |
| app (Files)                                                                           |          7 |        907 |         13 |         82 |      1,002 |
| app\(tabs)                                                                            |          3 |         36 |          0 |          7 |         43 |
| app\manage-skills-to-learn                                                            |         12 |      2,148 |         57 |        207 |      2,412 |
| app\manage-skills-to-teach                                                            |          5 |      1,181 |         42 |        139 |      1,362 |
| app\screens                                                                           |          1 |        674 |         12 |         38 |        724 |
| app\weekly-availability                                                               |          5 |        887 |         27 |         94 |      1,008 |
| components                                                                            |          9 |        290 |         14 |         38 |        342 |
| components (Files)                                                                    |          6 |        193 |          3 |         25 |        221 |
| components\ui                                                                         |          3 |         97 |         11 |         13 |        121 |
| constants                                                                             |          1 |         41 |          8 |          5 |         54 |
| hooks                                                                                 |          3 |         28 |          7 |         11 |         46 |
| lib                                                                                   |          1 |        157 |         31 |         32 |        220 |
| scripts                                                                               |          1 |         89 |         10 |         14 |        113 |
| server                                                                                |          6 |      1,672 |         38 |        112 |      1,822 |
| server (Files)                                                                        |          4 |      1,509 |         19 |         68 |      1,596 |
| server\models                                                                         |          1 |         37 |          1 |         10 |         48 |
| server\services                                                                       |          1 |        126 |         18 |         34 |        178 |
+---------------------------------------------------------------------------------------+------------+------------+------------+------------+------------+

Files
+---------------------------------------------------------------------------------------+--------------------+------------+------------+------------+------------+
| filename                                                                              | language           | code       | comment    | blank      | total      |
+---------------------------------------------------------------------------------------+--------------------+------------+------------+------------+------------+
| c:\Users\shet_\our-final-app\README.md                                                | Markdown           |         31 |          0 |         20 |         51 |
| c:\Users\shet_\our-final-app\app.json                                                 | JSON with Comments |         48 |          0 |          1 |         49 |
| c:\Users\shet_\our-final-app\app\(tabs)\_layout.tsx                                   | TypeScript JSX     |          4 |          0 |          2 |          6 |
| c:\Users\shet_\our-final-app\app\(tabs)\explore.tsx                                   | TypeScript JSX     |         28 |          0 |          3 |         31 |
| c:\Users\shet_\our-final-app\app\(tabs)\index.tsx                                     | TypeScript JSX     |          4 |          0 |          2 |          6 |
| c:\Users\shet_\our-final-app\app\_layout.tsx                                          | TypeScript JSX     |         20 |          0 |          5 |         25 |
| c:\Users\shet_\our-final-app\app\find-mentor.tsx                                      | TypeScript JSX     |        420 |          8 |         32 |        460 |
| c:\Users\shet_\our-final-app\app\index.tsx                                            | TypeScript JSX     |          4 |          0 |          2 |          6 |
| c:\Users\shet_\our-final-app\app\login.tsx                                            | TypeScript JSX     |        202 |          4 |         17 |        223 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\AddSkillToLearnForm.tsx       | TypeScript JSX     |        195 |          1 |         21 |        217 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\CategorySelector.tsx          | TypeScript JSX     |         90 |          1 |          5 |         96 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\ManageSkillsToLearnScreen.tsx | TypeScript JSX     |        483 |         21 |         47 |        551 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillChip.tsx                 | TypeScript JSX     |        126 |          1 |         12 |        139 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillsToLearnList.tsx         | TypeScript JSX     |        241 |          2 |         14 |        257 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SubCategorySelector.tsx       | TypeScript JSX     |         97 |          1 |          6 |        104 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SuggestedSkillsGrid.tsx       | TypeScript JSX     |        121 |          1 |         11 |        133 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\index.tsx                     | TypeScript JSX     |        390 |          8 |         30 |        428 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\skillData.ts                  | TypeScript         |        160 |          2 |          6 |        168 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\styles.ts                     | TypeScript         |          0 |          0 |          1 |          1 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\types.ts                      | TypeScript         |          0 |          0 |          1 |          1 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\useManageSkillsToLearn.ts     | TypeScript         |        245 |         19 |         53 |        317 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\AddSkillToTeachForm.tsx       | TypeScript JSX     |        196 |          1 |         21 |        218 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\ManageSkillsToTeachScreen.tsx | TypeScript JSX     |        487 |         21 |         49 |        557 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\SkillsToTeachList.tsx         | TypeScript JSX     |        242 |          2 |         14 |        258 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\index.tsx                     | TypeScript JSX     |          5 |          1 |          2 |          8 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\useManageSkillsToTeach.ts     | TypeScript         |        251 |         17 |         53 |        321 |
| c:\Users\shet_\our-final-app\app\modal.tsx                                            | TypeScript JSX     |         26 |          0 |          4 |         30 |
| c:\Users\shet_\our-final-app\app\screens\homescreen.tsx                               | TypeScript JSX     |        674 |         12 |         38 |        724 |
| c:\Users\shet_\our-final-app\app\sessions.tsx                                         | TypeScript JSX     |          0 |          0 |          1 |          1 |
| c:\Users\shet_\our-final-app\app\signup.tsx                                           | TypeScript JSX     |        235 |          1 |         21 |        257 |
| c:\Users\shet_\our-final-app\app\weekly-availability\TimeField.tsx                    | TypeScript JSX     |        110 |          4 |         15 |        129 |
| c:\Users\shet_\our-final-app\app\weekly-availability\components.tsx                   | TypeScript JSX     |        115 |          1 |         10 |        126 |
| c:\Users\shet_\our-final-app\app\weekly-availability\index.tsx                        | TypeScript JSX     |        256 |         12 |         37 |        305 |
| c:\Users\shet_\our-final-app\app\weekly-availability\styles.ts                        | TypeScript         |        287 |          9 |         14 |        310 |
| c:\Users\shet_\our-final-app\app\weekly-availability\useWeeklyAvailability.ts         | TypeScript         |        119 |          1 |         18 |        138 |
| c:\Users\shet_\our-final-app\components\external-link.tsx                             | TypeScript JSX     |         21 |          2 |          3 |         26 |
| c:\Users\shet_\our-final-app\components\haptic-tab.tsx                                | TypeScript JSX     |         16 |          1 |          2 |         19 |
| c:\Users\shet_\our-final-app\components\hello-wave.tsx                                | TypeScript JSX     |         18 |          0 |          2 |         20 |
| c:\Users\shet_\our-final-app\components\parallax-scroll-view.tsx                      | TypeScript JSX     |         73 |          0 |          7 |         80 |
| c:\Users\shet_\our-final-app\components\themed-text.tsx                               | TypeScript JSX     |         55 |          0 |          6 |         61 |
| c:\Users\shet_\our-final-app\components\themed-view.tsx                               | TypeScript JSX     |         10 |          0 |          5 |         15 |
| c:\Users\shet_\our-final-app\components\ui\collapsible.tsx                            | TypeScript JSX     |         40 |          0 |          6 |         46 |
| c:\Users\shet_\our-final-app\components\ui\icon-symbol.ios.tsx                        | TypeScript JSX     |         31 |          0 |          2 |         33 |
| c:\Users\shet_\our-final-app\components\ui\icon-symbol.tsx                            | TypeScript JSX     |         26 |         11 |          5 |         42 |
| c:\Users\shet_\our-final-app\constants\theme.ts                                       | TypeScript         |         41 |          8 |          5 |         54 |
| c:\Users\shet_\our-final-app\eslint.config.js                                         | JavaScript JSX     |          8 |          1 |          2 |         11 |
| c:\Users\shet_\our-final-app\hooks\use-color-scheme.ts                                | TypeScript         |          1 |          0 |          1 |          2 |
| c:\Users\shet_\our-final-app\hooks\use-color-scheme.web.ts                            | TypeScript         |         13 |          3 |          6 |         22 |
| c:\Users\shet_\our-final-app\hooks\use-theme-color.ts                                 | TypeScript         |         14 |          4 |          4 |         22 |
| c:\Users\shet_\our-final-app\lib\api.ts                                               | TypeScript         |        157 |         31 |         32 |        220 |
| c:\Users\shet_\our-final-app\package-lock.json                                        | JSON               |     13,421 |          0 |          1 |     13,422 |
| c:\Users\shet_\our-final-app\package.json                                             | JSON               |         49 |          0 |          1 |         50 |
| c:\Users\shet_\our-final-app\scripts\reset-project.js                                 | JavaScript JSX     |         89 |         10 |         14 |        113 |
| c:\Users\shet_\our-final-app\server\.env                                              | Dotenv             |          3 |          0 |          1 |          4 |
| c:\Users\shet_\our-final-app\server\models\User.js                                    | JavaScript JSX     |         37 |          1 |         10 |         48 |
| c:\Users\shet_\our-final-app\server\package-lock.json                                 | JSON               |      1,203 |          0 |          1 |      1,204 |
| c:\Users\shet_\our-final-app\server\package.json                                      | JSON               |          6 |          0 |          1 |          7 |
| c:\Users\shet_\our-final-app\server\server.js                                         | JavaScript JSX     |        297 |         19 |         65 |        381 |
| c:\Users\shet_\our-final-app\server\services\matchingService.js                       | JavaScript JSX     |        126 |         18 |         34 |        178 |
| c:\Users\shet_\our-final-app\tsconfig.json                                            | JSON with Comments |         17 |          0 |          1 |         18 |
| Total                                                                                 |                    |     21,684 |        260 |        805 |     22,749 |
+---------------------------------------------------------------------------------------+--------------------+------------+------------+------------+------------+
</file>

<file path="all_mobile_paths.txt">

</file>

<file path="app.json">
{
  "expo": {
    "name": "our-final-app",
    "slug": "our-final-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "ourfinalapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}
</file>

<file path="app/(auth)/_layout.tsx">
// app/(auth)/_layout.tsx
import { Stack } from "expo-router";
import React from "react";

export default function AuthLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "fade",
      }}
    />
  );
}
</file>

<file path="app/(auth)/login/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  Text,
  View,
} from "react-native";
import { getMe, login } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import { validateEmail, validatePassword } from "../shared/validators";

type FieldErrors = {
  email?: string;
  password?: string;
};

export default function LoginScreen() {
  const router = useRouter();

  const { register, focusNext } = useAuthFieldFocus([
    "email",
    "password",
  ] as const);

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [checkingSession, setCheckingSession] = useState(true);
  const [loading, setLoading] = useState(false);

  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const [forgotOpen, setForgotOpen] = useState(false);

  //  Session check (prevents flicker)
  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!token) {
          if (mounted) setCheckingSession(false);
          return;
        }

        await getMe(token);
        if (!mounted) return;
        router.replace("/(tabs)" as any);
      } catch {
        await AsyncStorage.removeItem("token");
        if (mounted) setCheckingSession(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  const canSubmit = useMemo(() => {
    if (checkingSession || loading) return false;
    const e = validateEmail(email);
    const p = validatePassword(password);
    return e.ok && p.ok;
  }, [checkingSession, loading, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await login({
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Login failed: missing token from server.");
        setPassword("");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
      setPassword("");
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <KeyboardAvoidingView
        style={authStyles.root}
        behavior={Platform.OS === "ios" ? "padding" : undefined}
      >
        <ScrollView
          contentContainerStyle={authStyles.content}
          keyboardShouldPersistTaps="handled"
        >
          <AuthHeader
            title="Sign in"
            subtitle="Welcome back  continue learning where you left off."
          />

          {checkingSession ? (
            <View
              style={{ paddingVertical: 24, alignItems: "center", gap: 10 }}
            >
              <ActivityIndicator />
              <Text style={authStyles.subtitle}>Checking your session</Text>
            </View>
          ) : (
            <>
              {bannerError ? (
                <View style={authStyles.bannerError}>
                  <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
                </View>
              ) : null}

              <AuthTextField
                ref={register("email")}
                label="Email"
                value={email}
                onChangeText={(t) => {
                  setEmail(t);
                  clearBannerAndField("email");
                }}
                placeholder="you@example.com"
                keyboardType="email-address"
                returnKeyType="next"
                onSubmitEditing={() => focusNext("email")}
                editable={!loading}
                errorText={fieldErrors.email}
              />

              <PasswordField
                ref={register("password")}
                value={password}
                onChangeText={(t) => {
                  setPassword(t);
                  clearBannerAndField("password");
                }}
                errorText={fieldErrors.password}
                returnKeyType="done"
                onSubmitEditing={onSubmit}
                editable={!loading}
              />

              <Pressable
                onPress={() => setForgotOpen(true)}
                disabled={loading}
                style={({ pressed }) => [
                  { alignSelf: "flex-end", marginTop: 6 },
                  pressed ? { opacity: 0.85 } : null,
                ]}
              >
                <Text style={authStyles.linkBtn}>Forgot password?</Text>
              </Pressable>

              <AuthButton
                title={loading ? "Signing in" : "Sign in"}
                loading={loading}
                disabled={!canSubmit}
                onPress={onSubmit}
              />

              <View style={authStyles.linkRow}>
                <Text style={authStyles.linkText}>Dont have an account?</Text>
                <Link href="/(auth)/signup" style={authStyles.linkBtn}>
                  Create one
                </Link>
              </View>
            </>
          )}
        </ScrollView>

        {/*  Forgot password modal */}
        <Modal
          transparent
          visible={forgotOpen}
          animationType="fade"
          onRequestClose={() => setForgotOpen(false)}
        >
          <Pressable
            onPress={() => setForgotOpen(false)}
            style={{
              flex: 1,
              backgroundColor: "rgba(0,0,0,0.6)",
              justifyContent: "center",
              padding: 18,
            }}
          >
            <Pressable
              onPress={() => {}}
              style={{
                backgroundColor: "#0B1120",
                borderRadius: 16,
                borderWidth: 1,
                borderColor: "#1E293B",
                padding: 16,
              }}
            >
              <Text
                style={{
                  color: "#F9FAFB",
                  fontSize: 16,
                  fontWeight: "900",
                  marginBottom: 6,
                }}
              >
                Password reset
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 13, lineHeight: 18 }}>
                Coming soon. For now, create a new account or contact support if
                youre locked out.
              </Text>

              <Pressable
                onPress={() => setForgotOpen(false)}
                style={({ pressed }) => [
                  {
                    marginTop: 14,
                    backgroundColor: "#22C55E",
                    borderRadius: 999,
                    paddingVertical: 12,
                    alignItems: "center",
                  },
                  pressed ? { opacity: 0.9 } : null,
                ]}
              >
                <Text style={{ color: "#022C22", fontWeight: "900" }}>OK</Text>
              </Pressable>
            </Pressable>
          </Pressable>
        </Modal>
      </KeyboardAvoidingView>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthButton.tsx">
import React from "react";
import { ActivityIndicator, Text, TouchableOpacity, View } from "react-native";
import { authStyles } from "./styles";

type Props = {
  title: string;
  onPress: () => void;
  loading?: boolean;
  disabled?: boolean;
};

export default function AuthButton({
  title,
  onPress,
  loading,
  disabled,
}: Props) {
  const isDisabled = !!disabled || !!loading;

  return (
    <TouchableOpacity
      style={[
        authStyles.primaryBtn,
        isDisabled && authStyles.primaryBtnDisabled,
      ]}
      onPress={onPress}
      disabled={isDisabled}
      activeOpacity={0.85}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: !!loading }}
    >
      {loading ? (
        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <ActivityIndicator />
          <Text style={authStyles.primaryBtnText}>{title}</Text>
        </View>
      ) : (
        <Text style={authStyles.primaryBtnText}>{title}</Text>
      )}
    </TouchableOpacity>
  );
}
</file>

<file path="app/(auth)/shared/AuthHeader.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { title: string; subtitle: string };

export default function AuthHeader({ title, subtitle }: Props) {
  return (
    <View style={authStyles.header}>
      <Text style={authStyles.title}>{title}</Text>
      <Text style={authStyles.subtitle}>{subtitle}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthTextField.tsx">
import React from "react";
import { Text, TextInput, TextInputProps, View } from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  label: string;
  value: string;
  onChangeText: (t: string) => void;
  placeholder?: string;
  errorText?: string | null;
} & Omit<TextInputProps, "value" | "onChangeText">;

const AuthTextField = React.forwardRef<TextInput, Props>(function AuthTextField(
  { label, value, onChangeText, placeholder, errorText, style, ...rest },
  ref
) {
  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>
      <TextInput
        ref={ref}
        style={[authStyles.input, !!errorText && authStyles.inputError, style]}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor="#64748B"
        autoCapitalize="none"
        autoCorrect={false}
        {...rest}
      />
      <InlineError text={errorText} />
    </View>
  );
});

export default AuthTextField;
</file>

<file path="app/(auth)/shared/InlineError.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { text?: string | null };

export default function InlineError({ text }: Props) {
  if (!text) return null;
  return (
    <View style={authStyles.inlineErrorBox}>
      <Text style={authStyles.inlineErrorText}>{text}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/mapApiError.ts">
export function mapApiError(err: any): string {
  // Try to pick the most useful message without leaking raw server dumps.
  const raw =
    String(err?.message || "").trim() ||
    String(err?.response?.data?.message || "").trim() ||
    String(err?.response?.data?.error || "").trim();

  const msg = raw.toLowerCase();

  if (!raw) return "Something went wrong. Please try again.";

  // Network-ish
  if (
    msg.includes("network request failed") ||
    msg.includes("failed to fetch") ||
    msg.includes("network") ||
    msg.includes("socket") ||
    msg.includes("ecconn") ||
    msg.includes("timeout")
  ) {
    return "Cant reach the server. Check your internet (or API URL) and try again.";
  }

  // Auth / credentials
  if (
    msg.includes("invalid credentials") ||
    msg.includes("invalid") && msg.includes("password") ||
    msg.includes("incorrect") ||
    msg.includes("unauthorized") ||
    msg.includes("401")
  ) {
    return "Email or password is incorrect.";
  }

  // Signup collisions
  if (msg.includes("already") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }
  if (msg.includes("exists") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }

  // User not found (login)
  if (msg.includes("not found") || msg.includes("no user")) {
    return "This email is not registered yet.";
  }

  // Token missing from backend
  if (msg.includes("missing") && msg.includes("token")) {
    return "Login succeeded but server didnt return a token. Please contact support.";
  }

  // Generic fallback: avoid very long raw messages
  if (raw.length > 140) return "Something went wrong. Please try again.";
  return raw;
}
</file>

<file path="app/(auth)/shared/PasswordField.tsx">
import React, { useState } from "react";
import {
  Text,
  TextInput,
  TextInputProps,
  TouchableOpacity,
  View,
} from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  value: string;
  onChangeText: (t: string) => void;
  errorText?: string | null;
  label?: string;
} & Omit<TextInputProps, "value" | "onChangeText" | "secureTextEntry">;

const PasswordField = React.forwardRef<TextInput, Props>(function PasswordField(
  { value, onChangeText, errorText, label = "Password", style, ...rest },
  ref
) {
  const [show, setShow] = useState(false);

  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>

      <View style={authStyles.passwordRow}>
        <TextInput
          ref={ref}
          style={[
            authStyles.input,
            { flex: 1 },
            !!errorText && authStyles.inputError,
            style,
          ]}
          value={value}
          onChangeText={onChangeText}
          placeholder=""
          placeholderTextColor="#64748B"
          secureTextEntry={!show}
          autoCapitalize="none"
          autoCorrect={false}
          {...rest}
        />

        <TouchableOpacity
          onPress={() => setShow((v) => !v)}
          style={authStyles.eyeBtn}
          accessibilityRole="button"
          accessibilityLabel={show ? "Hide password" : "Show password"}
          activeOpacity={0.85}
        >
          <Text style={authStyles.eyeText}>{show ? "Hide" : "Show"}</Text>
        </TouchableOpacity>
      </View>

      <InlineError text={errorText} />
    </View>
  );
});

export default PasswordField;
</file>

<file path="app/(auth)/shared/styles.ts">
import { StyleSheet } from "react-native";

export const authStyles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },

  content: {
    paddingHorizontal: 16,
    paddingTop: 28,
    paddingBottom: 28,
  },

  /* ===== Header ===== */
  header: { marginBottom: 18 },
  title: {
    color: "#F9FAFB",
    fontSize: 26,
    fontWeight: "900",
    letterSpacing: 0.2,
  },
  subtitle: {
    color: "#94A3B8",
    fontSize: 13,
    marginTop: 6,
    lineHeight: 18,
  },

  /* ===== Errors ===== */
  bannerError: {
    backgroundColor: "#451A1A",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  bannerErrorText: {
    color: "#FECACA",
    fontSize: 12,
    fontWeight: "800",
    lineHeight: 16,
  },

  inlineErrorBox: { marginTop: 6 },
  inlineErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "800",
  },

  /* ===== Fields ===== */
  fieldWrap: { marginBottom: 14 },
  fieldLabel: {
    color: "#CBD5E1",
    fontSize: 12,
    fontWeight: "800",
    marginBottom: 6,
  },

  input: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 14,
    paddingVertical: 12,
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "700",
  },

  inputError: {
    borderColor: "#FCA5A5",
  },

  passwordRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },

  eyeBtn: {
    paddingHorizontal: 12,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  eyeText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },

  /* ===== Buttons ===== */
  primaryBtn: {
    marginTop: 10,
    backgroundColor: "#22C55E",
    paddingVertical: 13,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryBtnDisabled: {
    opacity: 0.55,
  },
  primaryBtnText: {
    color: "#022C22",
    fontSize: 13,
    fontWeight: "900",
    letterSpacing: 0.3,
  },

  /* ===== Links ===== */
  linkRow: {
    marginTop: 16,
    flexDirection: "row",
    justifyContent: "center",
    gap: 6,
  },
  linkText: {
    color: "#94A3B8",
    fontSize: 12,
    fontWeight: "700",
  },
  linkBtn: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
});
</file>

<file path="app/(auth)/shared/useAuthFieldFocus.ts">
import { useRef } from "react";
import { TextInput } from "react-native";

export function useAuthFieldFocus<T extends string>(keys: readonly T[]) {
  const refs = useRef<Record<T, TextInput | null>>({} as any);

  const register = (key: T) => (ref: TextInput | null) => {
    refs.current[key] = ref;
  };

  const focusNext = (key: T) => {
    const idx = keys.indexOf(key);
    const nextKey = keys[idx + 1];
    if (nextKey && refs.current[nextKey]) {
      refs.current[nextKey]?.focus();
    }
  };

  return { register, focusNext };
}
</file>

<file path="app/(auth)/shared/useAuthRedirect.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useEffect, useState } from "react";

/**
 * If token exists -> redirect to "/"
 * Returns ready=false while checking storage (to avoid flicker)
 */
export function useAuthRedirect() {
  const router = useRouter();
  const [ready, setReady] = useState(false);

  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!mounted) return;

        if (token) {
          router.replace("/"); // go to tabs/home
          return;
        }
      } finally {
        if (mounted) setReady(true);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  return { ready };
}
</file>

<file path="app/(auth)/shared/validators.ts">
export function validateEmail(email: string) {
  const v = email.trim();
  const ok = /^\S+@\S+\.\S+$/.test(v);
  return { ok, value: v, error: ok ? null : "Please enter a valid email." };
}

export function validatePassword(password: string) {
  const v = password;
  const ok = v.length >= 6;
  return { ok, value: v, error: ok ? null : "Password must be at least 6 characters." };
}

export function validateFullName(fullName: string) {
  const v = fullName.trim();
  const ok = v.length >= 2;
  return { ok, value: v, error: ok ? null : "Please enter your full name." };
}
</file>

<file path="app/(auth)/signup/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import { ScrollView, Text, View } from "react-native";
import { signup } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import {
  validateEmail,
  validateFullName,
  validatePassword,
} from "../shared/validators";

type FieldErrors = {
  fullName?: string;
  email?: string;
  password?: string;
};

export default function SignupScreen() {
  const router = useRouter();
  const { register, focusNext } = useAuthFieldFocus([
    "fullName",
    "email",
    "password",
  ] as const);

  const [fullName, setFullName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [loading, setLoading] = useState(false);
  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const canSubmit = useMemo(() => {
    if (loading) return false;
    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);
    return n.ok && e.ok && p.ok;
  }, [loading, fullName, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!n.ok) nextErrors.fullName = n.error || "Please enter your full name.";
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await signup({
        fullName: n.value,
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Signup failed: missing token from server.");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <ScrollView
        contentContainerStyle={authStyles.content}
        keyboardShouldPersistTaps="handled"
      >
        <AuthHeader
          title="Create account"
          subtitle="Join SkillSwap and start learning & teaching."
        />

        {bannerError ? (
          <View style={authStyles.bannerError}>
            <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
          </View>
        ) : null}

        <AuthTextField
          ref={register("fullName")}
          label="Full name"
          value={fullName}
          onChangeText={(t) => {
            setFullName(t);
            clearBannerAndField("fullName");
          }}
          placeholder="Your name"
          errorText={fieldErrors.fullName}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("fullName")}
        />

        <AuthTextField
          ref={register("email")}
          label="Email"
          value={email}
          onChangeText={(t) => {
            setEmail(t);
            clearBannerAndField("email");
          }}
          placeholder="name@example.com"
          keyboardType="email-address"
          errorText={fieldErrors.email}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("email")}
        />

        <PasswordField
          ref={register("password")}
          value={password}
          onChangeText={(t) => {
            setPassword(t);
            clearBannerAndField("password");
          }}
          errorText={fieldErrors.password}
          editable={!loading}
          returnKeyType="done"
          onSubmitEditing={onSubmit}
        />

        <AuthButton
          title={loading ? "Creating" : "Create account"}
          loading={loading}
          disabled={!canSubmit}
          onPress={onSubmit}
        />

        <View style={authStyles.linkRow}>
          <Text style={authStyles.linkText}>Already have an account?</Text>
          <Link href="/(auth)/login" style={authStyles.linkBtn}>
            Sign in
          </Link>
        </View>
      </ScrollView>
    </View>
  );
}
</file>

<file path="app/(tabs)/chats/(components)/ChatInput.tsx">
import React, { useCallback, useMemo } from "react";
import {
  NativeSyntheticEvent,
  Platform,
  Pressable,
  StyleSheet,
  Text,
  TextInput,
  TextInputKeyPressEventData,
  View,
} from "react-native";

type Props = {
  value: string;
  sending: boolean;
  onChange: (v: string) => void;
  onSend: () => void;
};

export default function ChatInput({ value, sending, onChange, onSend }: Props) {
  const canSend = useMemo(
    () => value.trim().length > 0 && !sending,
    [value, sending]
  );

  const onKeyPress = useCallback(
    (e: NativeSyntheticEvent<TextInputKeyPressEventData>) => {
      // Web behavior: Enter sends, Shift+Enter newline
      if (Platform.OS !== "web") return;

      const key = e?.nativeEvent?.key;
      // RN web: shiftKey exists on nativeEvent in many builds but not typed
      const shift = !!(e as any)?.nativeEvent?.shiftKey;

      if (key === "Enter" && !shift) {
        (e as any)?.preventDefault?.();
        if (canSend) onSend();
      }
    },
    [canSend, onSend]
  );

  return (
    <View style={styles.bar}>
      <View style={styles.inputWrap}>
        <TextInput
          value={value}
          onChangeText={onChange}
          placeholder="Type a message"
          placeholderTextColor="#64748B"
          style={styles.input}
          multiline
          maxLength={4000}
          accessibilityLabel="Message input"
          returnKeyType={Platform.OS === "ios" ? "default" : "send"}
          blurOnSubmit={false}
          onKeyPress={onKeyPress}
        />
      </View>

      <Pressable
        onPress={onSend}
        disabled={!canSend}
        accessibilityRole="button"
        accessibilityLabel="Send message"
        style={({ pressed }) => [
          styles.sendBtn,
          canSend ? styles.sendOn : styles.sendOff,
          pressed && canSend ? { opacity: 0.92 } : null,
        ]}
        hitSlop={10}
      >
        <Text style={[styles.sendText, !canSend ? { opacity: 0.85 } : null]}>
          {sending ? "" : "Send"}
        </Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  bar: {
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: "#0B1120",
    backgroundColor: "#020617",
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 10,
  },

  inputWrap: {
    flex: 1,
    borderRadius: 18,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0B1120",
    paddingHorizontal: 14,
    paddingVertical: 10,
  },

  input: {
    color: "#E5E7EB",
    fontWeight: "700",
    minHeight: 42,
    maxHeight: 140,
  },

  sendBtn: {
    minHeight: 44,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 999,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },

  sendOn: { backgroundColor: "#F97316", borderColor: "#FB923C" },
  sendOff: { backgroundColor: "#334155", borderColor: "#475569" },

  sendText: { color: "#111827", fontWeight: "900" },
});
</file>

<file path="app/(tabs)/chats/(components)/TopLoadingHint.tsx">
import React from "react";
import { ActivityIndicator, StyleSheet, Text, View } from "react-native";

type Props = { visible: boolean };

export default function TopLoadingHint({ visible }: Props) {
  if (!visible) return null;

  return (
    <View style={styles.wrap} pointerEvents="none">
      <View style={styles.pill}>
        <ActivityIndicator />
        <Text style={styles.txt}>Loading older</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: { paddingTop: 10, alignItems: "center" },
  pill: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  txt: { color: "#94A3B8", fontWeight: "800", fontSize: 12 },
});
</file>

<file path="app/manage-skills-to-learn/AddSkillToLearnForm.tsx">
// app/manage-skills-to-learn/AddSkillToLearnForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { LEARN_LEVELS, LearnLevel } from "./types";

type Props = {
  onAdd: (name: string, level?: LearnLevel) => Promise<void> | void;
  onAddFavorite: (name: string, level?: LearnLevel) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

const AddSkillToLearnForm: React.FC<Props> = ({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}) => {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. React Native, Guitar, Public speaking";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    // slightly smarter: startsWith first, then includes
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) {
        await onAddFavorite(normalizedValue, selectedLevel);
      } else {
        await onAdd(normalizedValue, selectedLevel);
      }
      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      // keep local errors minimal; backend errors already appear in screen error box
      console.log("AddSkillToLearnForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Type a skill you want to learn, choose the level, then add it to your
        list.
      </Text>

      {/* Level selection */}
      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {LEARN_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      {/* Input */}
      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>

        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      {/* Actions */}
      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {/* Suggestions */}
      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
                accessibilityHint="Fills the input with this suggestion"
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
};

export default AddSkillToLearnForm;

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },

  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
  },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },

  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },

  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },

  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  levelPillText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "800",
  },
  levelPillTextActive: {
    color: "#ffffff",
  },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: {
    fontSize: 12,
    fontWeight: "800",
    color: "#2563eb",
  },

  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: {
    borderColor: "#fca5a5",
    backgroundColor: "#fff1f2",
  },

  errorText: {
    fontSize: 12,
    color: "#b91c1c",
    marginTop: 6,
  },

  buttonsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
  },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: {
    backgroundColor: "#2563eb",
  },
  primaryButtonText: {
    color: "#f9fafb",
    fontSize: 13,
    fontWeight: "900",
  },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: {
    color: "#374151",
    fontSize: 13,
    fontWeight: "800",
  },

  suggestionsSection: {
    marginTop: 12,
  },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: {
    fontSize: 12,
    color: "#6b7280",
    fontWeight: "800",
  },
  suggestionsHint: {
    fontSize: 11,
    color: "#9ca3af",
    fontWeight: "700",
  },
  suggestionsRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/CategorySelector.tsx">
// app/manage-skills-to-learn/CategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SKILL_CATEGORIES, SkillCategory } from "./skillData";

export type CategorySelectorProps = {
  selectedCategoryId: string | null;
  onSelect: (id: string) => void;
};

const CategorySelector: React.FC<CategorySelectorProps> = ({
  selectedCategoryId,
  onSelect,
}) => {
  return (
    <View style={styles.container}>
      <Text style={styles.label}>Category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        {SKILL_CATEGORIES.map((cat: SkillCategory) => {
          const isActive = cat.id === selectedCategoryId;
          return (
            <TouchableOpacity
              key={cat.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(cat.id)}
              activeOpacity={0.8}
            >
              <Text style={styles.chipEmoji}>{cat.icon}</Text>
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {cat.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

export default CategorySelector;

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#1d4ed8",
  },
  chipEmoji: {
    fontSize: 16,
    marginRight: 6,
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "500",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/index.tsx">
// app/manage-skills-to-learn/index.tsx
import React from "react";
import ManageSkillsToLearnScreen from "./ManageSkillsToLearnScreen";

export default function ManageSkillsToLearnRoute() {
  return <ManageSkillsToLearnScreen />;
}
</file>

<file path="app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx">
// app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import AddSkillToLearnForm from "./AddSkillToLearnForm";
import CategorySelector from "./CategorySelector";
import { SkillSubCategory } from "./skillData";
import { SkillsToLearnList } from "./SkillsToLearnList";
import { SubCategorySelector } from "./SubCategorySelector";
import SuggestedSkillsGrid from "./SuggestedSkillsGrid";
import { LEARN_LEVELS, LearnLevel, SkillToLearn } from "./types";
import { useManageSkillsToLearn } from "./useManageSkillsToLearn";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Public speaking",
  "Time management",
  "English conversation",
  "Excel / Google Sheets",
  "Problem solving",
  "Presentation design",
];

type FilterMode = "all" | "favorites" | "recent";

// Quick Start (shown once)
const QUICK_START_KEY = "skillsToLearn_quickStartSeen_v1";

// Toast
type ToastType = "success" | "error" | "info";
type ToastState = {
  visible: boolean;
  message: string;
  type: ToastType;
};

// Bottom Sheet modes
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToLearnScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,

    hasPendingSync, // (22)

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart, // (12)
    updateSkillLevel, // (11)
    trySyncPending, // (22)

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToLearn();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  // Quick Start
  const [showQuickStart, setShowQuickStart] = useState(false);

  // Toast
  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Bottom sheet (modal)
  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  // (12) when duplicate happens, we store the existing skill
  const [duplicateExisting, setDuplicateExisting] =
    useState<SkillToLearn | null>(null);

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name}  ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  // Global search placeholder
  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Python, Algorithms...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Academic writing...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing basics...";
    return "Search or add: React Native, Guitar, Public speaking...";
  }, [selectedCategory]);

  // Visible skills (filters)
  const visibleSkills = useMemo(() => {
    let base: SkillToLearn[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  // Step state
  const isStep1Active = !selectedCategoryId;
  const isStep2Active = !!selectedCategoryId && !selectedSubCategoryId;
  const isStep3Active =
    (!!selectedCategoryId && !!selectedSubCategoryId) || skills.length > 0;

  // Progressive disclosure rules (2)
  const showRecommended = !selectedCategoryId;
  const showDiscoverSection = true;
  const showYourListSection = skills.length > 0 || !!selectedCategoryId;

  // Quick Start load (3)
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const seen = await AsyncStorage.getItem(QUICK_START_KEY);
        if (!mounted) return;
        if (!seen && skills.length === 0) setShowQuickStart(true);
      } catch {
        // ignore
      }
    })();
    return () => {
      mounted = false;
    };
  }, [skills.length]);

  const dismissQuickStart = async () => {
    setShowQuickStart(false);
    try {
      await AsyncStorage.setItem(QUICK_START_KEY, "1");
    } catch {
      // ignore
    }
  };

  // Toast helper (4)
  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  // Sync pending when screen loads (22)
  useEffect(() => {
    // try once on mount (safe even if no pending)
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ----- Add handlers -----
  const handleAddSkillBase = async (name: string, level?: LearnLevel) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (
    name: string,
    level?: LearnLevel
  ) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) `);
    setFilterMode("all");
    setSearchQuery("");
  };

  // Clear all confirm
  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your learning list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  // Category selection
  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
    showToast("Category selected", "info");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  // ---------- Bottom Sheet logic (9 + 10 + 11 + 12) ----------
  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  // (11) open edit level sheet
  const openEditLevelSheet = (skill: SkillToLearn) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    // ----- QUICK ADD -----
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      // (12) smart add
      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        // show duplicate UI: offer edit level
        setDuplicateExisting(res.existing);
        showToast("Skill already exists  edit its level?", "info");
        // switch to edit mode but keep modal open
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- SUGGESTED ADD -----
    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list  edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- ADD ALL SUGGESTED -----
    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;

      // add all; duplicates will be skipped silently using addSkill
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      setFilterMode("all");
      setSearchQuery("");
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      closeSheet();
      return;
    }

    // ----- EDIT LEVEL (11) -----
    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };
  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills) {
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;
    }
    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }

    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  // loading
  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  // (20) stats

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {/* Toast */}
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}> Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you want to learn</Text>
        <Text style={styles.subtitle}>
          Choose a category then add skills with the right level for better
          matching.
        </Text>

        {/* Pending sync indicator (22) */}
        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
               Saved locally  syncing when online
            </Text>
          </View>
        )}

        {/* Global Search */}
        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}> Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your learning list.
          </Text>
        </View>

        {/* Steps */}
        <View style={styles.stepsRow}>
          <View
            style={[styles.stepPill, isStep1Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>1</Text>
            <Text style={styles.stepPillText}>Category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep2Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>2</Text>
            <Text style={styles.stepPillText}>Sub-category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep3Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>3</Text>
            <Text style={styles.stepPillText}>Your list</Text>
          </View>
        </View>

        {/* Quick Start */}
        {showQuickStart && (
          <View style={styles.quickStartCard}>
            <View style={styles.quickStartHeader}>
              <Text style={styles.quickStartTitle}> Quick start</Text>
              <TouchableOpacity onPress={dismissQuickStart} activeOpacity={0.8}>
                <Text style={styles.quickStartDismiss}>Got it</Text>
              </TouchableOpacity>
            </View>

            <Text style={styles.quickStartText}>
              1) Pick a category {"\n"}
              2) Tap a suggested skill {"\n"}
              3) Choose your level and add
            </Text>
          </View>
        )}

        {/* Error box */}
        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        {/* Category */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}> 1. Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>Youre exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        {/* Discover */}
        {showDiscoverSection && (
          <>
            <Text style={styles.mainSectionTitle}>
               2. Discover skills to add
            </Text>

            <SuggestedSkillsGrid
              title={
                selectedCategory
                  ? `Popular in ${selectedCategory.name}`
                  : "Suggested skills"
              }
              description="Tap a skill to choose its level and add it."
              skills={suggestedSkillsByCategory}
              onAdd={(name) => openSuggestedAddSheet(name)}
              onAddAll={
                suggestedSkillsByCategory.length ? openAddAllSheet : undefined
              }
              existingSkills={skills.map((s) => s.name)}
              favoriteSkills={favoriteSkills}
              disableAddAll={saving || !suggestedSkillsByCategory.length}
            />

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Recommended skills for most people"
                description="Useful across many careers."
                skills={recommendedSkills}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Popular among SkillSwap learners"
                description="Skills many people are currently focusing on."
                skills={GLOBAL_POPULAR_SKILLS}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}
          </>
        )}

        {/* Add form (still available) */}
        <AddSkillToLearnForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        {/* Your list */}
        {showYourListSection && (
          <>
            <Text style={styles.mainSectionTitle}>
               3. Your learning list
            </Text>

            {/* (20) Stats */}
            <View style={styles.statsCard}>
              <Text style={styles.statsText}>
                {stats.total} skills  {stats.fav} favorites
                {stats.topLevel ? `  Top level: ${stats.topLevel}` : ""}
              </Text>
              <Text style={styles.statsHint}>
                Tip: to edit a level, open Add and type the same skill name.
              </Text>
            </View>

            <Text style={styles.recentHint}>
              Recent = your last 6 added skills.
            </Text>

            {skills.length === 0 ? (
              <View style={styles.emptyStateCard}>
                <Text style={styles.emptyStateTitle}>No skills yet</Text>
                <Text style={styles.emptyStateText}>
                  Start by picking a category above, or tap + to add a custom
                  skill quickly.
                </Text>

                <View style={styles.emptyStateButtons}>
                  <TouchableOpacity
                    style={styles.emptyPrimaryBtn}
                    onPress={() =>
                      showToast("Pick a category above ", "info")
                    }
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptyPrimaryText}>Pick a category</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.emptySecondaryBtn}
                    onPress={openQuickAddSheet}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptySecondaryText}>
                      Add custom skill
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            ) : (
              <SkillsToLearnList
                skills={visibleSkills}
                totalCount={skills.length}
                searchQuery={searchQuery}
                onChangeSearchQuery={setSearchQuery}
                onRemove={removeSkill}
                favoriteSkills={favoriteSkills}
                onToggleFavorite={toggleFavorite}
                onClearAll={handleClearAllWithConfirm}
                filterMode={filterMode}
                onChangeFilter={setFilterMode}
              />
            )}
          </>
        )}

        {/* Undo bar */}
        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      {/* FAB */}
      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}></Text>
      </TouchableOpacity>

      {/* Bottom Sheet modal */}
      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {/* Duplicate helper card (12) */}
          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name}  {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press Save.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. React Native"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {LEARN_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: You can also add from the main form below.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },

  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },

  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },

  title: { fontSize: 24, fontWeight: "700", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: {
    fontSize: 12,
    color: "#9a3412",
    fontWeight: "700",
  },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "600", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  stepsRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 12,
    gap: 8,
  },
  stepPill: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  stepPillActive: { backgroundColor: "#2563eb" },
  stepPillNumber: {
    fontSize: 12,
    fontWeight: "700",
    color: "#111827",
    marginRight: 4,
  },
  stepPillText: { fontSize: 12, color: "#111827", fontWeight: "500" },

  quickStartCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  quickStartHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  quickStartTitle: { fontSize: 14, fontWeight: "700", color: "#111827" },
  quickStartDismiss: { fontSize: 12, fontWeight: "600", color: "#2563eb" },
  quickStartText: { fontSize: 12, color: "#4b5563", lineHeight: 18 },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "600",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "800" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  recentHint: { fontSize: 11, color: "#6b7280", marginBottom: 8 },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "700", color: "#2563eb" },

  emptyStateCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  emptyStateTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },
  emptyStateText: { marginTop: 6, fontSize: 13, color: "#6b7280" },
  emptyStateButtons: {
    marginTop: 12,
    flexDirection: "row",
    gap: 8,
  },
  emptyPrimaryBtn: {
    flex: 1,
    backgroundColor: "#2563eb",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
  },
  emptyPrimaryText: { color: "#ffffff", fontWeight: "700", fontSize: 13 },
  emptySecondaryBtn: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    backgroundColor: "#f9fafb",
  },
  emptySecondaryText: { color: "#374151", fontWeight: "700", fontSize: 13 },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "600" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "700" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "800", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-learn/SkillChip.tsx">
// app/manage-skills-to-learn/SkillChip.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label: string;
  onPress: () => void;
  compact?: boolean;

  disabled?: boolean;
  added?: boolean;

  showPlusIcon?: boolean;
  isFavorite?: boolean;

  // (24) accessibility extras
  accessibilityHint?: string;
};

export function SkillChip({
  label,
  onPress,
  compact = false,
  disabled = false,
  added = false,
  showPlusIcon = false,
  isFavorite = false,
  accessibilityHint,
}: Props) {
  const showPlus = showPlusIcon && !added;
  const showCheck = added;

  const badgeText = showCheck ? "" : showPlus ? "" : "";
  const badgeLabel = showCheck ? "Added" : showPlus ? "Add" : "";

  return (
    <TouchableOpacity
      onPress={disabled ? () => {} : onPress}
      activeOpacity={disabled ? 1 : 0.85}
      disabled={disabled}
      style={[
        styles.chip,
        compact && styles.chipCompact,
        disabled && styles.chipDisabled,
        added && styles.chipAdded,
      ]}
      accessibilityRole="button"
      accessibilityLabel={label}
      accessibilityHint={
        accessibilityHint ||
        (disabled ? "This item is disabled." : "Tap to select this skill.")
      }
      hitSlop={{ top: 6, bottom: 6, left: 6, right: 6 }}
    >
      <View style={styles.row}>
        {/* Left badge ( / ) */}
        {(showPlus || showCheck) && (
          <View
            style={[
              styles.badge,
              showCheck && styles.badgeCheck,
              showPlus && styles.badgePlus,
            ]}
            accessibilityLabel={badgeLabel}
          >
            <Text style={styles.badgeText}>{badgeText}</Text>
          </View>
        )}

        {/* Favorite star */}
        {isFavorite && (
          <Text style={styles.star} accessibilityLabel="Favorite">
            
          </Text>
        )}

        <Text
          style={[styles.label, disabled && styles.labelDisabled]}
          numberOfLines={1}
        >
          {label}
        </Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  chip: {
    alignSelf: "flex-start",
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipCompact: {
    paddingHorizontal: 10,
    paddingVertical: 7,
  },
  chipDisabled: {
    opacity: 0.62,
  },
  chipAdded: {
    backgroundColor: "#dcfce7",
    borderColor: "#86efac",
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },

  badge: {
    width: 18,
    height: 18,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  badgeCheck: {
    backgroundColor: "#16a34a",
    borderColor: "#16a34a",
  },
  badgePlus: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  badgeText: {
    fontSize: 12,
    color: "#ffffff",
    fontWeight: "900",
    lineHeight: 14,
  },

  star: {
    fontSize: 14,
    color: "#f59e0b",
    fontWeight: "900",
    marginRight: 2,
  },

  label: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "600",
    maxWidth: 240,
  },
  labelDisabled: {
    color: "#6b7280",
  },
});
</file>

<file path="app/manage-skills-to-learn/skillData.ts">
// app/manage-skills-to-learn/skillData.ts

export type SkillSubCategory = {
  id: string;
  name: string;
  skills: string[];
};

export type SkillCategory = {
  id: string;
  name: string;
  icon: string; //  FIX
  subCategories: SkillSubCategory[];
};

export const SKILL_CATEGORIES: SkillCategory[] = [
  {
    id: "programming",
    name: "Programming",
    icon: "",
    subCategories: [
      {
        id: "frontend",
        name: "Frontend",
        skills: ["HTML", "CSS", "JavaScript", "React", "TypeScript"],
      },
      {
        id: "backend",
        name: "Backend",
        skills: ["Node.js", "Express", "MongoDB", "SQL"],
      },
    ],
  },
  {
    id: "languages",
    name: "Languages",
    icon: "",
    subCategories: [
      {
        id: "spoken",
        name: "Spoken",
        skills: ["English", "Hebrew", "Arabic", "Spanish"],
      },
    ],
  },
];

export const RECOMMENDED_SKILLS = ["Public speaking", "Time management", "Problem solving"];

export const ALL_KNOWN_SKILLS = Array.from(
  new Set(SKILL_CATEGORIES.flatMap((c) => c.subCategories.flatMap((s) => s.skills)))
);
</file>

<file path="app/manage-skills-to-learn/SkillsToLearnList.tsx">
// app/manage-skills-to-learn/SkillsToLearnList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { SkillToLearn } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillToLearn[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  //  FIX: now matches the hook perfectly
  onRemove: (skill: SkillToLearn) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;
  onClearAll: () => void;
  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;
  onLayoutCard?: (y: number) => void;
};

export const SkillsToLearnList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "";
    if (mode === "favorites") return "";
    return "";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your learning list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your learning skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You dont have any learning skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <SkillChip
                  label={`${skill.name}  ${skill.level}`}
                  onPress={() => {}}
                />

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                  >
                    <Text style={styles.favoriteText}>{fav ? "" : ""}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)} //  FIX: remove by object
                    style={styles.removeButton}
                  >
                    <Text style={styles.removeIcon}></Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity style={styles.clearAllButton} onPress={onClearAll}>
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: {
    flexDirection: "row",
    gap: 6,
    marginBottom: 8,
  },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  filterChipText: {
    fontSize: 12,
    color: "#374151",
  },
  filterChipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: {
    fontSize: 13,
    color: "#6b7280",
  },
  skillsWrap: {
    gap: 8,
  },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: {
    paddingHorizontal: 6,
    paddingVertical: 4,
  },
  favoriteText: {
    fontSize: 16,
    color: "#f59e0b",
  },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: {
    fontSize: 13,
  },
  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: {
    fontSize: 12,
    color: "#374151",
  },
});
</file>

<file path="app/manage-skills-to-learn/SubCategorySelector.tsx">
// app/manage-skills-to-learn/SubCategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillSubCategory } from "./skillData";

type Props = {
  subCategories: SkillSubCategory[];
  selectedSubCategoryId: string | null;
  onSelect: (id: string | null) => void;
};

export const SubCategorySelector: React.FC<Props> = ({
  subCategories,
  selectedSubCategoryId,
  onSelect,
}) => {
  if (!subCategories.length) return null;

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Sub-category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        <TouchableOpacity
          style={[
            styles.chip,
            selectedSubCategoryId === null && styles.chipActive,
          ]}
          onPress={() => onSelect(null)}
        >
          <Text
            style={[
              styles.chipText,
              selectedSubCategoryId === null && styles.chipTextActive,
            ]}
          >
            All
          </Text>
        </TouchableOpacity>

        {subCategories.map((sub) => {
          const isActive = sub.id === selectedSubCategoryId;
          return (
            <TouchableOpacity
              key={sub.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(sub.id)}
              activeOpacity={0.8}
            >
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {sub.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#1d4ed8",
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/SuggestedSkillsGrid.tsx">
// app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { SkillChip } from "./SkillChip";

type Props = {
  title: string;
  description?: string;
  skills: string[];
  onAdd: (name: string) => void;
  onAddAll?: () => void;
  existingSkills: string[]; // names only
  favoriteSkills: string[]; // names only
  disableAddAll?: boolean;
};

export default function SuggestedSkillsGrid({
  title,
  description,
  skills,
  onAdd,
  onAddAll,
  existingSkills,
  favoriteSkills,
  disableAddAll = false,
}: Props) {
  const existingLower = new Set(existingSkills.map((s) => s.toLowerCase()));
  const favLower = new Set(favoriteSkills.map((s) => s.toLowerCase()));

  if (!skills?.length) return null;

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>{title}</Text>
          {!!description && <Text style={styles.desc}>{description}</Text>}
        </View>

        {!!onAddAll && (
          <TouchableOpacity
            onPress={disableAddAll ? () => {} : onAddAll}
            activeOpacity={disableAddAll ? 1 : 0.8}
            style={[styles.addAllBtn, disableAddAll && { opacity: 0.5 }]}
            disabled={disableAddAll}
          >
            <Text style={styles.addAllText}>Add all</Text>
          </TouchableOpacity>
        )}
      </View>

      <View style={styles.wrap}>
        {skills.map((name) => {
          const added = existingLower.has(name.toLowerCase());
          const isFav = favLower.has(name.toLowerCase());

          //  : SkillChip  onPress 
          const handlePress = added ? () => {} : () => onAdd(name);

          return (
            <SkillChip
              key={name}
              label={name}
              onPress={handlePress}
              compact
              disabled={added}
              added={added}
              showPlusIcon={!added}
              isFavorite={isFav}
            />
          );
        })}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 10,
  },
  title: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
  },
  desc: {
    marginTop: 4,
    fontSize: 12,
    color: "#6b7280",
  },
  addAllBtn: {
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 6,
    backgroundColor: "#f9fafb",
  },
  addAllText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "600",
  },
  wrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/types.ts">
// app/manage-skills-to-learn/types.ts

export const LEARN_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type LearnLevel = (typeof LEARN_LEVELS)[number];

export type SkillToLearn = {
  name: string;
  level: LearnLevel;
};

export type UndoState = {
  skill: SkillToLearn;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-learn/useManageSkillsToLearn.ts">
// app/manage-skills-to-learn/useManageSkillsToLearn.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "./skillData";
import { LEARN_LEVELS, LearnLevel, SkillToLearn, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToLearnFavorites";

// (22) offline pending sync
const PENDING_SKILLS_KEY = "skillsToLearn_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillToLearn }
  | { ok: false; existed: true; existing: SkillToLearn }
  | { ok: false; existed: false; error: string };

// normalize level
function normalizeLearnLevel(raw?: string | null): LearnLevel {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = LEARN_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToLearn() {
  const [skills, setSkills] = useState<SkillToLearn[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  // (22) indicates we have unsynced local changes
  const [hasPendingSync, setHasPendingSync] = useState(false);

  // category / subcategory
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  // ---------- helpers ----------
  function findExistingSkill(name: string): SkillToLearn | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  // (22) store pending local changes when backend update fails
  async function savePendingSkills(next: SkillToLearn[]) {
    try {
      await AsyncStorage.setItem(PENDING_SKILLS_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePendingSkills error:", e);
    }
  }

  async function clearPendingSkills() {
    try {
      await AsyncStorage.removeItem(PENDING_SKILLS_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPendingSkills error:", e);
    }
  }

  async function loadPendingSkills(): Promise<SkillToLearn[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillToLearn[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return {
            name,
            level: normalizeLearnLevel(item.level),
          } as SkillToLearn;
        })
        .filter(Boolean) as SkillToLearn[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPendingSkills error:", e);
      return null;
    }
  }

  // (22) try to sync pending changes to backend
  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPendingSkills();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      // if there are pending changes, push them
      await updateProfile(token, { skillsToLearn: pending });
      await clearPendingSkills();

      // make sure local state matches pending
      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e: any) {
      // stay pending
      console.log("trySyncPending error:", e);
      setHasPendingSync(true);
    }
  }

  // ---- load from backend + favorites local ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        // (22) attempt sync pending first
        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        // NOTE: backend old format could be string[] OR new format object[]
        const raw = Array.isArray(userFromApi?.skillsToLearn)
          ? userFromApi.skillsToLearn
          : [];

        const cleanSkills: SkillToLearn[] = raw
          .map((item: any) => {
            // string -> object
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as LearnLevel };
            }

            // object -> normalize
            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLearnLevel(item.level),
              } as SkillToLearn;
            }

            return null;
          })
          .filter(Boolean) as SkillToLearn[];

        // sort by name
        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        // favorites local
        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        // pending indicator
        const pending = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToLearn load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load learning skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  // ---- persist skills to backend ----
  async function persistSkills(next: SkillToLearn[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, {
        skillsToLearn: next,
      });

      // if this succeeds, clear pending
      await clearPendingSkills();
    } catch (e: any) {
      console.log("updateProfile(skillsToLearn) error:", e);

      // (22) store pending changes locally
      await savePendingSkills(next);

      setError(
        e?.message ||
          "Failed to save learning skills. Your changes are saved locally and will sync when you're back online."
      );
    } finally {
      setSaving(false);
    }
  }

  // ---- persist favorites local ----
  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites learn error:", e);
    }
  }

  // ---- add skill (kept the same signature: boolean) ----
  async function addSkill(name: string, level?: LearnLevel): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  // ---- (12) add skill smart: tells you if it exists and returns existing skill ----
  async function addSkillSmart(
    name: string,
    level?: LearnLevel
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      // don't set as a hard error; this is a "smart" signal
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  // ---- (11) update level for an existing skill ----
  async function updateSkillLevel(
    name: string,
    newLevel: LearnLevel
  ): Promise<boolean> {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalizedLevel = normalizeLearnLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalizedLevel) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalizedLevel };

    // keep alphabetical order stable
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  // ---- remove skill (accept SkillToLearn object) ----
  async function removeSkill(skill: SkillToLearn) {
    const skillName = skill.name;

    const index = skills.findIndex((s) => sameName(s.name, skillName));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    // remove from favorites if needed
    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  // ---- clear all ----
  async function clearAllSkills() {
    const next: SkillToLearn[] = [];
    setSkills(next);
    setLastRemoved(null);

    await persistFavorites([]);
    await persistSkills(next);
  }

  // ---- undo remove ----
  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);

    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  // ---- toggle favorite ----
  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));

    let next: string[];
    if (exists) {
      next = favoriteSkills.filter((f) => !sameName(f, name));
    } else {
      next = [...favoriteSkills, name];
    }

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---- category helpers ----
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  // ---- filtered + sorted (favorites first) ----
  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();

    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync, // (22)

    // category stuff
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill, // keep old
    addSkillSmart, // (12) new
    updateSkillLevel, // (11) new
    trySyncPending, // (22) new

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/manage-skills-to-teach/AddSkillToTeachForm.tsx">
// app/manage-skills-to-teach/AddSkillToTeachForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { Level, TEACH_LEVELS } from "./types";

type Props = {
  onAdd: (name: string, level?: Level) => Promise<void> | void;
  onAddFavorite: (name: string, level?: Level) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

export default function AddSkillToTeachForm({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}: Props) {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] = useState<Level>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. Math tutoring, React, Guitar";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) await onAddFavorite(normalizedValue, selectedLevel);
      else await onAdd(normalizedValue, selectedLevel);

      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      console.log("AddSkillToTeachForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom teaching skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Add what you can teach and choose your level.
      </Text>

      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {TEACH_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>
        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: { fontSize: 15, fontWeight: "800", color: "#111827" },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },
  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },
  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },
  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "800" },
  levelPillTextActive: { color: "#ffffff" },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: { fontSize: 12, fontWeight: "800", color: "#2563eb" },
  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: { borderColor: "#fca5a5", backgroundColor: "#fff1f2" },
  errorText: { fontSize: 12, color: "#b91c1c", marginTop: 6 },

  buttonsRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: { backgroundColor: "#2563eb" },
  primaryButtonText: { color: "#f9fafb", fontSize: 13, fontWeight: "900" },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: { color: "#374151", fontSize: 13, fontWeight: "800" },

  suggestionsSection: { marginTop: 12 },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: { fontSize: 12, color: "#6b7280", fontWeight: "800" },
  suggestionsHint: { fontSize: 11, color: "#9ca3af", fontWeight: "700" },
  suggestionsRow: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
});
</file>

<file path="app/manage-skills-to-teach/index.tsx">
// app/manage-skills-to-teach/index.tsx
import React from "react";
import ManageSkillsToTeachScreen from "./ManageSkillsToTeachScreen";

export default function ManageSkillsToTeachRoute() {
  return <ManageSkillsToTeachScreen />;
}
</file>

<file path="app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx">
// app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

//  reuse learn components
import CategorySelector from "../manage-skills-to-learn/CategorySelector";
import { SubCategorySelector } from "../manage-skills-to-learn/SubCategorySelector";
import SuggestedSkillsGrid from "../manage-skills-to-learn/SuggestedSkillsGrid";
import { SkillSubCategory } from "../manage-skills-to-learn/skillData";

import AddSkillToTeachForm from "./AddSkillToTeachForm";
import { SkillsToTeachList } from "./SkillsToTeachList";
import { Level, SkillTeach, TEACH_LEVELS } from "./types";
import { useManageSkillsToTeach } from "./useManageSkillsToTeach";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Math tutoring",
  "English conversation",
  "React",
  "Node.js",
  "UI/UX basics",
  "Public speaking",
];

type FilterMode = "all" | "favorites" | "recent";
type ToastType = "success" | "error" | "info";
type ToastState = { visible: boolean; message: string; type: ToastType };
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToTeachScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToTeach();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<Level>("Intermediate");

  const [duplicateExisting, setDuplicateExisting] = useState<SkillTeach | null>(
    null
  );

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name}  ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Node.js, Data structures...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Hebrew, Arabic...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing...";
    return "Search or add: Math tutoring, Guitar, Public speaking...";
  }, [selectedCategory]);

  const visibleSkills = useMemo(() => {
    let base: SkillTeach[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills)
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;

    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }
    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  useEffect(() => {
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleAddSkillBase = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) `);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your teaching list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openEditLevelSheet = (skill: SkillTeach) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Skill already exists  edit its level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list  edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      setFilterMode("all");
      setSearchQuery("");
      closeSheet();
      return;
    }

    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };

  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  const showRecommended = !selectedCategoryId;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}> Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you can teach</Text>
        <Text style={styles.subtitle}>
          Add what you can teach with the right level for better matching.
        </Text>

        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
               Saved locally  syncing when online
            </Text>
          </View>
        )}

        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}> Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your teaching list.
          </Text>
        </View>

        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        <View style={styles.card}>
          <Text style={styles.sectionTitle}> Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>Youre exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        <Text style={styles.mainSectionTitle}> Discover skills to add</Text>

        <SuggestedSkillsGrid
          title={
            selectedCategory
              ? `Popular in ${selectedCategory.name}`
              : "Suggested skills"
          }
          description="Tap a skill to choose its level and add it."
          skills={suggestedSkillsByCategory}
          onAdd={(name) => openSuggestedAddSheet(name)}
          onAddAll={
            suggestedSkillsByCategory.length ? openAddAllSheet : undefined
          }
          existingSkills={skills.map((s) => s.name)}
          favoriteSkills={favoriteSkills}
          disableAddAll={saving || !suggestedSkillsByCategory.length}
        />

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Recommended skills for most people"
            description="Useful across many careers."
            skills={recommendedSkills}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Popular among SkillSwap mentors"
            description="Skills many mentors are currently teaching."
            skills={GLOBAL_POPULAR_SKILLS}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        <AddSkillToTeachForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        <Text style={styles.mainSectionTitle}> Your teaching list</Text>

        <View style={styles.statsCard}>
          <Text style={styles.statsText}>
            {stats.total} skills  {stats.fav} favorites
            {stats.topLevel ? `  Top level: ${stats.topLevel}` : ""}
          </Text>
          <Text style={styles.statsHint}>Tap a skill to edit its level.</Text>
        </View>

        <SkillsToTeachList
          skills={visibleSkills}
          totalCount={skills.length}
          searchQuery={searchQuery}
          onChangeSearchQuery={setSearchQuery}
          onRemove={removeSkill}
          favoriteSkills={favoriteSkills}
          onToggleFavorite={toggleFavorite}
          onClearAll={handleClearAllWithConfirm}
          filterMode={filterMode}
          onChangeFilter={setFilterMode}
          onEditLevel={openEditLevelSheet}
        />

        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}></Text>
      </TouchableOpacity>

      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name}  {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press Save.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. Math tutoring"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {TEACH_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: Tap a skill in the list to edit level.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },
  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },
  title: { fontSize: 24, fontWeight: "800", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: { fontSize: 12, color: "#9a3412", fontWeight: "800" },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "700", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "700",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "900" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "900", color: "#2563eb" },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "700" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "900", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "800",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "900" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "900", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-teach/SkillsToTeachList.tsx">
// app/manage-skills-to-teach/SkillsToTeachList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { SkillTeach } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillTeach[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  onRemove: (skill: SkillTeach) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;

  onClearAll: () => void;

  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;

  //  optional: for edit level from list (we'll use it)
  onEditLevel?: (skill: SkillTeach) => void;

  onLayoutCard?: (y: number) => void;
};

export const SkillsToTeachList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onEditLevel,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "";
    if (mode === "favorites") return "";
    return "";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
        activeOpacity={0.85}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your teaching list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your teaching skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You dont have any teaching skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <TouchableOpacity
                  activeOpacity={0.85}
                  onPress={() => onEditLevel?.(skill)}
                  disabled={!onEditLevel}
                >
                  <SkillChip
                    label={`${skill.name}  ${skill.level}`}
                    onPress={() => onEditLevel?.(skill)}
                    disabled={!onEditLevel}
                  />
                </TouchableOpacity>

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.favoriteText}>{fav ? "" : ""}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)}
                    style={styles.removeButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.removeIcon}></Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity
          style={styles.clearAllButton}
          onPress={onClearAll}
          activeOpacity={0.85}
        >
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: { flexDirection: "row", gap: 6, marginBottom: 8 },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  filterChipText: { fontSize: 12, color: "#374151" },
  filterChipTextActive: { color: "#ffffff", fontWeight: "700" },

  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: { fontSize: 13, color: "#6b7280" },

  skillsWrap: { gap: 8 },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: { paddingHorizontal: 6, paddingVertical: 4 },
  favoriteText: { fontSize: 16, color: "#f59e0b" },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: { fontSize: 13 },

  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: { fontSize: 12, color: "#374151", fontWeight: "700" },
});
</file>

<file path="app/manage-skills-to-teach/types.ts">
// app/manage-skills-to-teach/types.ts

export const TEACH_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type Level = (typeof TEACH_LEVELS)[number];

export type SkillTeach = {
  name: string;
  level: Level;
};

export type UndoState = {
  skill: SkillTeach;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-teach/useManageSkillsToTeach.ts">
// app/manage-skills-to-teach/useManageSkillsToTeach.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";

//  reuse learn data + categories
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "../manage-skills-to-learn/skillData";

import { Level, SkillTeach, TEACH_LEVELS, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToTeachFavorites";
const PENDING_KEY = "skillsToTeach_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillTeach }
  | { ok: false; existed: true; existing: SkillTeach }
  | { ok: false; existed: false; error: string };

function normalizeLevel(raw?: string | null): Level {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = TEACH_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToTeach() {
  const [skills, setSkills] = useState<SkillTeach[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  const [hasPendingSync, setHasPendingSync] = useState(false);

  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  function findExistingSkill(name: string): SkillTeach | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  async function savePending(next: SkillTeach[]) {
    try {
      await AsyncStorage.setItem(PENDING_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePending teach error:", e);
    }
  }

  async function clearPending() {
    try {
      await AsyncStorage.removeItem(PENDING_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPending teach error:", e);
    }
  }

  async function loadPending(): Promise<SkillTeach[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_KEY);
      if (!raw) return null;

      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillTeach[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return { name, level: normalizeLevel(item.level) } as SkillTeach;
        })
        .filter(Boolean) as SkillTeach[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPending teach error:", e);
      return null;
    }
  }

  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPending();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      await updateProfile(token, { skillsToTeach: pending });
      await clearPending();

      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e) {
      console.log("trySyncPending teach error:", e);
      setHasPendingSync(true);
    }
  }

  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        const raw = Array.isArray(userFromApi?.skillsToTeach)
          ? userFromApi.skillsToTeach
          : [];

        const cleanSkills: SkillTeach[] = raw
          .map((item: any) => {
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as Level };
            }

            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLevel(item.level),
              } as SkillTeach;
            }

            return null;
          })
          .filter(Boolean) as SkillTeach[];

        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        const pending = await AsyncStorage.getItem(PENDING_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToTeach load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load teaching skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  async function persistSkills(next: SkillTeach[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, { skillsToTeach: next });
      await clearPending();
    } catch (e: any) {
      console.log("updateProfile(skillsToTeach) error:", e);
      await savePending(next);
      setError(
        e?.message ||
          "Failed to save teaching skills. Saved locally and will sync when online."
      );
    } finally {
      setSaving(false);
    }
  }

  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites teach error:", e);
    }
  }

  async function addSkill(name: string, level?: Level): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  async function addSkillSmart(
    name: string,
    level?: Level
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  async function updateSkillLevel(name: string, newLevel: Level) {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalized = normalizeLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalized) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalized };
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  async function removeSkill(skill: SkillTeach) {
    const index = skills.findIndex((s) => sameName(s.name, skill.name));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  async function clearAllSkills() {
    const next: SkillTeach[] = [];
    setSkills(next);
    setLastRemoved(null);
    await persistFavorites([]);
    await persistSkills(next);
  }

  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));
    const next = exists
      ? favoriteSkills.filter((f) => !sameName(f, name))
      : [...favoriteSkills, name];

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---------- category helpers (reuse learn data) ----------
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();
    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    // category
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/modal.tsx">
import { Link } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';

export default function ModalScreen() {
  return (
    <ThemedView style={styles.container}>
      <ThemedText type="title">This is a modal</ThemedText>
      <Link href="/" dismissTo style={styles.link}>
        <ThemedText type="link">Go to home screen</ThemedText>
      </Link>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});
</file>

<file path="app/profile.tsx">
// app/profile.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../lib/api";
import { getMe } from "../lib/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export default function ProfileScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const mountedRef = useRef(true);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);
    } catch (err: any) {
      console.log("Profile / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(err?.message || "Couldnt load your profile.");
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );

  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading profile</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView
        style={styles.scroll}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
            colors={["#F97316"]}
          />
        }
      >
        <View style={styles.headerCard}>
          <Text style={styles.title}>Profile</Text>
          <Text style={styles.name}>{user?.fullName || "SkillSwap user"}</Text>
          <Text style={styles.email}>{user?.email || ""}</Text>

          <View style={styles.headerStatsRow}>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>XP</Text>
              <Text style={styles.statValue}>{user?.xp ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Points</Text>
              <Text style={styles.statValue}>{user?.points ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Streak</Text>
              <Text style={styles.statValue}>{user?.streak ?? 0}</Text>
            </View>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldnt refresh</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        {/*  One place to manage everything (no bouncing) */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Manage</Text>
          <Text style={styles.sectionSubtitle}>
            Update what matters without jumping around too much.
          </Text>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-learn" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to learn</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToLearn?.length ?? 0) > 0
                  ? `${user?.skillsToLearn?.length} goal(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}></Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-teach" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to teach</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToTeach?.length ?? 0) > 0
                  ? `${user?.skillsToTeach?.length} skill(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}></Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/weekly-availability" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Weekly availability</Text>
              <Text style={styles.rowSub}>
                {slots.length
                  ? `${daysSet} day(s)  ${minutesToHuman(totalMin)} total`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}></Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/find-mentor" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Find mentor</Text>
              <Text style={styles.rowSub}>Get matched instantly</Text>
            </View>
            <Text style={styles.rowArrow}></Text>
          </TouchableOpacity>
        </View>

        <View style={styles.footerRow}>
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  headerCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  title: { color: "#9CA3AF", fontSize: 13 },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "700", marginTop: 6 },
  email: { color: "#64748B", fontSize: 12, marginTop: 4 },

  headerStatsRow: { flexDirection: "row", gap: 8, marginTop: 12 },
  headerStat: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 10,
  },
  statLabel: { color: "#94A3B8", fontSize: 11, marginBottom: 4 },
  statValue: { color: "#F9FAFB", fontSize: 18, fontWeight: "700" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryButton: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "500" },

  section: { marginTop: 8, marginBottom: 20 },
  sectionTitle: { color: "#F9FAFB", fontSize: 16, fontWeight: "600" },
  sectionSubtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  rowBtn: {
    marginTop: 10,
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  rowTitle: { color: "#F9FAFB", fontSize: 14, fontWeight: "600" },
  rowSub: { color: "#94A3B8", fontSize: 12, marginTop: 2 },
  rowArrow: { color: "#60A5FA", fontSize: 22, marginLeft: 10 },

  footerRow: { marginTop: 8, alignItems: "flex-start" },
  logoutButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },
});
</file>

<file path="app/screens/components/MatchReadinessStrip.tsx">
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import {
  getMatchingStatus,
  type MatchingMode,
  type MatchingStatus,
} from "../../../lib/api";

type Props = {
  currentMode?: MatchingMode; //  (     AsyncStorage)
  onApplyRecommended?: (recommended: MatchingMode) => void; //    "Use recommended"
  onOpenSettings?: () => void; //  (     )
  compact?: boolean; //    
};

function getHumanMessage(s: MatchingStatus): string {
  if (!s.openaiAvailable) {
    if (s.reason === "NO_KEY")
      return "AI matching is off (no API key). Using local matching.";
    return "AI matching is unavailable right now. Using local matching.";
  }
  return "AI matching is ready. For best results, use Hybrid mode.";
}

export default function MatchReadinessStrip({
  currentMode,
  onApplyRecommended,
  onOpenSettings,
  compact = false,
}: Props) {
  const [status, setStatus] = useState<MatchingStatus | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        setLoading(true);
        const s = await getMatchingStatus();
        if (!alive) return;
        setStatus(s);
      } catch {
        if (!alive) return;
        setStatus({
          openaiAvailable: false,
          reason: "ERROR",
          recommendedMode: "local",
        });
      } finally {
        if (!alive) return;
        setLoading(false);
      }
    })();

    return () => {
      alive = false;
    };
  }, []);

  const recommendedMode: MatchingMode = useMemo(() => {
    // server returns "local" | "hybrid"
    const r = status?.recommendedMode;
    return r === "hybrid" ? "hybrid" : "local";
  }, [status]);

  const showApplyButton = useMemo(() => {
    if (!status) return false;
    if (!onApplyRecommended) return false;
    if (currentMode && currentMode === recommendedMode) return false;
    return true;
  }, [status, onApplyRecommended, currentMode, recommendedMode]);

  const tone = useMemo(() => {
    if (!status) return "neutral";
    return status.openaiAvailable ? "good" : "warn";
  }, [status]);

  return (
    <View
      style={[
        styles.wrap,
        compact && styles.wrapCompact,
        tone === "good" && styles.goodWrap,
        tone === "warn" && styles.warnWrap,
      ]}
    >
      <View style={styles.left}>
        <Text style={styles.title}>Matching status</Text>

        {loading ? (
          <View style={styles.row}>
            <ActivityIndicator />
            <Text style={styles.subtitle}>Checking availability</Text>
          </View>
        ) : (
          <Text style={styles.subtitle}>
            {status ? getHumanMessage(status) : "Status unknown."}
          </Text>
        )}
      </View>

      <View style={styles.right}>
        {!loading && status && (
          <>
            <View style={styles.pill}>
              <Text style={styles.pillText}>
                Recommended: {recommendedMode.toUpperCase()}
              </Text>
            </View>

            {showApplyButton ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={styles.btn}
                onPress={() => onApplyRecommended?.(recommendedMode)}
              >
                <Text style={styles.btnText}>Use recommended</Text>
              </TouchableOpacity>
            ) : onOpenSettings ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={[styles.btn, styles.btnGhost]}
                onPress={onOpenSettings}
              >
                <Text style={styles.btnText}>Settings</Text>
              </TouchableOpacity>
            ) : null}
          </>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
    borderRadius: 16,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(15, 23, 42, 0.45)",
    padding: 14,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  wrapCompact: {
    paddingVertical: 10,
    paddingHorizontal: 12,
  },
  goodWrap: {
    borderColor: "rgba(34, 197, 94, 0.35)",
    backgroundColor: "rgba(20, 83, 45, 0.18)",
  },
  warnWrap: {
    borderColor: "rgba(251, 191, 36, 0.35)",
    backgroundColor: "rgba(120, 53, 15, 0.18)",
  },
  left: { flex: 1 },
  right: {
    alignItems: "flex-end",
    justifyContent: "center",
    gap: 8,
  },
  title: {
    color: "#e5e7eb",
    fontSize: 14,
    fontWeight: "700",
    marginBottom: 4,
  },
  subtitle: {
    color: "#cbd5e1",
    fontSize: 12.5,
    lineHeight: 18,
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  pill: {
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  pillText: {
    color: "#e5e7eb",
    fontSize: 11.5,
    fontWeight: "700",
    letterSpacing: 0.3,
  },
  btn: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  btnGhost: {
    backgroundColor: "transparent",
  },
  btnText: {
    color: "#e5e7eb",
    fontSize: 12,
    fontWeight: "700",
  },
});
</file>

<file path="app/screens/components/PillButton.tsx">
import React from "react";
import {
  ActivityIndicator,
  GestureResponderEvent,
  StyleProp,
  StyleSheet,
  Text,
  TouchableOpacity,
  ViewStyle,
} from "react-native";

type PillButtonProps = {
  title: string;
  onPress?: (event: GestureResponderEvent) => void;
  disabled?: boolean;
  loading?: boolean;
  style?: StyleProp<ViewStyle>;
  testID?: string;
};

export default function PillButton({
  title,
  onPress,
  disabled = false,
  loading = false,
  style,
  testID,
}: PillButtonProps) {
  const isDisabled = disabled || loading;

  return (
    <TouchableOpacity
      testID={testID}
      activeOpacity={0.85}
      onPress={onPress}
      disabled={isDisabled}
      style={[styles.pill, isDisabled && styles.pillDisabled, style]}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: loading }}
    >
      {loading ? (
        <ActivityIndicator />
      ) : (
        <Text style={[styles.text, isDisabled && styles.textDisabled]}>
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  pill: {
    width: "100%",
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.35)", // slate-400-ish
    backgroundColor: "rgba(15, 23, 42, 0.55)", // slate-900-ish
    alignItems: "center",
    justifyContent: "center",
  },
  pillDisabled: {
    opacity: 0.7,
  },
  text: {
    fontSize: 14.5,
    fontWeight: "600",
    color: "#e5e7eb",
    letterSpacing: 0.2,
  },
  textDisabled: {
    color: "rgba(229, 231, 235, 0.85)",
  },
});
</file>

<file path="app/screens/components/ProfileStatusCard.tsx">
// app/screens/components/ProfileStatusCard.tsx
import { useRouter } from "expo-router";
import React, { useMemo } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import type { ProfileCompletionStatus } from "../../../lib/profileCompletion";

type Props = {
  status: ProfileCompletionStatus;
};

function pickNextSection(status: ProfileCompletionStatus) {
  //   
  return status.sections.find((s) => !s.done) || status.sections[0];
}

export default function ProfileStatusCard({ status }: Props) {
  const router = useRouter();

  const next = useMemo(() => pickNextSection(status), [status]);

  const progressText = status.isComplete
    ? "Complete"
    : `${status.doneCount}/${status.totalCount} done`;

  const subtitle = status.isComplete
    ? "Your profile is ready. Youll get better matches."
    : "Finish these steps to unlock better mentor matches.";

  const onPrimary = () => {
    if (!next?.href) return;
    router.push(next.href as any);
  };

  return (
    <View style={styles.card}>
      <View style={styles.topRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>Profile completion</Text>
          <Text style={styles.subtitle}>{subtitle}</Text>
        </View>

        <View style={styles.percentPill}>
          <Text style={styles.percentText}>{status.percent}%</Text>
        </View>
      </View>

      <View style={styles.progressRow}>
        <View style={styles.progressBg}>
          <View
            style={[styles.progressFill, { width: `${status.percent}%` }]}
          />
        </View>
        <Text style={styles.progressMeta}>{progressText}</Text>
      </View>

      {!status.isComplete && (
        <View style={styles.nextBox}>
          <View style={{ flex: 1 }}>
            <Text style={styles.nextTitle}>Next step</Text>
            <Text style={styles.nextHint}>{next.hint}</Text>
          </View>

          <TouchableOpacity
            style={styles.primaryBtn}
            onPress={onPrimary}
            activeOpacity={0.85}
          >
            <Text style={styles.primaryBtnText}>{next.ctaLabel}</Text>
          </TouchableOpacity>
        </View>
      )}

      <View style={styles.stepsWrap}>
        {status.sections.map((s) => (
          <View
            key={s.key}
            style={[
              styles.stepChip,
              s.done ? styles.stepChipDone : styles.stepChipTodo,
            ]}
          >
            <Text
              style={[
                styles.stepText,
                s.done ? styles.stepTextDone : styles.stepTextTodo,
              ]}
            >
              {s.done ? "" : ""} {s.title}
            </Text>
          </View>
        ))}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  topRow: { flexDirection: "row", alignItems: "flex-start", gap: 10 },
  title: { color: "#F9FAFB", fontSize: 15, fontWeight: "700" },
  subtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  percentPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#334155",
  },
  percentText: { color: "#F97316", fontSize: 12, fontWeight: "800" },

  progressRow: { marginTop: 10 },
  progressBg: {
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#111827",
  },
  progressFill: { height: "100%", backgroundColor: "#F97316" },
  progressMeta: { color: "#94A3B8", fontSize: 11, marginTop: 6 },

  nextBox: {
    marginTop: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#0B1120",
    padding: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  nextTitle: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },
  nextHint: { color: "#94A3B8", fontSize: 11, marginTop: 4 },

  primaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#F97316",
  },
  primaryBtnText: { color: "#ffffff", fontSize: 12, fontWeight: "800" },

  stepsWrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 12,
  },
  stepChip: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderWidth: 1,
  },
  stepChipDone: { backgroundColor: "#052e16", borderColor: "#14532d" },
  stepChipTodo: { backgroundColor: "#0F172A", borderColor: "#1E293B" },

  stepText: { fontSize: 11, fontWeight: "700" },
  stepTextDone: { color: "#BBF7D0" },
  stepTextTodo: { color: "#E5E7EB" },
});
</file>

<file path="app/screens/components/QuickEditBar.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  onAvailability: () => void;
  onLearn: () => void;
  onTeach: () => void;
  onMatch: () => void;
};

function Pill({
  title,
  emoji,
  onPress,
  variant = "neutral",
}: {
  title: string;
  emoji: string;
  onPress: () => void;
  variant?: "neutral" | "primary";
}) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.85}
      style={[
        styles.pill,
        variant === "primary" ? styles.pillPrimary : styles.pillNeutral,
      ]}
    >
      <Text style={styles.pillEmoji}>{emoji}</Text>
      <Text
        style={[
          styles.pillText,
          variant === "primary"
            ? styles.pillTextPrimary
            : styles.pillTextNeutral,
        ]}
      >
        {title}
      </Text>
    </TouchableOpacity>
  );
}

export default function QuickEditBar({
  onAvailability,
  onLearn,
  onTeach,
  onMatch,
}: Props) {
  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Quick edit</Text>
        <Text style={styles.hint}>Avoid page hopping</Text>
      </View>

      <View style={styles.row}>
        <Pill title="Match" emoji="" onPress={onMatch} variant="primary" />
        <Pill title="Availability" emoji="" onPress={onAvailability} />
      </View>

      <View style={styles.row}>
        <Pill title="Learn" emoji="" onPress={onLearn} />
        <Pill title="Teach" emoji="" onPress={onTeach} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
  },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  hint: { color: "#64748B", fontSize: 11 },

  row: { flexDirection: "row", gap: 10, marginTop: 10 },
  pill: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
  },
  pillNeutral: { backgroundColor: "#0B1120", borderColor: "#334155" },
  pillPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },

  pillEmoji: { fontSize: 14 },
  pillText: { fontSize: 12, fontWeight: "700" },
  pillTextNeutral: { color: "#E5E7EB" },
  pillTextPrimary: { color: "#DBEAFE" },
});
</file>

<file path="app/screens/components/SkeletonCard.tsx">
import React, { useMemo } from "react";
import { StyleSheet, View, type DimensionValue } from "react-native";

type Props = {
  /**
   * width can be:
   * - number (e.g. 120)
   * - percentage string (e.g. "80%")
   */
  width?: number | `${number}%`;
  height?: number;
  radius?: number;
  style?: any;
};

export default function SkeletonCard({
  width = "100%",
  height = 14,
  radius = 10,
  style,
}: Props) {
  //  ensure correct type for RN style
  const safeWidth = useMemo(() => width as DimensionValue, [width]);

  return (
    <View
      style={[
        styles.skeleton,
        {
          width: safeWidth,
          height,
          borderRadius: radius,
        },
        style,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  skeleton: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    overflow: "hidden",
  },
});
</file>

<file path="app/screens/components/ViewProfileCTA.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label?: string;
  onPress: () => void;
};

export default function ViewProfileCTA({
  label = "View profile",
  onPress,
}: Props) {
  return (
    <TouchableOpacity
      style={styles.wrap}
      onPress={onPress}
      activeOpacity={0.85}
    >
      <View style={styles.left}>
        <Text style={styles.title}>{label}</Text>
        <Text style={styles.sub}>See and update your profile in one place</Text>
      </View>

      <View style={styles.right}>
        <Text style={styles.arrow}></Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 12,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 14,
  },
  left: { flex: 1, paddingRight: 10 },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  sub: { color: "#94A3B8", fontSize: 12, marginTop: 4 },
  right: {
    width: 36,
    height: 36,
    borderRadius: 999,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#334155",
    alignItems: "center",
    justifyContent: "center",
  },
  arrow: { color: "#60A5FA", fontSize: 18, fontWeight: "800" },
});
</file>

<file path="app/screens/home/components/CollapsibleCard.tsx">
import React from "react";
import { Pressable, StyleSheet, Text, View } from "react-native";

type Props = {
  title: string;
  icon?: string;
  open: boolean;
  onToggle: () => void;
  children: React.ReactNode;
};

export default function CollapsibleCard({
  title,
  icon,
  open,
  onToggle,
  children,
}: Props) {
  return (
    <View style={styles.card}>
      <Pressable onPress={onToggle} style={styles.head} hitSlop={8}>
        <Text style={styles.headTitle}>
          {icon ? `${icon} ` : ""}
          {title}
        </Text>
        <Text style={styles.chev}>{open ? "" : ""}</Text>
      </Pressable>

      {open ? <View style={{ marginTop: 10 }}>{children}</View> : null}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  head: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  headTitle: { color: "#E5E7EB", fontSize: 14, fontWeight: "900" },
  chev: { color: "#94A3B8", fontSize: 16, fontWeight: "900" },
});
</file>

<file path="app/screens/home/components/home.helpers.ts">
import type { AvailabilitySlot } from "@/lib/api";
import type { ChatInboxItem } from "@/lib/chat/api";

export const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

export function getInitials(name?: string) {
  if (!name) return "?";
  const parts = name.trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

export function getLevelFromXp(xp?: number) {
  const val = xp ?? 0;
  const level = Math.floor(val / 100);
  const progress = val % 100;
  return { level, progress };
}

export function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0").split(":").map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

export function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

export function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export function availabilityLabelFromMinutes(min: number) {
  if (min >= 600) return " Excellent";
  if (min >= 240) return " Good";
  if (min > 0) return " Low";
  return "Not set";
}

export function inferNextLine(user: any, inbox: ChatInboxItem[]) {
  const learnCount = user?.skillsToLearn?.length || 0;
  const hasInbox = inbox.length > 0;

  if (learnCount === 0) return "Next: add a learning goal to get better matches.";
  if (!hasInbox) return "Next: find a mentor and send your first message.";
  return "Next: open a chat or request a session with a mentor.";
}
</file>

<file path="app/screens/home/components/HomeEmptyState.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  onStartSetup: () => void;
};

export default function HomeEmptyState({ onStartSetup }: Props) {
  return (
    <View style={styles.card}>
      <Text style={styles.title}>Lets set you up</Text>
      <Text style={styles.body}>
        Add learning goals, availability, and what you can teach  then youre
        ready to match.
      </Text>

      <View style={styles.steps}>
        <Text style={styles.step}>1) Add a learning goal</Text>
        <Text style={styles.step}>2) Set weekly availability</Text>
        <Text style={styles.step}>3) Add a skill to teach</Text>
      </View>

      <TouchableOpacity
        style={styles.primary}
        activeOpacity={0.85}
        onPress={onStartSetup}
      >
        <Text style={styles.primaryText}>Start setup</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginTop: 14,
    marginBottom: 18,
    padding: 16,
    borderRadius: 18,
    borderWidth: 1,
    borderColor: "#1F2937",
    backgroundColor: "#0B1220",
  },
  title: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },
  body: { color: "#9CA3AF", fontSize: 12, marginTop: 8 },
  steps: { marginTop: 12, gap: 6 },
  step: { color: "#CBD5E1", fontSize: 12, fontWeight: "700" },

  primary: {
    marginTop: 14,
    alignSelf: "flex-start",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 12,
    backgroundColor: "#10B981",
  },
  primaryText: { color: "#06281C", fontWeight: "900" },
});
</file>

<file path="app/screens/home/components/HomeHero.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  fullName?: string;
  initials: string;
  level: number;
  progress: number; // 0..100
  streak: number;
  nextLine: string;
  onPrimary: () => void; // Find mentor
  onSecondary: () => void; // Sessions
};

export default function HomeHero({
  fullName,
  initials,
  level,
  progress,
  streak,
  nextLine,
  onPrimary,
  onSecondary,
}: Props) {
  return (
    <View style={styles.card}>
      <View style={styles.top}>
        <View style={{ flex: 1 }}>
          <Text style={styles.greeting}>Welcome back</Text>
          <Text style={styles.name}>{fullName || "SkillSwap user"}</Text>
          <Text style={styles.next}>{nextLine}</Text>

          <View style={styles.ctaRow}>
            <TouchableOpacity
              style={styles.primaryBtn}
              onPress={onPrimary}
              activeOpacity={0.85}
            >
              <Text style={styles.primaryText}>
                Start learning  Find a mentor
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.secondaryBtn}
              onPress={onSecondary}
              activeOpacity={0.85}
            >
              <Text style={styles.secondaryText}>My sessions</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.avatar}>
          <Text style={styles.avatarText}>{initials}</Text>
        </View>
      </View>

      <View style={styles.bottom}>
        <View style={styles.levelBox}>
          <Text style={styles.levelLabel}>Level</Text>
          <Text style={styles.levelVal}>{level}</Text>
        </View>

        <View style={{ flex: 1 }}>
          <View style={styles.progressHead}>
            <Text style={styles.progressLabel}>XP progress</Text>
            <Text style={styles.progressVal}>
              {Math.min(progress, 100)}/100
            </Text>
          </View>
          <View style={styles.progressBg}>
            <View
              style={[
                styles.progressFill,
                { width: `${Math.min(progress, 100)}%` },
              ]}
            />
          </View>
        </View>

        {streak > 0 ? (
          <View style={styles.streak}>
            <Text style={{ marginRight: 4 }}></Text>
            <Text style={styles.streakText}>{streak}-day</Text>
          </View>
        ) : null}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  top: { flexDirection: "row", alignItems: "flex-start", gap: 12 },
  greeting: { color: "#9CA3AF", fontSize: 13, fontWeight: "700" },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "900", marginTop: 4 },
  next: { color: "#94A3B8", fontSize: 12, marginTop: 8, lineHeight: 18 },

  ctaRow: { flexDirection: "row", gap: 10, marginTop: 12, flexWrap: "wrap" },
  primaryBtn: {
    flexGrow: 1,
    backgroundColor: "#F97316",
    borderRadius: 999,
    paddingVertical: 12,
    paddingHorizontal: 14,
    alignItems: "center",
  },
  primaryText: { color: "#0B1120", fontWeight: "900", fontSize: 13 },
  secondaryBtn: {
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1120",
    paddingVertical: 12,
    paddingHorizontal: 14,
    alignItems: "center",
  },
  secondaryText: { color: "#E5E7EB", fontWeight: "900", fontSize: 13 },

  avatar: {
    width: 50,
    height: 50,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "900" },

  bottom: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 14,
  },
  levelBox: { width: 66 },
  levelLabel: { color: "#94A3B8", fontSize: 11, fontWeight: "800" },
  levelVal: { color: "#E5E7EB", fontSize: 20, fontWeight: "900", marginTop: 2 },

  progressHead: { flexDirection: "row", justifyContent: "space-between" },
  progressLabel: { color: "#94A3B8", fontSize: 11, fontWeight: "800" },
  progressVal: { color: "#CBD5F5", fontSize: 11, fontWeight: "800" },
  progressBg: {
    marginTop: 6,
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#111827",
  },
  progressFill: { height: "100%", backgroundColor: "#F97316" },

  streak: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#F97316",
    flexDirection: "row",
    alignItems: "center",
  },
  streakText: { color: "#FED7AA", fontSize: 11, fontWeight: "900" },
});
</file>

<file path="app/screens/home/components/InboxPreview.tsx">
import React, { useMemo } from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { ChatInboxItem } from "../../../../lib/chat/api";

type Props = {
  loading: boolean;
  inbox?: ChatInboxItem[] | null; //  allow undefined/null (defensive)
  onOpenAll: () => void;
  onFindMentor: () => void;
  onOpenChat: (item: ChatInboxItem) => void;
};

function inboxTime(iso?: string | null) {
  if (!iso) return "";
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleTimeString(undefined, {
    hour: "2-digit",
    minute: "2-digit",
  });
}

function inboxInitials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return (parts[0][0] || "?").toUpperCase();
  return `${parts[0][0] || ""}${
    parts[parts.length - 1][0] || ""
  }`.toUpperCase();
}

export default function InboxPreview({
  loading,
  inbox,
  onOpenAll,
  onFindMentor,
  onOpenChat,
}: Props) {
  //  hard guard: inbox might be undefined at runtime
  const list = useMemo(() => (Array.isArray(inbox) ? inbox : []), [inbox]);

  return (
    <View style={{ marginBottom: 20 }}>
      <View style={styles.headerRow}>
        <Text style={styles.title}> Messages</Text>

        <TouchableOpacity
          onPress={onOpenAll}
          activeOpacity={0.85}
          style={styles.chip}
        >
          <Text style={styles.chipText}>View all</Text>
        </TouchableOpacity>
      </View>

      <View style={styles.card}>
        {loading ? (
          <View style={{ paddingVertical: 10, alignItems: "center" }}>
            <ActivityIndicator />
            <Text style={styles.loadingText}>Loading messages</Text>
          </View>
        ) : list.length === 0 ? (
          <View>
            <Text style={styles.emptyTitle}>No messages yet</Text>
            <Text style={styles.emptyBody}>
              Start by finding a mentor. After opening their profile, you can
              send a message.
            </Text>

            <TouchableOpacity
              style={styles.cta}
              onPress={onFindMentor}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaText}>Find mentors</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <View style={{ gap: 10 }}>
            {list.slice(0, 3).map((c, idx) => {
              const name = c?.peer?.fullName || "Unknown user";
              const last =
                c?.lastMessageText && c.lastMessageText.trim().length > 0
                  ? c.lastMessageText
                  : "Tap to continue the chat";
              const time = inboxTime(c?.lastMessageAt);
              const unread = Number(c?.unreadCount || 0);

              //  defensive key
              const key = c?.id ? String(c.id) : `fallback-${idx}`;

              return (
                <TouchableOpacity
                  key={key}
                  activeOpacity={0.88}
                  onPress={() => onOpenChat(c)}
                  style={styles.row}
                >
                  <View style={styles.avatar}>
                    <Text style={styles.avatarText}>{inboxInitials(name)}</Text>
                  </View>

                  <View style={{ flex: 1 }}>
                    <View style={styles.topLine}>
                      <Text style={styles.name} numberOfLines={1}>
                        {name}
                      </Text>

                      <View
                        style={{
                          flexDirection: "row",
                          alignItems: "center",
                          gap: 8,
                        }}
                      >
                        {!!unread && (
                          <View style={styles.badge}>
                            <Text style={styles.badgeText}>
                              {unread > 99 ? "99+" : String(unread)}
                            </Text>
                          </View>
                        )}
                        {!!time && <Text style={styles.time}>{time}</Text>}
                      </View>
                    </View>

                    <Text style={styles.last} numberOfLines={1}>
                      {last}
                    </Text>
                  </View>
                </TouchableOpacity>
              );
            })}
          </View>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  headerRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 8,
  },
  title: { color: "#F9FAFB", fontSize: 16, fontWeight: "800" },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1120",
  },
  chipText: { color: "#60A5FA", fontSize: 12, fontWeight: "800" },

  card: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 16,
    padding: 12,
  },

  loadingText: { color: "#94A3B8", marginTop: 8, fontWeight: "900" },

  emptyTitle: { color: "#E5E7EB", fontWeight: "900", fontSize: 13 },
  emptyBody: { color: "#94A3B8", marginTop: 6, fontSize: 12, lineHeight: 18 },
  cta: {
    marginTop: 10,
    alignSelf: "flex-start",
    backgroundColor: "#F97316",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  ctaText: { color: "#0B1120", fontWeight: "900" },

  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    padding: 10,
  },
  avatar: {
    width: 40,
    height: 40,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: { color: "#F97316", fontWeight: "900", fontSize: 14 },

  topLine: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 10,
  },
  name: { color: "#E5E7EB", fontWeight: "900", maxWidth: 210 },
  last: { color: "#94A3B8", marginTop: 4, fontSize: 12 },

  time: { color: "#64748B", fontSize: 11, fontWeight: "900" },
  badge: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
    paddingHorizontal: 8,
    height: 18,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  badgeText: { color: "#111827", fontWeight: "900", fontSize: 10 },
});
</file>

<file path="app/screens/home/components/MiniStatsRow.tsx">
import React from "react";
import { StyleSheet, Text, View } from "react-native";

type Props = {
  xp: number;
  points: number;
  streak: number;
};

function Stat({ label, value }: { label: string; value: number }) {
  return (
    <View style={styles.item}>
      <Text style={styles.value}>{value}</Text>
      <Text style={styles.label}>{label}</Text>
    </View>
  );
}

export default function MiniStatsRow({ xp, points, streak }: Props) {
  return (
    <View style={styles.wrap}>
      <Stat label="XP" value={xp} />
      <View style={styles.sep} />
      <Stat label="Points" value={points} />
      <View style={styles.sep} />
      <Stat label="Streak" value={streak} />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 16,
    paddingVertical: 10,
    paddingHorizontal: 12,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 18,
  },
  item: { flex: 1, alignItems: "center" },
  value: { color: "#F9FAFB", fontSize: 16, fontWeight: "900" },
  label: { color: "#94A3B8", fontSize: 11, fontWeight: "800", marginTop: 4 },
  sep: { width: 1, height: 26, backgroundColor: "#111827" },
});
</file>

<file path="app/screens/home/components/NextBestActionCard.tsx">
import React, { useMemo } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import type { ProfileCompletionStatus } from "../../../../lib/profileCompletion";

type Props = {
  profileStatus: ProfileCompletionStatus;
  setupCompleted: number;
  setupTotal: number;
  hasInbox: boolean;

  onGoProfileNext: () => void;
  onStartSetup: () => void;
  onFindMentor: () => void;
  onOpenChats: () => void;
};

export default function NextBestActionCard({
  profileStatus,
  setupCompleted,
  setupTotal,
  hasInbox,
  onGoProfileNext,
  onStartSetup,
  onFindMentor,
  onOpenChats,
}: Props) {
  const model = useMemo(() => {
    //  1:  
    if (!profileStatus?.isComplete) {
      return {
        title: "Complete your profile",
        body: "Finish the remaining steps to unlock better mentor matches.",
        primary: "Continue",
        onPrimary: onGoProfileNext,
        secondary: null as null | { label: string; onPress: () => void },
      };
    }

    //  2: setup 
    if (setupCompleted < setupTotal) {
      return {
        title: "Finish setup",
        body: `You're ${setupCompleted}/${setupTotal}. Add the missing parts to start faster.`,
        primary: "Start setup",
        onPrimary: onStartSetup,
        secondary: null,
      };
    }

    //  3:   inbox
    if (!hasInbox) {
      return {
        title: "Find your first mentor",
        body: "Browse mentors and start a conversation in minutes.",
        primary: "Find mentors",
        onPrimary: onFindMentor,
        secondary: null,
      };
    }

    //  4:  inbox
    return {
      title: "Continue where you left off",
      body: "Open your inbox and reply quickly.",
      primary: "Open chats",
      onPrimary: onOpenChats,
      secondary: { label: "Find mentors", onPress: onFindMentor },
    };
  }, [
    profileStatus,
    setupCompleted,
    setupTotal,
    hasInbox,
    onGoProfileNext,
    onStartSetup,
    onFindMentor,
    onOpenChats,
  ]);

  return (
    <View style={styles.card}>
      <Text style={styles.title}>{model.title}</Text>
      <Text style={styles.body}>{model.body}</Text>

      <View style={styles.row}>
        <TouchableOpacity
          style={styles.primary}
          activeOpacity={0.85}
          onPress={model.onPrimary}
        >
          <Text style={styles.primaryText}>{model.primary}</Text>
        </TouchableOpacity>

        {model.secondary ? (
          <TouchableOpacity
            style={styles.secondary}
            activeOpacity={0.85}
            onPress={model.secondary.onPress}
          >
            <Text style={styles.secondaryText}>{model.secondary.label}</Text>
          </TouchableOpacity>
        ) : null}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginBottom: 14,
    padding: 14,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: "#1F2937",
    backgroundColor: "#0B1220",
  },
  title: { color: "#E5E7EB", fontSize: 15, fontWeight: "900" },
  body: { color: "#9CA3AF", fontSize: 12, marginTop: 6 },

  row: { flexDirection: "row", alignItems: "center", gap: 10, marginTop: 12 },
  primary: {
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 12,
    backgroundColor: "#10B981",
  },
  primaryText: { color: "#06281C", fontWeight: "900" },

  secondary: {
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },
  secondaryText: { color: "#E5E7EB", fontWeight: "900" },
});
</file>

<file path="app/screens/home/components/SectionHeader.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  icon?: string;
  title: string;
  subtitle?: string;
  actionLabel?: string;
  onAction?: () => void;
};

export default function SectionHeader({
  icon,
  title,
  subtitle,
  actionLabel,
  onAction,
}: Props) {
  return (
    <View style={styles.wrap}>
      <View style={{ flex: 1 }}>
        <Text style={styles.title}>
          {icon ? `${icon} ` : ""}
          {title}
        </Text>
        {!!subtitle && <Text style={styles.subtitle}>{subtitle}</Text>}
      </View>

      {!!actionLabel && !!onAction && (
        <TouchableOpacity
          onPress={onAction}
          activeOpacity={0.85}
          style={styles.actionChip}
        >
          <Text style={styles.actionText}>{actionLabel}</Text>
        </TouchableOpacity>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginBottom: 8,
  },
  title: { color: "#F9FAFB", fontSize: 16, fontWeight: "800" },
  subtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },
  actionChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1120",
  },
  actionText: { color: "#60A5FA", fontSize: 12, fontWeight: "800" },
});
</file>

<file path="app/screens/home/components/SetupProgressHeader.tsx">
import React from "react";
import { StyleSheet, Text, View } from "react-native";

type Props = {
  completed: number;
  total: number;
  learnCount: number;
  teachCount: number;
  daysSet: number;
  totalMin: number;
  qualityLabel: string;
  totalHuman: string;
};

export default function SetupProgressHeader({
  completed,
  total,
  learnCount,
  teachCount,
  daysSet,
  totalMin,
  qualityLabel,
  totalHuman,
}: Props) {
  return (
    <View style={styles.wrap}>
      <View style={styles.topRow}>
        <Text style={styles.title}>Setup</Text>
        <View style={styles.pill}>
          <Text style={styles.pillText}>
            {completed}/{total}
          </Text>
        </View>
      </View>

      <Text style={styles.subtitle}>
        Learn: {learnCount}  Availability:{" "}
        {totalMin > 0
          ? `${qualityLabel} (${daysSet}d, ${totalHuman})`
          : "Not set"}{" "}
         Teach: {teachCount}
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: { marginBottom: 12 },
  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: { color: "#E5E7EB", fontSize: 14, fontWeight: "900" },
  pill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },
  pillText: { color: "#E5E7EB", fontSize: 12, fontWeight: "900" },
  subtitle: { color: "#9CA3AF", fontSize: 12, marginTop: 8 },
});
</file>

<file path="app/screens/home/components/StickyPrimaryCTA.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  visible: boolean;
  onPress: () => void;
  label?: string;
};

export default function StickyPrimaryCTA({
  visible,
  onPress,
  label = "Start: Find a mentor",
}: Props) {
  if (!visible) return null;

  return (
    <View style={styles.wrap} pointerEvents="box-none">
      <View style={styles.inner}>
        <TouchableOpacity
          style={styles.btn}
          onPress={onPress}
          activeOpacity={0.9}
        >
          <Text style={styles.text}>{label}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    paddingHorizontal: 16,
    paddingBottom: 14,
  },
  inner: {
    backgroundColor: "rgba(2, 6, 23, 0.85)",
    borderRadius: 18,
    padding: 10,
    borderWidth: 1,
    borderColor: "#111827",
  },
  btn: {
    backgroundColor: "#F97316",
    borderRadius: 999,
    paddingVertical: 14,
    alignItems: "center",
  },
  text: { color: "#0B1120", fontWeight: "900", fontSize: 14 },
});
</file>

<file path="app/screens/homescreen.styles.ts">
// app/screens/homescreen.styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: { flex: 1, alignItems: "center", justifyContent: "center" },

  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 16,
  },

  avatar: {
    width: 44,
    height: 44,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
  },

  avatarText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },

  nameWrap: { marginLeft: 12 },
  nameText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },
  metaText: { color: "#94A3B8", fontSize: 12, fontWeight: "700", marginTop: 2 },

  logoutBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1220",
  },

  card: {
    backgroundColor: "#0B1220",
    borderWidth: 1,
    borderColor: "#1F2937",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
  },

  cardTitle: { color: "#E5E7EB", fontSize: 14, fontWeight: "900", marginBottom: 8 },

  row: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  rowLeft: { flexDirection: "row", alignItems: "center" },

  pill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  pillText: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },

  small: { color: "#94A3B8", fontSize: 12, fontWeight: "700" },
  divider: { height: 1, backgroundColor: "#111827", marginVertical: 12 },

  actionBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  actionText: { color: "#E5E7EB", fontSize: 13, fontWeight: "900" },

  badge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },

  logoutText: { color: "#E5E7EB", fontSize: 12 },
});
</file>

<file path="app/sessions/room/[id]/components/ChatPanel.tsx">
// app/sessions/room/[id]/components/ChatPanel.tsx
import React from "react";
import {
  ActivityIndicator,
  FlatList,
  Pressable,
  Text,
  TextInput,
  View,
} from "react-native";
import type { RoomChatItem } from "../hooks/useSessionChat";

export default function ChatPanel({
  meId,
  items,
  loading,
  error,
  peerTyping,
  text,
  sending,
  canSend,
  onChangeText,
  onSend,
}: {
  meId: string;
  items: RoomChatItem[];
  loading: boolean;
  error: string | null;
  peerTyping: boolean;
  text: string;
  sending: boolean;
  canSend: boolean;
  onChangeText: (v: string) => void;
  onSend: () => void;
}) {
  return (
    <View
      style={{
        flex: 1,
        backgroundColor: "#020617",
        borderWidth: 1,
        borderColor: "#1F2937",
        borderRadius: 16,
        overflow: "hidden",
      }}
    >
      <View
        style={{
          padding: 12,
          borderBottomWidth: 1,
          borderBottomColor: "#0B1120",
        }}
      >
        <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>Chat</Text>
        {peerTyping ? (
          <Text style={{ color: "#94A3B8", marginTop: 4 }}>Typing</Text>
        ) : null}
      </View>

      {loading ? (
        <View
          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}
        >
          <ActivityIndicator />
        </View>
      ) : error ? (
        <View style={{ flex: 1, padding: 12 }}>
          <Text style={{ color: "#FCA5A5" }}>{error}</Text>
        </View>
      ) : (
        <FlatList
          data={[...items].reverse()} // inverted manually
          keyExtractor={(it) => it.id}
          contentContainerStyle={{ padding: 12, gap: 10 }}
          renderItem={({ item }) => {
            const mine = String(item.senderId) === String(meId);
            return (
              <View
                style={{
                  alignSelf: mine ? "flex-end" : "flex-start",
                  maxWidth: "80%",
                  paddingVertical: 10,
                  paddingHorizontal: 12,
                  borderRadius: 14,
                  backgroundColor: mine ? "#22C55E" : "#0F172A",
                  borderWidth: 1,
                  borderColor: "#1F2937",
                }}
              >
                <Text
                  style={{
                    color: mine ? "#052E16" : "#E2E8F0",
                    fontWeight: "700",
                  }}
                >
                  {item.text}
                </Text>
                <Text
                  style={{
                    color: mine ? "#064E3B" : "#64748B",
                    marginTop: 4,
                    fontSize: 12,
                  }}
                >
                  {new Date(item.createdAt).toLocaleTimeString()}
                </Text>
              </View>
            );
          }}
        />
      )}

      <View
        style={{
          padding: 10,
          borderTopWidth: 1,
          borderTopColor: "#0B1120",
          gap: 8,
        }}
      >
        <TextInput
          value={text}
          onChangeText={onChangeText}
          placeholder="Type a message"
          placeholderTextColor="#64748B"
          style={{
            backgroundColor: "#0B1220",
            borderWidth: 1,
            borderColor: "#1F2937",
            borderRadius: 12,
            paddingHorizontal: 12,
            paddingVertical: 10,
            color: "#E2E8F0",
          }}
        />
        <Pressable
          onPress={onSend}
          disabled={!canSend || sending}
          style={{
            paddingVertical: 10,
            borderRadius: 12,
            backgroundColor: !canSend || sending ? "#14532D" : "#22C55E",
            opacity: !canSend || sending ? 0.6 : 1,
            alignItems: "center",
          }}
        >
          <Text style={{ color: "#052E16", fontWeight: "900" }}>
            {sending ? "Sending" : "Send"}
          </Text>
        </Pressable>
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/room/[id]/components/FilesPanel.tsx">
// app/sessions/room/[id]/components/FilesPanel.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";
import type { SessionFileDTO } from "../../../api/sessionsApi";

export default function FilesPanel({
  files,
  loading,
  error,
  uploading,
  onUpload,
}: {
  files: SessionFileDTO[];
  loading: boolean;
  error: string | null;
  uploading: boolean;
  onUpload: () => void;
}) {
  return (
    <View
      style={{
        backgroundColor: "#0B1220",
        borderWidth: 1,
        borderColor: "#1F2937",
        borderRadius: 16,
        padding: 12,
        gap: 10,
      }}
    >
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>Files</Text>

        <Pressable
          onPress={onUpload}
          disabled={uploading}
          style={{
            paddingVertical: 8,
            paddingHorizontal: 10,
            borderRadius: 12,
            backgroundColor: "#334155",
            opacity: uploading ? 0.6 : 1,
          }}
        >
          <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>
            {uploading ? "Uploading" : "Upload"}
          </Text>
        </Pressable>
      </View>

      {loading ? (
        <ActivityIndicator />
      ) : error ? (
        <Text style={{ color: "#FCA5A5" }}>{error}</Text>
      ) : files.length === 0 ? (
        <Text style={{ color: "#64748B" }}>No files yet.</Text>
      ) : (
        files.slice(0, 6).map((f) => (
          <View
            key={f._id}
            style={{
              padding: 10,
              borderRadius: 12,
              backgroundColor: "#0F172A",
              borderWidth: 1,
              borderColor: "#1F2937",
            }}
          >
            <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>
              {f.name}
            </Text>
            <Text style={{ color: "#64748B", marginTop: 2 }}>{f.url}</Text>
          </View>
        ))
      )}
    </View>
  );
}
</file>

<file path="app/sessions/room/[id]/components/MessageBubble.tsx">
import { Text, View } from "react-native";

export default function MessageBubble({
  msg,
  mine,
}: {
  msg: any;
  mine: boolean;
}) {
  return (
    <View
      style={{
        alignSelf: mine ? "flex-end" : "flex-start",
        backgroundColor: mine ? "#10B981" : "#1F2937",
        padding: 10,
        borderRadius: 12,
        marginVertical: 4,
        maxWidth: "80%",
      }}
    >
      <Text style={{ color: "#fff" }}>{msg.text}</Text>
    </View>
  );
}
</file>

<file path="app/sessions/room/[id]/components/RoomHeader.tsx">
// app/sessions/room/[id]/components/RoomHeader.tsx
import React, { useMemo } from "react";
import { Pressable, Text, View } from "react-native";
import type { SessionDTO } from "../../../api/sessionsApi";

function fmtCountdown(sec: number | null) {
  if (sec === null) return "";
  const s = Math.max(0, sec);
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const r = s % 60;
  if (h > 0) return `${h}h ${m}m ${r}s`;
  if (m > 0) return `${m}m ${r}s`;
  return `${r}s`;
}

export default function RoomHeader({
  session,
  countdownSeconds,
  joinEnabled,
  joinHint,
  busy,
  onJoin,
  onCancel,
  onRefresh,
  onBack,
}: {
  session: SessionDTO;
  countdownSeconds: number | null;
  joinEnabled: boolean;
  joinHint: string;
  busy: boolean;
  onJoin: () => void;
  onCancel: () => void;
  onRefresh: () => void;
  onBack: () => void;
}) {
  const statusText = useMemo(
    () => String(session.status).toUpperCase(),
    [session.status]
  );

  const showJoin = session.status === "accepted";
  const showCancel =
    session.status !== "completed" && session.status !== "cancelled";

  return (
    <View
      style={{
        backgroundColor: "#0B1220",
        borderWidth: 1,
        borderColor: "#1F2937",
        borderRadius: 16,
        padding: 12,
        gap: 10,
      }}
    >
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          gap: 10,
        }}
      >
        <View style={{ flex: 1 }}>
          <Text style={{ color: "#E2E8F0", fontWeight: "900", fontSize: 16 }}>
            {session.skill || "Session"}{" "}
            {session.level ? ` ${session.level}` : ""}
          </Text>

          <Text style={{ color: "#94A3B8", marginTop: 4 }}>
            {session.scheduledAt
              ? new Date(session.scheduledAt).toLocaleString()
              : ""}
          </Text>

          <Text style={{ color: "#64748B", marginTop: 4 }}>
            Starts in:{" "}
            {countdownSeconds !== null && countdownSeconds > 0
              ? fmtCountdown(countdownSeconds)
              : "Started"}
          </Text>

          {showJoin ? (
            <Text
              style={{
                color: joinEnabled ? "#22C55E" : "#F59E0B",
                marginTop: 6,
              }}
            >
              {joinHint}
            </Text>
          ) : null}
        </View>

        <View style={{ alignItems: "flex-end" }}>
          <View
            style={{
              paddingHorizontal: 10,
              paddingVertical: 6,
              borderRadius: 999,
              backgroundColor: "#111827",
              borderWidth: 1,
              borderColor: "#1F2937",
            }}
          >
            <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>
              {statusText}
            </Text>
          </View>
        </View>
      </View>

      <View style={{ flexDirection: "row", flexWrap: "wrap", gap: 10 }}>
        {showJoin ? (
          <Pressable
            onPress={onJoin}
            disabled={!joinEnabled || busy}
            style={{
              paddingVertical: 10,
              paddingHorizontal: 12,
              borderRadius: 12,
              backgroundColor: !joinEnabled || busy ? "#14532D" : "#22C55E",
              opacity: !joinEnabled || busy ? 0.6 : 1,
            }}
          >
            <Text style={{ color: "#052E16", fontWeight: "900" }}>
              Join (Zoom)
            </Text>
          </Pressable>
        ) : null}

        {showCancel ? (
          <Pressable
            onPress={onCancel}
            disabled={busy}
            style={{
              paddingVertical: 10,
              paddingHorizontal: 12,
              borderRadius: 12,
              backgroundColor: "#334155",
              opacity: busy ? 0.6 : 1,
            }}
          >
            <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>Cancel</Text>
          </Pressable>
        ) : null}

        <Pressable
          onPress={onRefresh}
          disabled={busy}
          style={{
            paddingVertical: 10,
            paddingHorizontal: 12,
            borderRadius: 12,
            backgroundColor: "#1F2937",
            opacity: busy ? 0.6 : 1,
          }}
        >
          <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>Refresh</Text>
        </Pressable>

        <Pressable
          onPress={onBack}
          disabled={busy}
          style={{
            paddingVertical: 10,
            paddingHorizontal: 12,
            borderRadius: 12,
            backgroundColor: "#0F172A",
            borderWidth: 1,
            borderColor: "#1F2937",
            opacity: busy ? 0.6 : 1,
          }}
        >
          <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>
            My Sessions
          </Text>
        </Pressable>
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/room/[id]/hooks/useSessionChat.ts">
// app/sessions/room/[id]/hooks/useSessionChat.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import type { SessionChatMsg } from "../../../api/sessionsApi";
import {
    getSessionTyping,
    listSessionChat,
    sendSessionChat,
    setSessionTyping,
} from "../../../api/sessionsApi";

export type RoomChatItem = {
  id: string;
  senderId: string;
  text: string;
  createdAt: string;
};

async function getToken() {
  return (await AsyncStorage.getItem("token")) || null;
}

function mapMsg(m: SessionChatMsg): RoomChatItem {
  return {
    id: String(m._id),
    senderId: String(m.senderId),
    text: String(m.text || ""),
    createdAt: String(m.createdAt || new Date().toISOString()),
  };
}

export function useSessionChat(sessionId: string, meId: string) {
  const [items, setItems] = useState<RoomChatItem[]>([]);
  const [loadingChat, setLoadingChat] = useState(true);
  const [errorChat, setErrorChat] = useState<string | null>(null);

  const [text, setText] = useState("");
  const [sending, setSending] = useState(false);

  const [peerTyping, setPeerTyping] = useState(false);

  const tokenRef = useRef<string | null>(null);
  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const typingPollRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const typingDebounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const refresh = useCallback(
    async (silent?: boolean) => {
      if (!sessionId) return;

      try {
        setErrorChat(null);
        if (!silent) setLoadingChat(true);

        const tk = tokenRef.current || (await getToken());
        tokenRef.current = tk;
        if (!tk) {
          setItems([]);
          setErrorChat("Not logged in");
          return;
        }

        const msgs = await listSessionChat(tk, sessionId);
        const mapped = msgs.map((m: SessionChatMsg) => mapMsg(m));

        // sort newest last for UI, we'll render inverted in component
        mapped.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
        setItems(mapped);
      } catch (e: any) {
        setErrorChat(e?.message || "Failed to load chat");
      } finally {
        if (!silent) setLoadingChat(false);
      }
    },
    [sessionId]
  );

  useEffect(() => {
    void refresh(false);

    if (pollRef.current) clearInterval(pollRef.current);
    pollRef.current = setInterval(() => void refresh(true), 5000);

    return () => {
      if (pollRef.current) clearInterval(pollRef.current);
      pollRef.current = null;
    };
  }, [refresh]);

  // typing poll (requirement #10)
  useEffect(() => {
    if (!sessionId) return;

    const run = async () => {
      const tk = tokenRef.current || (await getToken());
      tokenRef.current = tk;
      if (!tk) return;

      try {
        const res = await getSessionTyping(tk, sessionId);
        const ids = Array.isArray(res?.typingUserIds) ? res.typingUserIds : [];
const someoneElseTyping = ids.some((id: string) => String(id) !== String(meId));
        setPeerTyping(someoneElseTyping);
      } catch {
        // ignore typing failures to avoid noise
      }
    };

    void run();

    if (typingPollRef.current) clearInterval(typingPollRef.current);
    typingPollRef.current = setInterval(() => void run(), 2500);

    return () => {
      if (typingPollRef.current) clearInterval(typingPollRef.current);
      typingPollRef.current = null;
    };
  }, [meId, sessionId]);

  const send = useCallback(async () => {
    const t = text.trim();
    if (!t || sending) return;
    if (!sessionId) return;

    const tk = tokenRef.current || (await getToken());
    tokenRef.current = tk;
    if (!tk) {
      setErrorChat("Not logged in");
      return;
    }

    const optimistic: RoomChatItem = {
      id: `optimistic-${Math.random().toString(16).slice(2)}`,
      senderId: meId || "me",
      text: t,
      createdAt: new Date().toISOString(),
    };

    setSending(true);
    setText("");
    setItems((prev) => [...prev, optimistic]);

    try {
      const real = await sendSessionChat(tk, sessionId, t);
      const mapped = mapMsg(real);

      setItems((prev) => {
        const without = prev.filter((x) => x.id !== optimistic.id);
        return [...without, mapped].sort(
          (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        );
      });

      // stop typing after send
      try {
        await setSessionTyping(tk, sessionId, false);
      } catch {}
    } catch (e: any) {
      setItems((prev) => prev.filter((x) => x.id !== optimistic.id));
      setText(t);
      setErrorChat(e?.message || "Failed to send");
    } finally {
      setSending(false);
    }
  }, [meId, sending, sessionId, text]);

  // send typing with debounce while user types (requirement #10)
  useEffect(() => {
    if (!sessionId) return;

    const run = async () => {
      const tk = tokenRef.current || (await getToken());
      tokenRef.current = tk;
      if (!tk) return;

      try {
        await setSessionTyping(tk, sessionId, text.trim().length > 0);
      } catch {
        // ignore
      }
    };

    if (typingDebounceRef.current) clearTimeout(typingDebounceRef.current);
    typingDebounceRef.current = setTimeout(() => void run(), 350);

    return () => {
      if (typingDebounceRef.current) clearTimeout(typingDebounceRef.current);
      typingDebounceRef.current = null;
    };
  }, [sessionId, text]);

  const canSend = useMemo(() => text.trim().length > 0 && !sending, [sending, text]);

  return {
    items,
    loadingChat,
    errorChat,

    text,
    setText,
    sending,
    canSend,

    peerTyping,

    refresh,
    send,
  };
}
</file>

<file path="app/sessions/room/[id]/hooks/useSessionFiles.ts">
// app/sessions/room/[id]/hooks/useSessionFiles.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as DocumentPicker from "expo-document-picker";
import { useCallback, useEffect, useRef, useState } from "react";

import type { SessionFileDTO } from "../../../api/sessionsApi";
import { listSessionFiles, uploadSessionFile } from "../../../api/sessionsApi";

async function getToken() {
  return (await AsyncStorage.getItem("token")) || null;
}

export function useSessionFiles(sessionId: string) {
  const [files, setFiles] = useState<SessionFileDTO[]>([]);
  const [loadingFiles, setLoadingFiles] = useState(true);
  const [errorFiles, setErrorFiles] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);

  const tokenRef = useRef<string | null>(null);

  const refresh = useCallback(
    async (silent?: boolean) => {
      if (!sessionId) return;

      try {
        setErrorFiles(null);
        if (!silent) setLoadingFiles(true);

        const tk = tokenRef.current || (await getToken());
        tokenRef.current = tk;
        if (!tk) {
          setFiles([]);
          setErrorFiles("Not logged in");
          return;
        }

        const list = await listSessionFiles(tk, sessionId);
        setFiles(Array.isArray(list) ? list : []);
      } catch (e: any) {
        setErrorFiles(e?.message || "Failed to load files");
      } finally {
        if (!silent) setLoadingFiles(false);
      }
    },
    [sessionId]
  );

  useEffect(() => {
    void refresh(false);
  }, [refresh]);

  const upload = useCallback(async () => {
    if (!sessionId || uploading) return;

    const tk = tokenRef.current || (await getToken());
    tokenRef.current = tk;
    if (!tk) {
      setErrorFiles("Not logged in");
      return;
    }

    try {
      const res = await DocumentPicker.getDocumentAsync({
        type: "*/*",
        copyToCacheDirectory: true,
        multiple: false,
      });

      if (res.canceled) return;
      const asset = res.assets?.[0];
      if (!asset?.uri) return;

      setUploading(true);
      const up = await uploadSessionFile(tk, sessionId, {
        uri: asset.uri,
        name: asset.name || "file",
        mimeType: asset.mimeType || "application/octet-stream",
      });

      setFiles((prev) => [up, ...prev]);
    } catch (e: any) {
      setErrorFiles(e?.message || "Upload failed");
    } finally {
      setUploading(false);
    }
  }, [sessionId, uploading]);

  return {
    files,
    loadingFiles,
    errorFiles,
    uploading,
    refresh,
    upload,
  };
}
</file>

<file path="app/sessions/room/[id]/hooks/useSessionRoom.ts">
// app/sessions/room/[id]/hooks/useSessionRoom.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Alert, Linking } from "react-native";

import { getMe } from "../../../../../lib/api";
import type { SessionDTO, SessionStatus } from "../../../api/sessionsApi";
import { ensureZoomMeeting, getSessionById, joinSession, updateSessionStatus } from "../../../api/sessionsApi";

const UI_RULES = {
  JOIN_EARLY_MIN: 5,
  JOIN_LATE_MIN: 180,
};

function toMs(iso?: string | null) {
  if (!iso) return null;
  const t = new Date(String(iso)).getTime();
  return Number.isFinite(t) ? t : null;
}
function minutesUntil(iso?: string | null) {
  const t = toMs(iso);
  if (!t) return null;
  return Math.floor((t - Date.now()) / 60000);
}
function secondsUntil(iso?: string | null) {
  const t = toMs(iso);
  if (!t) return null;
  return Math.floor((t - Date.now()) / 1000);
}

function canJoinNow(iso?: string | null) {
  const untilMin = minutesUntil(iso);
  if (untilMin === null) return { ok: false as const, reason: "Invalid time" };

  if (untilMin > 0 && untilMin <= UI_RULES.JOIN_EARLY_MIN) return { ok: true as const };
  if (untilMin <= 0) {
    const start = toMs(iso) || Date.now();
    const sinceMin = Math.floor((Date.now() - start) / 60000);
    if (sinceMin <= UI_RULES.JOIN_LATE_MIN) return { ok: true as const };
    return { ok: false as const, reason: "Join window expired" };
  }
  return { ok: false as const, reason: `Join opens ${UI_RULES.JOIN_EARLY_MIN} min before` };
}

async function getToken() {
  return (await AsyncStorage.getItem("token")) || null;
}

export function useSessionRoom(sessionId: string) {
  const [meId, setMeId] = useState<string>("");
  const [session, setSession] = useState<SessionDTO | null>(null);

  const [loadingSession, setLoadingSession] = useState(true);
  const [busyAction, setBusyAction] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const tokenRef = useRef<string | null>(null);
  const refreshTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const tickRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const [tick, setTick] = useState(0);

  const refresh = useCallback(
    async (silent?: boolean) => {
      if (!sessionId) return;

      try {
        setError(null);
        if (!silent) setLoadingSession(true);

        const tk = tokenRef.current || (await getToken());
        tokenRef.current = tk;

        if (!tk) {
          setSession(null);
          setError("Not logged in");
          return;
        }

        const me = await getMe(tk);
        const myId = String((me as any)?._id || (me as any)?.id || "").trim();
        setMeId(myId);

        const s = await getSessionById(tk, sessionId);
        setSession(s);
      } catch (e: any) {
        setError(e?.message || "Failed to load session");
        setSession(null);
      } finally {
        if (!silent) setLoadingSession(false);
      }
    },
    [sessionId]
  );

  useEffect(() => {
    void refresh(false);

    if (tickRef.current) clearInterval(tickRef.current);
    tickRef.current = setInterval(() => setTick((x) => x + 1), 1000);

    if (refreshTimerRef.current) clearInterval(refreshTimerRef.current);
    refreshTimerRef.current = setInterval(() => void refresh(true), 8000);

    return () => {
      if (tickRef.current) clearInterval(tickRef.current);
      if (refreshTimerRef.current) clearInterval(refreshTimerRef.current);
      tickRef.current = null;
      refreshTimerRef.current = null;
    };
  }, [refresh]);

  const isMentor = useMemo(() => {
    if (!session || !meId) return false;
    return String(session.mentorId) === String(meId);
  }, [session, meId]);

  const isLearner = useMemo(() => {
    if (!session || !meId) return false;
    return String(session.learnerId) === String(meId);
  }, [session, meId]);

  const joinGate = useMemo(() => {
    void tick;
    return canJoinNow(session?.scheduledAt);
  }, [session?.scheduledAt, tick]);

  const countdownSeconds = useMemo(() => {
    void tick;
    return secondsUntil(session?.scheduledAt);
  }, [session?.scheduledAt, tick]);

  const runStatus = useCallback(
    async (status: SessionStatus) => {
      const tk = tokenRef.current || (await getToken());
      tokenRef.current = tk;
      if (!tk) return Alert.alert("Not logged in", "Please login again.");

      try {
        setBusyAction(true);
        const updated = await updateSessionStatus(tk, sessionId, status);
        setSession(updated);
      } catch (e: any) {
        Alert.alert("Failed", e?.message || "Request failed");
      } finally {
        setBusyAction(false);
      }
    },
    [sessionId]
  );

  const cancel = useCallback(async () => {
    if (!session) return;
    if (session.status === "cancelled" || session.status === "completed") {
      return Alert.alert("Not allowed", "Session already finished.");
    }

    Alert.alert("Cancel session", "Are you sure you want to cancel?", [
      { text: "Back", style: "cancel" },
      { text: "Cancel", style: "destructive", onPress: () => void runStatus("cancelled") },
    ]);
  }, [runStatus, session]);

  const openZoom = useCallback(async () => {
    if (!session) return;

    if (session.status !== "accepted") {
      return Alert.alert("Not allowed", "Session must be accepted first.");
    }
    if (!joinGate.ok) {
      return Alert.alert("Join locked", joinGate.reason || "Join is not available yet.");
    }

    const tk = tokenRef.current || (await getToken());
    tokenRef.current = tk;
    if (!tk) return Alert.alert("Not logged in", "Please login again.");

    try {
      setBusyAction(true);

      // mark join on server (keeps your existing flow)
      const updated = await joinSession(tk, sessionId);
      setSession(updated);

      //  Safe zoom url resolution:
      // 1) prefer updated.zoomJoinUrl
      // 2) else try ensureZoomMeeting
      // 3) else fallback to session.zoomJoinUrl if exists
      let zoomUrl = String(updated?.zoomJoinUrl || "").trim();
      if (!zoomUrl) {
        try {
          const ensured = await ensureZoomMeeting(tk, sessionId);
          zoomUrl = String((ensured as any)?.zoomJoinUrl || "").trim();
        } catch {}
      }
      if (!zoomUrl) {
        zoomUrl = String(session?.zoomJoinUrl || "").trim();
      }

      if (!zoomUrl) {
        Alert.alert("Missing Zoom link", "No Zoom link found for this session.");
        return;
      }

      const can = await Linking.canOpenURL(zoomUrl);
      if (!can) {
        Alert.alert("Cannot open", "Invalid Zoom link.");
        return;
      }
      await Linking.openURL(zoomUrl);
    } catch (e: any) {
      Alert.alert("Join failed", e?.message || "Failed to join session.");
    } finally {
      setBusyAction(false);
    }
  }, [joinGate.ok, joinGate.reason, session, sessionId]);

  return {
    meId,
    session,

    loadingSession,
    busyAction,
    error,

    isMentor,
    isLearner,

    joinGate,
    countdownSeconds,

    refresh,
    cancel,
    openZoom,
  };
}
</file>

<file path="app/sessions/room/[id]/index.tsx">
// app/sessions/room/[id]/index.tsx
import { useLocalSearchParams, useRouter } from "expo-router";
import React from "react";
import { ActivityIndicator, StyleSheet, Text, View } from "react-native";

import ChatPanel from "./components/ChatPanel";
import FilesPanel from "./components/FilesPanel";
import RoomHeader from "./components/RoomHeader";

import { useSessionChat } from "./hooks/useSessionChat";
import { useSessionFiles } from "./hooks/useSessionFiles";
import { useSessionRoom } from "./hooks/useSessionRoom";

export default function SessionRoomScreen() {
  const router = useRouter();
  const { id } = useLocalSearchParams<{ id: string }>();
  const sessionId = String(id || "").trim();

  const room = useSessionRoom(sessionId);
  const files = useSessionFiles(sessionId);
  const chat = useSessionChat(sessionId, room.meId);

  if (!sessionId) {
    return (
      <View style={styles.center}>
        <Text style={styles.error}>Missing session id</Text>
      </View>
    );
  }

  if (room.loadingSession) {
    return (
      <View style={styles.center}>
        <ActivityIndicator />
      </View>
    );
  }

  if (room.error || !room.session) {
    return (
      <View style={styles.center}>
        <Text style={styles.error}>{room.error || "Session not found"}</Text>
      </View>
    );
  }

  const joinEnabled = !!room.joinGate.ok && !room.busyAction;
  const joinHint =
    room.session.status !== "accepted"
      ? "Session is not accepted yet."
      : room.joinGate.ok
      ? "Join is available now."
      : room.joinGate.reason || "Join is locked.";

  return (
    <View style={styles.container}>
      <RoomHeader
        session={room.session}
        countdownSeconds={room.countdownSeconds}
        joinEnabled={joinEnabled}
        joinHint={joinHint}
        busy={room.busyAction}
        onJoin={room.openZoom}
        onCancel={room.cancel}
        onRefresh={() => {
          room.refresh(false);
          files.refresh(false);
          chat.refresh(false);
        }}
        onBack={() => router.replace("/sessions")} // adjust if your My Sessions route differs
      />

      <FilesPanel
        files={files.files}
        loading={files.loadingFiles}
        error={files.errorFiles}
        uploading={files.uploading}
        onUpload={files.upload}
      />

      <ChatPanel
        meId={room.meId}
        items={chat.items}
        loading={chat.loadingChat}
        error={chat.errorChat}
        peerTyping={chat.peerTyping}
        text={chat.text}
        sending={chat.sending}
        canSend={chat.canSend}
        onChangeText={chat.setText}
        onSend={chat.send}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#0B1220",
    padding: 14,
    gap: 12,
  },
  center: {
    flex: 1,
    backgroundColor: "#0B1220",
    justifyContent: "center",
    alignItems: "center",
    padding: 14,
  },
  error: {
    color: "#E2E8F0",
    fontSize: 16,
    fontWeight: "900",
    textAlign: "center",
  },
});
</file>

<file path="app/sessions/room/[id]/utils/presence.ts">

</file>

<file path="app/sessions/room/[id]/utils/zoom.ts">

</file>

<file path="app/sessions/room/[id]old.tsx">
import * as DocumentPicker from "expo-document-picker";
import { useLocalSearchParams } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";

import {
  ActivityIndicator,
  Alert,
  FlatList,
  Linking,
  Pressable,
  Text,
  TextInput,
  View,
} from "react-native";

import type { SessionDTO } from "../api/sessionsApi";
import {
  getSessionById,
  listSessionChat,
  listSessionFiles,
  sendSessionChat,
  updateSessionStatus,
  uploadSessionFile,
} from "../api/sessionsApi";

import AsyncStorage from "@react-native-async-storage/async-storage";
import { API_URL } from "../../../lib/api";

type ChatMsg = {
  _id: string;
  senderId: string;
  text: string;
  createdAt: string;
};

type SessionFile = {
  _id: string;
  uploaderId: string;
  name: string;
  url: string;
  createdAt: string;
};

async function getToken() {
  //       
  return (await AsyncStorage.getItem("token")) || null;
}

export default function SessionRoomScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const sessionId = String(id || "").trim();
console.log("ROOM PARAMS", { id, sessionId });

  const [token, setToken] = useState<string | null>(null);

  const [loading, setLoading] = useState(true);
  const [session, setSession] = useState<SessionDTO | null>(null);

  const [chatLoading, setChatLoading] = useState(false);
  const [messages, setMessages] = useState<ChatMsg[]>([]);
  const [text, setText] = useState("");

  const [filesLoading, setFilesLoading] = useState(false);
  const [files, setFiles] = useState<SessionFile[]>([]);

  const [busy, setBusy] = useState(false);

  const flatRef = useRef<FlatList>(null);

  const zoomUrl = useMemo(() => (session as any)?.zoomJoinUrl || "", [session]);

  async function loadAll(tk: string) {
    try {
      setLoading(true);
      console.log("ROOM LOAD", { sessionId, API_URL });

      const s = await getSessionById(tk, sessionId);
      console.log("ROOM GOT SESSION", { ok: !!s, _id: (s as any)?._id, status: (s as any)?.status });

      setSession(s);

      setChatLoading(true);
      const chat = await listSessionChat(tk, sessionId);
      setMessages(chat);

      setFilesLoading(true);
      const fl = await listSessionFiles(tk, sessionId);
      setFiles(fl);
    } catch (e: any) {
console.log("ROOM ERROR", {
  message: e?.message,
  status: e?.status,
  body: e?.body,
});
Alert.alert(
  "Failed",
  `${e?.message || "Failed"}\nstatus=${e?.status || "?"}\n${JSON.stringify(e?.body || {}, null, 2)}`
);
    } finally {
      setLoading(false);
      setChatLoading(false);
      setFilesLoading(false);
    }
  }

  useEffect(() => {
    (async () => {
      const tk = await getToken();
      setToken(tk);
      if (!tk) {
        setLoading(false);
        Alert.alert("Not logged in", "Please login again.");
        return;
      }
      if (!sessionId) {
        setLoading(false);
        Alert.alert("Missing id", "No session id in route.");
        return;
      }
      await loadAll(tk);
    })();
  }, [sessionId]);

  const onSend = async () => {
    if (!token) return;
    const t = text.trim();
    if (!t) return;

    try {
      setBusy(true);
      const msg = await sendSessionChat(token, sessionId, t);
      setMessages((prev) => [...prev, msg]);
      setText("");

      // scroll
      setTimeout(() => flatRef.current?.scrollToEnd?.({ animated: true }), 50);
    } catch (e: any) {
      Alert.alert("Send failed", e?.message || "Send failed");
    } finally {
      setBusy(false);
    }
  };

  const onPickUpload = async () => {
    if (!token) return;

    try {
      const res = await DocumentPicker.getDocumentAsync({
        type: "*/*",
        copyToCacheDirectory: true,
        multiple: false,
      });

      if (res.canceled) return;
      const file = res.assets?.[0];
      if (!file?.uri) return;

      setBusy(true);
      const uploaded = await uploadSessionFile(token, sessionId, {
        uri: file.uri,
        name: file.name || "file",
        mimeType: file.mimeType || "application/octet-stream",
      });

      setFiles((prev) => [uploaded, ...prev]);
    } catch (e: any) {
      Alert.alert("Upload failed", e?.message || "Upload failed");
    } finally {
      setBusy(false);
    }
  };

  const onEnterZoom = async () => {
    const url = String(zoomUrl || "").trim();
    if (!url) {
      Alert.alert("No Zoom link", "This session has no zoomJoinUrl yet.");
      return;
    }
    const ok = await Linking.canOpenURL(url);
    if (!ok) return Alert.alert("Cannot open", "Invalid Zoom link.");
    Linking.openURL(url);
  };

  const onEndMeeting = async () => {
    if (!token || !sessionId) return;

    const ok = await new Promise<boolean>((resolve) => {
      Alert.alert("End meeting", "This will mark the session as completed.", [
        { text: "Cancel", style: "cancel", onPress: () => resolve(false) },
        { text: "End", style: "destructive", onPress: () => resolve(true) },
      ]);
    });
    if (!ok) return;

    try {
      setBusy(true);
      const updated = await updateSessionStatus(token, sessionId, "completed");
      setSession(updated);
      Alert.alert("Done", "Session marked as completed.");
    } catch (e: any) {
      Alert.alert("Failed", e?.message || "Failed to complete session");
    } finally {
      setBusy(false);
    }
  };

  if (loading) {
    return (
      <View style={{ flex: 1, backgroundColor: "#0B1220", padding: 16 }}>
        <ActivityIndicator />
      </View>
    );
  }

  if (!session) {
    return (
      <View style={{ flex: 1, backgroundColor: "#0B1220", padding: 16 }}>
        <Text style={{ color: "#E2E8F0" }}>Session not found.</Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, backgroundColor: "#0B1220", padding: 14, gap: 12 }}>
      {/* Header */}
      <View
        style={{
          borderWidth: 1,
          borderColor: "#1F2937",
          borderRadius: 16,
          padding: 12,
          gap: 6,
        }}
      >
        <Text style={{ color: "#E2E8F0", fontWeight: "900", fontSize: 16 }}>
          {session.skill}  {session.level}
        </Text>
        <Text style={{ color: "#94A3B8" }}>{session.scheduledAt}</Text>
        <Text style={{ color: "#64748B" }}>Status: {session.status}</Text>

        {/* Actions */}
        <View style={{ flexDirection: "row", gap: 10, flexWrap: "wrap" }}>
          <Pressable
            onPress={onEnterZoom}
            disabled={busy}
            style={{
              paddingVertical: 10,
              paddingHorizontal: 12,
              borderRadius: 12,
              backgroundColor: "#10B981",
              opacity: busy ? 0.6 : 1,
            }}
          >
            <Text style={{ color: "#0B1220", fontWeight: "900" }}>
              Enter Zoom
            </Text>
          </Pressable>

          <Pressable
            onPress={onEndMeeting}
            disabled={busy}
            style={{
              paddingVertical: 10,
              paddingHorizontal: 12,
              borderRadius: 12,
              backgroundColor: "#EF4444",
              opacity: busy ? 0.6 : 1,
            }}
          >
            <Text style={{ color: "#0B1220", fontWeight: "900" }}>
              End Meeting
            </Text>
          </Pressable>

          <Pressable
            onPress={() => token && loadAll(token)}
            disabled={busy}
            style={{
              paddingVertical: 10,
              paddingHorizontal: 12,
              borderRadius: 12,
              backgroundColor: "#334155",
              opacity: busy ? 0.6 : 1,
            }}
          >
            <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>Refresh</Text>
          </Pressable>
        </View>
      </View>

      {/* Files */}
      <View
        style={{
          borderWidth: 1,
          borderColor: "#1F2937",
          borderRadius: 16,
          padding: 12,
          gap: 10,
          flexShrink: 0,
        }}
      >
        <View style={{ flexDirection: "row", justifyContent: "space-between" }}>
          <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>Files</Text>

          <Pressable
            onPress={onPickUpload}
            disabled={busy}
            style={{
              paddingVertical: 8,
              paddingHorizontal: 10,
              borderRadius: 12,
              backgroundColor: "#334155",
              opacity: busy ? 0.6 : 1,
            }}
          >
            <Text style={{ color: "#E2E8F0", fontWeight: "800" }}>Upload</Text>
          </Pressable>
        </View>

        {filesLoading ? (
          <ActivityIndicator />
        ) : files.length === 0 ? (
          <Text style={{ color: "#64748B" }}>No files yet.</Text>
        ) : (
          files.slice(0, 6).map((f) => (
            <Pressable
              key={f._id}
              onPress={() => {
                const u = String(f.url || "");
                const full = u.startsWith("http") ? u : `${API_URL}${u}`;
                Linking.openURL(full);
              }}
              style={{
                padding: 10,
                borderRadius: 12,
                backgroundColor: "#0F172A",
                borderWidth: 1,
                borderColor: "#1F2937",
              }}
            >
              <Text style={{ color: "#E2E8F0", fontWeight: "800" }}>
                {f.name}
              </Text>
              <Text style={{ color: "#64748B", marginTop: 2 }}>
                Tap to open
              </Text>
            </Pressable>
          ))
        )}
      </View>

      {/* Chat */}
      <View
        style={{
          flex: 1,
          borderWidth: 1,
          borderColor: "#1F2937",
          borderRadius: 16,
          padding: 12,
          gap: 10,
        }}
      >
        <Text style={{ color: "#E2E8F0", fontWeight: "900" }}>Chat</Text>

        {chatLoading ? (
          <ActivityIndicator />
        ) : (
          <FlatList
            ref={flatRef}
            data={messages}
            keyExtractor={(m) => m._id}
            renderItem={({ item }) => (
              <View style={{ paddingVertical: 6 }}>
                <Text style={{ color: "#94A3B8", fontSize: 12 }}>
                  {item.senderId}
                </Text>
                <Text style={{ color: "#E2E8F0", fontWeight: "700" }}>
                  {item.text}
                </Text>
              </View>
            )}
          />
        )}

        <View style={{ flexDirection: "row", gap: 10 }}>
          <TextInput
            value={text}
            onChangeText={setText}
            placeholder="Type..."
            placeholderTextColor="#64748B"
            style={{
              flex: 1,
              borderWidth: 1,
              borderColor: "#1F2937",
              borderRadius: 12,
              padding: 10,
              color: "#E2E8F0",
            }}
          />
          <Pressable
            onPress={onSend}
            disabled={busy}
            style={{
              paddingVertical: 10,
              paddingHorizontal: 12,
              borderRadius: 12,
              backgroundColor: "#10B981",
              opacity: busy ? 0.6 : 1,
              justifyContent: "center",
            }}
          >
            <Text style={{ color: "#0B1220", fontWeight: "900" }}>Send</Text>
          </Pressable>
        </View>
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/(components)/SessionsEmptyState.tsx">
import React from "react";
import { Pressable, StyleSheet, Text, View } from "react-native";

type Variant = "noSessions" | "noResults" | "error";

type Props = {
  variant: Variant;
  title?: string;
  body?: string;
  primaryText?: string;
  onPrimary?: () => void;
  secondaryText?: string;
  onSecondary?: () => void;
};

export default function SessionsEmptyState({
  variant,
  title,
  body,
  primaryText,
  onPrimary,
  secondaryText,
  onSecondary,
}: Props) {
  const defaults = getDefaults(variant);

  const t = title || defaults.title;
  const b = body || defaults.body;

  const showPrimary = !!primaryText && !!onPrimary;
  const showSecondary = !!secondaryText && !!onSecondary;

  return (
    <View style={styles.wrap} accessibilityRole="summary">
      <Text style={styles.icon} accessibilityLabel="Empty state icon">
        {defaults.icon}
      </Text>

      <Text style={styles.title}>{t}</Text>
      <Text style={styles.body}>{b}</Text>

      {(showPrimary || showSecondary) && (
        <View style={styles.btnRow}>
          {showPrimary && (
            <Pressable
              onPress={onPrimary}
              accessibilityRole="button"
              accessibilityLabel={primaryText}
              style={({ pressed }) => [
                styles.primaryBtn,
                pressed ? { opacity: 0.92 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.primaryText}>{primaryText}</Text>
            </Pressable>
          )}

          {showSecondary && (
            <Pressable
              onPress={onSecondary}
              accessibilityRole="button"
              accessibilityLabel={secondaryText}
              style={({ pressed }) => [
                styles.secondaryBtn,
                pressed ? { opacity: 0.92 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.secondaryText}>{secondaryText}</Text>
            </Pressable>
          )}
        </View>
      )}
    </View>
  );
}

function getDefaults(v: Variant) {
  if (v === "noResults") {
    return {
      icon: "",
      title: "No results",
      body: "Try changing filters or search keywords.",
    };
  }

  if (v === "error") {
    return {
      icon: "",
      title: "Something went wrong",
      body: "Couldnt load sessions. Please try again.",
    };
  }

  return {
    icon: "",
    title: "No sessions yet",
    body: "When you request a session, it will appear here with full details.",
  };
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 16,
    alignItems: "center",
    gap: 8,
  },

  icon: {
    fontSize: 28,
  },

  title: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 16,
    textAlign: "center",
  },

  body: {
    color: "#94A3B8",
    fontWeight: "700",
    fontSize: 12,
    textAlign: "center",
    lineHeight: 18,
  },

  btnRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 10,
  },

  primaryBtn: {
    backgroundColor: "#F97316",
    borderColor: "#FB923C",
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 10,
  },

  primaryText: {
    color: "#111827",
    fontWeight: "900",
  },

  secondaryBtn: {
    backgroundColor: "#020617",
    borderColor: "#1E293B",
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 10,
  },

  secondaryText: {
    color: "#E5E7EB",
    fontWeight: "900",
  },
});
</file>

<file path="app/sessions/screens/(components)/SessionsHeader.tsx">
import { useRouter } from "expo-router";
import React, { useCallback, useMemo } from "react";
import {
  Pressable,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import type { Scope } from "../(hooks)/useSessionsData";
import type { SessionDTO } from "../../api/sessionsApi";
import { UpdatingMiniBadge } from "./SessionsRowRenderer";
import type { StatusFilter } from "./SessionsRows";
import { computeStatusCounts } from "./SessionsRows";

function scopeLabelOf(scope: Scope) {
  if (scope === "upcoming") return "Upcoming sessions";
  if (scope === "past") return "Past sessions";
  return "All sessions";
}

function statusLabel(v: StatusFilter) {
  if (v === "all") return "All";
  if (v === "requested") return "Requested";
  if (v === "accepted") return "Accepted";
  if (v === "rejected") return "Rejected";
  if (v === "cancelled") return "Cancelled";
  if (v === "completed") return "Completed";
  return "All";
}

function Chip({
  label,
  active,
  onPress,
  accent = "orange",
  rightBadge,
}: {
  label: string;
  active: boolean;
  onPress: () => void;
  accent?: "orange" | "blue";
  rightBadge?: string;
}) {
  const border =
    accent === "blue"
      ? active
        ? "#60A5FA"
        : "#1E293B"
      : active
      ? "#F97316"
      : "#1E293B";

  const text =
    accent === "blue"
      ? active
        ? "#BFDBFE"
        : "#E5E7EB"
      : active
      ? "#FED7AA"
      : "#E5E7EB";

  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.85}
      style={{
        paddingHorizontal: 12,
        paddingVertical: 8,
        borderRadius: 999,
        borderWidth: 1,
        borderColor: border,
        backgroundColor: active ? "#0B1120" : "#020617",
        flexDirection: "row",
        alignItems: "center",
        gap: 8,
      }}
    >
      <Text style={{ color: text, fontWeight: "900", fontSize: 12 }}>
        {label}
      </Text>

      {!!rightBadge && (
        <View
          style={{
            minWidth: 22,
            paddingHorizontal: 8,
            height: 18,
            borderRadius: 999,
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: active
              ? accent === "blue"
                ? "#60A5FA"
                : "#F97316"
              : "#111827",
            borderWidth: 1,
            borderColor: active
              ? accent === "blue"
                ? "#93C5FD"
                : "#FB923C"
              : "#1E293B",
          }}
        >
          <Text
            style={{
              color: active ? "#0B1120" : "#CBD5E1",
              fontWeight: "900",
              fontSize: 11,
            }}
          >
            {rightBadge}
          </Text>
        </View>
      )}
    </TouchableOpacity>
  );
}

export default function SessionsHeader({
  scope,
  setScope,
  statusFilter,
  setStatusFilter,
  sessions,
  filteredCount,
  loadingList,
  errorText,
  onRetry,

  //  NEW (controlled search)
  query,
  setQuery,

  //  NEW (safe actions)
  onFindMentor,
  onRequestSession,
}: {
  scope: Scope;
  setScope: (v: Scope) => void;
  statusFilter: StatusFilter;
  setStatusFilter: (v: StatusFilter) => void;
  sessions: SessionDTO[];
  filteredCount: number;
  loadingList: boolean;
  errorText: string | null;
  onRetry: () => void;

  query: string;
  setQuery: (v: string) => void;

  onFindMentor?: () => void;
  onRequestSession?: () => void; // optional (   routes)
}) {
  const router = useRouter();

  const scopeLabel = useMemo(() => scopeLabelOf(scope), [scope]);
  const countsAll = useMemo(() => computeStatusCounts(sessions), [sessions]);

  const badge = (n: number) => (n > 99 ? "99+" : String(n));

  const hasAnyFilter = useMemo(() => {
    return scope !== "upcoming" || statusFilter !== "all" || !!query.trim();
  }, [query, scope, statusFilter]);

  const onReset = useCallback(() => {
    setScope("upcoming");
    setStatusFilter("all");
    setQuery("");
  }, [setQuery, setScope, setStatusFilter]);

  const searchHint = useMemo(() => {
    return "Search: skill / level / status / note";
  }, []);

  const handleFind = useCallback(() => {
    if (onFindMentor) return onFindMentor();
    router.push("/find-mentor" as any);
  }, [onFindMentor, router]);

  return (
    <View style={{ padding: 16, paddingBottom: 10 }}>
      {/* Top nav */}
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
          <Text style={{ color: "#60A5FA", fontWeight: "900" }}> Back</Text>
        </TouchableOpacity>

        <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
          Sessions
        </Text>

        {/* right actions */}
        <View style={{ flexDirection: "row", gap: 8, alignItems: "center" }}>
          <Pressable
            onPress={handleFind}
            style={({ pressed }) => [
              {
                paddingHorizontal: 10,
                paddingVertical: 8,
                borderRadius: 999,
                borderWidth: 1,
                borderColor: "#1E293B",
                backgroundColor: "#0B1120",
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
              Find
            </Text>
          </Pressable>

          {/*  optional:      SessionsScreen */}
          {onRequestSession ? (
            <Pressable
              onPress={onRequestSession}
              style={({ pressed }) => [
                {
                  paddingHorizontal: 10,
                  paddingVertical: 8,
                  borderRadius: 999,
                  borderWidth: 1,
                  borderColor: "#FB923C",
                  backgroundColor: "#F97316",
                },
                pressed ? { opacity: 0.92 } : null,
              ]}
            >
              <Text
                style={{ color: "#111827", fontWeight: "900", fontSize: 12 }}
              >
                Request
              </Text>
            </Pressable>
          ) : null}
        </View>
      </View>

      {/* Subtitle */}
      <Text style={{ color: "#94A3B8", marginTop: 8, fontWeight: "700" }}>
        {scopeLabel}{" "}
        <Text style={{ color: "#CBD5E1", fontWeight: "900" }}>
          ({filteredCount}/{sessions.length})
        </Text>
      </Text>

      {/* Search (now   ) */}
      <View
        style={{
          marginTop: 12,
          backgroundColor: "#0B1120",
          borderWidth: 1,
          borderColor: "#111827",
          borderRadius: 14,
          paddingHorizontal: 12,
          paddingVertical: 10,
          flexDirection: "row",
          alignItems: "center",
          gap: 10,
        }}
      >
        <Text style={{ color: "#64748B", fontWeight: "900" }}></Text>

        <TextInput
          value={query}
          onChangeText={setQuery}
          placeholder={searchHint}
          placeholderTextColor="#64748B"
          style={{ flex: 1, color: "#E5E7EB", fontWeight: "700" }}
          returnKeyType="search"
          accessibilityLabel="Search sessions"
        />

        {!!query.trim() && (
          <Pressable
            onPress={() => setQuery("")}
            style={({ pressed }) => [
              {
                width: 28,
                height: 28,
                borderRadius: 999,
                backgroundColor: "#111827",
                borderWidth: 1,
                borderColor: "#1E293B",
                alignItems: "center",
                justifyContent: "center",
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
            hitSlop={10}
          >
            <Text
              style={{
                color: "#E5E7EB",
                fontWeight: "900",
                fontSize: 16,
                lineHeight: 18,
              }}
            >
              
            </Text>
          </Pressable>
        )}
      </View>

      {/* Reset filters */}
      {hasAnyFilter ? (
        <View style={{ marginTop: 10, flexDirection: "row", gap: 10 }}>
          <Pressable
            onPress={onReset}
            style={({ pressed }) => [
              {
                paddingHorizontal: 12,
                paddingVertical: 8,
                borderRadius: 999,
                borderWidth: 1,
                borderColor: "#1E293B",
                backgroundColor: "#020617",
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
              Reset filters
            </Text>
          </Pressable>

          <Text
            style={{
              color: "#64748B",
              fontWeight: "800",
              fontSize: 12,
              alignSelf: "center",
            }}
          >
            Filters active
          </Text>
        </View>
      ) : null}

      {/* Scope chips */}
      <View
        style={{
          flexDirection: "row",
          gap: 8,
          marginTop: 14,
          flexWrap: "wrap",
        }}
      >
        <Chip
          label="upcoming"
          active={scope === "upcoming"}
          onPress={() => setScope("upcoming")}
        />
        <Chip
          label="past"
          active={scope === "past"}
          onPress={() => setScope("past")}
        />
        <Chip
          label="all"
          active={scope === "all"}
          onPress={() => setScope("all")}
        />
      </View>

      {/* Status chips */}
      <View
        style={{
          flexDirection: "row",
          gap: 8,
          marginTop: 10,
          flexWrap: "wrap",
        }}
      >
        <Chip
          accent="blue"
          label={statusLabel("all")}
          active={statusFilter === "all"}
          onPress={() => setStatusFilter("all")}
          rightBadge={badge(countsAll.total)}
        />
        <Chip
          accent="blue"
          label={statusLabel("requested")}
          active={statusFilter === "requested"}
          onPress={() => setStatusFilter("requested")}
          rightBadge={badge(countsAll.byStatus.requested)}
        />
        <Chip
          accent="blue"
          label={statusLabel("accepted")}
          active={statusFilter === "accepted"}
          onPress={() => setStatusFilter("accepted")}
          rightBadge={badge(countsAll.byStatus.accepted)}
        />
        <Chip
          accent="blue"
          label={statusLabel("completed")}
          active={statusFilter === "completed"}
          onPress={() => setStatusFilter("completed")}
          rightBadge={badge(countsAll.byStatus.completed)}
        />
        <Chip
          accent="blue"
          label={statusLabel("cancelled")}
          active={statusFilter === "cancelled"}
          onPress={() => setStatusFilter("cancelled")}
          rightBadge={badge(countsAll.byStatus.cancelled)}
        />
      </View>

      {/* Error */}
      {errorText ? (
        <View
          style={{
            marginTop: 14,
            backgroundColor: "#451A1A",
            borderRadius: 12,
            padding: 12,
            borderWidth: 1,
            borderColor: "#FCA5A5",
          }}
        >
          <Text style={{ color: "#FECACA", fontWeight: "900" }}>
            Couldnt load sessions
          </Text>
          <Text style={{ color: "#FECACA", marginTop: 6 }}>{errorText}</Text>

          <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
            <TouchableOpacity
              onPress={onRetry}
              activeOpacity={0.85}
              style={{
                paddingHorizontal: 12,
                paddingVertical: 8,
                borderRadius: 999,
                backgroundColor: "#B91C1C",
              }}
            >
              <Text style={{ color: "#FEE2E2", fontWeight: "900" }}>
                Try again
              </Text>
            </TouchableOpacity>

            {hasAnyFilter ? (
              <TouchableOpacity
                onPress={onReset}
                activeOpacity={0.85}
                style={{
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  borderRadius: 999,
                  backgroundColor: "#0B1120",
                  borderWidth: 1,
                  borderColor: "#1E293B",
                }}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                  Reset
                </Text>
              </TouchableOpacity>
            ) : null}
          </View>
        </View>
      ) : null}

      {/* List meta */}
      <View
        style={{
          marginTop: 16,
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between",
        }}
      >
        <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 14 }}>
          Results
        </Text>

        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <Text style={{ color: "#64748B", fontWeight: "800", fontSize: 12 }}>
            Total: {badge(countsAll.total)}
          </Text>
          {loadingList ? <UpdatingMiniBadge /> : null}
        </View>
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/(components)/SessionsRows.tsx">
// app/sessions/screens/(components)/SessionsRows.ts
import type { SessionDTO } from "../../api/sessionsApi";

export type StatusFilter =
  | "all"
  | "requested"
  | "accepted"
  | "rejected"
  | "cancelled"
  | "completed";

export type Row =
  | { type: "header"; key: string; title: string; count: number }
  | { type: "session"; key: string; session: SessionDTO };

function toDate(v: any) {
  const d = new Date(String(v || ""));
  return Number.isNaN(d.getTime()) ? null : d;
}

function safeId(s: any) {
  return String(s?._id || s?.id || "").trim();
}

function normStatus(v: any) {
  const st = String(v || "")
    .trim()
    .toLowerCase();
  if (st === "canceled") return "cancelled";
  if (st === "done") return "completed";
  return st;
}

function getWhen(s: any): Date | null {
  // scheduledAt       fallback createdAt
  return toDate(s?.scheduledAt) || toDate(s?.createdAt) || null;
}

function startOfDay(d: Date) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function dayKey(d: Date) {
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(
    2,
    "0"
  )}-${String(d.getDate()).padStart(2, "0")}`;
}

function dayTitleSmart(d: Date) {
  const today = startOfDay(new Date());
  const that = startOfDay(d);

  const diffDays = Math.round(
    (that.getTime() - today.getTime()) / (24 * 60 * 60 * 1000)
  );

  if (diffDays === 0) return "Today";
  if (diffDays === 1) return "Tomorrow";
  if (diffDays === -1) return "Yesterday";

  const dow = d.toLocaleDateString(undefined, { weekday: "long" });
  const md = d.toLocaleDateString(undefined, {
    month: "short",
    day: "2-digit",
  });
  return `${dow}  ${md}`;
}

//  status priority   (  )
function statusRank(st: string) {
  const s = normStatus(st);
  if (s === "requested") return 0;
  if (s === "accepted") return 1;
  if (s === "completed") return 2;
  if (s === "cancelled") return 3;
  if (s === "rejected") return 4;
  return 9;
}

export function filterSessionsByStatus(
  sessions: SessionDTO[],
  statusFilter: StatusFilter
) {
  if (statusFilter === "all") return sessions;
  const target = normStatus(statusFilter);

  return (Array.isArray(sessions) ? sessions : []).filter((s: any) => {
    const st = normStatus(s?.status);
    return st === target;
  });
}

export function computeStatusCounts(sessions: SessionDTO[]) {
  const list = Array.isArray(sessions) ? sessions : [];

  const byStatus = {
    requested: 0,
    accepted: 0,
    rejected: 0,
    cancelled: 0,
    completed: 0,
  };

  for (const x of list as any[]) {
    const st = normStatus(x?.status);
    if (st === "requested") byStatus.requested++;
    else if (st === "accepted") byStatus.accepted++;
    else if (st === "rejected") byStatus.rejected++;
    else if (st === "cancelled") byStatus.cancelled++;
    else if (st === "completed") byStatus.completed++;
  }

  return { total: list.length, byStatus };
}

export function buildGroupedRows(filteredSessions: SessionDTO[]): Row[] {
  const list = Array.isArray(filteredSessions) ? filteredSessions : [];

  // Groups by date + special "unknown"
  const map = new Map<string, { date: Date | null; list: SessionDTO[] }>();

  for (const s of list) {
    const d = getWhen(s);
    const k = d ? dayKey(d) : "unknown";

    const g = map.get(k);
    if (!g) map.set(k, { date: d, list: [s] });
    else g.list.push(s);
  }

  // Sort groups: unknown      (desc)
  const keys = Array.from(map.keys()).sort((a, b) => {
    if (a === "unknown" && b === "unknown") return 0;
    if (a === "unknown") return 1;
    if (b === "unknown") return -1;

    const da = map.get(a)!.date?.getTime() ?? 0;
    const db = map.get(b)!.date?.getTime() ?? 0;
    return db - da;
  });

  const out: Row[] = [];

  for (const k of keys) {
    const g = map.get(k)!;

    // Sort sessions  :
    // 1) status priority
    // 2) time (newer first)
    g.list.sort((a: any, b: any) => {
      const ra = statusRank(a?.status);
      const rb = statusRank(b?.status);
      if (ra !== rb) return ra - rb;

      const ta = getWhen(a)?.getTime() ?? 0;
      const tb = getWhen(b)?.getTime() ?? 0;
      return tb - ta;
    });

    out.push({
      type: "header",
      key: `h:${k}`,
      title: k === "unknown" ? "Unknown date" : dayTitleSmart(g.date as Date),
      count: g.list.length,
    });

    for (let i = 0; i < g.list.length; i++) {
      const s: any = g.list[i];
      const id = safeId(s);
      //  key  ( random)
      out.push({
        type: "session",
        key: `s:${id || `${k}:${i}`}`,
        session: s,
      });
    }
  }

  return out;
}
</file>

<file path="app/sessions/screens/(components)/SessionsSummaryBar.tsx">
import React, { useMemo } from "react";
import { StyleSheet, Text, View } from "react-native";

type Props = {
  total: number;
  upcoming: number;
  pending: number; // requested
  completed: number;
  nextSessionAtIso?: string | null; // optional
};

function formatWhen(iso?: string | null) {
  if (!iso) return null;
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return null;

  // : Jan 01, 15:59
  return d.toLocaleString(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

function StatPill({ label, value }: { label: string; value: number | string }) {
  return (
    <View style={styles.pill}>
      <Text style={styles.pillLabel} numberOfLines={1}>
        {label}
      </Text>
      <Text style={styles.pillValue} numberOfLines={1}>
        {String(value)}
      </Text>
    </View>
  );
}

export default function SessionsSummaryBar({
  total,
  upcoming,
  pending,
  completed,
  nextSessionAtIso,
}: Props) {
  const next = useMemo(() => formatWhen(nextSessionAtIso), [nextSessionAtIso]);

  return (
    <View style={styles.wrap} accessibilityRole="summary">
      <View style={styles.topRow}>
        <Text style={styles.title}>Overview</Text>
        {next ? (
          <View
            style={styles.nextWrap}
            accessibilityLabel={`Next session ${next}`}
          >
            <Text style={styles.nextLabel}>Next</Text>
            <Text style={styles.nextValue}>{next}</Text>
          </View>
        ) : (
          <Text style={styles.nextMuted}>No upcoming scheduled</Text>
        )}
      </View>

      <View style={styles.row}>
        <StatPill label="Total" value={total} />
        <StatPill label="Upcoming" value={upcoming} />
        <StatPill label="Pending" value={pending} />
        <StatPill label="Done" value={completed} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    gap: 10,
  },

  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },

  title: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 14,
  },

  nextWrap: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },

  nextLabel: {
    color: "#94A3B8",
    fontWeight: "900",
    fontSize: 11,
  },

  nextValue: {
    color: "#F97316",
    fontWeight: "900",
    fontSize: 11,
  },

  nextMuted: {
    color: "#64748B",
    fontWeight: "800",
    fontSize: 12,
  },

  row: {
    flexDirection: "row",
    gap: 10,
  },

  pill: {
    flex: 1,
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    paddingHorizontal: 10,
    paddingVertical: 10,
    gap: 4,
    minHeight: 58,
  },

  pillLabel: {
    color: "#94A3B8",
    fontWeight: "900",
    fontSize: 11,
  },

  pillValue: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 16,
  },
});
</file>

<file path="app/sessions/screens/request/components/MentorCard.tsx">
// app/sessions/screens/request/components/MentorCard.tsx
import React, { useMemo } from "react";
import { Pressable, Text, View } from "react-native";
import { COLORS } from "../styles";

function initialsFromName(name: string) {
  const clean = String(name || "").trim();
  if (!clean) return "M";
  const parts = clean.split(" ").filter(Boolean);
  const a = parts[0]?.[0] || "M";
  const b = parts.length > 1 ? parts[parts.length - 1]?.[0] : "";
  return (a + b).toUpperCase();
}

// UI-only helper: avoid showing "111111" as a name
function looksLikeIdOrNumber(name: string) {
  const n = name.trim();
  if (!n) return false;
  const digitsOnly = /^\d+$/.test(n);
  if (digitsOnly) return true;
  if (n.length <= 2) return true;
  return false;
}

export default function MentorCard({
  mentorName,
  mentorId,
  onChangeMentor,
  matchedSkill, //  optional: pass skill if you have it (UI-only)
}: {
  mentorName?: string;
  mentorId?: string;
  onChangeMentor?: () => void;
  matchedSkill?: string;
}) {
  const rawName = String(mentorName || "").trim();
  const rawSkill = String(matchedSkill || "").trim();

  const title = useMemo(() => {
    if (!rawName) return "Selected mentor";
    if (looksLikeIdOrNumber(rawName)) return "Selected mentor";
    return rawName;
  }, [rawName]);

  const badge = useMemo(() => {
    if (!rawName || looksLikeIdOrNumber(rawName)) return "M";
    return initialsFromName(rawName);
  }, [rawName]);

  //  short, useful, and contextual (no extra logic)
  const reason = useMemo(() => {
    const s = rawSkill.trim();
    if (!s) return "Recommended based on your request.";
    return `Recommended for learning ${s}.`;
  }, [rawSkill]);

  return (
    <View
      style={{
        backgroundColor: COLORS.card,
        borderWidth: 1,
        borderColor: COLORS.border,
        borderRadius: 16,
        padding: 14,
      }}
      accessibilityRole="summary"
      accessibilityLabel={`Selected mentor: ${title}`}
    >
      <View style={{ flexDirection: "row", alignItems: "center", gap: 12 }}>
        <View
          style={{
            width: 46,
            height: 46,
            borderRadius: 16,
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "#111827",
            borderWidth: 1,
            borderColor: COLORS.border,
          }}
        >
          <Text style={{ color: "#FED7AA", fontWeight: "900" }}>{badge}</Text>
        </View>

        <View style={{ flex: 1 }}>
          {/*  keep small label, but the main focus is the name */}
          <Text
            style={{ color: COLORS.muted, fontWeight: "900", fontSize: 12 }}
          >
            Selected mentor
          </Text>

          {/*  show name (not "Selected mentor" in the middle) */}
          <Text
            style={{
              color: COLORS.text,
              fontWeight: "900",
              fontSize: 16, // slightly stronger for clarity
              marginTop: 2,
            }}
            numberOfLines={1}
          >
            {looksLikeIdOrNumber(rawName) ? "Mentor" : title}
          </Text>

          {/*  replace generic sentence with a short useful one */}
          <Text
            style={{
              color: COLORS.hint,
              marginTop: 6,
              fontSize: 12,
              fontWeight: "800",
            }}
            numberOfLines={2}
          >
            {reason}
          </Text>
        </View>

        {onChangeMentor ? (
          <Pressable
            onPress={onChangeMentor}
            hitSlop={10}
            accessibilityRole="button"
            accessibilityLabel="Change mentor"
            style={({ pressed }) => [
              {
                paddingHorizontal: 12,
                paddingVertical: 10,
                borderRadius: 999,
                borderWidth: 1,
                borderColor: COLORS.border,
                backgroundColor: COLORS.bg,
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
          >
            <Text
              style={{ color: COLORS.text, fontWeight: "900", fontSize: 12 }}
            >
              Change
            </Text>
          </Pressable>
        ) : null}
      </View>

      <View style={{ marginTop: 10 }}>
        <Text style={{ color: COLORS.tip, fontWeight: "800", fontSize: 12 }}>
          You can edit the topic and time before sending.
        </Text>
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/RequestTopBar.tsx">
// app/sessions/screens/request/components/RequestTopBar.tsx
import React from "react";
import { Pressable, Text, View } from "react-native";
import { COLORS } from "../styles";
import { Title } from "./UI";

/**
 * RequestTopBar (UI/UX fix)
 * :  "Back"             (router.back)
 * :  "Close" ( "Cancel")  .
 *
 *           .
 */
export default function RequestTopBar({
  onBack,
  title,
  leftLabel = "Close",
}: {
  onBack: () => void;
  title: string;
  leftLabel?: string; // optional, default "Close"
}) {
  return (
    <View
      style={{
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: 12,
      }}
    >
      <Pressable
        onPress={onBack}
        hitSlop={12}
        accessibilityRole="button"
        accessibilityLabel={leftLabel}
        style={({ pressed }) => [
          {
            paddingHorizontal: 10,
            paddingVertical: 8,
            borderRadius: 999,
            borderWidth: 1,
            borderColor: COLORS.border,
            backgroundColor: COLORS.bg,
          },
          pressed ? { opacity: 0.9 } : null,
        ]}
      >
        <Text style={{ color: COLORS.link, fontWeight: "900", fontSize: 12 }}>
           {leftLabel}
        </Text>
      </Pressable>

      <View style={{ flex: 1, paddingHorizontal: 10 }}>
        <Title>{title}</Title>
      </View>

      {/* spacer to keep title centered */}
      <View style={{ width: 74 }} />
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepNote.tsx">
// app/sessions/screens/request/components/StepNote.tsx
import React from "react";
import { Text, TextInput, View } from "react-native";
import { COLORS, fieldBase } from "../styles";
import { Hint, Label } from "./UI";

type Props = {
  note: string;
  onChangeNote: (v: string) => void;
};

export default function StepNote({ note, onChangeNote }: Props) {
  return (
    <View style={{ gap: 10 }}>
      <Label>Note (optional)</Label>

      <TextInput
        value={note}
        onChangeText={onChangeNote}
        placeholder="Anything the mentor should know before the session"
        placeholderTextColor={COLORS.hint}
        multiline
        style={{
          ...fieldBase,
          minHeight: 120,
          textAlignVertical: "top",
        }}
        accessibilityLabel="Optional note for the mentor"
      />

      {/* Soft guidance instead of silence */}
      <Hint>
        Optional  Share goals, questions, or anything important to prepare.
      </Hint>

      {/* Character hint (UI-only, no limits enforced) */}
      <Text
        style={{
          alignSelf: "flex-end",
          color: COLORS.muted,
          fontSize: 11,
          fontWeight: "800",
        }}
      >
        {note.length} characters
      </Text>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepPills.tsx">
// app/sessions/screens/request/components/StepPills.tsx
import React, { useMemo } from "react";
import { Text, View } from "react-native";
import type { Step } from "../(hooks)/useRequestSessionForm";
import { COLORS } from "../styles";

export default function StepPills({ step }: { step: Step }) {
  const items = useMemo(
    () =>
      [
        { n: 1 as const, label: "Topic" },
        { n: 2 as const, label: "Time" },
        { n: 3 as const, label: "Note" },
      ] as const,
    []
  );

  return (
    <View style={{ flexDirection: "row", gap: 8, flexWrap: "wrap" }}>
      {items.map((it) => {
        const active = it.n === step;
        const done = it.n < step;

        return (
          <View
            key={it.n}
            style={{
              paddingHorizontal: 10,
              paddingVertical: 7,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: active ? COLORS.orange : COLORS.border,
              backgroundColor: active ? COLORS.card : COLORS.bg,
              opacity: done ? 0.92 : 1,
              flexDirection: "row",
              alignItems: "center",
              gap: 6,
            }}
            accessibilityRole="text"
            accessibilityLabel={`Step ${it.n}: ${it.label}${
              active ? " (current)" : done ? " (done)" : ""
            }`}
          >
            {/* number / check */}
            <Text
              style={{
                color: active ? "#FED7AA" : done ? "#86EFAC" : COLORS.muted,
                fontWeight: "900",
                fontSize: 12,
              }}
            >
              {done ? "" : it.n}
            </Text>

            {/* label */}
            <Text
              style={{
                color: active ? "#FED7AA" : COLORS.muted,
                fontWeight: "900",
                fontSize: 12,
              }}
            >
              {it.label}
            </Text>
          </View>
        );
      })}
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepSchedule.tsx">
// app/sessions/screens/request/components/StepSchedule.tsx
import React, { useMemo, useState } from "react";
import { Pressable, Text, TextInput, View } from "react-native";
import { COLORS, fieldBase } from "../styles";
import { Hint, Label } from "./UI";

type Props = {
  date: string; // YYYY-MM-DD
  time: string; // HH:MM
  onChangeDate: (v: string) => void;
  onChangeTime: (v: string) => void;
  errors?: { date?: string; time?: string };
  onQuickPick?: (preset: "today" | "tomorrow" | "plus30" | "plus60") => void;
};

export default function StepSchedule({
  date,
  time,
  onChangeDate,
  onChangeTime,
  errors,
  onQuickPick,
}: Props) {
  const quicks = useMemo(
    () => [
      { key: "today" as const, label: "Today" },
      { key: "tomorrow" as const, label: "Tomorrow" },
      { key: "plus30" as const, label: "+30 min" },
      { key: "plus60" as const, label: "+1 hour" },
    ],
    []
  );

  const hasQuick = !!onQuickPick;

  //  UI-only: remember last clicked option so user "feels" selection
  const [lastPick, setLastPick] = useState<
    "today" | "tomorrow" | "plus30" | "plus60" | null
  >(null);

  const filled = !!date?.trim() && !!time?.trim();

  return (
    <View style={{ gap: 14 }}>
      {hasQuick ? (
        <View>
          <Label>Quick pick (recommended)</Label>

          <View
            style={{
              flexDirection: "row",
              gap: 8,
              flexWrap: "wrap",
              marginTop: 10,
            }}
          >
            {quicks.map((q) => {
              const active = q.key === lastPick;

              return (
                <Pressable
                  key={q.key}
                  onPress={() => {
                    setLastPick(q.key); //  visual confirmation
                    onQuickPick?.(q.key); //  existing behavior
                  }}
                  hitSlop={8}
                  accessibilityRole="button"
                  accessibilityLabel={`Pick ${q.label}`}
                  style={({ pressed }) => [
                    {
                      paddingHorizontal: 14,
                      paddingVertical: 10,
                      borderRadius: 999,
                      borderWidth: 1,
                      borderColor: active ? COLORS.orange : COLORS.border,
                      backgroundColor: active ? COLORS.card : COLORS.bg,
                      opacity: pressed ? 0.92 : 1,
                      transform: [{ scale: pressed ? 0.98 : 1 }],
                    },
                  ]}
                >
                  <Text
                    style={{
                      color: active ? "#FED7AA" : COLORS.text,
                      fontWeight: "900",
                      fontSize: 12,
                    }}
                  >
                    {q.label}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          {/*  actually useful feedback */}
          <Hint>
            {filled
              ? `Filled: ${date}  ${time}`
              : "Tap one option to fill date & time."}
          </Hint>
        </View>
      ) : null}

      <View>
        <Label>Date</Label>
        <TextInput
          value={date}
          onChangeText={(v) => {
            setLastPick(null); // typing means not a preset
            onChangeDate(v);
          }}
          placeholder="YYYY-MM-DD"
          placeholderTextColor={COLORS.hint}
          style={{
            ...fieldBase,
            borderColor: date?.trim()
              ? COLORS.orangeBorder
              : fieldBase.borderColor,
          }}
          keyboardType="numbers-and-punctuation"
          autoCapitalize="none"
          autoCorrect={false}
          returnKeyType="next"
          accessibilityLabel="Date input YYYY-MM-DD"
        />
        {!!errors?.date && (
          <Text
            style={{ color: COLORS.danger, marginTop: 8, fontWeight: "900" }}
          >
            {errors.date}
          </Text>
        )}
      </View>

      <View>
        <Label>Time</Label>
        <TextInput
          value={time}
          onChangeText={(v) => {
            setLastPick(null);
            onChangeTime(v);
          }}
          placeholder="HH:MM (24h)"
          placeholderTextColor={COLORS.hint}
          style={{
            ...fieldBase,
            borderColor: time?.trim()
              ? COLORS.orangeBorder
              : fieldBase.borderColor,
          }}
          keyboardType="numbers-and-punctuation"
          autoCapitalize="none"
          autoCorrect={false}
          returnKeyType="done"
          accessibilityLabel="Time input HH:MM"
        />
        {!!errors?.time && (
          <Text
            style={{ color: COLORS.danger, marginTop: 8, fontWeight: "900" }}
          >
            {errors.time}
          </Text>
        )}
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepSkillLevel.tsx">
// app/sessions/screens/request/components/StepSkillLevel.tsx
import React, { useMemo } from "react";
import { Pressable, Text, TextInput, View } from "react-native";
import { COLORS, fieldBase } from "../styles";
import { Hint, Label } from "./UI";

type Props = {
  skill: string;
  level: string;
  onChangeSkill: (v: string) => void;
  onChangeLevel: (v: string) => void;
};

function Chip({
  label,
  active,
  onPress,
  accessibilityLabel,
}: {
  label: string;
  active?: boolean;
  onPress: () => void;
  accessibilityLabel: string;
}) {
  return (
    <Pressable
      onPress={onPress}
      hitSlop={8}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      style={({ pressed }) => [
        {
          paddingHorizontal: 14,
          paddingVertical: 10,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: active ? COLORS.orange : COLORS.border,
          backgroundColor: active ? COLORS.card : COLORS.bg,
          //  clearer "pressed" feedback
          opacity: pressed ? 0.92 : 1,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
    >
      <Text
        style={{
          color: active ? "#FED7AA" : COLORS.text,
          fontWeight: "900",
          fontSize: 12,
        }}
      >
        {label}
      </Text>
    </Pressable>
  );
}

export default function StepSkillLevel({
  skill,
  level,
  onChangeSkill,
  onChangeLevel,
}: Props) {
  const levelOptions = useMemo(
    () => ["Beginner", "Intermediate", "Advanced", "Not sure"],
    []
  );

  const skillPresets = useMemo(
    () => ["English", "React", "Math", "Interview prep"],
    []
  );

  return (
    <View style={{ gap: 14 }}>
      {/* Skill */}
      <View>
        <Label>Skill</Label>
        <TextInput
          value={skill}
          onChangeText={onChangeSkill}
          placeholder="e.g. React basics"
          placeholderTextColor={COLORS.hint}
          style={fieldBase}
          autoCapitalize="sentences"
          autoCorrect={false}
          accessibilityLabel="Skill input"
          returnKeyType="next"
        />

        <View
          style={{
            flexDirection: "row",
            flexWrap: "wrap",
            gap: 8,
            marginTop: 10,
          }}
        >
          {skillPresets.map((s) => {
            const active = skill.trim().toLowerCase() === s.toLowerCase();
            return (
              <Chip
                key={s}
                label={s}
                active={active}
                onPress={() => onChangeSkill(s)}
                accessibilityLabel={`Select skill ${s}`}
              />
            );
          })}
        </View>

        <Hint>Tap a preset to avoid typing mistakes.</Hint>
      </View>

      {/* Level */}
      <View>
        <Label>Level</Label>

        <View
          style={{
            flexDirection: "row",
            flexWrap: "wrap",
            gap: 8,
            marginTop: 10,
          }}
        >
          {levelOptions.map((opt) => {
            const active = level.trim().toLowerCase() === opt.toLowerCase();
            return (
              <Chip
                key={opt}
                label={opt}
                active={active}
                onPress={() => onChangeLevel(opt)}
                accessibilityLabel={`Select level ${opt}`}
              />
            );
          })}
        </View>

        {/* keep fallback input, but make it clearly secondary */}
        <TextInput
          value={level}
          onChangeText={onChangeLevel}
          placeholder="Or type a custom level (optional)"
          placeholderTextColor={COLORS.hint}
          style={{
            ...fieldBase,
            marginTop: 12,
            opacity: 0.85,
          }}
          accessibilityLabel="Custom level input"
        />
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StickyFooter.tsx">
// app/sessions/screens/request/components/StickyFooter.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";
import { COLORS } from "../styles";

/**
 * StickyFooter
 * UI/UX improvements only:
 * - Clear primary action
 * - Stable button size (no layout jump on loading)
 * - Visual priority to Next / Send
 * - Back is secondary and calm
 */
export default function StickyFooter({
  showBack,
  backLabel,
  nextLabel,
  disableNext,
  loading,
  onBack,
  onNext,
}: {
  showBack: boolean;
  backLabel: string;
  nextLabel: string;
  disableNext?: boolean;
  loading?: boolean;
  onBack: () => void;
  onNext: () => void;
}) {
  return (
    <View
      style={{
        marginTop: 16,
        paddingTop: 12,
        borderTopWidth: 1,
        borderTopColor: COLORS.border,
        flexDirection: "row",
        alignItems: "center",
        gap: 12,
      }}
    >
      {/* Back (secondary) */}
      {showBack ? (
        <Pressable
          onPress={onBack}
          hitSlop={10}
          accessibilityRole="button"
          accessibilityLabel={backLabel}
          style={({ pressed }) => [
            {
              paddingHorizontal: 14,
              paddingVertical: 12,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: COLORS.border,
              backgroundColor: COLORS.bg,
            },
            pressed ? { opacity: 0.9 } : null,
          ]}
        >
          <Text
            style={{
              color: COLORS.text,
              fontWeight: "900",
              fontSize: 13,
            }}
          >
            {backLabel}
          </Text>
        </Pressable>
      ) : (
        <View />
      )}

      {/* Spacer */}
      <View style={{ flex: 1 }} />

      {/* Primary action */}
      <Pressable
        onPress={onNext}
        disabled={!!disableNext || !!loading}
        hitSlop={10}
        accessibilityRole="button"
        accessibilityLabel={nextLabel}
        style={({ pressed }) => [
          {
            minWidth: 180,
            paddingVertical: 14,
            paddingHorizontal: 18,
            borderRadius: 999,
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: COLORS.orange,
            borderWidth: 1,
            borderColor: COLORS.orangeBorder,
            opacity: disableNext || loading ? 0.55 : 1,
          },
          pressed ? { opacity: 0.92 } : null,
        ]}
      >
        {loading ? (
          <View style={{ flexDirection: "row", gap: 10, alignItems: "center" }}>
            <ActivityIndicator />
            <Text
              style={{
                color: "#111827",
                fontWeight: "900",
                fontSize: 14,
              }}
            >
              Sending
            </Text>
          </View>
        ) : (
          <Text
            style={{
              color: "#111827",
              fontWeight: "900",
              fontSize: 14,
            }}
          >
            {nextLabel}
          </Text>
        )}
      </Pressable>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/UI.tsx">
// app/sessions/screens/request/components/UI.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";
import { COLORS, shadowCard } from "../styles";

/**
 * UI primitives  refined for clarity, speed, and consistency
 * No logic changes, visuals only.
 */

export function Title({ children }: { children: React.ReactNode }) {
  return (
    <Text
      style={{
        color: COLORS.text,
        fontWeight: "900",
        fontSize: 18,
        textAlign: "center",
      }}
      accessibilityRole="header"
    >
      {children}
    </Text>
  );
}

export function Label({ children }: { children: React.ReactNode }) {
  return (
    <Text
      style={{
        color: COLORS.muted,
        fontWeight: "900",
        fontSize: 12,
        marginBottom: 4,
      }}
    >
      {children}
    </Text>
  );
}

export function Hint({ children }: { children: React.ReactNode }) {
  return (
    <Text
      style={{
        color: COLORS.hint,
        fontWeight: "800",
        fontSize: 12,
        marginTop: 6,
      }}
    >
      {children}
    </Text>
  );
}

export function Card({ children }: { children: React.ReactNode }) {
  return (
    <View
      style={{
        ...shadowCard,
        gap: 14,
      }}
    >
      {children}
    </View>
  );
}

export function PrimaryBtn({
  label,
  onPress,
  disabled,
  loading,
}: {
  label: string;
  onPress: () => void;
  disabled?: boolean;
  loading?: boolean;
}) {
  return (
    <Pressable
      onPress={onPress}
      disabled={!!disabled || !!loading}
      accessibilityRole="button"
      accessibilityLabel={label}
      style={({ pressed }) => [
        {
          borderRadius: 999,
          paddingVertical: 14,
          paddingHorizontal: 18,
          alignItems: "center",
          justifyContent: "center",
          backgroundColor: COLORS.orange,
          borderWidth: 1,
          borderColor: COLORS.orangeBorder,
          opacity: disabled || loading ? 0.55 : 1,
          minHeight: 48,
        },
        pressed ? { opacity: 0.92 } : null,
      ]}
    >
      {loading ? (
        <View style={{ flexDirection: "row", gap: 10, alignItems: "center" }}>
          <ActivityIndicator />
          <Text style={{ color: "#111827", fontWeight: "900" }}>Working</Text>
        </View>
      ) : (
        <Text style={{ color: "#111827", fontWeight: "900" }}>{label}</Text>
      )}
    </Pressable>
  );
}

export function GhostBtn({
  label,
  onPress,
}: {
  label: string;
  onPress: () => void;
}) {
  return (
    <Pressable
      onPress={onPress}
      hitSlop={10}
      accessibilityRole="button"
      accessibilityLabel={label}
      style={({ pressed }) => [
        {
          paddingHorizontal: 14,
          paddingVertical: 12,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: COLORS.border,
          backgroundColor: COLORS.bg,
          minHeight: 44,
          justifyContent: "center",
        },
        pressed ? { opacity: 0.9 } : null,
      ]}
    >
      <Text
        style={{
          color: COLORS.text,
          fontWeight: "900",
          fontSize: 13,
        }}
      >
        {label}
      </Text>
    </Pressable>
  );
}
</file>

<file path="app/sessions/screens/request/RequestSessionScreen.tsx">
// app/sessions/screens/request/RequestSessionScreen.tsx
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import {
  Alert,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Text,
  View,
} from "react-native";

import MentorCard from "./components/MentorCard";
import RequestTopBar from "./components/RequestTopBar";
import StepNote from "./components/StepNote";
import StepPills from "./components/StepPills";
import StepSchedule from "./components/StepSchedule";
import StepSkillLevel from "./components/StepSkillLevel";
import StickyFooter from "./components/StickyFooter";
import { Card, Hint } from "./components/UI";
import { COLORS, SPACING } from "./styles";

import { useRequestSessionForm } from "./(hooks)/useRequestSessionForm";

type Params = {
  mentorId?: string;
  mentorName?: string;
  skill?: string;
  level?: string;
};

function StepLabel({
  active,
  children,
}: {
  active: boolean;
  children: string;
}) {
  return (
    <Text
      style={{
        color: active ? "#FED7AA" : COLORS.muted,
        fontWeight: "900",
        fontSize: 12,
      }}
    >
      {children}
    </Text>
  );
}

function InlineError({ text }: { text?: string }) {
  if (!text) return null;
  return (
    <Text style={{ color: COLORS.danger, marginTop: 10, fontWeight: "900" }}>
      {text}
    </Text>
  );
}

export default function RequestSessionScreen() {
  const router = useRouter();
  const params = useLocalSearchParams<Params>();

  const mentorId = useMemo(
    () => String(params.mentorId || "").trim(),
    [params.mentorId]
  );
  const mentorName = useMemo(
    () => String(params.mentorName || "").trim(),
    [params.mentorName]
  );
  const preSkill = useMemo(
    () => String(params.skill || "").trim(),
    [params.skill]
  );
  const preLevel = useMemo(
    () => String(params.level || "").trim(),
    [params.level]
  );

  const form = useRequestSessionForm({
    mentorId,
    mentorName,
    prefillSkill: preSkill,
    prefillLevel: preLevel,
  });

  // UI-only state: show success hint (no logic changes)
  const [sentOk, setSentOk] = useState(false);

  const headerSub = useMemo(() => {
    const n = mentorName?.trim();
    return n ? `Requesting a session with ${n}` : "Requesting a session";
  }, [mentorName]);

  const microSub = "3 steps";

  const primaryLabel = useMemo(() => {
    if (form.step === 3) return "Send request";
    return "Continue";
  }, [form.step]);

  const onNext = () => {
    //  no alerts: just reveal inline errors for this step
    if (!form.canGoNext) {
      form.touchStep(form.step);
      return;
    }
    form.next();
  };

  const onSubmit = async () => {
    // reveal all inline errors
    form.touchStep(1);
    form.touchStep(2);
    form.touchStep(3);

    const out = await form.submit();
    if (!out.ok) {
      //  no alert  show inline submitError (hook already sets it)
      return;
    }

    setSentOk(true);

    // Success confirmation is OK (single clean confirmation)
    Alert.alert("Sent ", "Your request was sent.", [
      {
        text: "Go to sessions",
        onPress: () => router.replace("/sessions" as any),
      },
    ]);
  };

  if (!mentorId) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: COLORS.bg,
          alignItems: "center",
          justifyContent: "center",
          padding: 16,
        }}
      >
        <Text style={{ color: COLORS.danger, fontWeight: "900" }}>
          Missing mentorId.
        </Text>
        <Text
          style={{ color: COLORS.muted, marginTop: 8, textAlign: "center" }}
        >
          Open this screen from a mentor profile so it can prefill correctly.
        </Text>
      </View>
    );
  }

  const isLast = form.step === 3;

  const stepTitle =
    form.step === 1 ? "Topic" : form.step === 2 ? "Time" : "Note";

  // Inline error strings per step (no component changes required)
  const topicError =
    form.touched.topic && (form.errors.skill || form.errors.level)
      ? form.errors.skill || form.errors.level
      : undefined;

  const scheduleErrors = form.touched.schedule
    ? { date: form.errors.date, time: form.errors.time }
    : undefined;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: COLORS.bg }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
      keyboardVerticalOffset={Platform.OS === "ios" ? 90 : 0}
    >
      <ScrollView
        contentContainerStyle={{ padding: SPACING.pagePad, paddingBottom: 28 }}
      >
        <RequestTopBar onBack={() => router.back()} title="Request session" />

        {/* Context header */}
        <View style={{ marginBottom: 12 }}>
          <Text style={{ color: COLORS.text, fontWeight: "900", fontSize: 16 }}>
            {headerSub}
          </Text>
          <Text
            style={{
              color: COLORS.hint,
              fontWeight: "800",
              marginTop: 6,
              fontSize: 12,
            }}
          >
            Choose a topic, pick a time, and send.
          </Text>
        </View>

        {/* Mentor summary (fast reassurance) */}
        <View style={{ marginBottom: 12 }}>
          <MentorCard mentorName={mentorName} mentorId={mentorId} />
        </View>

        {/* Stepper */}
        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <StepPills step={form.step} />
          <View style={{ flex: 1 }} />
          <Text
            style={{ color: COLORS.muted, fontWeight: "900", fontSize: 12 }}
          >
            Step {form.step}/3  {stepTitle}
          </Text>
        </View>

        <View style={{ marginTop: 14 }}>
          <Card>
            {/* Step content */}
            {form.step === 1 ? (
              <>
                <StepSkillLevel
                  skill={form.skill}
                  level={form.level}
                  onChangeSkill={form.setSkill}
                  onChangeLevel={form.setLevel}
                />
                <InlineError text={topicError} />
                <Text
                  style={{
                    marginTop: 10,
                    color: COLORS.tip,
                    fontSize: 12,
                    fontWeight: "800",
                  }}
                >
                  Tip: keep it short (e.g. React hooks, English speaking).
                </Text>
              </>
            ) : form.step === 2 ? (
              <StepSchedule
                date={form.date}
                time={form.time}
                onChangeDate={form.setDate}
                onChangeTime={form.setTime}
                errors={scheduleErrors}
                //  use hook helper (no duplicate logic)
                onQuickPick={(preset) => form.quickPick(preset)}
              />
            ) : (
              <>
                {/* Review summary (prevents mistakes before sending) */}
                <View
                  style={{
                    borderWidth: 1,
                    borderColor: COLORS.border,
                    backgroundColor: COLORS.bg,
                    borderRadius: 14,
                    padding: 12,
                    marginBottom: 12,
                  }}
                >
                  <Text
                    style={{
                      color: COLORS.muted,
                      fontWeight: "900",
                      fontSize: 12,
                    }}
                  >
                    Review
                  </Text>

                  <View style={{ marginTop: 8, gap: 6 }}>
                    <Text style={{ color: COLORS.text, fontWeight: "900" }}>
                      Skill:{" "}
                      <Text style={{ color: COLORS.text, fontWeight: "800" }}>
                        {form.skill?.trim() ? form.skill.trim() : ""}
                      </Text>
                    </Text>

                    <Text style={{ color: COLORS.text, fontWeight: "900" }}>
                      Level:{" "}
                      <Text style={{ color: COLORS.text, fontWeight: "800" }}>
                        {form.level?.trim() ? form.level.trim() : ""}
                      </Text>
                    </Text>

                    <Text style={{ color: COLORS.text, fontWeight: "900" }}>
                      When:{" "}
                      <Text style={{ color: COLORS.text, fontWeight: "800" }}>
                        {form.reviewScheduleText}
                      </Text>
                    </Text>
                  </View>
                </View>

                <StepNote note={form.note} onChangeNote={form.setNote} />

                {/* Submit error inline */}
                <InlineError text={form.submitError || undefined} />

                {sentOk ? (
                  <Text
                    style={{
                      marginTop: 10,
                      color: "#86EFAC",
                      fontWeight: "900",
                    }}
                  >
                    Sent successfully 
                  </Text>
                ) : null}
              </>
            )}

            {/* Footer */}
            <StickyFooter
              showBack={form.step !== 1}
              backLabel="Back"
              nextLabel={primaryLabel}
              disableNext={!form.canGoNext}
              loading={isLast ? form.submitting : false}
              onBack={form.back}
              onNext={isLast ? onSubmit : onNext}
            />
          </Card>

          {/* One-line help (short + clear) */}
          <View style={{ marginTop: 10 }}>
            <Hint>
              Cant access this screen? Find Mentor  open a mentor profile 
              Request.
            </Hint>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/sessions/screens/request/styles.ts">
// app/sessions/screens/request/styles.ts

export const COLORS = {
  bg: "#020617",
  card: "#0B1120",

  border: "#1E293B",
  borderSoft: "#111827",
  fieldBorder: "#1F2937",

  text: "#E5E7EB",
  muted: "#94A3B8",
  hint: "#64748B",
  tip: "#334155",

  link: "#60A5FA",
  danger: "#FCA5A5",

  orange: "#F97316",
  orangeBorder: "#FB923C",
};

export const SPACING = {
  pagePad: 16,
  cardPad: 14,

  radius: 16,
  pillRadius: 999,

  // consistent hit targets (fast + accessible)
  tapMinH: 44,
  inputMinH: 48,
};

export const shadowCard = {
  borderWidth: 1,
  borderColor: COLORS.border,
  backgroundColor: COLORS.card,
  borderRadius: SPACING.radius,
  padding: SPACING.cardPad,

  // subtle depth (no performance heavy shadows)
  // RN Android: elevation is cheap
  elevation: 1,
};

export const fieldBase = {
  marginTop: 8,
  borderRadius: 14,
  borderWidth: 1,
  borderColor: COLORS.fieldBorder,
  backgroundColor: COLORS.bg,

  color: COLORS.text,
  paddingHorizontal: 12,
  paddingVertical: 12,

  fontWeight: "800" as const,

  minHeight: SPACING.inputMinH,
};
</file>

<file path="app/sessions/utils/formatSession.ts">
// app/sessions/utils/formatSession.ts
// I AM THE REAL formatSession.ts

import type { SessionStatus } from "../api/sessionsApi";

export function formatSessionDateTime(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "Invalid date";
  return d.toLocaleString();
}

export function statusBadge(
  status: SessionStatus
): { label: string; bg: string; border: string; text: string } {
  switch (status) {
    case "requested":
      return { label: "Requested", bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
    case "accepted":
      return { label: "Accepted", bg: "#052E16", border: "#16A34A", text: "#D1FAE5" };
    case "rejected":
      return { label: "Rejected", bg: "#450A0A", border: "#EF4444", text: "#FEE2E2" };
    case "cancelled":
      return { label: "Cancelled", bg: "#111827", border: "#6B7280", text: "#E5E7EB" };
    case "completed":
      return { label: "Completed", bg: "#0B1120", border: "#F97316", text: "#FED7AA" };
    default:
      return { label: String(status), bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
  }
}
</file>

<file path="app/shared/levels.ts">
// app/shared/levels.ts

export const LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
] as const;

export type Level = (typeof LEVELS)[number];

/**
 *   
 *       
 */
export const LEVEL_RANK: Record<Level, number> = {
  Beginner: 1,
  Intermediate: 2,
  Advanced: 3,
};
</file>

<file path="app/shared/profileCompletion.ts">
// app/shared/profileCompletion.ts
//  Single-source-of-truth: re-export from /lib to avoid duplicated logic.
// This keeps old imports working if any screen still imports from app/shared.

export { getProfileCompletionStatus } from "../../lib/profileCompletion";
export type { ProfileCompletionStatus } from "../../lib/profileCompletion";
</file>

<file path="app/weekly-availability/SaveBar.tsx">
// app/weekly-availability/SaveBar.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";

type Props = {
  visible: boolean;
  saving?: boolean;
  onSave: () => void;
  onDiscard: () => void;
  lastSavedText?: string;
};

export default function SaveBar({
  visible,
  saving,
  onSave,
  onDiscard,
  lastSavedText,
}: Props) {
  if (!visible) return null;

  const disabled = !!saving;

  return (
    <View
      style={{
        position: "absolute",
        left: 14,
        right: 14,
        bottom: 14,
        borderRadius: 16,
        borderWidth: 1,
        borderColor: "#1E293B",
        backgroundColor: "#0B1120",
        padding: 12,
      }}
    >
      <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
        <View style={{ flex: 1 }}>
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
            Unsaved changes
          </Text>
          <Text
            style={{
              color: "#94A3B8",
              fontSize: 11,
              marginTop: 3,
              lineHeight: 14,
            }}
          >
            {lastSavedText ? `Last saved: ${lastSavedText}` : "Not saved yet"}
          </Text>
        </View>

        <Pressable
          onPress={onDiscard}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 12,
              paddingVertical: 10,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: "#334155",
              backgroundColor: "#020617",
              opacity: disabled ? 0.6 : 1,
            },
            pressed && !disabled ? { opacity: 0.85 } : null,
          ]}
        >
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
            Discard
          </Text>
        </Pressable>

        <Pressable
          onPress={onSave}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 14,
              paddingVertical: 10,
              borderRadius: 999,
              backgroundColor: "#22C55E",
              opacity: disabled ? 0.65 : 1,
              flexDirection: "row",
              alignItems: "center",
              gap: 8,
            },
            pressed && !disabled ? { opacity: 0.9 } : null,
          ]}
        >
          {saving ? <ActivityIndicator /> : null}
          <Text style={{ color: "#022C22", fontWeight: "900", fontSize: 12 }}>
            {saving ? "Saving" : "Save"}
          </Text>
        </Pressable>
      </View>
    </View>
  );
}
</file>

<file path="app/weekly-availability/styles.ts">
// app/weekly-availability/styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: {
    flex: 1,
    backgroundColor: "#020617",
  },
  scroll: {
    flex: 1,
  },
  content: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 120, // extra space for save bar + toast
  },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    color: "#9CA3AF",
    marginTop: 8,
    fontSize: 14,
  },

  title: {
    color: "#F9FAFB",
    fontSize: 22,
    fontWeight: "800",
    marginBottom: 4,
  },
  subtitle: {
    color: "#64748B",
    fontSize: 13,
    marginBottom: 12,
    lineHeight: 18,
  },

  // Section headers (step-by-step)
  sectionTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "900",
    marginTop: 10,
    marginBottom: 4,
  },
  sectionHint: {
    color: "#64748B",
    fontSize: 12,
    marginBottom: 8,
    lineHeight: 16,
  },

  // Error box
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
    marginBottom: 8,
  },

  // Summary card
  summaryCard: {
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  summaryTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "900",
    marginBottom: 4,
  },
  summaryText: {
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },
  summaryRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
    gap: 8,
    flexWrap: "wrap",
  },
  summaryBadge: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
  },
  summaryBadgeText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  // Day selector row
  daySelectorRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  dayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  dayChipToday: {
    borderColor: "#60A5FA",
  },
  dayChipSelected: {
    backgroundColor: "#F97316",
    borderColor: "#F97316",
  },
  dayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },
  dayChipTextToday: {
    color: "#BFDBFE",
    fontWeight: "800",
  },
  dayChipTextSelected: {
    color: "#0F172A",
    fontWeight: "900",
  },

  // Time input card
  timeCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  // subtle state borders (edit vs normal) - safe additions
  timeCardNormal: {
    borderColor: "#1E293B",
  },
  timeCardEditing: {
    borderColor: "#60A5FA",
  },

  timeLabelRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 8,
    marginBottom: 8,
  },
  timeLabel: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "900",
  },
  timeSelectedDayText: {
    color: "#94A3B8",
    fontSize: 12,
  },

  editBanner: {
    marginTop: 8,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#334155",
  },
  editBannerTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
    marginBottom: 2,
  },
  editBannerSub: {
    color: "#94A3B8",
    fontSize: 11,
    lineHeight: 15,
  },
  editBannerRow: {
    marginTop: 8,
    flexDirection: "row",
    gap: 8,
    flexWrap: "wrap",
  },
  bannerBtn: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  bannerBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  bannerDanger: {
    borderColor: "#7F1D1D",
    backgroundColor: "#451A1A",
  },
  bannerDangerText: {
    color: "#FECACA",
  },
  bannerPrimary: {
    borderColor: "#60A5FA",
    backgroundColor: "#60A5FA",
  },
  bannerPrimaryText: {
    color: "#0F172A",
  },

  timeRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 6,
  },
  timeDash: {
    color: "#9CA3AF",
    marginHorizontal: 8,
    fontSize: 16,
    fontWeight: "900",
  },
  timeHint: {
    color: "#64748B",
    fontSize: 12,
    marginTop: 6,
    lineHeight: 16,
  },
  timeErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    marginTop: 8,
    lineHeight: 16,
  },

  // Quick presets
  quickRow: {
    flexDirection: "row",
    marginTop: 10,
    gap: 8,
    flexWrap: "wrap",
  },
  quickChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  quickChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  quickChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },
  quickChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "900",
  },

  // Multi-day add
  multiRow: {
    marginTop: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    backgroundColor: "#0B1120",
  },
  multiTopRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    flexWrap: "wrap",
  },
  multiTopActions: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
  },
  miniActionBtn: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  miniActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  multiTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  multiCountText: {
    color: "#94A3B8",
    fontSize: 11,
    marginTop: 6,
    marginBottom: 8,
    lineHeight: 15,
  },
  multiDaysRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  multiDayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  multiDayChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  multiDayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  primaryButton: {
    marginTop: 12,
    backgroundColor: "#22C55E",
    paddingVertical: 11,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryButtonDisabled: {
    opacity: 0.6,
  },
  primaryText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
  },

  secondaryActionsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
    flexWrap: "wrap",
  },
  secondaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  secondaryBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  // Day cards list
  dayCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
    marginBottom: 10,
  },
  dayHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 6,
  },
  dayHeaderActions: {
    flexDirection: "row",
    gap: 10,
    alignItems: "center",
    flexWrap: "wrap",
  },
  dayName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "900",
  },
  daySubText: {
    marginTop: 2,
    color: "#94A3B8",
    fontSize: 11,
  },
  clearDayText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },
  copyDayText: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
  daySlotsEmptyText: {
    color: "#6B7280",
    fontSize: 12,
  },

  slotChipRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  slotChip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    gap: 10,
  },
  slotChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  slotRemoveText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },

  // Save bar (sticky)
  saveBarSticky: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(2,6,23,0.95)",
    borderTopWidth: 1,
    borderTopColor: "#1E293B",
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  saveRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  saveHint: {
    color: "#94A3B8",
    fontSize: 12,
    flex: 1,
  },
  discardButton: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  discardText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },
  saveButton: {
    backgroundColor: "#22C55E",
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 999,
    alignItems: "center",
    minWidth: 110,
  },
  saveButtonDisabled: {
    opacity: 0.6,
  },
  saveText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
    textAlign: "center",
  },

  // Time picker field
  timeFieldBox: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0F172A",
  },
  timeFieldLabel: {
    color: "#64748B",
    fontSize: 11,
    fontWeight: "800",
  },
  timeFieldValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "900",
    marginTop: 4,
  },

  // Modal
  modalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "flex-end",
  },
  modalCard: {
    backgroundColor: "#0B1120",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingVertical: 18,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  modalTitle: {
    fontSize: 16,
    fontWeight: "900",
    textAlign: "center",
    marginBottom: 10,
    color: "#F9FAFB",
  },
  modalButtonsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
  },
  modalCancel: {
    fontSize: 14,
    color: "#94A3B8",
    fontWeight: "800",
  },
  modalDone: {
    fontSize: 14,
    fontWeight: "900",
    color: "#F9FAFB",
  },

  // Copy modal list
  copyList: {
    marginTop: 10,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    justifyContent: "center",
  },
  copyChip: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  copyChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  copyChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  copyHint: {
    marginTop: 10,
    textAlign: "center",
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },

  // Toast
  toastWrap: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 84, // above save bar
    alignItems: "center",
    justifyContent: "center",
  },
  toastCard: {
    backgroundColor: "rgba(11,17,32,0.96)",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 999,
  },
  toastText: {
    color: "#F9FAFB",
    fontSize: 12,
    fontWeight: "800",
  },
});
</file>

<file path="components/external-link.tsx">
import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}
</file>

<file path="components/haptic-tab.tsx">
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}
</file>

<file path="components/hello-wave.tsx">
import Animated from 'react-native-reanimated';

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          '50%': { transform: [{ rotate: '25deg' }] },
        },
        animationIterationCount: 4,
        animationDuration: '300ms',
      }}>
      
    </Animated.Text>
  );
}
</file>

<file path="components/parallax-scroll-view.tsx">
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/themed-view';
import { useColorScheme } from '@/hooks/use-color-scheme';
import { useThemeColor } from '@/hooks/use-theme-color';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const backgroundColor = useThemeColor({}, 'background');
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <Animated.ScrollView
      ref={scrollRef}
      style={{ backgroundColor, flex: 1 }}
      scrollEventThrottle={16}>
      <Animated.View
        style={[
          styles.header,
          { backgroundColor: headerBackgroundColor[colorScheme] },
          headerAnimatedStyle,
        ]}>
        {headerImage}
      </Animated.View>
      <ThemedView style={styles.content}>{children}</ThemedView>
    </Animated.ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});
</file>

<file path="components/themed-text.tsx">
import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});
</file>

<file path="components/themed-view.tsx">
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}
</file>

<file path="components/ui/collapsible.tsx">
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { IconSymbol } from '@/components/ui/icon-symbol';
import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});
</file>

<file path="components/ui/icon-symbol.ios.tsx">
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}
</file>

<file path="components/ui/icon-symbol.tsx">
// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight, SymbolViewProps } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}
</file>

<file path="constants/theme.ts">
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

import { Platform } from 'react-native';

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

export const Fonts = Platform.select({
  ios: {
    /** iOS `UIFontDescriptorSystemDesignDefault` */
    sans: 'system-ui',
    /** iOS `UIFontDescriptorSystemDesignSerif` */
    serif: 'ui-serif',
    /** iOS `UIFontDescriptorSystemDesignRounded` */
    rounded: 'ui-rounded',
    /** iOS `UIFontDescriptorSystemDesignMonospaced` */
    mono: 'ui-monospace',
  },
  default: {
    sans: 'normal',
    serif: 'serif',
    rounded: 'normal',
    mono: 'monospace',
  },
  web: {
    sans: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    serif: "Georgia, 'Times New Roman', serif",
    rounded: "'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif",
    mono: "SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
});
</file>

<file path="eslint.config.js">
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);
</file>

<file path="filetree_mobile.txt">
Too many parameters - lib
</file>

<file path="hooks/use-color-scheme.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="hooks/use-color-scheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
</file>

<file path="hooks/use-theme-color.ts">
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
</file>

<file path="lib/availabilityStorage.ts">
// lib/availabilityStorage.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import type { AvailabilitySlot } from "./api";
import { patchSectionStatus } from "./sectionStatus"; //  update Home status too

//  Keys (versioned to avoid future breaking)
const KEY_LAST_SAVED_AT = "weeklyAvailability_lastSavedAt_v1";
const KEY_PENDING = "weeklyAvailability_pending_v1";

/**
 * The pending payload stored locally when user edits availability
 * but hasn't synced to server yet.
 */
export type PendingAvailabilityPayload = {
  slots: AvailabilitySlot[];
  updatedAtISO: string; // when user changed locally
  source: "user-edit" | "auto-restore";
};

function safeParseJSON<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export async function getWeeklyLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_LAST_SAVED_AT);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

/**
 *  IMPORTANT:
 * - write local timestamp
 * - also patch sectionStatus so HomeScreen reflects it immediately
 */
export async function setWeeklyLastSavedAt(
  ts: number = Date.now()
): Promise<void> {
  try {
    await AsyncStorage.setItem(KEY_LAST_SAVED_AT, String(ts));
  } catch {
    // swallow - we don't want UI crash
  }

  // keep Home in sync (ignore errors safely)
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: ts });
  } catch {
    // ignore
  }
}

export async function clearWeeklyLastSavedAt(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_LAST_SAVED_AT);
  } catch {
    // ignore
  }

  // keep Home in sync
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: null });
  } catch {
    // ignore
  }
}

export async function getPendingWeeklyAvailability(): Promise<PendingAvailabilityPayload | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_PENDING);
    const parsed = safeParseJSON<PendingAvailabilityPayload>(raw);
    if (
      !parsed ||
      !Array.isArray(parsed.slots) ||
      typeof parsed.updatedAtISO !== "string"
    ) {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}

export async function setPendingWeeklyAvailability(
  slots: AvailabilitySlot[],
  source: PendingAvailabilityPayload["source"] = "user-edit"
): Promise<void> {
  try {
    const payload: PendingAvailabilityPayload = {
      slots,
      updatedAtISO: new Date().toISOString(),
      source,
    };
    await AsyncStorage.setItem(KEY_PENDING, JSON.stringify(payload));
  } catch {
    // ignore
  }
}

export async function clearPendingWeeklyAvailability(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_PENDING);
  } catch {
    // ignore
  }
}

/**
 * Convenience: mark "saved successfully" (server sync succeeded)
 * - clear pending
 * - bump lastSavedAt (and Home status)
 */
export async function markWeeklyAvailabilitySynced(): Promise<void> {
  await Promise.all([
    clearPendingWeeklyAvailability(),
    setWeeklyLastSavedAt(Date.now()), //  this also patches sectionStatus
  ]);
}

/**
 * Use this when entering weekly availability screen:
 * If there is a pending payload, you can offer restore.
 */
export async function hasPendingWeeklyAvailability(): Promise<boolean> {
  const p = await getPendingWeeklyAvailability();
  return !!p?.slots?.length;
}
</file>

<file path="lib/profileCompletion.ts">
// lib/profileCompletion.ts
import type { AvailabilitySlot, SkillLearn, SkillTeach } from "./api";

export type ProfileCompletionSection = {
  key: "basics" | "learn" | "teach" | "availability";
  title: string;
  done: boolean;
  hint: string;
  ctaLabel: string;
  href: string; // expo-router route
};

export type ProfileCompletionStatus = {
  percent: number; // 0..100
  isComplete: boolean;
  doneCount: number;
  totalCount: number;
  sections: ProfileCompletionSection[];
};

type UserLike = {
  fullName?: string;
  email?: string;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

function bool(v: any) {
  return !!v;
}

export function getProfileCompletionStatus(user: UserLike | null | undefined): ProfileCompletionStatus {
  const fullName = (user?.fullName || "").trim();
  const email = (user?.email || "").trim();

  const hasBasics = bool(fullName) && bool(email);

  const learnCount = user?.skillsToLearn?.length ?? 0;
  const teachCount = user?.skillsToTeach?.length ?? 0;
  const availabilityCount = user?.availabilitySlots?.length ?? 0;

  const hasLearn = learnCount > 0;
  const hasTeach = teachCount > 0;
  const hasAvailability = availabilityCount > 0;

  const sections: ProfileCompletionSection[] = [
    {
      key: "basics",
      title: "Profile basics",
      done: hasBasics,
      hint: hasBasics ? "Looks good." : "Add your name + email to finish the basics.",
      ctaLabel: hasBasics ? "View" : "Fix basics",
      //       
      href: "/settings",
    },
    {
      key: "learn",
      title: "Skills to learn",
      done: hasLearn,
      hint: hasLearn
        ? `You have ${learnCount} learning goal${learnCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you want to learn (improves matching).",
      ctaLabel: hasLearn ? "Manage" : "Add skills",
      href: "/manage-skills-to-learn",
    },
    {
      key: "teach",
      title: "Skills to teach",
      done: hasTeach,
      hint: hasTeach
        ? `You can teach ${teachCount} skill${teachCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you can teach (unlocks more matches).",
      ctaLabel: hasTeach ? "Manage" : "Add skills",
      href: "/manage-skills-to-teach",
    },
    {
      key: "availability",
      title: "Weekly availability",
      done: hasAvailability,
      hint: hasAvailability
        ? `You have ${availabilityCount} time slot${availabilityCount === 1 ? "" : "s"} set.`
        : "Set 12 time slots so mentors can align with you.",
      ctaLabel: hasAvailability ? "Edit" : "Set now",
      href: "/weekly-availability",
    },
  ];

  const totalCount = sections.length;
  const doneCount = sections.filter((s) => s.done).length;

  //    
  const percent = clamp(Math.round((doneCount / totalCount) * 100), 0, 100);
  const isComplete = doneCount === totalCount;

  return { percent, isComplete, doneCount, totalCount, sections };
}
</file>

<file path="lib/sectionStatus.ts">
// lib/sectionStatus.ts
import AsyncStorage from "@react-native-async-storage/async-storage";

const STORAGE_KEY = "sectionStatus_v1";

export type SectionStatus = {
  weeklyAvailabilityLastSavedAt: number | null;
  learnHasPendingSync: boolean;
  teachHasPendingSync: boolean;
  updatedAt: number;
};

function safeJsonParse<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export function makeDefaultSectionStatus(
  overrides: Partial<SectionStatus> = {}
): SectionStatus {
  const now = Date.now();
  const next: SectionStatus = {
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: now,
    ...overrides,
  };

  if (!(typeof next.updatedAt === "number" && Number.isFinite(next.updatedAt))) {
    next.updatedAt = now;
  }
  return next;
}

export function normalizeSectionStatus(input: unknown): SectionStatus {
  const obj = (input ?? {}) as Partial<SectionStatus>;

  const weeklyAvailabilityLastSavedAt =
    typeof obj.weeklyAvailabilityLastSavedAt === "number" &&
    Number.isFinite(obj.weeklyAvailabilityLastSavedAt)
      ? obj.weeklyAvailabilityLastSavedAt
      : null;

  const learnHasPendingSync = obj.learnHasPendingSync === true;
  const teachHasPendingSync = obj.teachHasPendingSync === true;

  const updatedAt =
    typeof obj.updatedAt === "number" && Number.isFinite(obj.updatedAt)
      ? obj.updatedAt
      : Date.now();

  return {
    weeklyAvailabilityLastSavedAt,
    learnHasPendingSync,
    teachHasPendingSync,
    updatedAt,
  };
}

export async function readSectionStatus(): Promise<SectionStatus> {
  const raw = await AsyncStorage.getItem(STORAGE_KEY);
  const parsed = safeJsonParse<SectionStatus>(raw);
  if (!parsed) return makeDefaultSectionStatus();
  return normalizeSectionStatus(parsed);
}

export async function writeSectionStatus(next: SectionStatus): Promise<void> {
  const normalized = normalizeSectionStatus(next);
  await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
}

export async function patchSectionStatus(
  patch: Partial<Omit<SectionStatus, "updatedAt">>
): Promise<SectionStatus> {
  const current = await readSectionStatus();
  const next: SectionStatus = { ...current, ...patch, updatedAt: Date.now() };
  await writeSectionStatus(next);
  return next;
}

export function formatTimeAgo(
  timestampMs: number,
  nowMs: number = Date.now()
): string {
  const diffMs = Math.max(0, nowMs - timestampMs);
  const min = Math.floor(diffMs / 60000);

  if (min < 1) return "Just now";
  if (min < 60) return `${min}m ago`;

  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}h ago`;

  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}d ago`;

  const week = Math.floor(day / 7);
  if (week < 5) return `${week}w ago`;

  const month = Math.floor(day / 30);
  if (month < 12) return `${month}mo ago`;

  const year = Math.floor(day / 365);
  return `${year}y ago`;
}
</file>

<file path="o -20">
[33m575b693[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32madam[m[33m, [m[1;31morigin/main[m[33m)[m HEAD@{2026-01-03 22:09:29 +0200}: reset: moving to origin/main
[33m687ffeb[m[33m ([m[1;31morigin/adam[m[33m)[m HEAD@{2026-01-02 16:52:39 +0200}: commit: adding chat ubgrading session and make them work together
[33md1a7537[m HEAD@{2025-12-28 11:28:29 +0200}: commit: sessions
[33mfd4643d[m HEAD@{2025-12-24 13:36:05 +0200}: commit: working on rating+sessions+and points system maybe i finished with sessions and rating for now maybe will be small vhanges or uxui upgrading
[33m5eace2c[m HEAD@{2025-12-15 14:07:46 +0200}: commit: s.t.l s.t.t home matching with ai and without upgrading the availability slots page making find a mentor page with all the logic that needs work
[33m919b7e1[m HEAD@{2025-12-08 20:27:25 +0200}: commit: pushed new fixed
[33mbeed9ef[m[33m ([m[1;32mmain[m[33m)[m HEAD@{2025-12-08 20:25:02 +0200}: checkout: moving from main to adam
[33mbeed9ef[m[33m ([m[1;32mmain[m[33m)[m HEAD@{2025-12-08 20:24:22 +0200}: Branch: renamed refs/heads/main to refs/heads/main
[33mbeed9ef[m[33m ([m[1;32mmain[m[33m)[m HEAD@{2025-12-08 20:22:28 +0200}: Branch: renamed refs/heads/master to refs/heads/main
[33mbeed9ef[m[33m ([m[1;32mmain[m[33m)[m HEAD@{2025-12-08 20:11:56 +0200}: commit: a
[33mf756d36[m HEAD@{2025-12-08 19:54:38 +0200}: commit: starting the manange page
[33m4b7c0ad[m HEAD@{2025-11-17 22:06:07 +0200}: commit (initial): Initial commit
</file>

<file path="README.md">
# Welcome to your Expo app 

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
</file>

<file path="scripts/reset-project.js">
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(` /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(` /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(` /${dir} deleted.`);
        }
      } else {
        console.log(` /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log(" app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log(" app/_layout.tsx created.");

    console.log("\n Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(` Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log(" Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);
</file>

<file path="server/matching/localMatcher.js">
// server/matching/localMatcher.js
const User = require("../models/User");
const {
  normalizeSkillName,
  computeSkillSimilarity,
  computeLevelCompatibility,
  computeAvailabilityScore,
  computeProfileQuality,
  computeMultiSkillBonus,
} = require("./normalize");
const { buildMatchScore } = require("./scoreUtils");

/**
 * Local heuristic matcher (string-based)
 */
async function findMentorMatchesLocal({
  userId,
  skillQuery,
  level,
  userAvailability,
}) {
  const skillToMatch = String(skillQuery || "").trim();
  const normalizedSkill = normalizeSkillName(skillToMatch);
  const normalizedDesiredLevel = String(level || "Beginner");

  if (!normalizedSkill) return [];

  const requestingUser = await User.findById(userId).lean();
  if (!requestingUser) return [];

  const mentorsRaw = await User.find({
    _id: { $ne: userId },
    skillsToTeach: { $exists: true, $ne: [] },
  }).lean();

  if (!mentorsRaw.length) return [];

  const results = [];

  const studentGoals = Array.isArray(requestingUser.skillsToLearn)
    ? requestingUser.skillsToLearn
    : [];

  const userAvail = Array.isArray(userAvailability) ? userAvailability : [];

  for (const mentor of mentorsRaw) {
    const teachSkills = Array.isArray(mentor.skillsToTeach)
      ? mentor.skillsToTeach
      : [];
    if (!teachSkills.length) continue;

    const mentorAvailability = Array.isArray(mentor.availabilitySlots)
      ? mentor.availabilitySlots
      : [];

    let bestSkill = null;
    let bestSkillSim = 0;

    for (const skillObj of teachSkills) {
      if (!skillObj || !skillObj.name) continue;

      const sim = computeSkillSimilarity(skillToMatch, skillObj.name);
      if (sim < 0.35) continue;

      if (sim > bestSkillSim) {
        bestSkillSim = sim;
        bestSkill = skillObj;
      }
    }

    if (!bestSkill) continue;

    const levelScore = computeLevelCompatibility(
      normalizedDesiredLevel,
      bestSkill.level || "Not specified"
    );

    const availabilityScore = computeAvailabilityScore(
      userAvail,
      mentorAvailability
    );
    const profileQuality = computeProfileQuality(mentor);
    const multiSkillBonus = computeMultiSkillBonus(studentGoals, teachSkills);

    const matchScore = buildMatchScore({
      skillSimilarity: bestSkillSim,
      levelScore,
      availabilityScore,
      profileQuality,
      multiSkillBonus,
    });

    if (matchScore < 0.25) continue;

    results.push({
      mentorId: String(mentor._id),
      fullName: mentor.fullName || "Unknown mentor",
      matchScore,
      mainMatchedSkill: {
        name: bestSkill.name,
        level: bestSkill.level || "Not specified",
        similarityScore: bestSkillSim,
      },
      skillsToTeach: teachSkills,
      availabilitySlots: mentorAvailability,
    });
  }

  results.sort((a, b) => b.matchScore - a.matchScore);
  return results.slice(0, 20);
}

module.exports = { findMentorMatchesLocal };
</file>

<file path="server/matching/normalize.js">
// server/matching/normalize.js

function normalize(str) {
  if (!str) return "";
  return String(str).toLowerCase().trim();
}

// Synonyms   
const SKILL_SYNONYMS = {
  js: "javascript",
  node: "node.js",
  nodejs: "node.js",
  rn: "react-native",
  "react native": "react-native",
};

function normalizeSkillName(name) {
  let s = normalize(name)
    .replace(/[()+\-_/]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

  if (SKILL_SYNONYMS[s]) s = SKILL_SYNONYMS[s];
  return s;
}

/**
 * Pure string-based similarity between two skill names (0..1)
 */
function computeSkillSimilarity(a, b) {
  const s1 = normalizeSkillName(a);
  const s2 = normalizeSkillName(b);

  if (!s1 || !s2) return 0;
  if (s1 === s2) return 1;

  if (s1.startsWith(s2) || s2.startsWith(s1)) return 0.9;
  if (s1.includes(s2) || s2.includes(s1)) return 0.7;

  const tokens1 = new Set(s1.split(/\s+/));
  const tokens2 = new Set(s2.split(/\s+/));

  let intersection = 0;
  for (const t of tokens1) if (tokens2.has(t)) intersection++;

  const union = tokens1.size + tokens2.size - intersection;
  if (union === 0) return 0;

  const jaccard = intersection / union;
  return Math.max(0.3, Math.min(0.6, jaccard));
}

// ========== Levels ==========

function mapLevelToNumber(level) {
  const l = normalize(level);
  if (l.includes("advanced")) return 3;
  if (l.includes("intermediate")) return 2;
  if (l.includes("beginner")) return 1;
  return 2;
}

/**
 * Level compatibility with direction:
 * mentor >= student 
 * 0..1
 */
function computeLevelCompatibility(requestLevel, mentorLevel) {
  const req = mapLevelToNumber(requestLevel);
  const men = mapLevelToNumber(mentorLevel);

  const diff = men - req;

  if (diff >= 0) {
    if (diff === 0) return 1.0;
    if (diff === 1) return 0.9;
    return 0.8;
  } else {
    const absDiff = Math.abs(diff);
    if (absDiff === 1) return 0.5;
    return 0.2;
  }
}

// ========== Availability ==========

function timeToMinutes(t) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map(Number);
  return (h || 0) * 60 + (m || 0);
}

function computeTotalOverlapMinutes(
  userAvailability = [],
  mentorAvailability = []
) {
  if (!userAvailability.length || !mentorAvailability.length) return 0;

  let total = 0;

  for (const ua of userAvailability) {
    for (const ma of mentorAvailability) {
      if (ua.dayOfWeek !== ma.dayOfWeek) continue;

      const start1 = timeToMinutes(ua.from);
      const end1 = timeToMinutes(ua.to);
      const start2 = timeToMinutes(ma.from);
      const end2 = timeToMinutes(ma.to);

      const overlap = Math.max(
        0,
        Math.min(end1, end2) - Math.max(start1, start2)
      );
      total += overlap;
    }
  }

  return total;
}

function computeAvailabilityScore(
  userAvailability = [],
  mentorAvailability = []
) {
  if (!userAvailability.length || !mentorAvailability.length) return 0.4;

  const overlapMinutes = computeTotalOverlapMinutes(
    userAvailability,
    mentorAvailability
  );

  if (overlapMinutes <= 0) {
    const sameDay = userAvailability.some((ua) =>
      mentorAvailability.some((ma) => ma.dayOfWeek === ua.dayOfWeek)
    );
    return sameDay ? 0.5 : 0.2;
  }

  const ratio = Math.min(overlapMinutes / 240, 1);

  if (ratio >= 0.75) return 1.0;
  if (ratio >= 0.4) return 0.8;
  if (ratio >= 0.15) return 0.6;
  return 0.4;
}

// ========== Profile Quality & Multi-skill Context ==========

function computeProfileQuality(mentor) {
  let score = 0;

  if (mentor.fullName) score += 0.05;

  if (typeof mentor.avgRating === "number" && mentor.ratingCount > 0) {
    const normRating = Math.max(0, Math.min(mentor.avgRating / 5, 1));
    score += 0.25 * normRating;
    if (mentor.ratingCount >= 5) score += 0.05;
    if (mentor.ratingCount >= 20) score += 0.05;
  }

  if (Array.isArray(mentor.skillsToTeach) && mentor.skillsToTeach.length >= 1) {
    score += 0.1;
  }
  if (mentor.skillsToTeach && mentor.skillsToTeach.length >= 3) {
    score += 0.15;
  }

  if (
    Array.isArray(mentor.availabilitySlots) &&
    mentor.availabilitySlots.length > 0
  ) {
    score += 0.15;
  }

  if (mentor.points && mentor.points > 0) score += 0.05;
  if (mentor.xp && mentor.xp > 0) score += 0.05;

  if (
    mentor.preferences &&
    Array.isArray(mentor.preferences.languages) &&
    mentor.preferences.languages.length > 0
  ) {
    score += 0.05;
  }

  return Math.min(score, 1);
}

/**
 * Bonus         
 * 0..0.2
 */
function computeMultiSkillBonus(studentGoals = [], mentorSkills = []) {
  if (!studentGoals.length || !mentorSkills.length) return 0;

  // supports goals being either string OR {name, level}
  const goalNames = studentGoals
    .map((g) => (typeof g === "string" ? g : g?.name))
    .filter(Boolean);

  const goalSet = new Set(goalNames.map((s) => normalizeSkillName(s)));
  const mentorSet = new Set(
    mentorSkills.map((s) => normalizeSkillName(s.name))
  );

  let common = 0;
  for (const g of goalSet) {
    if (mentorSet.has(g)) common++;
  }

  if (common === 0) return 0;
  return Math.min(common * 0.05, 0.2);
}

module.exports = {
  normalizeSkillName,
  computeSkillSimilarity,
  computeLevelCompatibility,
  computeAvailabilityScore,
  computeProfileQuality,
  computeMultiSkillBonus,
};
</file>

<file path="server/matching/scoreUtils.js">
// server/matching/scoreUtils.js

/**
 * Cosine similarity between two vectors
 * returns value in range 0..1 (or 0 on invalid input)
 */
function cosineSimilarity(a, b) {
  if (
    !Array.isArray(a) ||
    !Array.isArray(b) ||
    a.length === 0 ||
    b.length === 0 ||
    a.length !== b.length
  ) {
    return 0;
  }

  let dot = 0;
  let na = 0;
  let nb = 0;

  for (let i = 0; i < a.length; i++) {
    const x = Number(a[i]) || 0;
    const y = Number(b[i]) || 0;
    dot += x * y;
    na += x * x;
    nb += y * y;
  }

  const denom = Math.sqrt(na) * Math.sqrt(nb);
  if (!denom) return 0;

  const sim = dot / denom;
  return sim < 0 ? 0 : sim > 1 ? 1 : sim;
}

/**
 * Final weighted match score builder
 *
 * Weights rationale:
 * - skillSimilarity (0.6): core of matching
 * - levelScore     (0.2): mentor >= student preference
 * - availability   (0.15): scheduling feasibility
 * - profileQuality (0.05): trust & completeness
 * - multiSkillBonus (0..0.2): additive bonus
 */
function buildMatchScore({
  skillSimilarity,
  levelScore,
  availabilityScore,
  profileQuality,
  multiSkillBonus,
}) {
  const wSkill = 0.6;
  const wLevel = 0.2;
  const wAvail = 0.15;
  const wProfile = 0.05;

  let score =
    wSkill * (Number(skillSimilarity) || 0) +
    wLevel * (Number(levelScore) || 0) +
    wAvail * (Number(availabilityScore) || 0) +
    wProfile * (Number(profileQuality) || 0);

  score += Number(multiSkillBonus) || 0;

  // final clamp (explicit & safe)
  if (Number.isNaN(score)) return 0;
  if (score < 0) return 0;
  if (score > 1) return 1;
  return score;
}

module.exports = { cosineSimilarity, buildMatchScore };
</file>

<file path="server/models/Conversation.js">
// server/models/Conversation.js
const mongoose = require("mongoose");

const ConversationSchema = new mongoose.Schema(
  {
    // 1-to-1 only
    participants: {
      type: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }],
      required: true,
      validate: {
        validator(arr) {
          return Array.isArray(arr) && arr.length === 2;
        },
        message: "Conversation must have exactly 2 participants",
      },
      index: true,
    },

    lastMessageText: { type: String, default: "" },
    lastMessageAt: { type: Date, default: null },
  },
  { timestamps: true }
);

// Helpful indexes for inbox queries
ConversationSchema.index({ participants: 1, lastMessageAt: -1 });

module.exports = mongoose.model("Conversation", ConversationSchema);
</file>

<file path="server/models/Message.js">
// server/models/Message.js
const mongoose = require("mongoose");

const MessageSchema = new mongoose.Schema(
  {
    conversationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Conversation",
      required: true,
      index: true,
    },

    senderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    text: {
      type: String,
      required: true,
      trim: true,
      maxlength: 4000,
    },

    // simple read receipts
    readBy: {
      type: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }],
      default: [],
    },
  },
  { timestamps: true }
);

MessageSchema.index({ conversationId: 1, createdAt: -1 });

module.exports = mongoose.model("Message", MessageSchema);
</file>

<file path="server/models/PointTransaction.js">
// server/models/PointTransaction.js
const mongoose = require("mongoose");

const PointTransactionSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    amount: {
      type: Number,
      required: true, // + or -
    },

    reason: {
      type: String,
      required: true, // e.g. "teach_session", "learn_session"
    },

    sessionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Session",
      default: null,
    },

    balanceAfter: {
      type: Number,
      required: true,
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("PointTransaction", PointTransactionSchema);
</file>

<file path="server/models/Rating.js">
// server/models/Rating.js
const mongoose = require("mongoose");

const RatingSchema = new mongoose.Schema(
  {
    sessionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Session",
      required: true,
      unique: true, // rating   session
    },

    fromUserId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    toUserId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    score: {
      type: Number,
      min: 1,
      max: 5,
      required: true,
    },

    comment: {
      type: String,
      trim: true,
      maxlength: 500,
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Rating", RatingSchema);
</file>

<file path="server/routes/users.js">
// server/routes/users.js
const express = require("express");
const mongoose = require("mongoose");
const User = require("../models/User");

function isValidObjectId(id) {
  return mongoose.Types.ObjectId.isValid(String(id));
}

function toPublicUser(u) {
  return {
    id: String(u._id),
    fullName: u.fullName,
    points: u.points,
    xp: u.xp,
    streak: u.streak,
    avgRating: u.avgRating,
    ratingCount: u.ratingCount,
    skillsToTeach: u.skillsToTeach || [],
    availabilitySlots: u.availabilitySlots || [],
    preferences: u.preferences || { communicationModes: [], languages: [] },
  };
}

module.exports = function usersRouter(authMiddleware) {
  const router = express.Router();

  // GET /api/users/:id
  router.get("/:id", authMiddleware, async (req, res) => {
    try {
      const id = String(req.params.id);
      if (!isValidObjectId(id)) {
        return res.status(400).json({ error: "Invalid user id" });
      }

      const u = await User.findById(id).select(
        "fullName points xp streak avgRating ratingCount skillsToTeach availabilitySlots preferences"
      );

      if (!u) return res.status(404).json({ error: "User not found" });

      return res.json(toPublicUser(u));
    } catch (err) {
      console.error("GET PUBLIC USER ERROR:", err);
      return res.status(500).json({ error: "Failed to load user profile" });
    }
  });

  return router;
};
</file>

<file path="server/services/gamificationRules.js">
// server/services/gamificationRules.js

module.exports = {
  // Points economy (from your book examples)
  POINTS: {
    BOOK_LEARN_SESSION_COST: 10, // learner pays on ACCEPT
    TEACH_SESSION_REWARD: 10, // mentor gets on COMPLETE
    HIGH_RATING_BONUS: 2, // bonus when rating is high
    CANCEL_LATE_PENALTY: 2, // penalty when cancel close to scheduled time
  },

  // Rating threshold for bonus
  RATING: {
    HIGH_SCORE_THRESHOLD: 4, // >=4 => bonus
    MIN: 1,
    MAX: 5,
  },

  // Define "late cancellation"
  CANCEL: {
    LATE_WINDOW_MINUTES: 120, // 2 hours
  },

  // Reasons saved in PointTransaction.reason (keep stable forever)
  REASONS: {
    LEARN_SESSION_BOOKED: "learn_session_booked",
    TEACH_SESSION_COMPLETED: "teach_session_completed",
    HIGH_RATING_BONUS: "high_rating_bonus",
    CANCEL_LATE: "cancel_late",
  },
};
</file>

<file path="server/services/matchingService.js">
// server/services/matchingService.js
const { findMentorMatches } = require("../matching");
module.exports = { findMentorMatches };
</file>

<file path="server/services/ratingsService.js">
// server/services/ratingsService.js
const mongoose = require("mongoose");
const Rating = require("../models/Rating");
const Session = require("../models/Session");
const User = require("../models/User");

const rules = require("./gamificationRules");
const { addPoints } = require("./pointsService");

function httpError(status, message) {
  const e = new Error(message);
  e.status = status;
  return e;
}

function isValidObjectId(id) {
  return mongoose.Types.ObjectId.isValid(String(id));
}

function clampLimit(n, def = 20, max = 100) {
  const x = Number(n);
  if (!Number.isFinite(x) || x <= 0) return def;
  return Math.min(max, Math.max(1, Math.floor(x)));
}

async function recomputeAndSaveAvg(toUserId, mongoSession) {
  // compute avg + count from Rating collection (source of truth)
  const agg = await Rating.aggregate([
    { $match: { toUserId: new mongoose.Types.ObjectId(String(toUserId)) } },
    {
      $group: {
        _id: "$toUserId",
        avg: { $avg: "$score" },
        count: { $sum: 1 },
      },
    },
  ]).session(mongoSession);

  const avg = Number(agg?.[0]?.avg || 0);
  const count = Number(agg?.[0]?.count || 0);

  const updatedUser = await User.findByIdAndUpdate(
    toUserId,
    { avgRating: avg, ratingCount: count },
    { new: true, session: mongoSession }
  )
    .select("fullName avgRating ratingCount points xp streak")
    .lean();

  return updatedUser;
}

/**
 * createSessionRating:
 * - validates session + permissions
 * - creates Rating (unique per session)
 * - updates User avgRating + ratingCount
 * - gives high-rating bonus points (idempotent via pointsService)
 * - best-effort: sets Session.rating/feedback if empty (compat with old endpoint)
 */
async function createSessionRating({ fromUserId, sessionId, score, comment }) {
  const fromId = String(fromUserId || "").trim();
  const sessId = String(sessionId || "").trim();
  const s = Number(score);
  const c = String(comment || "").trim();

  if (!isValidObjectId(fromId)) throw httpError(401, "Invalid user");
  if (!isValidObjectId(sessId)) throw httpError(400, "Invalid sessionId");

  const min = rules?.RATING?.MIN ?? 1;
  const max = rules?.RATING?.MAX ?? 5;

  if (!Number.isFinite(s) || s < min || s > max) {
    throw httpError(400, `score must be between ${min} and ${max}`);
  }

  const mongoSession = await mongoose.startSession();
  mongoSession.startTransaction();

  try {
    const sessionDoc = await Session.findById(sessId).session(mongoSession);
    if (!sessionDoc) throw httpError(404, "Session not found");

    if (String(sessionDoc.status) !== "completed") {
      throw httpError(400, "You can rate only completed sessions");
    }

    const mentorId = String(sessionDoc.mentorId);
    const learnerId = String(sessionDoc.learnerId);

    const isMentor = mentorId === fromId;
    const isLearner = learnerId === fromId;

    if (!isMentor && !isLearner) {
      throw httpError(403, "Not allowed");
    }

    const toUserId = isMentor ? learnerId : mentorId;
    if (!toUserId || !isValidObjectId(toUserId)) {
      throw httpError(500, "Invalid session participants");
    }

    // Create rating (unique per session)
    let rating;
    try {
      rating = await Rating.create(
        [
          {
            sessionId: sessId,
            fromUserId: fromId,
            toUserId,
            score: Math.round(s),
            comment: c || undefined,
          },
        ],
        { session: mongoSession }
      );
      rating = rating?.[0];
    } catch (err) {
      // Duplicate key => rating already exists for this session
      if (String(err?.code) === "11000") {
        throw httpError(400, "Session already rated");
      }
      throw err;
    }

    // Best-effort: keep Session fields in sync (only if empty)
    if (sessionDoc.rating == null) sessionDoc.rating = rating.score;
    if (!String(sessionDoc.feedback || "").trim() && c) sessionDoc.feedback = c;
    await sessionDoc.save({ session: mongoSession });

    // Update avg rating & count
    const updatedUser = await recomputeAndSaveAvg(toUserId, mongoSession);

    // High rating bonus (bonus goes to the rated person)
    const threshold = rules?.RATING?.HIGH_SCORE_THRESHOLD ?? 4;
    const bonus = rules?.POINTS?.HIGH_RATING_BONUS ?? 0;

    if (bonus > 0 && rating.score >= threshold) {
      // pointsService is idempotent by (userId+reason+sessionId)
      await addPoints(
        toUserId,
        bonus,
        rules.REASONS.HIGH_RATING_BONUS,
        sessId,
        { mongoSession }
      );
    }

    await mongoSession.commitTransaction();
    mongoSession.endSession();

    return { rating, updatedUser };
  } catch (err) {
    await mongoSession.abortTransaction();
    mongoSession.endSession();
    throw err;
  }
}

/**
 * listRatingsForUser:
 * - latest ratings received by user
 */
async function listRatingsForUser({ userId, limit }) {
  const id = String(userId || "").trim();
  if (!isValidObjectId(id)) throw httpError(400, "Invalid user id");

  const lim = clampLimit(limit, 20, 100);

  const items = await Rating.find({ toUserId: id })
    .sort({ createdAt: -1 })
    .limit(lim)
    .select("sessionId fromUserId toUserId score comment createdAt")
    .lean();

  return items.map((r) => ({
    id: String(r._id),
    sessionId: String(r.sessionId),
    fromUserId: String(r.fromUserId),
    toUserId: String(r.toUserId),
    score: Number(r.score),
    comment: String(r.comment || ""),
    createdAt: r.createdAt,
  }));
}

module.exports = {
  createSessionRating,
  listRatingsForUser,
};
</file>

<file path="tracked_files.txt">
.VSCodeCounter/2025-12-10_22-45-17/details.md
.VSCodeCounter/2025-12-10_22-45-17/diff-details.md
.VSCodeCounter/2025-12-10_22-45-17/diff.csv
.VSCodeCounter/2025-12-10_22-45-17/diff.md
.VSCodeCounter/2025-12-10_22-45-17/diff.txt
.VSCodeCounter/2025-12-10_22-45-17/results.csv
.VSCodeCounter/2025-12-10_22-45-17/results.json
.VSCodeCounter/2025-12-10_22-45-17/results.md
.VSCodeCounter/2025-12-10_22-45-17/results.txt
.env
.gitignore
.vscode/extensions.json
.vscode/settings.json
README.md
app.json
app/(auth)/_layout.tsx
app/(auth)/login/index.tsx
app/(auth)/shared/AuthButton.tsx
app/(auth)/shared/AuthHeader.tsx
app/(auth)/shared/AuthTextField.tsx
app/(auth)/shared/InlineError.tsx
app/(auth)/shared/PasswordField.tsx
app/(auth)/shared/mapApiError.ts
app/(auth)/shared/styles.ts
app/(auth)/shared/useAuthFieldFocus.ts
app/(auth)/shared/useAuthRedirect.ts
app/(auth)/shared/validators.ts
app/(auth)/signup/index.tsx
app/(tabs)/_layout.tsx
app/(tabs)/chats/(components)/ChatHeader.tsx
app/(tabs)/chats/(components)/ChatInput.tsx
app/(tabs)/chats/(components)/MessageBubble.tsx
app/(tabs)/chats/(components)/MessagesList.tsx
app/(tabs)/chats/(components)/TopLoadingHint.tsx
app/(tabs)/chats/[conversationId].tsx
app/(tabs)/chats/index.tsx
app/(tabs)/explore.tsx
app/(tabs)/index.tsx
app/_layout.tsx
app/find-mentor.tsx
app/index.tsx
app/login.tsx
app/manage-skills-to-learn/AddSkillToLearnForm.tsx
app/manage-skills-to-learn/CategorySelector.tsx
app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
app/manage-skills-to-learn/SkillChip.tsx
app/manage-skills-to-learn/SkillsToLearnList.tsx
app/manage-skills-to-learn/SubCategorySelector.tsx
app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
app/manage-skills-to-learn/index.tsx
app/manage-skills-to-learn/skillData.ts
app/manage-skills-to-learn/types.ts
app/manage-skills-to-learn/useManageSkillsToLearn.ts
app/manage-skills-to-teach/AddSkillToTeachForm.tsx
app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
app/manage-skills-to-teach/SkillsToTeachList.tsx
app/manage-skills-to-teach/index.tsx
app/manage-skills-to-teach/types.ts
app/manage-skills-to-teach/useManageSkillsToTeach.ts
app/mentor/[id].tsx
app/modal.tsx
app/profile.tsx
app/screens/HomeScreen.tsx
app/screens/components/MatchReadinessStrip.tsx
app/screens/components/PillButton.tsx
app/screens/components/ProfileStatusCard.tsx
app/screens/components/QuickEditBar.tsx
app/screens/components/SkeletonCard.tsx
app/screens/components/ViewProfileCTA.tsx
app/screens/homescreen.styles.ts
app/sessions/api/sessionsApi.ts
app/sessions/components/SessionCard.tsx
app/sessions/index.tsx
app/sessions/request.tsx
app/sessions/screens/(components)/SessionsEmptyState.tsx
app/sessions/screens/(components)/SessionsHeader.tsx
app/sessions/screens/(components)/SessionsRowRenderer.tsx
app/sessions/screens/(components)/SessionsRows.tsx
app/sessions/screens/(components)/SessionsSummaryBar.tsx
app/sessions/screens/(hooks)/useSessionsData.ts
app/sessions/screens/SessionsScreen.tsx
app/sessions/screens/request/(hooks)/useRequestSessionForm.ts
app/sessions/screens/request/RequestSessionScreen.tsx
app/sessions/screens/request/components/MentorCard.tsx
app/sessions/screens/request/components/RequestTopBar.tsx
app/sessions/screens/request/components/StepNote.tsx
app/sessions/screens/request/components/StepPills.tsx
app/sessions/screens/request/components/StepSchedule.tsx
app/sessions/screens/request/components/StepSkillLevel.tsx
app/sessions/screens/request/components/StickyFooter.tsx
app/sessions/screens/request/components/UI.tsx
app/sessions/screens/request/styles.ts
app/sessions/utils/formatSession.ts
app/shared/levels.ts
app/shared/profileCompletion.ts
app/signup.tsx
app/weekly-availability/SaveBar.tsx
app/weekly-availability/TimeField.tsx
app/weekly-availability/components.tsx
app/weekly-availability/index.tsx
app/weekly-availability/styles.ts
app/weekly-availability/useWeeklyAvailability.ts
components/external-link.tsx
components/haptic-tab.tsx
components/hello-wave.tsx
components/parallax-scroll-view.tsx
components/themed-text.tsx
components/themed-view.tsx
components/ui/collapsible.tsx
components/ui/icon-symbol.ios.tsx
components/ui/icon-symbol.tsx
constants/theme.ts
eslint.config.js
hooks/use-color-scheme.ts
hooks/use-color-scheme.web.ts
hooks/use-theme-color.ts
lib/api.ts
lib/availabilityStorage.ts
lib/chat/api.ts
lib/chat/socket.ts
lib/profileCompletion.ts
lib/sectionStatus.ts
package-lock.json
package.json
repomix-mobile.xml
scripts/reset-project.js
server/.env
server/matching/embeddingService.js
server/matching/index.js
server/matching/localMatcher.js
server/matching/normalize.js
server/matching/openaiMatcher.js
server/matching/scoreUtils.js
server/models/Conversation.js
server/models/Message.js
server/models/PointTransaction.js
server/models/Rating.js
server/models/Session.js
server/models/User.js
server/package-lock.json
server/package.json
server/repomix-server.xml
server/routes/chat.js
server/routes/points.routes.js
server/routes/ratings.js
server/routes/sessions.js
server/routes/users.js
server/server.js
server/services/matchingService.js
server/services/pointsService.js
tsconfig.json
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}
</file>

<file path="app/_layout.tsx">
import {
  DarkTheme,
  DefaultTheme,
  ThemeProvider,
} from "@react-navigation/native";
import { Stack } from "expo-router";
import { StatusBar } from "expo-status-bar";
import "react-native-reanimated";

import { useColorScheme } from "@/hooks/use-color-scheme";

export const unstable_settings = {
  anchor: "(tabs)",
};

export default function RootLayout() {
  const colorScheme = useColorScheme();

  return (
    <ThemeProvider value={colorScheme === "dark" ? DarkTheme : DefaultTheme}>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="(auth)" options={{ headerShown: false }} />{" "}
        {/*  add this */}
        <Stack.Screen
          name="modal"
          options={{ presentation: "modal", title: "Modal" }}
        />
      </Stack>
      <StatusBar style="auto" />
    </ThemeProvider>
  );
}
</file>

<file path="app/(tabs)/chats/(components)/ChatHeader.tsx">
import React, { useMemo } from "react";
import { I18nManager, Pressable, StyleSheet, Text, View } from "react-native";

export type ConnStatus = "connected" | "reconnecting" | "disconnected";

type Props = {
  title: string; // peerName
  onBack: () => void;

  //  NEW (optional)
  onPressTitle?: () => void; // open profile
  onPressAvatar?: () => void; // open profile
  onRequestSession?: () => void; // request session CTA

  // realtime UI
  conn: ConnStatus;
  peerTyping: boolean;
  peerOnline: boolean;
  peerLastSeenIso: string | null;
};

function initials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return (parts[0][0] || "?").toUpperCase();
  return `${parts[0][0] || ""}${
    parts[parts.length - 1][0] || ""
  }`.toUpperCase();
}

function formatLastSeen(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleString(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export default function ChatHeader({
  title,
  onBack,
  onPressTitle,
  onPressAvatar,
  onRequestSession,
  conn,
  peerTyping,
  peerOnline,
  peerLastSeenIso,
}: Props) {
  const isRTL = I18nManager.isRTL;

  const subtitle = useMemo(() => {
    if (peerTyping) return isRTL ? "" : "typing";

    if (conn === "reconnecting")
      return isRTL ? "  " : "reconnecting";
    if (conn !== "connected") return isRTL ? " " : "offline";

    if (peerOnline) return isRTL ? " " : "online";
    if (peerLastSeenIso) {
      const seen = formatLastSeen(peerLastSeenIso);
      return isRTL ? `  ${seen}` : `last seen ${seen}`;
    }
    return isRTL ? " " : "offline";
  }, [conn, peerLastSeenIso, peerOnline, peerTyping, isRTL]);

  const avatar = useMemo(() => initials(title), [title]);

  const dot = useMemo(() => {
    if (peerTyping) return "#FBBF24"; // yellow
    if (conn !== "connected") return "#64748B"; // gray
    if (peerOnline) return "#22C55E"; // green
    return "#64748B";
  }, [conn, peerOnline, peerTyping]);

  const canOpenProfile = !!onPressTitle || !!onPressAvatar;
  const canRequest = !!onRequestSession;

  return (
    <View style={styles.header}>
      <Pressable
        onPress={onBack}
        accessibilityRole="button"
        accessibilityLabel="Back"
        style={({ pressed }) => [
          styles.backBtn,
          pressed ? { opacity: 0.9 } : null,
        ]}
        hitSlop={12}
      >
        <Text style={styles.backText}>{isRTL ? "" : ""}</Text>
      </Pressable>

      <View style={styles.center}>
        <Pressable
          onPress={onPressAvatar}
          disabled={!onPressAvatar}
          accessibilityRole={onPressAvatar ? "button" : undefined}
          accessibilityLabel={onPressAvatar ? "Open profile" : undefined}
          style={({ pressed }) => [
            styles.avatar,
            pressed && onPressAvatar ? { opacity: 0.92 } : null,
          ]}
          hitSlop={10}
        >
          <Text style={styles.avatarText}>{avatar}</Text>
        </Pressable>

        <Pressable
          onPress={onPressTitle}
          disabled={!onPressTitle}
          accessibilityRole={onPressTitle ? "button" : undefined}
          accessibilityLabel={onPressTitle ? "Open profile" : undefined}
          style={({ pressed }) => [
            { flex: 1 },
            pressed && onPressTitle ? { opacity: 0.92 } : null,
          ]}
          hitSlop={10}
        >
          <Text
            style={styles.title}
            numberOfLines={1}
            accessibilityRole="header"
          >
            {title || "Chat"}
          </Text>

          <View style={styles.subRow}>
            <View style={[styles.dot, { backgroundColor: dot }]} />
            <Text style={styles.sub} numberOfLines={1}>
              {subtitle}
            </Text>
          </View>
        </Pressable>
      </View>

      <View style={styles.right}>
        {canRequest ? (
          <Pressable
            onPress={onRequestSession}
            accessibilityRole="button"
            accessibilityLabel="Request session"
            style={({ pressed }) => [
              styles.reqBtn,
              pressed ? { opacity: 0.92 } : null,
            ]}
            hitSlop={10}
          >
            <Text style={styles.reqText}>{isRTL ? " " : "Session"}</Text>
          </Pressable>
        ) : (
          // keep layout stable
          <View style={{ width: 56 }} />
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  header: {
    paddingHorizontal: 12,
    paddingTop: 14,
    paddingBottom: 10,
    flexDirection: "row",
    alignItems: "center",
    borderBottomWidth: 1,
    borderBottomColor: "#0B1120",
    backgroundColor: "#020617",
  },

  backBtn: {
    width: 44,
    height: 40,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  backText: {
    color: "#60A5FA",
    fontWeight: "900",
    fontSize: 18,
    lineHeight: 18,
  },

  center: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    paddingHorizontal: 6,
  },

  avatar: {
    width: 40,
    height: 40,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: {
    color: "#F97316",
    fontWeight: "900",
    fontSize: 14,
  },

  title: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 15,
    maxWidth: 260,
  },

  subRow: {
    marginTop: 3,
    flexDirection: "row",
    alignItems: "center",
    gap: 7,
  },
  dot: {
    width: 8,
    height: 8,
    borderRadius: 999,
  },

  sub: {
    color: "#94A3B8",
    fontWeight: "800",
    fontSize: 11,
  },

  right: {
    width: 70,
    alignItems: "flex-end",
    justifyContent: "center",
  },
  reqBtn: {
    height: 32,
    paddingHorizontal: 12,
    borderRadius: 999,
    backgroundColor: "#111827",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  reqText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },
});
</file>

<file path="app/(tabs)/chats/(components)/MessageBubble.tsx">
import React, { useMemo } from "react";
import { Pressable, StyleSheet, Text, View } from "react-native";
import type { ChatMessage } from "../../../../lib/chat/api";

type Props = {
  item: ChatMessage;
  mine: boolean;
  isLastMine?: boolean;
  lastMineId?: string | null;
  seen?: boolean;
};

function formatTime(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleTimeString(undefined, {
    hour: "2-digit",
    minute: "2-digit",
  });
}

export default function MessageBubble({ item, mine, isLastMine, seen }: Props) {
  const time = useMemo(
    () => formatTime(String((item as any)?.createdAt || "")),
    [item]
  );

  const tickText = useMemo(() => {
    if (!mine) return "";
    //  = sent/delivered (basic)
    //  = seen (only show when this is the last mine)
    if (isLastMine && seen) return "";
    return "";
  }, [isLastMine, mine, seen]);

  return (
    <View style={[styles.row, mine ? styles.rowMine : styles.rowTheirs]}>
      <Pressable
        style={[styles.bubble, mine ? styles.mine : styles.theirs]}
        accessibilityRole="text"
      >
        <Text style={[styles.text, mine ? styles.textMine : styles.textTheirs]}>
          {item.text}
        </Text>

        <View style={styles.metaRow}>
          <Text
            style={[styles.time, mine ? styles.timeMine : styles.timeTheirs]}
          >
            {time}
          </Text>

          {mine ? (
            <Text
              style={[
                styles.tick,
                // make  slightly more visible but keep your palette
                isLastMine && seen ? styles.tickSeen : null,
              ]}
            >
              {tickText}
            </Text>
          ) : null}
        </View>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  row: { width: "100%", marginVertical: 6, flexDirection: "row" },
  rowMine: { justifyContent: "flex-end" },
  rowTheirs: { justifyContent: "flex-start" },

  bubble: {
    maxWidth: "82%",
    borderRadius: 18,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderWidth: 1,
  },

  mine: { backgroundColor: "#F97316", borderColor: "#FB923C" },
  theirs: { backgroundColor: "#0B1120", borderColor: "#111827" },

  text: { fontWeight: "800", fontSize: 14, lineHeight: 20 },
  textMine: { color: "#111827" },
  textTheirs: { color: "#E5E7EB" },

  metaRow: {
    marginTop: 6,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    gap: 6,
  },

  time: { fontSize: 11, fontWeight: "900" },
  tick: { fontSize: 12, fontWeight: "900" },

  timeMine: { color: "rgba(17,24,39,0.75)" },
  timeTheirs: { color: "#94A3B8" },

  tickSeen: {
    // keep same color family but slightly stronger
    color: "rgba(17,24,39,0.9)",
  },
});
</file>

<file path="app/(tabs)/chats/(components)/MessagesList.tsx">
import React, { useCallback, useMemo, useRef } from "react";
import {
  FlatList,
  NativeScrollEvent,
  NativeSyntheticEvent,
  StyleSheet,
  View,
} from "react-native";
import type { ChatMessage } from "../../../../lib/chat/api";
import MessageBubble from "./MessageBubble";
import TopLoadingHint from "./TopLoadingHint";

type UiMessage = ChatMessage & { createdAt: string };

type Props = {
  items: ChatMessage[];
  meId: string;
  paging: boolean;
  hasMore: boolean;
  onLoadOlder: () => Promise<void>;

  //  NEW: timestamp when peer read messages in this conversation
  // passed from ConversationScreen (peerReadAtIso state)
  peerReadAtIso?: string | null;

  //  optional (backward compatible): if you still want to pass id
  seenLastMineId?: string | null;
};

function toTime(iso: string) {
  const d = new Date(iso);
  const t = d.getTime();
  return Number.isNaN(t) ? 0 : t;
}

export default function MessagesList({
  items,
  meId,
  paging,
  hasMore,
  onLoadOlder,
  peerReadAtIso,
  seenLastMineId,
}: Props) {
  const listRef = useRef<FlatList<UiMessage>>(null);
  const loadingOlderRef = useRef(false);

  const data = useMemo(() => {
    const arr = (Array.isArray(items) ? items : []).map((m) => ({
      ...m,
      createdAt:
        typeof (m as any).createdAt === "string"
          ? (m as any).createdAt
          : new Date().toISOString(),
    }));
    arr.sort((a, b) => toTime(b.createdAt) - toTime(a.createdAt)); // newest first for inverted list
    return arr;
  }, [items]);

  //  last outgoing (mine) message (newest mine because list is newest-first)
  const lastMine = useMemo(() => {
    return data.find((m) => String(m.senderId) === String(meId)) || null;
  }, [data, meId]);

  const lastMineId = lastMine?.id || null;

  //  if peerReadAtIso exists, and peerReadAt >= lastMine.createdAt => last mine is seen
  const computedSeenLastMineId = useMemo(() => {
    if (!lastMine) return null;
    if (!peerReadAtIso) return null;

    const readT = toTime(String(peerReadAtIso));
    const msgT = toTime(String(lastMine.createdAt));
    if (!readT || !msgT) return null;

    return readT >= msgT ? String(lastMine.id) : null;
  }, [lastMine, peerReadAtIso]);

  //  final seen id (prefer computed from timestamp; fallback to prop)
  const effectiveSeenLastMineId =
    computedSeenLastMineId || (seenLastMineId ? String(seenLastMineId) : null);

  const keyExtractor = useCallback((m: UiMessage) => m.id, []);

  const renderItem = useCallback(
    ({ item }: { item: UiMessage }) => {
      const mine = String(item.senderId) === String(meId);
      const isLastMine =
        mine && !!lastMineId && String(item.id) === String(lastMineId);

      const seen =
        isLastMine &&
        !!effectiveSeenLastMineId &&
        String(effectiveSeenLastMineId) === String(item.id);

      return (
        <MessageBubble
          item={item}
          mine={mine}
          isLastMine={isLastMine}
          lastMineId={lastMineId}
          seen={seen}
        />
      );
    },
    [effectiveSeenLastMineId, lastMineId, meId]
  );

  const onEndReached = useCallback(async () => {
    if (!hasMore) return;
    if (paging) return;
    if (loadingOlderRef.current) return;

    loadingOlderRef.current = true;
    try {
      await onLoadOlder();
    } finally {
      loadingOlderRef.current = false;
    }
  }, [hasMore, onLoadOlder, paging]);

  const onScroll = useCallback((e: NativeSyntheticEvent<NativeScrollEvent>) => {
    void e;
  }, []);

  return (
    <View style={styles.wrap}>
      <TopLoadingHint visible={paging} />

      <FlatList
        ref={listRef}
        data={data}
        keyExtractor={keyExtractor}
        renderItem={renderItem}
        inverted
        onEndReached={onEndReached}
        onEndReachedThreshold={0.2}
        onScroll={onScroll}
        scrollEventThrottle={16}
        contentContainerStyle={styles.content}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: { flex: 1, backgroundColor: "#020617" },
  content: { paddingHorizontal: 14, paddingTop: 12, paddingBottom: 12 },
});
</file>

<file path="app/(tabs)/chats/[conversationId].tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  Text,
  View,
} from "react-native";

import { getMe } from "../../../lib/api";
import {
  getConversationMessages,
  markConversationReadRest,
  sendMessageRest,
  type ChatMessage,
} from "../../../lib/chat/api";

import {
  connectChatSocket,
  disconnectChatSocket,
  getPresenceSnapshot,
  joinConversationRoom,
  markConversationRead,
  onConnectionStatus,
  onNewMessage,
  onPeerTyping,
  onPresenceUpdate,
  onReadReceipt,
  sendRealtimeMessage,
  unwatchPresence,
  watchPresence,
  type RealtimeMessage,
} from "../../../lib/chat/socket";

import ChatHeader from "./(components)/ChatHeader";
import ChatInput from "./(components)/ChatInput";
import MessagesList from "./(components)/MessagesList";

function toChatMessage(m: RealtimeMessage): ChatMessage {
  return {
    id: m.id,
    conversationId: m.conversationId,
    senderId: m.senderId,
    text: m.text,
    createdAt:
      typeof m.createdAt === "string" ? m.createdAt : new Date().toISOString(),
  };
}

function toTime(s: string) {
  const d = new Date(s);
  const t = d.getTime();
  return Number.isNaN(t) ? 0 : t;
}

export default function ConversationScreen() {
  const router = useRouter();
  const params = useLocalSearchParams<{
    conversationId?: string;
    peerName?: string;
    peerId?: string;
  }>();

  const convId = String(params.conversationId || "").trim();
  const peerName = String(params.peerName || params.peerId || "Chat");
  const peerId = String(params.peerId || "").trim();

  const mountedRef = useRef(true);

  const [meId, setMeId] = useState("");
  const [loading, setLoading] = useState(true);

  const [items, setItems] = useState<ChatMessage[]>([]);
  const [text, setText] = useState("");
  const [sending, setSending] = useState(false);

  const [conn, setConn] = useState<
    "connected" | "reconnecting" | "disconnected"
  >("disconnected");

  const [peerTyping, setPeerTyping] = useState(false);
  const typingTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [peerOnline, setPeerOnline] = useState(false);
  const [peerLastSeenIso, setPeerLastSeenIso] = useState<string | null>(null);

  //  for Seen status
  const [peerReadAtIso, setPeerReadAtIso] = useState<string | null>(null);

  const [paging, setPaging] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const sorted = useMemo(() => {
    return items
      .slice()
      .sort((a, b) => toTime(a.createdAt) - toTime(b.createdAt));
  }, [items]);

  const oldestIso = useMemo(() => {
    if (!sorted.length) return null;
    return sorted[0]?.createdAt || null;
  }, [sorted]);

  const safeMarkRead = useCallback(
    async (token: string) => {
      if (!convId) return;

      // socket event (fast)
      try {
        markConversationRead(convId);
      } catch {}

      // REST (source of truth)
      try {
        await markConversationReadRest(token, convId);
      } catch {}
    },
    [convId]
  );

  const boot = useCallback(async () => {
    if (!convId) {
      router.back();
      return () => {};
    }

    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return () => {};
    }

    setLoading(true);

    const cleanupFns: ((() => void) | undefined)[] = [];

    try {
      const me = await getMe(token);
      if (!mountedRef.current) return () => {};

      const myId = String(me?.user?._id || "");
      setMeId(myId);

      const first = await getConversationMessages(token, convId, { limit: 50 });
      if (!mountedRef.current) return () => {};

      const firstArr = Array.isArray(first?.items) ? first.items : [];
      setItems(firstArr);
      setHasMore(firstArr.length >= 50);

      connectChatSocket(token);
      joinConversationRoom(convId, peerId);

      cleanupFns.push(onConnectionStatus(setConn));

      //  Presence: snapshot + watch realtime
      if (peerId) {
        watchPresence(peerId);

        void (async () => {
          const snap = await getPresenceSnapshot(peerId);
          if (!mountedRef.current) return;
          if (snap && String(snap.userId) === String(peerId)) {
            setPeerOnline(!!snap.online);
            setPeerLastSeenIso(snap.lastSeen ? String(snap.lastSeen) : null);
          }
        })();
      }

      cleanupFns.push(
        onNewMessage((m) => {
          if (String(m.conversationId) !== convId) return;

          const cm = toChatMessage(m);
          setItems((prev) => {
            if (prev.some((x) => x.id === cm.id)) return prev;
            return [...prev, cm];
          });

          // mark read only if message is from peer (not me)
          if (String(cm.senderId) !== String(myId)) {
            void safeMarkRead(token);
          }
        })
      );

      cleanupFns.push(
        onPeerTyping((p) => {
          if (String(p.conversationId) !== convId) return;
          if (String(p.userId) === myId) return;

          setPeerTyping(!!p.isTyping);

          if (typingTimerRef.current) clearTimeout(typingTimerRef.current);
          if (p.isTyping) {
            typingTimerRef.current = setTimeout(() => {
              setPeerTyping(false);
            }, 1400);
          }
        })
      );

      cleanupFns.push(
        onPresenceUpdate((p) => {
          if (!peerId) return;
          if (String(p.userId) !== String(peerId)) return;

          setPeerOnline(!!p.online);
          setPeerLastSeenIso(p.lastSeen ? String(p.lastSeen) : null);
        })
      );

      //  Read receipts
      cleanupFns.push(
        onReadReceipt((p) => {
          if (String(p.conversationId) !== convId) return;

          // receipt from peer means: peer has read my messages
          if (peerId && String(p.readerId) === String(peerId)) {
            setPeerReadAtIso(
              p.readAt ? String(p.readAt) : new Date().toISOString()
            );
          }
        })
      );

      void safeMarkRead(token);

      return () => {
        cleanupFns.forEach((fn) => {
          try {
            fn?.();
          } catch {}
        });
      };
    } finally {
      if (mountedRef.current) setLoading(false);
    }
  }, [convId, peerId, router, safeMarkRead]);

  useEffect(() => {
    mountedRef.current = true;

    let cleanup: (() => void) | null = null;
    (async () => {
      cleanup = await boot();
    })();

    return () => {
      mountedRef.current = false;

      try {
        cleanup?.();
      } catch {}

      try {
        if (typingTimerRef.current) clearTimeout(typingTimerRef.current);
      } catch {}

      try {
        if (peerId) unwatchPresence(peerId);
      } catch {}

      disconnectChatSocket();
    };
  }, [boot, peerId]);

  const loadOlder = useCallback(async () => {
    if (paging || !hasMore || !oldestIso) return;

    const token = await AsyncStorage.getItem("token");
    if (!token) return;

    setPaging(true);
    try {
      const older = await getConversationMessages(token, convId, {
        limit: 50,
        before: oldestIso,
      });

      const arr = Array.isArray(older?.items) ? older.items : [];
      setHasMore(arr.length >= 50);

      setItems((prev) => {
        const existing = new Set(prev.map((x) => x.id));
        const merged = [...arr.filter((x) => !existing.has(x.id)), ...prev];
        return merged;
      });
    } finally {
      if (mountedRef.current) setPaging(false);
    }
  }, [convId, hasMore, oldestIso, paging]);

  const send = useCallback(async () => {
    const clean = String(text || "").trim();
    if (!clean || !convId || sending) return;

    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return;
    }

    setSending(true);
    try {
      const rt = await sendRealtimeMessage(convId, clean);

      if (rt.ok && rt.message) {
        const cm = toChatMessage(rt.message);
        setItems((prev) => {
          if (prev.some((x) => x.id === cm.id)) return prev;
          return [...prev, cm];
        });
        setText("");
        return;
      }

      const m = await sendMessageRest(token, convId, clean);
      setItems((prev) => [...prev, m]);
      setText("");
    } catch {
      // silent
    } finally {
      setSending(false);
    }
  }, [convId, router, sending, text]);

  const openPeerProfile = useCallback(() => {
    if (!peerId) return;
    router.push(`/mentor/${peerId}` as any);
  }, [peerId, router]);

  const requestSessionFromChat = useCallback(() => {
    if (!peerId) return;
    router.push({
      pathname: "/sessions/request" as any,
      params: { mentorId: peerId, mentorName: peerName },
    });
  }, [peerId, peerName, router]);

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator />
        <Text style={{ marginTop: 10, color: "#94A3B8", fontWeight: "800" }}>
          Loading chat
        </Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
      keyboardVerticalOffset={Platform.OS === "ios" ? 90 : 0}
    >
      <ChatHeader
        title={peerName}
        onBack={() => router.back()}
        conn={conn}
        peerTyping={peerTyping}
        peerOnline={peerOnline}
        peerLastSeenIso={peerLastSeenIso}
        //  new actions
        onPressTitle={openPeerProfile}
        onPressAvatar={openPeerProfile}
        onRequestSession={requestSessionFromChat}
      />

      <MessagesList
        items={items}
        meId={meId}
        paging={paging}
        hasMore={hasMore}
        onLoadOlder={loadOlder}
        //  pass read timestamp for Seen UI
        peerReadAtIso={peerReadAtIso}
      />

      <ChatInput
        value={text}
        sending={sending}
        onChange={setText}
        onSend={send}
      />
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/(tabs)/chats/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  FlatList,
  Pressable,
  RefreshControl,
  StyleSheet,
  Text,
  TextInput,
  View,
} from "react-native";
import {
  getChatInbox,
  getInboxCache,
  setInboxCache,
  type ChatInboxItem,
} from "../../../lib/chat/api";
import { connectChatSocket, onNewMessage } from "../../../lib/chat/socket";

function initials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return `${parts[0][0] ?? ""}${
    parts[parts.length - 1][0] ?? ""
  }`.toUpperCase();
}

function timeAgo(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  const diff = Date.now() - d.getTime();
  const sec = Math.floor(diff / 1000);
  if (sec < 60) return "Now";
  const min = Math.floor(sec / 60);
  if (min < 60) return `${min}m`;
  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}h`;
  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}d`;
  return d.toLocaleDateString(undefined, { month: "short", day: "2-digit" });
}

type LoadMode = "load" | "refresh";

export default function ChatsInboxScreen() {
  const router = useRouter();

  const [items, setItems] = useState<ChatInboxItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [query, setQuery] = useState("");
  const [pendingOpenId, setPendingOpenId] = useState<string | null>(null);

  const mountedRef = useRef(true);

  const load = useCallback(
    async (mode: LoadMode) => {
      try {
        setErrorText(null);

        if (mode === "refresh") setRefreshing(true);
        else setLoading(true);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        //     (  load  refresh)
        if (mode === "load") {
          const cached = await getInboxCache();
          if (mountedRef.current && cached?.length) {
            const sortedCached = cached.slice().sort((a, b) => {
              const ta = a.lastMessageAt
                ? new Date(a.lastMessageAt).getTime()
                : 0;
              const tb = b.lastMessageAt
                ? new Date(b.lastMessageAt).getTime()
                : 0;
              return tb - ta;
            });
            setItems(sortedCached);
            setLoading(false);
          }
        }

        const list = await getChatInbox(token);

        if (!mountedRef.current) return;

        const sorted = (Array.isArray(list) ? list : [])
          .slice()
          .sort((a, b) => {
            const ta = a.lastMessageAt
              ? new Date(a.lastMessageAt).getTime()
              : 0;
            const tb = b.lastMessageAt
              ? new Date(b.lastMessageAt).getTime()
              : 0;
            return tb - ta;
          });

        setItems(sorted);
        void setInboxCache(sorted);
      } catch (e: any) {
        if (!mountedRef.current) return;
        setErrorText(e?.message || "Failed to load chats.");
      } finally {
        if (!mountedRef.current) return;
        setLoading(false);
        setRefreshing(false);
      }
    },
    [router]
  );

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;

      // load from cache + fetch
      load("load");

      // realtime inbox updates
      let offMsg: (() => void) | null = null;

      (async () => {
        const token = await AsyncStorage.getItem("token");
        if (!token || !mountedRef.current) return;

        connectChatSocket(token);

        offMsg = onNewMessage((m) => {
          // Move conversation to top + update preview/unread fast
          setItems((prev) => {
            const list = Array.isArray(prev) ? prev.slice() : [];
            const idx = list.findIndex(
              (x) => String(x.id) === String(m.conversationId)
            );

            const nextItem: ChatInboxItem =
              idx >= 0
                ? {
                    ...list[idx],
                    lastMessageText: m.text || list[idx].lastMessageText,
                    lastMessageAt: m.createdAt || list[idx].lastMessageAt,
                    unreadCount: Number(list[idx].unreadCount || 0) + 1,
                  }
                : {
                    id: String(m.conversationId),
                    peer: null,
                    lastMessageText: String(m.text || ""),
                    lastMessageAt: String(
                      m.createdAt || new Date().toISOString()
                    ),
                    updatedAt: null,
                    createdAt: null,
                    unreadCount: 1,
                  };

            if (idx >= 0) list.splice(idx, 1);
            const merged = [nextItem, ...list];

            void setInboxCache(merged);
            return merged;
          });
        });
      })();

      return () => {
        mountedRef.current = false;
        try {
          offMsg?.();
        } catch {}
      };
    }, [load])
  );

  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return items;

    return items.filter((x) => {
      const name = String(x.peer?.fullName || "").toLowerCase();
      const last = String(x.lastMessageText || "").toLowerCase();
      return name.includes(q) || last.includes(q);
    });
  }, [items, query]);

  const empty = useMemo(
    () => !loading && !errorText && filtered.length === 0,
    [loading, errorText, filtered.length]
  );

  const openConversation = useCallback(
    (item: ChatInboxItem) => {
      const id = String(item?.id || "").trim();
      if (!id) return;
      if (pendingOpenId === id) return;

      setPendingOpenId(id);

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: {
          conversationId: id,
          peerName: item.peer?.fullName || "Chat",
          peerId: item.peer?.id || "",
        },
      } as any);

      setTimeout(() => setPendingOpenId(null), 650);
    },
    [pendingOpenId, router]
  );

  const renderItem = useCallback(
    ({ item }: { item: ChatInboxItem }) => {
      const name = item.peer?.fullName || "Unknown user";
      const last = item.lastMessageText?.trim()
        ? item.lastMessageText
        : "Say hi ";
      const ts = item.lastMessageAt ? timeAgo(item.lastMessageAt) : "";
      const unread = Number((item as any)?.unreadCount || 0);
      const disabled = pendingOpenId === item.id;

      return (
        <Pressable
          onPress={() => openConversation(item)}
          disabled={disabled}
          accessibilityRole="button"
          accessibilityLabel={`Open chat with ${name}`}
          accessibilityHint="Opens the conversation"
          style={({ pressed }) => [
            styles.row,
            pressed ? { opacity: 0.92 } : null,
            disabled ? { opacity: 0.65 } : null,
          ]}
          hitSlop={10}
        >
          <View style={styles.avatar} accessibilityLabel={`Avatar: ${name}`}>
            <Text style={styles.avatarText}>{initials(name)}</Text>
          </View>

          <View style={{ flex: 1 }}>
            <View style={styles.topLine}>
              <Text style={styles.name} numberOfLines={1}>
                {name}
              </Text>

              <View style={styles.rightMeta}>
                {!!unread && (
                  <View
                    style={styles.badge}
                    accessibilityLabel={`${unread} unread messages`}
                  >
                    <Text style={styles.badgeText}>
                      {unread > 99 ? "99+" : String(unread)}
                    </Text>
                  </View>
                )}

                {!!ts && <Text style={styles.time}>{ts}</Text>}
              </View>
            </View>

            <Text
              style={[styles.last, unread ? styles.lastUnread : null]}
              numberOfLines={2}
            >
              {last}
            </Text>
          </View>
        </Pressable>
      );
    },
    [openConversation, pendingOpenId]
  );

  const keyExtractor = useCallback((x: ChatInboxItem) => x.id, []);

  return (
    <View style={styles.root}>
      <View style={styles.header}>
        <Text style={styles.title} accessibilityRole="header">
          Chats
        </Text>
        <Text style={styles.subtitle}>Your 1:1 conversations (text only).</Text>

        <View style={styles.searchWrap}>
          <Text style={styles.searchIcon}></Text>
          <TextInput
            value={query}
            onChangeText={setQuery}
            placeholder="Search by name or message"
            placeholderTextColor="#64748B"
            style={styles.searchInput}
            accessibilityLabel="Search chats"
            accessibilityHint="Filters conversations by name or last message"
            returnKeyType="search"
          />
          {!!query.trim() && (
            <Pressable
              onPress={() => setQuery("")}
              accessibilityRole="button"
              accessibilityLabel="Clear search"
              style={({ pressed }) => [
                styles.clearBtn,
                pressed ? { opacity: 0.9 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.clearText}></Text>
            </Pressable>
          )}
        </View>
      </View>

      {loading ? (
        <View style={styles.center}>
          <ActivityIndicator />
          <Text style={styles.muted}>Loading</Text>
        </View>
      ) : errorText ? (
        <View style={{ padding: 16 }}>
          <View style={styles.errCard}>
            <Text style={styles.errTitle}>Couldnt load chats</Text>
            <Text style={styles.errBody}>{errorText}</Text>

            <Pressable
              onPress={() => load("load")}
              accessibilityRole="button"
              accessibilityLabel="Try again"
              style={({ pressed }) => [
                styles.tryBtn,
                pressed ? { opacity: 0.9 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.tryText}>Try again</Text>
            </Pressable>
          </View>
        </View>
      ) : empty ? (
        <View style={{ padding: 16 }}>
          <View style={styles.emptyCard}>
            <Text style={styles.emptyTitle}>
              {query.trim() ? "No results" : "No chats yet"}
            </Text>
            <Text style={styles.emptyBody}>
              {query.trim()
                ? "Try a different search."
                : "Open any mentor profile and press Message."}
            </Text>
          </View>
        </View>
      ) : (
        <FlatList
          data={filtered}
          keyExtractor={keyExtractor}
          renderItem={renderItem}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={() => load("refresh")}
              tintColor="#94A3B8"
            />
          }
          contentContainerStyle={{ padding: 16, paddingBottom: 26 }}
          ItemSeparatorComponent={() => <View style={{ height: 10 }} />}
          keyboardShouldPersistTaps="handled"
          accessibilityLabel="Chats list"
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },

  header: { padding: 16, paddingBottom: 10 },
  title: { color: "#E5E7EB", fontWeight: "900", fontSize: 18 },
  subtitle: { color: "#94A3B8", marginTop: 6, fontSize: 12 },

  searchWrap: {
    marginTop: 12,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  searchIcon: { color: "#64748B", fontWeight: "900" },
  searchInput: { flex: 1, color: "#E5E7EB", fontWeight: "700" },
  clearBtn: {
    width: 28,
    height: 28,
    borderRadius: 999,
    backgroundColor: "#111827",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  clearText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 16,
    lineHeight: 18,
  },

  center: { flex: 1, alignItems: "center", justifyContent: "center" },
  muted: { color: "#94A3B8", marginTop: 10, fontWeight: "800" },

  errCard: {
    backgroundColor: "#451A1A",
    borderColor: "#FCA5A5",
    borderWidth: 1,
    borderRadius: 14,
    padding: 12,
  },
  errTitle: { color: "#FECACA", fontWeight: "900" },
  errBody: { color: "#FECACA", marginTop: 6 },

  tryBtn: {
    alignSelf: "flex-start",
    marginTop: 10,
    backgroundColor: "#B91C1C",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  tryText: { color: "#FEE2E2", fontWeight: "900" },

  emptyCard: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 14,
  },
  emptyTitle: { color: "#E5E7EB", fontWeight: "900" },
  emptyBody: { color: "#94A3B8", marginTop: 6 },

  row: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    minHeight: 66,
  },

  avatar: {
    width: 44,
    height: 44,
    borderRadius: 999,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: { color: "#F97316", fontWeight: "900", fontSize: 16 },

  topLine: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 10,
  },
  name: { color: "#E5E7EB", fontWeight: "900", maxWidth: 220 },

  rightMeta: { flexDirection: "row", alignItems: "center", gap: 8 },

  time: {
    color: "#64748B",
    fontSize: 11,
    fontWeight: "800",
    writingDirection: "ltr",
  },

  badge: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
    paddingHorizontal: 8,
    height: 20,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  badgeText: { color: "#111827", fontWeight: "900", fontSize: 11 },

  last: { color: "#94A3B8", marginTop: 6 },
  lastUnread: { color: "#E5E7EB", fontWeight: "900" },
});
</file>

<file path="app/(tabs)/explore.tsx">
import React from "react";
import { StyleSheet, Text, View } from "react-native";

export default function ExploreScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Explore</Text>
      <Text style={styles.subtitle}>Coming soon...</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#0f172a",
  },
  title: {
    fontSize: 28,
    fontWeight: "bold",
    color: "#e5e7eb",
  },
  subtitle: {
    marginTop: 8,
    fontSize: 16,
    color: "#9ca3af",
  },
});
</file>

<file path="app/index.tsx">
import { Redirect } from "expo-router";

export default function Page() {
  return <Redirect href="/(tabs)" />;
}
</file>

<file path="app/mentor/[id].tsx">
// app/mentor/[id].tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import { getOrCreateConversation } from "../../lib/chat/api";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import {
  AvailabilitySlot,
  PublicUserProfile,
  SkillTeach,
  getPublicUserProfile,
} from "../../lib/api";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = String(name).trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function ratingText(avg?: number, count?: number) {
  const a = typeof avg === "number" ? avg : 0;
  const c = typeof count === "number" ? count : 0;
  if (c <= 0) return "No ratings yet";
  return `${a.toFixed(1)}/5  ${c} rating${c === 1 ? "" : "s"}`;
}

function safeArrayStrings(v: any): string[] {
  if (!Array.isArray(v)) return [];
  return v.map((x) => String(x || "").trim()).filter(Boolean);
}

type MentorVM = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

function toMentorVM(p: PublicUserProfile): MentorVM {
  return {
    id: String(p.id),
    fullName: p.fullName || "Unknown",
    points: Number(p.points || 0),
    xp: Number(p.xp || 0),
    streak: Number(p.streak || 0),
    avgRating: Number(p.avgRating || 0),
    ratingCount: Number(p.ratingCount || 0),
    skillsToTeach: Array.isArray(p.skillsToTeach)
      ? p.skillsToTeach
          .filter((s) => s && s.name)
          .map((s) => ({
            name: String(s.name).trim(),
            level: String(s.level || "Not specified").trim() || "Not specified",
          }))
      : [],
    availabilitySlots: Array.isArray(p.availabilitySlots)
      ? p.availabilitySlots
          .filter(
            (a) =>
              a &&
              typeof a.dayOfWeek === "number" &&
              a.dayOfWeek >= 0 &&
              a.dayOfWeek <= 6 &&
              a.from &&
              a.to
          )
          .map((a) => ({
            dayOfWeek: Number(a.dayOfWeek),
            from: String(a.from),
            to: String(a.to),
          }))
      : [],
    preferences: p.preferences,
  };
}

export default function MentorProfileScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();

  const mentorIdRaw = params?.id;
  const mentorId =
    typeof mentorIdRaw === "string"
      ? mentorIdRaw
      : Array.isArray(mentorIdRaw)
      ? mentorIdRaw[0]
      : "";

  const [mentor, setMentor] = useState<MentorVM | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorText, setErrorText] = useState<string | null>(null);
  const [reloadKey, setReloadKey] = useState(0);

  const loadMentor = useCallback(async () => {
    try {
      setErrorText(null);
      setLoading(true);

      if (!mentorId) {
        setErrorText("Invalid mentor id.");
        return;
      }

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const profile = await getPublicUserProfile(token, mentorId);
      setMentor(toMentorVM(profile));
    } catch (e: any) {
      setErrorText(e?.message || "Failed to load mentor profile.");
    } finally {
      setLoading(false);
    }
  }, [mentorId, router]);

  useEffect(() => {
    loadMentor();
  }, [loadMentor, reloadKey]);

  const skills = useMemo(
    () => mentor?.skillsToTeach ?? [],
    [mentor?.skillsToTeach]
  );

  const slots = useMemo(
    () =>
      (mentor?.availabilitySlots ?? [])
        .slice()
        .sort((a, b) => a.dayOfWeek - b.dayOfWeek),
    [mentor?.availabilitySlots]
  );

  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);

  const bestDay = useMemo(() => {
    if (!slots.length) return null;
    const minutesByDay = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;
      minutesByDay[d] += Math.max(
        0,
        timeToMinutes(s.to) - timeToMinutes(s.from)
      );
    }

    let bestIdx = -1;
    let bestMin = 0;
    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }
    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]}  ${minutesToHuman(bestMin)}`;
  }, [slots]);

  const languages = safeArrayStrings(mentor?.preferences?.languages);
  const commModes = safeArrayStrings(mentor?.preferences?.communicationModes);

  const goBack = () => router.back();

  const handleRequestSession = () => {
    if (!mentor) return;

    router.push({
      pathname: "/sessions/request",
      params: {
        mentorId: mentor.id,
        mentorName: mentor.fullName,
      },
    } as any);
  };

  const handleMessage = async () => {
    try {
      if (!mentor?.id) return;

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const conversationId = await getOrCreateConversation(token, mentor.id);

      //     
      if (!conversationId || typeof conversationId !== "string") {
        console.warn("Invalid conversationId, aborting chat open");
        return;
      }

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: { conversationId },
      });
    } catch (e: any) {
      console.warn("Open chat failed:", e?.message || e);
    }
  };

  if (loading && !mentor && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading mentor profile</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView style={{ flex: 1 }} contentContainerStyle={styles.container}>
        <View style={styles.topRow}>
          <TouchableOpacity onPress={goBack} activeOpacity={0.85}>
            <Text style={styles.backText}> Back</Text>
          </TouchableOpacity>

          <View style={styles.idBadge}>
            <Text style={styles.idBadgeText}>Mentor</Text>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldnt load profile</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryBtn}
              onPress={() => setReloadKey((k) => k + 1)}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={styles.heroCard}>
          <View style={styles.heroRow}>
            <View style={styles.avatar}>
              <Text style={styles.avatarText}>
                {getInitials(mentor?.fullName)}
              </Text>
            </View>

            <View style={{ flex: 1 }}>
              <Text style={styles.heroName}>
                {mentor?.fullName || "Unknown mentor"}
              </Text>
              <Text style={styles.heroMeta}>
                 {ratingText(mentor?.avgRating, mentor?.ratingCount)}
              </Text>

              <View style={styles.badgesRow}>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>XP</Text>
                  <Text style={styles.badgeValue}>{mentor?.xp ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Points</Text>
                  <Text style={styles.badgeValue}>{mentor?.points ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Streak</Text>
                  <Text style={styles.badgeValue}>{mentor?.streak ?? 0}</Text>
                </View>
              </View>
            </View>
          </View>

          <View style={styles.ctaRow}>
            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaPrimary]}
              onPress={handleRequestSession}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaPrimaryText}>Request session</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaSecondary]}
              onPress={handleMessage}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaSecondaryText}>Message</Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.ctaNote}>
            (Next step: well connect these buttons to Sessions + Chat)
          </Text>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>What this mentor teaches</Text>
          <Text style={styles.sectionSub}>
            Skills list (clean & fast)  ready for future filters.
          </Text>

          {skills.length ? (
            <View style={styles.skillsWrap}>
              {skills.map((s, idx) => (
                <View key={`${s.name}-${idx}`} style={styles.skillChip}>
                  <Text style={styles.skillChipText}>
                    {s.name}
                    {s.level && s.level !== "Not specified"
                      ? `  ${s.level}`
                      : ""}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No teaching skills listed</Text>
              <Text style={styles.emptyText}>
                This mentor hasnt added teaching skills yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Availability</Text>
          <Text style={styles.sectionSub}>
            Total:{" "}
            <Text style={styles.sectionSubStrong}>
              {minutesToHuman(totalMin)}
            </Text>
            {bestDay ? (
              <>
                {"  "} Best:{" "}
                <Text style={styles.sectionSubStrong}>{bestDay}</Text>
              </>
            ) : null}
          </Text>

          {slots.length ? (
            <View style={styles.availCard}>
              {slots.map((a, idx) => (
                <View
                  key={`${a.dayOfWeek}-${a.from}-${a.to}-${idx}`}
                  style={[
                    styles.availRow,
                    idx !== slots.length - 1 && styles.availRowBorder,
                  ]}
                >
                  <Text style={styles.availDay}>
                    {dayNames[a.dayOfWeek] ?? `Day ${a.dayOfWeek}`}
                  </Text>
                  <Text style={styles.availTime}>
                    {a.from}  {a.to}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No availability set</Text>
              <Text style={styles.emptyText}>
                This mentor didnt add weekly availability yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Preferences</Text>

          <View style={styles.prefGrid}>
            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Languages</Text>
              <Text style={styles.prefValue}>
                {languages.length ? languages.join(", ") : "Not specified"}
              </Text>
            </View>

            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Communication</Text>
              <Text style={styles.prefValue}>
                {commModes.length ? commModes.join(", ") : "Not specified"}
              </Text>
            </View>
          </View>
        </View>

        <View style={styles.footer}>
          <Text style={styles.footerHint}>
            Youre viewing a mentor profile (not yours) 
          </Text>
          <TouchableOpacity
            onPress={goBack}
            style={styles.footerBtn}
            activeOpacity={0.85}
          >
            <Text style={styles.footerBtnText}>Back to results</Text>
          </TouchableOpacity>
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  container: { paddingHorizontal: 16, paddingTop: 16, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 10, color: "#9CA3AF", fontSize: 14 },

  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  backText: { fontSize: 14, color: "#60A5FA" },
  idBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0B1120",
  },
  idBadgeText: { color: "#CBD5F5", fontSize: 12, fontWeight: "600" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 12,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 10 },
  retryBtn: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "600" },

  heroCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  heroRow: { flexDirection: "row", alignItems: "center" },

  avatar: {
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 12,
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "800" },

  heroName: { color: "#F9FAFB", fontSize: 20, fontWeight: "800" },
  heroMeta: { color: "#9CA3AF", fontSize: 12, marginTop: 4 },

  badgesRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  badge: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    paddingVertical: 10,
    paddingHorizontal: 10,
    borderWidth: 1,
    borderColor: "#111827",
  },
  badgeLabel: { color: "#94A3B8", fontSize: 11 },
  badgeValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "800",
    marginTop: 4,
  },

  ctaRow: { flexDirection: "row", gap: 10, marginTop: 12 },
  ctaBtn: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
  },
  ctaPrimary: { backgroundColor: "#F97316" },
  ctaPrimaryText: { color: "#ffffff", fontWeight: "800", fontSize: 13 },
  ctaSecondary: {
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  ctaSecondaryText: { color: "#E5E7EB", fontWeight: "700", fontSize: 13 },
  ctaNote: { marginTop: 10, color: "#64748B", fontSize: 11 },

  section: { marginBottom: 18 },
  sectionTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "700",
    marginBottom: 4,
  },
  sectionSub: { color: "#94A3B8", fontSize: 12, marginBottom: 10 },
  sectionSubStrong: { color: "#E5E7EB", fontWeight: "800" },

  skillsWrap: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  skillChipText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  availCard: {
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    overflow: "hidden",
  },
  availRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  availRowBorder: { borderBottomWidth: 1, borderBottomColor: "#0B1120" },
  availDay: { color: "#E5E7EB", fontSize: 13, fontWeight: "700" },
  availTime: { color: "#9CA3AF", fontSize: 13, fontWeight: "600" },

  prefGrid: { flexDirection: "row", gap: 10 },
  prefBox: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  prefLabel: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "700",
    marginBottom: 4,
  },
  prefValue: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "800",
    marginBottom: 4,
  },
  emptyText: { color: "#64748B", fontSize: 12 },

  footer: { marginTop: 6 },
  footerHint: { color: "#64748B", fontSize: 11, marginBottom: 10 },
  footerBtn: {
    borderRadius: 999,
    paddingVertical: 11,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  footerBtnText: { color: "#E5E7EB", fontSize: 12, fontWeight: "700" },
});
</file>

<file path="app/sessions/index.tsx">
import SessionsScreen from "./screens/SessionsScreen";

export default SessionsScreen;
</file>

<file path="app/sessions/request.tsx">
// app/sessions/request.tsx
import RequestSessionScreen from "./screens/request/RequestSessionScreen";

export default function Request() {
  return <RequestSessionScreen />;
}
</file>

<file path="app/sessions/screens/(components)/SessionsRowRenderer.tsx">
// app/sessions/screens/(components)/SessionsRowRenderer.tsx
import React, { useCallback, useRef } from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";

import type { SessionDTO } from "../../api/sessionsApi";
import SessionCard from "../../components/SessionCard";
import type { Row } from "./SessionsRows";

type Props = {
  token: string | null;
  currentUserId: string | null;
  onChanged: () => Promise<void> | void;

  //  NEW
  onDeletedLocal?: (sessionId: string) => void;
};

function pluralize(n: number, one: string, many: string) {
  return n === 1 ? one : many;
}

export function useRowRenderer({
  token,
  currentUserId,
  onChanged,
  onDeletedLocal,
}: Props) {
  const safeOnChanged = useCallback(async () => {
    try {
      await onChanged?.();
    } catch {
      /* ignore */
    }
  }, [onChanged]);

  //  double-tap guard (  )
  const lastTapRef = useRef<{ id: string; at: number } | null>(null);
  const canTap = useCallback((id: string) => {
    const now = Date.now();
    const prev = lastTapRef.current;
    if (prev && prev.id === id && now - prev.at < 550) return false;
    lastTapRef.current = { id, at: now };
    return true;
  }, []);

  return useCallback(
    ({ item }: { item: Row }) => {
      if (item.type === "header") {
        const n = Number(item.count || 0);
        return (
          <View
            style={{ paddingHorizontal: 16, paddingTop: 6, paddingBottom: 8 }}
          >
            <View
              style={{
                flexDirection: "row",
                justifyContent: "space-between",
                alignItems: "center",
              }}
            >
              <Text style={{ color: "#CBD5E1", fontWeight: "900" }}>
                {item.title}
              </Text>

              <Text
                style={{ color: "#64748B", fontWeight: "900", fontSize: 12 }}
              >
                {n} {pluralize(n, "session", "sessions")}
              </Text>
            </View>
          </View>
        );
      }

      const s = item.session as SessionDTO;
      const sid = String(
        (s as any)?._id || (s as any)?.id || item.key || ""
      ).trim();

      return (
        <View style={{ paddingHorizontal: 16, paddingBottom: 10 }}>
          <Pressable
            onPress={() => {
              if (!sid) return;
              canTap(sid);
            }}
            style={({ pressed }) => [
              { borderRadius: 16 },
              pressed ? { opacity: 0.98 } : null,
            ]}
          >
            <SessionCard
              session={s}
              token={token}
              currentUserId={currentUserId}
              onChanged={safeOnChanged}
              //  NEW (SessionCard    )
              onDeletedLocal={onDeletedLocal}
            />
          </Pressable>
        </View>
      );
    },
    [token, currentUserId, safeOnChanged, canTap, onDeletedLocal]
  );
}

export function UpdatingMiniBadge() {
  return (
    <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
      <ActivityIndicator />
      <Text style={{ color: "#94A3B8", fontWeight: "900" }}>Updating</Text>
    </View>
  );
}
</file>

<file path="app/sessions/screens/(hooks)/useSessionsData.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import { getMe } from "../../../../lib/api";
import { listMySessions, type SessionDTO } from "../../api/sessionsApi";

export type Scope = "upcoming" | "past" | "all";

type LoadOpts = {
  silent?: boolean; //   loading 
  listOnly?: boolean; //  loadingList  loading
  force?: boolean; //    fetch 
};

function cacheKey(scope: Scope, userId?: string | null) {
  //  FIX: make cache per-user to avoid showing previous account sessions
  const uid = (userId || "anon").trim() || "anon";
  return `sessions_cache_v1:${uid}:${scope}`;
}

function safeJsonParse<T>(txt: string | null): T | null {
  if (!txt) return null;
  try {
    return JSON.parse(txt) as T;
  } catch {
    return null;
  }
}

function sortSessions(list: SessionDTO[]) {
  //   ( scheduledAt) 
  return list
    .slice()
    .sort(
      (a, b) =>
        new Date(b.scheduledAt).getTime() - new Date(a.scheduledAt).getTime()
    );
}
function pickUserId(me: any): string | null {
  const candidates = [
    me?.id,
    me?._id,
    me?.user?.id,
    me?.user?._id,
    me?.data?.id,
    me?.data?._id,
    me?.profile?.id,
    me?.profile?._id,
    me?.userId,
  ]
    .map((x) => String(x || "").trim())
    .filter(Boolean);

  return candidates[0] || null;
}

function decodeJwtUserId(token: string): string | null {
  try {
    const parts = token.split(".");
    if (parts.length < 2) return null;

    // base64url -> base64
    const b64 = parts[1].replace(/-/g, "+").replace(/_/g, "/");
    const pad = "=".repeat((4 - (b64.length % 4)) % 4);
    const json = Buffer.from(b64 + pad, "base64").toString("utf8");
    const payload = JSON.parse(json);

    const id =
      payload?.id || payload?._id || payload?.userId || payload?.sub || null;

    const out = String(id || "").trim();
    return out || null;
  } catch {
    return null;
  }
}

export function useSessionsData(scope: Scope) {
  const router = useRouter();

  const mountedRef = useRef(true);
  const tokenRef = useRef<string | null>(null);
  const meIdRef = useRef<string | null>(null);
  const didMountRef = useRef(false);

  //  race conditions
  const reqSeqRef = useRef(0);

  const [token, setToken] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  const [sessions, setSessions] = useState<SessionDTO[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingList, setLoadingList] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  //         scope
  const shownCacheForScopeRef = useRef<Record<string, boolean>>({});

  const ensureToken = useCallback(async () => {
    if (tokenRef.current) return tokenRef.current;

    const t = await AsyncStorage.getItem("token");
    console.log("[sessions] token =", t);

    tokenRef.current = t;

    if (mountedRef.current) setToken(t);

    return t;
  }, []);
const ensureMe = useCallback(async () => {
  if (meIdRef.current) return meIdRef.current;

  const t = await ensureToken();
  if (!t) return null;

  const me = await getMe(t);

  //  1)    response   
  let id = pickUserId(me);

  //  2) fallback:   
  if (!id) id = decodeJwtUserId(t);

  meIdRef.current = id;
  if (mountedRef.current) setCurrentUserId(id);

  return id;
}, [ensureToken]);


  const showCacheIfAvailable = useCallback(
    async (scopeToUse: Scope, userId?: string | null) => {
      const key = cacheKey(scopeToUse, userId);

      //        
      if (shownCacheForScopeRef.current[key]) return;

      const cachedRaw = await AsyncStorage.getItem(key);
      const cached =
        safeJsonParse<{ ts: number; items: SessionDTO[] }>(cachedRaw);

      if (cached?.items?.length && mountedRef.current) {
        setSessions(sortSessions(cached.items));
      }

      shownCacheForScopeRef.current[key] = true;
    },
    []
  );

  const writeCache = useCallback(
    async (scopeToUse: Scope, userId: string | null, list: SessionDTO[]) => {
      const key = cacheKey(scopeToUse, userId);
      const payload = { ts: Date.now(), items: list };
      try {
        await AsyncStorage.setItem(key, JSON.stringify(payload));
      } catch {
        // ignore
      }
    },
    []
  );

  const load = useCallback(
    async (opts?: LoadOpts) => {
      const seq = ++reqSeqRef.current;

      const silent = !!opts?.silent;
      const listOnly = !!opts?.listOnly;
      const force = !!opts?.force;

      if (!silent) {
        if (listOnly) setLoadingList(true);
        else setLoading(true);
      }
      setErrorText(null);

      try {
        const t = await ensureToken();
        if (!t) {
          // user not logged in -> go to login
          if (mountedRef.current) router.replace("/auth/login" as any);
          return;
        }

        const meId = await ensureMe();

        // show cache quickly (unless force)
        if (!force) {
          await showCacheIfAvailable(scope, meId);
        }

const items = await listMySessions(t);
        const sorted = sortSessions(items);

        // ignore older requests
        if (reqSeqRef.current !== seq) return;

        if (mountedRef.current) {
          setSessions(sorted);
        }

        if (meId) {
          await writeCache(scope, meId, sorted);
        }
      } catch (e: any) {
        if (reqSeqRef.current !== seq) return;

        const msg = e?.message || "Failed to load sessions";
        if (mountedRef.current) setErrorText(msg);
      } finally {
        if (!silent) {
          if (listOnly) setLoadingList(false);
          else setLoading(false);
        }
        setRefreshing(false);
      }
    },
    [ensureMe, ensureToken, router, scope, showCacheIfAvailable, writeCache]
  );

  const refresh = useCallback(async () => {
    setRefreshing(true);
    await load({ silent: true, force: true });
  }, [load]);

  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  useEffect(() => {
    if (didMountRef.current) {
      load({ listOnly: true });
      return;
    }
    didMountRef.current = true;
    load();
  }, [load]);

  const hasAny = useMemo(() => sessions.length > 0, [sessions.length]);

  return {
    token,
    currentUserId,
    sessions,
    loading,
    loadingList,
    refreshing,
    errorText,
    load,
    refresh,
    hasAny,
  };
}
</file>

<file path="app/weekly-availability/components.tsx">
// app/weekly-availability/components.tsx
import React, { useMemo } from "react";
import { Text, TouchableOpacity, View } from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { styles } from "./styles";

type DaySelectorProps = {
  selectedDay: number;
  onSelect: (dayIndex: number) => void;
  onLongPressDay?: (dayIndex: number) => void;
  dayNames: string[]; // ["Sun".."Sat"]
  todayIndex: number;
};

export const DaySelector: React.FC<DaySelectorProps> = ({
  selectedDay,
  onSelect,
  onLongPressDay,
  dayNames,
  todayIndex,
}) => {
  return (
    <View style={styles.daySelectorRow}>
      {dayNames.map((d, idx) => {
        const isSelected = idx === selectedDay;
        const isToday = idx === todayIndex;

        return (
          <TouchableOpacity
            key={`${d}-${idx}`}
            style={[
              styles.dayChip,
              isToday && styles.dayChipToday,
              isSelected && styles.dayChipSelected,
            ]}
            onPress={() => onSelect(idx)}
            onLongPress={() => onLongPressDay?.(idx)}
            delayLongPress={250}
            activeOpacity={0.85}
            accessibilityRole="button"
            accessibilityLabel={`Select ${d}`}
          >
            <Text
              style={[
                styles.dayChipText,
                isToday && styles.dayChipTextToday,
                isSelected && styles.dayChipTextSelected,
              ]}
            >
              {d}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

// ====================== Day Card ======================

type DayAvailabilityCardProps = {
  dayIndex: number;
  dayLabel: string;
  slots: AvailabilitySlot[];
  totalMinutesForDay: number;

  collapsed: boolean;
  onToggleCollapsed: (dayIndex: number) => void;

  onRemoveSlot: (slot: AvailabilitySlot) => void;
  onEditSlot: (slot: AvailabilitySlot) => void;
  onClearDay: (dayIndex: number) => void;

  onCopyDay: (dayIndex: number) => void;

  onQuickAdd?: (dayIndex: number, from: string, to: string) => void;

  highlightSlotKey?: string | null; // `${from}-${to}`
};

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export const DayAvailabilityCard: React.FC<DayAvailabilityCardProps> = ({
  dayIndex,
  dayLabel,
  slots,
  totalMinutesForDay,
  collapsed,
  onToggleCollapsed,
  onRemoveSlot,
  onEditSlot,
  onClearDay,
  onCopyDay,
  onQuickAdd,
  highlightSlotKey,
}) => {
  const dayHasSlots = slots.length > 0;

  const daySub = useMemo(() => {
    if (!dayHasSlots) return "No slots yet";
    return `${slots.length} slot${
      slots.length === 1 ? "" : "s"
    }  ${minutesToHuman(totalMinutesForDay)}`;
  }, [dayHasSlots, slots.length, totalMinutesForDay]);

  const showQuickForEmpty = !dayHasSlots;

  return (
    <View style={styles.dayCard}>
      {/* Header */}
      <View style={styles.dayHeaderRow}>
        <TouchableOpacity
          onPress={() => onToggleCollapsed(dayIndex)}
          activeOpacity={0.85}
          style={{ flex: 1 }}
          accessibilityRole="button"
          accessibilityLabel={`Toggle ${dayLabel}`}
        >
          <Text style={styles.dayName}>
            {dayLabel}{" "}
            <Text style={{ color: "#64748B", fontSize: 12, fontWeight: "900" }}>
              {collapsed ? "" : ""}
            </Text>
          </Text>
          <Text style={styles.daySubText}>{daySub}</Text>
        </TouchableOpacity>

        <View style={styles.dayHeaderActions}>
          {dayHasSlots ? (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          ) : (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          )}
        </View>
      </View>

      {/* Body */}
      {collapsed ? (
        <Text style={styles.daySlotsEmptyText}>
          {dayHasSlots ? "Collapsed" : "Collapsed (empty)"}
        </Text>
      ) : (
        <>
          {/* Empty state quick actions */}
          {showQuickForEmpty && onQuickAdd && (
            <View style={{ marginTop: 6 }}>
              <Text style={styles.daySlotsEmptyText}>
                Add something quick to get started:
              </Text>

              <View style={styles.quickRow}>
                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "18:00", "20:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>18:0020:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "20:00", "22:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>20:0022:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "10:00", "14:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>10:0014:00</Text>
                </TouchableOpacity>
              </View>
            </View>
          )}

          {/* Slots */}
          {dayHasSlots ? (
            <View style={[styles.slotChipRow, { marginTop: 10 }]}>
              {slots.map((slot, idx) => {
                const key = `${slot.from}-${slot.to}`;
                const isHighlight = highlightSlotKey === key;

                return (
                  <TouchableOpacity
                    key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                    style={[
                      styles.slotChip,
                      isHighlight && {
                        borderColor: "#60A5FA",
                        backgroundColor: "#0B1120",
                      },
                    ]}
                    onPress={() => onEditSlot(slot)}
                    activeOpacity={0.85}
                    accessibilityRole="button"
                    accessibilityLabel={`Edit ${slot.from} to ${slot.to}`}
                  >
                    <Text style={styles.slotChipText}>
                      {slot.from}  {slot.to}
                    </Text>

                    <TouchableOpacity
                      onPress={() => onRemoveSlot(slot)}
                      activeOpacity={0.85}
                      accessibilityRole="button"
                      accessibilityLabel={`Remove ${slot.from} to ${slot.to}`}
                    >
                      <Text style={styles.slotRemoveText}>Remove</Text>
                    </TouchableOpacity>
                  </TouchableOpacity>
                );
              })}
            </View>
          ) : (
            !onQuickAdd && (
              <Text style={[styles.daySlotsEmptyText, { marginTop: 6 }]}>
                No slots.
              </Text>
            )
          )}
        </>
      )}
    </View>
  );
};

// ====================== SaveBar ======================

type SaveBarProps = {
  hasChanges: boolean;
  saving: boolean;
  onSave: () => void;
  onDiscard: () => void;
};

export const SaveBar: React.FC<SaveBarProps> = ({
  hasChanges,
  saving,
  onSave,
  onDiscard,
}) => {
  if (!hasChanges) return null;

  return (
    <View style={styles.saveBarSticky}>
      <View style={styles.saveRow}>
        <Text style={styles.saveHint}>
          You have unsaved changes. Save to update your profile.
        </Text>

        <TouchableOpacity
          style={styles.discardButton}
          onPress={onDiscard}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.discardText}>Discard</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.saveButton, saving && styles.saveButtonDisabled]}
          onPress={onSave}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.saveText}>{saving ? "Saving" : "Save"}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};
</file>

<file path="app/weekly-availability/index.tsx">
// app/weekly-availability/index.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  ScrollView,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { getMe, updateProfile } from "../../lib/api";
import {
  getPendingWeeklyAvailability,
  getWeeklyLastSavedAt,
  markWeeklyAvailabilitySynced,
  setPendingWeeklyAvailability,
  clearPendingWeeklyAvailability,
} from "../../lib/availabilityStorage";
import SaveBar from "./SaveBar";
import TimeField from "./TimeField";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function isValidSlot(s: AvailabilitySlot) {
  return timeToMinutes(s.to) > timeToMinutes(s.from);
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  const diff = Date.now() - ts;
  if (diff < 60_000) return "Just now";
  if (diff < 60 * 60_000) return `${Math.floor(diff / 60_000)}m ago`;
  if (diff < 24 * 60 * 60_000) return `${Math.floor(diff / (60 * 60_000))}h ago`;
  return new Date(ts).toLocaleDateString();
}

function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  // clean + sort for stable comparisons
  const clean = (Array.isArray(slots) ? slots : [])
    .map((s) => ({
      dayOfWeek: Number((s as any)?.dayOfWeek ?? 0),
      from: String((s as any)?.from ?? "18:00"),
      to: String((s as any)?.to ?? "19:00"),
    }))
    .filter((s) => s.dayOfWeek >= 0 && s.dayOfWeek <= 6);

  clean.sort((a, b) => a.dayOfWeek - b.dayOfWeek || timeToMinutes(a.from) - timeToMinutes(b.from));
  return clean;
}

function slotsEqual(a: AvailabilitySlot[], b: AvailabilitySlot[]) {
  const A = normalizeSlots(a);
  const B = normalizeSlots(b);
  if (A.length !== B.length) return false;
  for (let i = 0; i < A.length; i++) {
    if (A[i].dayOfWeek !== B[i].dayOfWeek) return false;
    if (A[i].from !== B[i].from) return false;
    if (A[i].to !== B[i].to) return false;
  }
  return true;
}

export default function WeeklyAvailabilityScreen() {
  const router = useRouter();
  const mountedRef = useRef(true);

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  const [selectedDay, setSelectedDay] = useState<number>(0);

  const [serverSlots, setServerSlots] = useState<AvailabilitySlot[]>([]);
  const [draftSlots, setDraftSlots] = useState<AvailabilitySlot[]>([]);

  const [restorePrompt, setRestorePrompt] = useState<null | {
    updatedAtISO: string;
    slots: AvailabilitySlot[];
  }>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  const lastSavedText = useMemo(() => formatLastUpdated(lastSavedAt), [lastSavedAt]);

  const dirty = useMemo(() => !slotsEqual(serverSlots, draftSlots), [serverSlots, draftSlots]);

  const daySlots = useMemo(
    () => draftSlots.filter((s) => Number(s.dayOfWeek) === Number(selectedDay)),
    [draftSlots, selectedDay]
  );

  useEffect(() => {
    mountedRef.current = true;

    (async () => {
      try {
        setLoading(true);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const [me, pending, ts] = await Promise.all([
          getMe(token),
          getPendingWeeklyAvailability(),
          getWeeklyLastSavedAt(),
        ]);

        const userFromApi: any = (me as any)?.user ?? me;
        const slotsFromApi = normalizeSlots(userFromApi?.availabilitySlots ?? []);

        if (!mountedRef.current) return;

        setServerSlots(slotsFromApi);
        setDraftSlots(slotsFromApi);
        setLastSavedAt(ts);

        if (pending?.slots?.length) {
          const pendingSlots = normalizeSlots(pending.slots);
          // show restore only if it differs from server
          if (!slotsEqual(pendingSlots, slotsFromApi)) {
            setRestorePrompt({
              updatedAtISO: pending.updatedAtISO,
              slots: pendingSlots,
            });
          } else {
            // pending same as server -> cleanup
            await clearPendingWeeklyAvailability();
          }
        }
      } catch (e: any) {
        console.log("weekly availability load error:", e);
        Alert.alert(
          "Couldnt load availability",
          e?.message || "Please try again."
        );
      } finally {
        if (mountedRef.current) setLoading(false);
      }
    })();

    return () => {
      mountedRef.current = false;
    };
  }, [router]);

  // Auto store pending draft when user changes (simple, safe)
  useEffect(() => {
    if (loading) return;
    if (!dirty) return;
    setPendingWeeklyAvailability(draftSlots, "user-edit");
  }, [draftSlots, dirty, loading]);

  const addSlot = () => {
    setDraftSlots((prev) =>
      normalizeSlots([
        ...prev,
        { dayOfWeek: selectedDay, from: "18:00", to: "19:00" },
      ])
    );
  };

  const updateSlot = (idxInDay: number, patch: Partial<AvailabilitySlot>) => {
    // map daySlots index to actual index in draftSlots
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.map((s) => {
        if (
          Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
          s.from === target.from &&
          s.to === target.to
        ) {
          return { ...s, ...patch };
        }
        return s;
      });
      return normalizeSlots(next);
    });
  };

  const removeSlot = (idxInDay: number) => {
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.filter(
        (s) =>
          !(
            Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
            s.from === target.from &&
            s.to === target.to
          )
      );
      return normalizeSlots(next);
    });
  };

  const restorePending = async () => {
    if (!restorePrompt) return;
    setDraftSlots(restorePrompt.slots);
    setRestorePrompt(null);
  };

  const discardPending = async () => {
    setRestorePrompt(null);
    await clearPendingWeeklyAvailability();
  };

  const discardChanges = () => {
    setDraftSlots(serverSlots);
  };

  const save = async () => {
    const invalid = draftSlots.some((s) => !isValidSlot(s));
    if (invalid) {
      Alert.alert(
        "Fix time slots",
        "Make sure every slot has From earlier than To."
      );
      return;
    }

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      await updateProfile(token, {
        availabilitySlots: normalizeSlots(draftSlots),
      } as any);

      if (!mountedRef.current) return;

      const normalized = normalizeSlots(draftSlots);
      setServerSlots(normalized);
      setDraftSlots(normalized);

      await markWeeklyAvailabilitySynced();
      const ts = await getWeeklyLastSavedAt();
      setLastSavedAt(ts);

      Alert.alert("Saved ", "Your weekly availability has been updated.");
    } catch (e: any) {
      console.log("weekly availability save error:", e);
      Alert.alert(
        "Save failed",
        e?.message || "Couldnt save. Please try again."
      );
    } finally {
      if (mountedRef.current) setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={{ flex: 1, backgroundColor: "#020617", alignItems: "center", justifyContent: "center" }}>
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>Loading availability</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <View style={{ flex: 1 }}>
        <ScrollView
          contentContainerStyle={{ padding: 16, paddingBottom: 110 }}
          keyboardShouldPersistTaps="handled"
        >
          {/* Header */}
          <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
            <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
              <Text style={{ color: "#60A5FA", fontWeight: "900" }}> Back</Text>
            </TouchableOpacity>

            <Text style={{ color: "#94A3B8", fontSize: 12, fontWeight: "800" }}>
              Last saved: {lastSavedText}
            </Text>
          </View>

          <Text style={{ color: "#F9FAFB", fontSize: 22, fontWeight: "900", marginTop: 10 }}>
            Weekly availability
          </Text>
          <Text style={{ color: "#94A3B8", marginTop: 6, lineHeight: 18, fontSize: 12 }}>
            Add 12 time slots (evenings/weekend). Better mentor matches when your schedule is clear.
          </Text>

          {/* Restore pending banner */}
          {restorePrompt && (
            <View
              style={{
                marginTop: 12,
                backgroundColor: "#0B1120",
                borderWidth: 1,
                borderColor: "#1E293B",
                borderRadius: 14,
                padding: 12,
              }}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
                Restore unsaved changes?
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 12, marginTop: 4, lineHeight: 16 }}>
                Found a previous edit from {new Date(restorePrompt.updatedAtISO).toLocaleString()}.
              </Text>

              <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                <Pressable
                  onPress={restorePending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#22C55E",
                      borderRadius: 999,
                      paddingVertical: 10,
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#022C22", fontWeight: "900" }}>Restore</Text>
                </Pressable>

                <Pressable
                  onPress={discardPending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#020617",
                      borderRadius: 999,
                      paddingVertical: 10,
                      borderWidth: 1,
                      borderColor: "#334155",
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>Discard</Text>
                </Pressable>
              </View>
            </View>
          )}

          {/* Day selector */}
          <View style={{ flexDirection: "row", gap: 8, flexWrap: "wrap", marginTop: 14 }}>
            {dayNames.map((d, idx) => {
              const active = idx === selectedDay;
              return (
                <Pressable
                  key={d}
                  onPress={() => setSelectedDay(idx)}
                  style={({ pressed }) => [
                    {
                      paddingHorizontal: 12,
                      paddingVertical: 8,
                      borderRadius: 999,
                      borderWidth: 1,
                      borderColor: active ? "#F97316" : "#1E293B",
                      backgroundColor: active ? "#0B1120" : "#020617",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: active ? "#FED7AA" : "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                    {d}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          {/* Slots for selected day */}
          <View style={{ marginTop: 14 }}>
            <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
              <Text style={{ color: "#F9FAFB", fontWeight: "900", fontSize: 14 }}>
                {dayNames[selectedDay]} slots
              </Text>

              <TouchableOpacity onPress={addSlot} activeOpacity={0.85}>
                <Text style={{ color: "#60A5FA", fontWeight: "900" }}>+ Add</Text>
              </TouchableOpacity>
            </View>

            {daySlots.length === 0 ? (
              <View
                style={{
                  marginTop: 10,
                  backgroundColor: "#020617",
                  borderWidth: 1,
                  borderColor: "#111827",
                  borderRadius: 14,
                  padding: 12,
                }}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "800" }}>No slots yet</Text>
                <Text style={{ color: "#64748B", marginTop: 4, fontSize: 12, lineHeight: 16 }}>
                  Tap Add to create your first slot for this day.
                </Text>
              </View>
            ) : (
              <View style={{ marginTop: 10, gap: 10 }}>
                {daySlots.map((slot, idx) => {
                  const ok = isValidSlot(slot);
                  return (
                    <View
                      key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                      style={{
                        backgroundColor: "#0B1120",
                        borderWidth: 1,
                        borderColor: ok ? "#1E293B" : "#FCA5A5",
                        borderRadius: 14,
                        padding: 12,
                      }}
                    >
                      <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
                        <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                          Slot #{idx + 1} {ok ? "" : " (Fix time)"}
                        </Text>

                        <Pressable
                          onPress={() => removeSlot(idx)}
                          style={({ pressed }) => [
                            {
                              paddingHorizontal: 10,
                              paddingVertical: 6,
                              borderRadius: 999,
                              borderWidth: 1,
                              borderColor: "#334155",
                              backgroundColor: "#020617",
                            },
                            pressed ? { opacity: 0.85 } : null,
                          ]}
                        >
                          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>Remove</Text>
                        </Pressable>
                      </View>

                      <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            From
                          </Text>
                          <TimeField
                            value={slot.from}
                            onChange={(v: string) => updateSlot(idx, { from: v })}
                          />
                        </View>

                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            To
                          </Text>
                          <TimeField
                            value={slot.to}
                            onChange={(v: string) => updateSlot(idx, { to: v })}
                          />
                        </View>
                      </View>

                      {!ok && (
                        <Text style={{ color: "#FCA5A5", marginTop: 10, fontWeight: "900", fontSize: 12 }}>
                          To must be later than From.
                        </Text>
                      )}
                    </View>
                  );
                })}
              </View>
            )}
          </View>

          {/* Small reset button (non-intrusive) */}
          {dirty && (
            <Pressable
              onPress={discardChanges}
              style={({ pressed }) => [
                {
                  marginTop: 16,
                  alignSelf: "flex-start",
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  borderRadius: 999,
                  borderWidth: 1,
                  borderColor: "#334155",
                  backgroundColor: "#020617",
                },
                pressed ? { opacity: 0.9 } : null,
              ]}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                Reset to last saved
              </Text>
            </Pressable>
          )}
        </ScrollView>

        <SaveBar
          visible={dirty}
          saving={saving}
          onSave={save}
          onDiscard={discardChanges}
          lastSavedText={lastSavedText}
        />
      </View>
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/weekly-availability/TimeField.tsx">
// app/weekly-availability/TimeField.tsx
import React, { useEffect, useState } from "react";
import { Platform, StyleSheet, Text, TextInput, View } from "react-native";

type Props = {
  label?: string;
  value: string;
  onChange: (v: string) => void;
  placeholder?: string;
  disabled?: boolean;
};

function normalizeTimeInput(raw: string): string {
  let s = raw.replace(/[^\d:]/g, "");

  const digitsOnly = s.replace(/:/g, "");
  if (!s.includes(":") && digitsOnly.length >= 3) {
    const hh = digitsOnly.slice(0, 2);
    const mm = digitsOnly.slice(2, 4);
    s = `${hh}:${mm}`;
  }

  if (s.length > 5) s = s.slice(0, 5);

  if (s.includes(":")) {
    const [hhRaw = "", mmRaw = ""] = s.split(":");
    const hh = hhRaw.slice(0, 2);
    const mm = mmRaw.slice(0, 2);
    s = `${hh}:${mm}`;
  }

  return s;
}

function isValidPartialTime(v: string): boolean {
  if (v === "") return true;
  if (!/^\d{0,2}(:\d{0,2})?$/.test(v)) return false;

  const [hhStr, mmStr] = v.split(":");
  if (hhStr.length > 0) {
    const hh = Number(hhStr);
    if (!Number.isFinite(hh) || hh > 23) return false;
  }
  if (mmStr !== undefined && mmStr.length > 0) {
    const mm = Number(mmStr);
    if (!Number.isFinite(mm) || mm > 59) return false;
  }
  return true;
}

export default function TimeField({
  label,
  value,
  onChange,
  placeholder = "HH:MM",
  disabled = false,
}: Props) {
  const [local, setLocal] = useState<string>(value ?? "");

  //  : side-effect -> useEffect
  useEffect(() => {
    setLocal(value ?? "");
  }, [value]);

  const onTextChange = (txt: string) => {
    const normalized = normalizeTimeInput(txt);
    if (!isValidPartialTime(normalized)) return;

    setLocal(normalized);
    onChange(normalized);
  };

  return (
    <View style={styles.wrap}>
      {label ? <Text style={styles.label}>{label}</Text> : null}

      <TextInput
        value={local}
        onChangeText={onTextChange}
        placeholder={placeholder}
        editable={!disabled}
        keyboardType={Platform.select({
          ios: "numbers-and-punctuation",
          android: "numeric",
          default: "numeric",
        })}
        style={[styles.input, disabled && styles.inputDisabled]}
        placeholderTextColor="#64748B"
        maxLength={5}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
  },
  label: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "900",
    marginBottom: 6,
  },
  input: {
    borderWidth: 1,
    borderColor: "#1F2937",
    backgroundColor: "#0B1220",
    color: "#E5E7EB",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    fontSize: 14,
    fontWeight: "700",
  },
  inputDisabled: {
    opacity: 0.6,
  },
});
</file>

<file path="app/weekly-availability/useWeeklyAvailability.ts">
// app/weekly-availability/useWeeklyAvailability.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  AvailabilitySlot,
  getMe,
  updateWeeklyAvailability,
} from "../../lib/api";

/**
 * Local key for "last saved" timestamp (used by Home + Weekly Availability)
 */
const WEEKLY_AVAIL_LAST_SAVED_KEY = "weeklyAvailability_lastSavedAt_v1";

/**
 * Sort slots by day, then time
 */
export function sortAvailability(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return [...slots].sort((a, b) => {
    if (a.dayOfWeek !== b.dayOfWeek) return a.dayOfWeek - b.dayOfWeek;
    return a.from.localeCompare(b.from);
  });
}

/**
 * Normalize + validate slots coming from API or UI
 */
function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return sortAvailability(
    (Array.isArray(slots) ? slots : [])
      .filter(
        (s) =>
          typeof s?.dayOfWeek === "number" &&
          s.dayOfWeek >= 0 &&
          s.dayOfWeek <= 6 &&
          typeof s?.from === "string" &&
          typeof s?.to === "string" &&
          s.from.trim() &&
          s.to.trim()
      )
      .map((s) => ({
        dayOfWeek: s.dayOfWeek,
        from: s.from.trim(),
        to: s.to.trim(),
      }))
  );
}

/**
 * Stable deep-equality key
 */
function slotsKey(slots: AvailabilitySlot[]): string {
  return normalizeSlots(slots)
    .map((s) => `${s.dayOfWeek}|${s.from}|${s.to}`)
    .join(";");
}

async function readLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(WEEKLY_AVAIL_LAST_SAVED_KEY);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

async function writeLastSavedAt(ts: number): Promise<void> {
  try {
    await AsyncStorage.setItem(WEEKLY_AVAIL_LAST_SAVED_KEY, String(ts));
  } catch {
    // ignore
  }
}

export type UserProfile = {
  _id: string;
  fullName: string;
  email: string;
  availabilitySlots?: AvailabilitySlot[];
  skillsToLearn?: any[];
  skillsToTeach?: any[];
};

type UseWeeklyAvailabilityResult = {
  user: UserProfile | null;
  availability: AvailabilitySlot[];
  loading: boolean;
  saving: boolean;
  errorText: string | null;
  hasChanges: boolean;
  lastSavedAt: number | null;

  reload: () => Promise<void>;
  save: () => Promise<boolean>;

  updateAvailability: (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => void;

  setErrorText: (t: string | null) => void;
};

export function useWeeklyAvailability(): UseWeeklyAvailabilityResult {
  const router = useRouter();

  const [user, setUser] = useState<UserProfile | null>(null);
  const [availability, setAvailability] = useState<AvailabilitySlot[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  /**
   * Baseline snapshot to detect unsaved changes
   */
  const baselineKeyRef = useRef<string>("");

  const hasChanges = useMemo(() => {
    return slotsKey(availability) !== baselineKeyRef.current;
  }, [availability]);

  /**
   * Load profile + availability
   */
  const reload = useCallback(async () => {
    try {
      setLoading(true);
      setErrorText(null);

      // load lastSavedAt (fast + local)
      const savedTs = await readLastSavedAt();
      setLastSavedAt(savedTs);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        //  keep consistent with your auth group routes
        router.replace("/(auth)/login" as any);
        return;
      }

      const data = (await getMe(token)) as UserProfile;
      const normalized = normalizeSlots(data.availabilitySlots || []);

      setUser(data);
      setAvailability(normalized);
      baselineKeyRef.current = slotsKey(normalized);

      // If user already has availability from backend but no local timestamp yet,
      // set a helpful baseline timestamp once (not critical, but improves UX).
      if (!savedTs && normalized.length > 0) {
        const now = Date.now();
        setLastSavedAt(now);
        await writeLastSavedAt(now);
      }
    } catch (err: any) {
      console.log("weekly-availability / load error:", err);
      setErrorText(
        err?.message || "We couldnt load your availability. Please try again."
      );
    } finally {
      setLoading(false);
    }
  }, [router]);

  useEffect(() => {
    reload();
  }, [reload]);

  /**
   * Safe updater wrapper (always normalizes)
   */
  const updateAvailability = (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => {
    setAvailability((prev) => normalizeSlots(updater(prev)));
  };

  /**
   * Save changes to backend
   */
  const save = useCallback(async () => {
    //  prevents double taps + saves only when needed
    if (saving || !hasChanges) return false;

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return false;
      }

      const normalized = normalizeSlots(availability);

      const updated = (await updateWeeklyAvailability(
        token,
        normalized
      )) as UserProfile;

      const updatedNormalized = normalizeSlots(updated.availabilitySlots || []);

      setUser(updated);
      setAvailability(updatedNormalized);
      baselineKeyRef.current = slotsKey(updatedNormalized);

      //  write "last saved" timestamp for Home + other screens
      const now = Date.now();
      setLastSavedAt(now);
      await writeLastSavedAt(now);

      return true;
    } catch (err: any) {
      console.log("weekly-availability / save error:", err);
      setErrorText(
        err?.message || "Something went wrong while saving your availability."
      );
      return false;
    } finally {
      setSaving(false);
    }
  }, [availability, hasChanges, router, saving]);

  return {
    user,
    availability,
    loading,
    saving,
    errorText,
    hasChanges,
    lastSavedAt,

    reload,
    save,
    updateAvailability,
    setErrorText,
  };
}
</file>

<file path="lib/chat/api.ts">
// lib/chat/api.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { API_URL } from "../api";

export type ChatMessage = {
  id: string;
  conversationId: string;
  senderId: string;
  text: string;
  createdAt: string; // ISO
};

export type PeerPublic = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
};

export type ChatInboxItem = {
  id: string; // conversationId
  peer: PeerPublic | null;
  lastMessageText: string;
  lastMessageAt: string | null;
  updatedAt: string | null;
  createdAt: string | null;
  unreadCount: number;
};

async function handleResponse(res: Response) {
  const text = await res.text();

  let data: any = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    const message =
      (data && (data as any).error) ||
      (data && (data as any).message) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;

    throw new Error(message);
  }

  return data;
}

function authHeader(token: string) {
  return { Authorization: `Bearer ${token}` };
}

/**
 * GET /api/chat/inbox
 * returns: ChatInboxItem[]
 */
export async function getChatInbox(token: string): Promise<ChatInboxItem[]> {
  const res = await fetch(`${API_URL}/api/chat/inbox`, {
    method: "GET",
    headers: {
      ...authHeader(token),
    },
  });

  const data = await handleResponse(res);
  return Array.isArray(data?.items) ? (data.items as ChatInboxItem[]) : [];
}

// ---- inbox cache (fast boot) ----
const INBOX_CACHE_KEY = "chat_inbox_cache_v1";

export async function getInboxCache(): Promise<ChatInboxItem[] | null> {
  try {
    const raw = await AsyncStorage.getItem(INBOX_CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? (parsed as ChatInboxItem[]) : null;
  } catch {
    return null;
  }
}

export async function setInboxCache(items: ChatInboxItem[]): Promise<void> {
  try {
    await AsyncStorage.setItem(INBOX_CACHE_KEY, JSON.stringify(items));
  } catch {}
}

/**
 * POST /api/chat/conversation
 * body: { peerId }
 * returns: { conversationId: string }
 */
export async function getOrCreateConversation(
  token: string,
  peerId: string
): Promise<string> {
  const res = await fetch(`${API_URL}/api/chat/conversation`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...authHeader(token),
    },
    body: JSON.stringify({ peerId }),
  });

  const data = await handleResponse(res);

  const conversationId = String(data?.conversationId || "").trim();
  if (!conversationId) throw new Error("Invalid conversationId");
  return conversationId;
}

/**
 *  POST /api/chat/:conversationId/read
 * marks all messages as read for current user
 */
export async function markConversationReadRest(
  token: string,
  conversationId: string
): Promise<{ ok: true; modified: number }> {
  const res = await fetch(
    `${API_URL}/api/chat/${encodeURIComponent(conversationId)}/read`,
    {
      method: "POST",
      headers: {
        ...authHeader(token),
      },
    }
  );

  const data = await handleResponse(res);
  return { ok: true, modified: Number(data?.modified || 0) };
}

/**
 * GET /api/chat/:conversationId/messages?limit=50&before=ISO
 * returns: { items: ChatMessage[] }
 */
export async function getConversationMessages(
  token: string,
  conversationId: string,
  opts?: { limit?: number; before?: string }
): Promise<{ items: ChatMessage[] }> {
  const params = new URLSearchParams();
  if (opts?.limit != null) params.set("limit", String(opts.limit));
  if (opts?.before) params.set("before", String(opts.before));

  const q = params.toString();
  const url = `${API_URL}/api/chat/${encodeURIComponent(
    conversationId
  )}/messages${q ? `?${q}` : ""}`;

  const res = await fetch(url, {
    method: "GET",
    headers: {
      ...authHeader(token),
    },
  });

  const data = await handleResponse(res);

  return {
    items: Array.isArray(data?.items) ? (data.items as ChatMessage[]) : [],
  };
}

/**
 * POST /api/chat/:conversationId/messages
 * body: { text }
 * returns: { message: ChatMessage }
 */
export async function sendMessageRest(
  token: string,
  conversationId: string,
  text: string
): Promise<ChatMessage> {
  const res = await fetch(
    `${API_URL}/api/chat/${encodeURIComponent(conversationId)}/messages`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...authHeader(token),
      },
      body: JSON.stringify({ text }),
    }
  );

  const data = await handleResponse(res);

  const msgObj = data?.message;
  if (!msgObj?.id) throw new Error("Invalid message payload");
  return msgObj as ChatMessage;
}
</file>

<file path="lib/chat/socket.ts">
import { io, Socket } from "socket.io-client";
import { API_URL } from "../api";

export type RealtimeMessage = {
  id: string;
  conversationId: string;
  senderId: string;
  text: string;
  createdAt: string;
};

type ConnStatus = "connected" | "reconnecting" | "disconnected";

let socket: Socket | null = null;
let currentToken: string | null = null;

//  keep last joined room so we can re-join on reconnect safely
let lastJoin: { conversationId: string; peerId: string } | null = null;

//  prevent duplicate global connection listeners
let connListenersBound = false;

//  presence watch set (so we can re-watch on reconnect)
const watchedPresence = new Set<string>();

function normalizeCreatedAt(v: any): string {
  if (!v) return new Date().toISOString();
  if (typeof v === "string") return v;
  if (v instanceof Date) return v.toISOString();
  const d = new Date(v);
  return Number.isNaN(d.getTime()) ? new Date().toISOString() : d.toISOString();
}

function ensureConnected(token: string) {
  currentToken = token;

  if (socket) {
    socket.auth = token ? { token } : {};
    if (!socket.connected) socket.connect();
    return socket;
  }

  socket = io(API_URL, {
    transports: ["websocket"],
    auth: token ? { token } : {},
    autoConnect: true,
    reconnection: true,
  });

  return socket;
}

export function connectChatSocket(token: string) {
  const s = ensureConnected(token);

  //  bind only once per socket instance
  if (!connListenersBound) {
    connListenersBound = true;

    s.on("connect", () => {
      // rejoin last room
      if (lastJoin?.conversationId) {
        s.emit("conversation:join", {
          conversationId: lastJoin.conversationId,
          peerId: lastJoin.peerId || "",
        });
      }

      // re-watch presence users
      if (watchedPresence.size) {
        for (const uid of watchedPresence) {
          s.emit("presence:watch", { userId: uid });
        }
      }
    });
  }

  return s;
}

export function disconnectChatSocket() {
  try {
    socket?.disconnect();
  } finally {
    socket = null;
    currentToken = null;
    lastJoin = null;
    connListenersBound = false;
    watchedPresence.clear();
  }
}

export function joinConversationRoom(conversationId: string, peerId?: string) {
  const s = socket;
  if (!s) return;

  const cid = String(conversationId || "").trim();
  const pid = String(peerId || "").trim();
  if (!cid) return;

  lastJoin = { conversationId: cid, peerId: pid };
  s.emit("conversation:join", { conversationId: cid, peerId: pid || "" });
}

export function markConversationRead(conversationId: string) {
  const s = socket;
  if (!s) return Promise.resolve();
  const cid = String(conversationId || "").trim();
  if (!cid) return Promise.resolve();

  return new Promise<void>((resolve) => {
    s.emit("conversation:read", { conversationId: cid });
    resolve();
  });
}

export function emitTyping(conversationId: string, isTyping: boolean) {
  const s = socket;
  if (!s) return;
  const cid = String(conversationId || "").trim();
  if (!cid) return;
  s.emit("typing", { conversationId: cid, isTyping: !!isTyping });
}

export function onNewMessage(handler: (m: RealtimeMessage) => void) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    const msg: RealtimeMessage = {
      id: String(payload?.id || payload?._id || ""),
      conversationId: String(payload?.conversationId || ""),
      senderId: String(payload?.senderId || ""),
      text: String(payload?.text || ""),
      createdAt: normalizeCreatedAt(payload?.createdAt),
    };
    if (!msg.id || !msg.conversationId) return;
    handler(msg);
  };

  s.on("message:new", wrapped);
  return () => s.off("message:new", wrapped);
}

export function onPeerTyping(
  handler: (p: { conversationId: string; userId: string; isTyping: boolean }) => void
) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      conversationId: String(payload?.conversationId || ""),
      userId: String(payload?.userId || ""),
      isTyping: !!payload?.isTyping,
    });
  };

  s.on("typing", wrapped);
  return () => s.off("typing", wrapped);
}

export function onPresenceUpdate(
  handler: (p: { userId: string; online: boolean; lastSeen: string | null }) => void
) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      userId: String(payload?.userId || ""),
      online: !!payload?.online,
      lastSeen: payload?.lastSeen ? String(payload.lastSeen) : null,
    });
  };

  s.on("presence:update", wrapped);
  return () => s.off("presence:update", wrapped);
}

//  NEW: Read receipts (Seen)
export function onReadReceipt(
  handler: (p: { conversationId: string; readerId: string; readAt?: string }) => void
) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      conversationId: String(payload?.conversationId || ""),
      readerId: String(payload?.readerId || ""),
      readAt: payload?.readAt ? String(payload.readAt) : undefined,
    });
  };

  s.on("read:receipt", wrapped);
  return () => s.off("read:receipt", wrapped);
}

//  watch/unwatch presence
export function watchPresence(userId: string) {
  const s = socket;
  if (!s) return;
  const uid = String(userId || "").trim();
  if (!uid) return;
  watchedPresence.add(uid);
  s.emit("presence:watch", { userId: uid });
}

export function unwatchPresence(userId: string) {
  const s = socket;
  const uid = String(userId || "").trim();
  if (!uid) return;
  watchedPresence.delete(uid);
  if (!s) return;
  s.emit("presence:unwatch", { userId: uid });
}

//  snapshot request (ack)
export function getPresenceSnapshot(
  userId: string
): Promise<{ userId: string; online: boolean; lastSeen: string | null } | null> {
  return new Promise((resolve) => {
    const s = socket;
    const uid = String(userId || "").trim();
    if (!s || !uid) return resolve(null);

    s.emit("presence:get", { userId: uid }, (resp: any) => {
      if (!resp) return resolve(null);
      resolve({
        userId: String(resp?.userId || uid),
        online: !!resp?.online,
        lastSeen: resp?.lastSeen ? String(resp.lastSeen) : null,
      });
    });
  });
}

export function onConnectionStatus(handler: (s: ConnStatus) => void) {
  const s = socket;
  if (!s) return () => {};

  const onConnect = () => handler("connected");
  const onDisconnect = () => handler("disconnected");
  const onReconnectAttempt = () => handler("reconnecting");
  const onConnectError = () => handler("reconnecting");

  s.on("connect", onConnect);
  s.on("disconnect", onDisconnect);
  s.io.on("reconnect_attempt", onReconnectAttempt);
  s.on("connect_error", onConnectError);

  handler(s.connected ? "connected" : "disconnected");

  return () => {
    s.off("connect", onConnect);
    s.off("disconnect", onDisconnect);
    s.off("connect_error", onConnectError);
    s.io.off("reconnect_attempt", onReconnectAttempt);
  };
}

export function sendRealtimeMessage(
  conversationId: string,
  text: string
): Promise<{ ok: boolean; message?: RealtimeMessage; error?: string }> {
  return new Promise((resolve) => {
    const s = socket;
    if (!s) return resolve({ ok: false, error: "Socket not connected" });

    const cid = String(conversationId || "").trim();
    const t = String(text || "").trim();
    if (!cid || !t) return resolve({ ok: false, error: "Missing data" });

    s.emit(
      "message:send",
      { conversationId: cid, text: t },
      (resp: any = { ok: false, error: "No response" }) => {
        if (!resp?.ok)
          return resolve({
            ok: false,
            error: String(resp?.error || "Failed"),
          });

        const payload = resp?.message || resp;
        const msg: RealtimeMessage = {
          id: String(payload?.id || payload?._id || "") || `${Date.now()}`,
          conversationId: String(payload?.conversationId || cid),
          senderId: String(payload?.senderId || ""),
          text: String(payload?.text || t),
          createdAt: normalizeCreatedAt(payload?.createdAt),
        };

        return resolve({ ok: true, message: msg });
      }
    );
  });
}
</file>

<file path="server/matching/embeddingService.js">
// server/matching/embeddingService.js
const OpenAI = require("openai");

let client = null;

// ===== In-memory cache (no external deps) =====
const CACHE_TTL_MS =
  Number(process.env.EMBED_CACHE_TTL_MS) || 1000 * 60 * 60 * 24; // 24h
const CACHE_MAX_ITEMS = Number(process.env.EMBED_CACHE_MAX_ITEMS) || 2000;

// key -> { value: number[], expiresAt: number, touchedAt: number }
const cache = new Map();

// key -> Promise<number[]|null>
const inFlight = new Map();

function now() {
  return Date.now();
}

function normalizeKey(text) {
  return String(text || "")
    .trim()
    .toLowerCase();
}

function purgeExpired() {
  const t = now();
  for (const [k, entry] of cache.entries()) {
    if (!entry || entry.expiresAt <= t) cache.delete(k);
  }
}

function evictIfNeeded() {
  if (cache.size <= CACHE_MAX_ITEMS) return;

  // Evict least-recently-touched entries
  const items = Array.from(cache.entries());
  items.sort((a, b) => (a[1]?.touchedAt || 0) - (b[1]?.touchedAt || 0));

  const removeCount = Math.ceil(CACHE_MAX_ITEMS * 0.15); // remove 15%
  for (let i = 0; i < removeCount && i < items.length; i++) {
    cache.delete(items[i][0]);
  }
}

function hasUsableKey() {
  const apiKey = String(process.env.OPENAI_API_KEY || "").trim();
  return !!apiKey && apiKey !== "YOUR_KEY_HERE";
}

function getClientSafe() {
  // IMPORTANT: never throw here (we want clean fallback UX)
  if (!hasUsableKey()) return null;

  if (client) return client;

  client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  return client;
}

function getModel() {
  return process.env.OPENAI_EMBED_MODEL || "text-embedding-3-small";
}

/**
 * Returns embedding vector for a text
 * - returns null if:
 *   - empty text
 *   - no API key
 *   - OpenAI error
 *
 * @param {string} text
 * @returns {Promise<number[]|null>}
 */
async function getEmbedding(text) {
  const input = String(text || "").trim();
  if (!input) return null;

  // no key => no embedding (caller should fallback)
  const openai = getClientSafe();
  if (!openai) return null;

  const key = normalizeKey(input);

  // keep cache healthy
  purgeExpired();

  // 1) cache hit
  const cached = cache.get(key);
  if (cached && Array.isArray(cached.value) && cached.value.length > 0) {
    cached.touchedAt = now();
    return cached.value;
  }

  // 2) in-flight dedupe
  const existingPromise = inFlight.get(key);
  if (existingPromise) return existingPromise;

  // 3) fetch + store
  const promise = (async () => {
    try {
      const model = getModel();

      const resp = await openai.embeddings.create({
        model,
        input,
      });

      const emb = resp?.data?.[0]?.embedding;
      if (!Array.isArray(emb) || emb.length === 0) return null;

      cache.set(key, {
        value: emb,
        expiresAt: now() + CACHE_TTL_MS,
        touchedAt: now(),
      });

      evictIfNeeded();
      return emb;
    } catch (err) {
      // silent fail => caller can fallback (hybrid/local)
      return null;
    } finally {
      inFlight.delete(key);
    }
  })();

  inFlight.set(key, promise);
  return promise;
}

module.exports = { getEmbedding };
</file>

<file path="server/matching/index.js">
// server/matching/index.js
const { findMentorMatchesLocal } = require("./localMatcher");
const { findMentorMatchesOpenAI } = require("./openaiMatcher");

function normalizeMode(raw) {
  const m = String(raw || "")
    .trim()
    .toLowerCase();
  if (m === "openai" || m === "local" || m === "hybrid") return m;
  return null;
}

function getMode(overrideMode) {
  const fromOverride = normalizeMode(overrideMode);
  if (fromOverride) return fromOverride;

  const fromEnv = normalizeMode(process.env.MATCHING_MODE);
  return fromEnv || "local";
}

function isOpenAIReady() {
  const raw = String(process.env.OPENAI_API_KEY || "").trim();
  return !!raw && raw !== "YOUR_KEY_HERE";
}

function metaBase({ requestedMode, modeUsed, fallbackUsed, reason = "OK" }) {
  return {
    requestedMode: requestedMode || null,
    modeUsed: modeUsed || null,
    fallbackUsed: !!fallbackUsed,
    reason, // OK | NO_KEY | OPENAI_EMPTY | OPENAI_ERROR
  };
}

/**
 * modes:
 * - local
 * - openai
 * - hybrid (openai then fallback to local)
 *
 * Returns:
 * { results: MentorMatch[], meta: { requestedMode, modeUsed, fallbackUsed, reason } }
 */
async function findMentorMatches(params) {
  const requestedMode = normalizeMode(params?.mode) || null;
  const mode = getMode(params?.mode);

  // -------- LOCAL --------
  if (mode === "local") {
    const results = await findMentorMatchesLocal(params);
    return {
      results,
      meta: metaBase({
        requestedMode,
        modeUsed: "local",
        fallbackUsed: false,
        reason: "OK",
      }),
    };
  }

  // -------- OPENAI --------
  if (mode === "openai") {
    //    key       +  
    if (!isOpenAIReady()) {
      return {
        results: [],
        meta: metaBase({
          requestedMode,
          modeUsed: "openai",
          fallbackUsed: false,
          reason: "NO_KEY",
        }),
      };
    }

    try {
      const results = await findMentorMatchesOpenAI(params);
      return {
        results: Array.isArray(results) ? results : [],
        meta: metaBase({
          requestedMode,
          modeUsed: "openai",
          fallbackUsed: false,
          reason: results && results.length ? "OK" : "OPENAI_EMPTY",
        }),
      };
    } catch (e) {
      console.log("OPENAI mode failed:", e?.message || e);
      return {
        results: [],
        meta: metaBase({
          requestedMode,
          modeUsed: "openai",
          fallbackUsed: false,
          reason: "OPENAI_ERROR",
        }),
      };
    }
  }

  // -------- HYBRID --------
  // OpenAI  fallback  Local  //  key
  if (mode === "hybrid") {
    if (!isOpenAIReady()) {
      const local = await findMentorMatchesLocal(params);
      return {
        results: local,
        meta: metaBase({
          requestedMode,
          modeUsed: "local",
          fallbackUsed: true,
          reason: "NO_KEY",
        }),
      };
    }

    try {
      const ai = await findMentorMatchesOpenAI(params);
      if (Array.isArray(ai) && ai.length > 0) {
        return {
          results: ai,
          meta: metaBase({
            requestedMode,
            modeUsed: "openai",
            fallbackUsed: false,
            reason: "OK",
          }),
        };
      }

      const local = await findMentorMatchesLocal(params);
      return {
        results: local,
        meta: metaBase({
          requestedMode,
          modeUsed: "local",
          fallbackUsed: true,
          reason: "OPENAI_EMPTY",
        }),
      };
    } catch (e) {
      console.log("HYBRID: OpenAI failed -> fallback local:", e?.message || e);
      const local = await findMentorMatchesLocal(params);
      return {
        results: local,
        meta: metaBase({
          requestedMode,
          modeUsed: "local",
          fallbackUsed: true,
          reason: "OPENAI_ERROR",
        }),
      };
    }
  }

  // -------- SAFETY FALLBACK --------
  const results = await findMentorMatchesLocal(params);
  return {
    results,
    meta: metaBase({
      requestedMode,
      modeUsed: "local",
      fallbackUsed: true,
      reason: "OK",
    }),
  };
}

module.exports = { findMentorMatches };
</file>

<file path="server/matching/openaiMatcher.js">
// server/matching/openaiMatcher.js
const User = require("../models/User");
const { getEmbedding } = require("./embeddingService");
const {
  computeLevelCompatibility,
  computeAvailabilityScore,
  computeProfileQuality,
  computeMultiSkillBonus,
} = require("./normalize");
const { cosineSimilarity, buildMatchScore } = require("./scoreUtils");

/**
 * OpenAI embedding matcher (SAFE optimized):
 * - embedding(skillQuery)
 * - cosine similarity with each mentor skill embedding
 * - batch-save embeddings per mentor (1 write max)
 *
 * NOTE:
 * - If OpenAI isn't available (no key / error), getEmbedding returns null,
 *   so this returns [] and HYBRID will fallback to local.
 */
async function findMentorMatchesOpenAI({
  userId,
  skillQuery,
  level,
  userAvailability,
}) {
  const skillToMatch = String(skillQuery || "").trim();
  const normalizedDesiredLevel =
    String(level || "Beginner").trim() || "Beginner";
  if (!skillToMatch) return [];

  const requestingUser = await User.findById(userId).lean();
  if (!requestingUser) return [];

  const mentorsRaw = await User.find({
    _id: { $ne: userId },
    skillsToTeach: { $exists: true, $ne: [] },
  }).lean();

  if (!mentorsRaw.length) return [];

  //  SAFE: may return null if no key or OpenAI error
  const queryEmbedding = await getEmbedding(skillToMatch);
  if (!Array.isArray(queryEmbedding) || queryEmbedding.length === 0) {
    return [];
  }

  const results = [];
  const studentGoals = Array.isArray(requestingUser.skillsToLearn)
    ? requestingUser.skillsToLearn
    : [];
  const userAvail = Array.isArray(userAvailability) ? userAvailability : [];

  for (const mentor of mentorsRaw) {
    const teachSkills = Array.isArray(mentor.skillsToTeach)
      ? mentor.skillsToTeach
      : [];
    if (!teachSkills.length) continue;

    const mentorAvailability = Array.isArray(mentor.availabilitySlots)
      ? mentor.availabilitySlots
      : [];

    let bestSkill = null;
    let bestSim = 0;

    let changed = false;
    const updatedTeachSkills = teachSkills.map((s) => ({ ...s }));

    for (let i = 0; i < updatedTeachSkills.length; i++) {
      const skillObj = updatedTeachSkills[i];
      if (!skillObj || !skillObj.name) continue;

      let emb = skillObj.embedding;

      // fetch embedding only if missing
      if (!Array.isArray(emb) || emb.length === 0) {
        const fresh = await getEmbedding(skillObj.name);
        if (Array.isArray(fresh) && fresh.length > 0) {
          emb = fresh;
          skillObj.embedding = fresh;
          changed = true;
        } else {
          // can't embed this skill => skip it (do not fail whole mentor)
          continue;
        }
      }

      const sim = cosineSimilarity(queryEmbedding, emb);
      if (sim > bestSim) {
        bestSim = sim;
        bestSkill = skillObj;
      }
    }

    // write back embeddings once per mentor
    if (changed) {
      try {
        await User.updateOne(
          { _id: mentor._id },
          { $set: { skillsToTeach: updatedTeachSkills } }
        );
      } catch (e) {
        // silent fail (non-critical)
      }
    }

    // threshold guard (tuneable)
    if (!bestSkill || bestSim < 0.78) continue;

    const levelScore = computeLevelCompatibility(
      normalizedDesiredLevel,
      bestSkill.level || "Not specified"
    );

    const availabilityScore = computeAvailabilityScore(
      userAvail,
      mentorAvailability
    );
    const profileQuality = computeProfileQuality(mentor);
    const multiSkillBonus = computeMultiSkillBonus(studentGoals, teachSkills);

    const matchScore = buildMatchScore({
      skillSimilarity: bestSim,
      levelScore,
      availabilityScore,
      profileQuality,
      multiSkillBonus,
    });

    if (matchScore < 0.25) continue;

    results.push({
      mentorId: String(mentor._id),
      fullName: mentor.fullName || "Unknown mentor",
      matchScore,
      mainMatchedSkill: {
        name: bestSkill.name,
        level: bestSkill.level || "Not specified",
        similarityScore: bestSim,
      },
      // return mentor skills WITHOUT embeddings (clean payload)
      skillsToTeach: teachSkills.map((s) => ({
        name: s.name,
        level: s.level || "Not specified",
      })),
      availabilitySlots: mentorAvailability,
    });
  }

  results.sort((a, b) => b.matchScore - a.matchScore);
  return results.slice(0, 20);
}

module.exports = { findMentorMatchesOpenAI };
</file>

<file path="server/routes/points.routes.js">
// server/routes/points.routes.js
const express = require("express");
const PointTransaction = require("../models/PointTransaction");
const { getBalance } = require("../services/pointsService");

const router = express.Router();

/**
 * GET /api/points/balance
 * returns: { balance: number }
 */
router.get("/balance", async (req, res) => {
  try {
    const balance = await getBalance(req.userId);
    return res.json({ balance });
  } catch (err) {
    return res.status(400).json({ error: String(err?.message || err) });
  }
});

/**
 * GET /api/points/transactions?limit=50
 * returns: { items: PointTransaction[] }
 */
router.get("/transactions", async (req, res) => {
  try {
    const rawLimit = Number(req.query.limit);
    const limit = Number.isFinite(rawLimit)
      ? Math.max(1, Math.min(200, rawLimit))
      : 50;

    const items = await PointTransaction.find({ userId: req.userId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .select("amount reason sessionId balanceAfter createdAt");

    return res.json({ items });
  } catch (err) {
    return res.status(400).json({ error: String(err?.message || err) });
  }
});

module.exports = router;
</file>

<file path="server/routes/ratings.js">
// server/routes/users.js
const express = require("express");
const mongoose = require("mongoose");
const User = require("../models/User");

function isValidObjectId(id) {
  return mongoose.Types.ObjectId.isValid(String(id));
}

function toPublicUser(u) {
  if (!u) return null;

  return {
    id: String(u._id),
    fullName: String(u.fullName || ""),
    points: Number(u.points || 0),
    xp: Number(u.xp || 0),
    streak: Number(u.streak || 0),

    // ratings
    avgRating: Number(u.avgRating || 0),
    ratingCount: Number(u.ratingCount || 0),

    // profile info
    skillsToTeach: Array.isArray(u.skillsToTeach) ? u.skillsToTeach : [],
    availabilitySlots: Array.isArray(u.availabilitySlots)
      ? u.availabilitySlots
      : [],
    preferences:
      u.preferences && typeof u.preferences === "object"
        ? {
            communicationModes: Array.isArray(u.preferences.communicationModes)
              ? u.preferences.communicationModes
              : [],
            languages: Array.isArray(u.preferences.languages)
              ? u.preferences.languages
              : [],
          }
        : { communicationModes: [], languages: [] },
  };
}

module.exports = function usersRouter(authMiddleware) {
  const router = express.Router();

  /**
   * GET /api/users/:id
   * Public mentor profile (for mentor page)
   */
  router.get("/:id", authMiddleware, async (req, res) => {
    try {
      const id = String(req.params.id);

      if (!isValidObjectId(id)) {
        return res.status(400).json({ error: "Invalid user id" });
      }

      const u = await User.findById(id)
        .select(
          "fullName points xp streak avgRating ratingCount skillsToTeach availabilitySlots preferences"
        )
        .lean();

      if (!u) return res.status(404).json({ error: "User not found" });

      return res.json(toPublicUser(u));
    } catch (err) {
      console.error("GET PUBLIC USER ERROR:", err);
      return res.status(500).json({ error: "Failed to load user profile" });
    }
  });

  return router;
};
</file>

<file path="server/services/pointsService.js">
// server/services/pointsService.js
const mongoose = require("mongoose");
const User = require("../models/User");
const PointTransaction = require("../models/PointTransaction");

async function getBalance(userId) {
  const user = await User.findById(userId).select("points");
  if (!user) throw new Error("User not found");
  return user.points || 0;
}

async function findExistingTx({ userId, reason, sessionId, mongoSession }) {
  // Idempotency only makes sense when reason+sessionId are provided
  if (!sessionId || !reason) return null;

  return PointTransaction.findOne({
    userId,
    reason,
    sessionId,
  })
    .select("balanceAfter")
    .session(mongoSession || null);
}

async function addPoints(userId, amount, reason, sessionId = null, opts = {}) {
  if (amount <= 0) throw new Error("Amount must be positive");

  const mongoSession = opts.mongoSession || (await mongoose.startSession());
  const ownsSession = !opts.mongoSession;

  if (ownsSession) mongoSession.startTransaction();

  try {
    //  Idempotency: if already applied, return stored balanceAfter
    const existing = await findExistingTx({
      userId,
      reason,
      sessionId,
      mongoSession,
    });
    if (existing) {
      if (ownsSession) {
        await mongoSession.commitTransaction();
        mongoSession.endSession();
      }
      return existing.balanceAfter;
    }

    const user = await User.findById(userId).session(mongoSession);
    if (!user) throw new Error("User not found");

    const current = user.points || 0;
    const next = current + amount;

    user.points = next;
    await user.save({ session: mongoSession });

    await PointTransaction.create(
      [
        {
          userId,
          amount: +amount,
          reason,
          sessionId: sessionId || null,
          balanceAfter: next,
        },
      ],
      { session: mongoSession }
    );

    if (ownsSession) {
      await mongoSession.commitTransaction();
      mongoSession.endSession();
    }

    return next;
  } catch (err) {
    if (ownsSession) {
      await mongoSession.abortTransaction();
      mongoSession.endSession();
    }
    throw err;
  }
}

async function deductPoints(
  userId,
  amount,
  reason,
  sessionId = null,
  opts = {}
) {
  if (amount <= 0) throw new Error("Amount must be positive");

  const mongoSession = opts.mongoSession || (await mongoose.startSession());
  const ownsSession = !opts.mongoSession;

  if (ownsSession) mongoSession.startTransaction();

  try {
    //  Idempotency: if already applied, return stored balanceAfter
    const existing = await findExistingTx({
      userId,
      reason,
      sessionId,
      mongoSession,
    });
    if (existing) {
      if (ownsSession) {
        await mongoSession.commitTransaction();
        mongoSession.endSession();
      }
      return existing.balanceAfter;
    }

    const user = await User.findById(userId).session(mongoSession);
    if (!user) throw new Error("User not found");

    const current = user.points || 0;
    if (current < amount) {
      throw new Error("Not enough points");
    }

    const next = current - amount;

    user.points = next;
    await user.save({ session: mongoSession });

    await PointTransaction.create(
      [
        {
          userId,
          amount: -amount,
          reason,
          sessionId: sessionId || null,
          balanceAfter: next,
        },
      ],
      { session: mongoSession }
    );

    if (ownsSession) {
      await mongoSession.commitTransaction();
      mongoSession.endSession();
    }

    return next;
  } catch (err) {
    if (ownsSession) {
      await mongoSession.abortTransaction();
      mongoSession.endSession();
    }
    throw err;
  }
}

module.exports = {
  getBalance,
  addPoints,
  deductPoints,
};
</file>

<file path="app/find-mentor.tsx">
// app/find-mentor.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import type { MatchingMode } from "../lib/api";
import {
  AvailabilitySlot,
  MentorMatch,
  SkillLearn,
  getMe,
  getMentorMatches,
} from "../lib/api";

//  chat: open conversation directly from results
import { getOrCreateConversation } from "../lib/chat/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points: number;
  xp: number;
  streak: number;
  skillsToLearn?: SkillLearn[];
  availabilitySlots?: AvailabilitySlot[];
};

type LevelOption = "Beginner" | "Intermediate" | "Advanced";

const LEVELS: { value: LevelOption; label: string }[] = [
  { value: "Beginner", label: "Beginner" },
  { value: "Intermediate", label: "Intermediate" },
  { value: "Advanced", label: "Advanced" },
];

const MODES: { value: MatchingMode; label: string; hint: string }[] = [
  { value: "local", label: "Local", hint: "Fast, no API key needed" },
  { value: "openai", label: "OpenAI", hint: "Semantic embeddings (needs key)" },
  { value: "hybrid", label: "Hybrid", hint: "OpenAI  fallback to Local" },
];

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

export default function FindMentorScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loadingUser, setLoadingUser] = useState(true);
  const [loadingMatches, setLoadingMatches] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [selectedSkill, setSelectedSkill] = useState<string>("");
  const [customSkill, setCustomSkill] = useState<string>("");
  const [selectedLevel, setSelectedLevel] = useState<LevelOption>("Beginner");
  const [useMyAvailability, setUseMyAvailability] = useState<boolean>(true);
  const [mode, setMode] = useState<MatchingMode>("local");

  const [matches, setMatches] = useState<MentorMatch[]>([]);
  const [hasSearched, setHasSearched] = useState(false);

  // ---- Load current user ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      try {
        setErrorText(null);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const data = (await getMe(token)) as any;
        const userFromApi: User = (data?.user ?? data) as User;

        if (!isMounted) return;

        setUser(userFromApi);

        const skills = userFromApi.skillsToLearn ?? [];
        if (skills.length > 0 && skills[0]?.name) {
          setSelectedSkill(skills[0].name);
        }
      } catch (err: any) {
        console.log("FindMentor / getMe error:", err);
        if (isMounted) {
          setErrorText(
            err?.message ||
              "We couldnt load your profile. Please go back and try again."
          );
        }
      } finally {
        if (isMounted) setLoadingUser(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, [router]);

  const learningSkills = useMemo(() => {
    const arr = user?.skillsToLearn ?? [];
    return arr
      .map((s) => ({
        name: String(s?.name || "").trim(),
        level: String((s as any)?.level || "Not specified").trim(),
      }))
      .filter((s) => !!s.name);
  }, [user?.skillsToLearn]);

  const availabilitySlots = useMemo(
    () => user?.availabilitySlots ?? [],
    [user?.availabilitySlots]
  );

  const effectiveSkill = useMemo(() => {
    if (customSkill.trim()) return customSkill.trim();
    return selectedSkill.trim();
  }, [customSkill, selectedSkill]);

  const canSearch = !!effectiveSkill && !loadingMatches && !loadingUser;

  const handleSearch = async () => {
    if (!canSearch) return;

    try {
      setErrorText(null);
      setLoadingMatches(true);
      setHasSearched(true);
      setMatches([]);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const payload = {
        skill: effectiveSkill,
        level: selectedLevel,
        availabilitySlots: useMyAvailability ? availabilitySlots : [],
        mode,
      };

      const res = await getMentorMatches(token, payload);
      setMatches(res.results ?? []);
    } catch (err: any) {
      console.log("getMentorMatches error:", err);
      setErrorText(
        err?.message ||
          "Something went wrong while searching for mentors. Please try again."
      );
    } finally {
      setLoadingMatches(false);
    }
  };

  const handleBack = () => router.back();

  //  NEW: open mentor profile
  const openMentorProfile = (mentorId: string) => {
    router.push({ pathname: "/mentor/[id]", params: { id: mentorId } } as any);
  };

  //  NEW: open chat directly
  const openMentorChat = async (mentorId: string) => {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return;
    }

    const conversationId = await getOrCreateConversation(token, mentorId);

    //    
    if (!conversationId || typeof conversationId !== "string") {
      console.warn("Invalid conversationId, aborting navigation");
      return;
    }

    router.push({
      pathname: "/(tabs)/chats/[conversationId]",
      params: { conversationId },
    });
  };

  const requestSession = (m: MentorMatch) => {
    router.push({
      pathname: "/sessions/request",
      params: {
        mentorId: m.mentorId,
        mentorName: m.fullName,
        skill: m.mainMatchedSkill?.name,
        level: m.mainMatchedSkill?.level,
      },
    } as any);
  };

  if (loadingUser && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your profile</Text>
      </View>
    );
  }

  const noLearningSkills = learningSkills.length === 0;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={handleBack} activeOpacity={0.85}>
            <Text style={styles.backText}> Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Find a mentor</Text>
        <Text style={styles.subtitle}>
          Pick a skill you want help with and well look for people who can
          teach you.
        </Text>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Something went wrong</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
          </View>
        )}

        {/* 0. Matching mode */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>0. Matching mode</Text>
          <Text style={styles.sectionDescription}>
            Switch matching method with one tap (no code changes).
          </Text>

          <View style={styles.levelRow}>
            {MODES.map((opt) => {
              const active = mode === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setMode(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>

          <Text style={styles.modeHint}>
            Current: <Text style={styles.modeHintStrong}>{mode}</Text> {" "}
            {MODES.find((m) => m.value === mode)?.hint}
          </Text>
        </View>

        {/* 1. Skill selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>1. Choose a skill</Text>
          <Text style={styles.sectionDescription}>
            Start with one of your learning goals, or type a custom skill.
          </Text>

          {noLearningSkills ? (
            <View style={styles.infoBox}>
              <Text style={styles.infoTitle}>No learning skills found</Text>
              <Text style={styles.infoBody}>
                You dont have any learning goals yet. Go back to your dashboard
                and add some skills you want to learn.
              </Text>
            </View>
          ) : (
            <>
              <Text style={styles.label}>From your learning list</Text>
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.chipsRow}
              >
                {learningSkills.map((skillObj) => {
                  const active = selectedSkill === skillObj.name;
                  return (
                    <TouchableOpacity
                      key={skillObj.name}
                      onPress={() => setSelectedSkill(skillObj.name)}
                      style={[
                        styles.skillChip,
                        active && styles.skillChipActive,
                      ]}
                      activeOpacity={0.85}
                    >
                      <Text
                        style={[
                          styles.skillChipText,
                          active && styles.skillChipTextActive,
                        ]}
                      >
                        {skillObj.name}
                        {skillObj.level && skillObj.level !== "Not specified"
                          ? `  ${skillObj.level}`
                          : ""}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </ScrollView>
            </>
          )}

          <Text style={[styles.label, { marginTop: 10 }]}>
            Or type a custom skill
          </Text>
          <TextInput
            style={styles.input}
            placeholder="e.g. React Native, Public speaking"
            placeholderTextColor="#6b7280"
            value={customSkill}
            onChangeText={setCustomSkill}
          />

          <View style={styles.currentSkillBox}>
            <Text style={styles.currentSkillLabel}>Current search skill:</Text>
            <Text style={styles.currentSkillValue}>
              {effectiveSkill || "Not selected yet"}
            </Text>
          </View>
        </View>

        {/* 2. Level selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>2. Your level</Text>
          <Text style={styles.sectionDescription}>
            This helps us prioritize mentors who match your current experience.
          </Text>

          <View style={styles.levelRow}>
            {LEVELS.map((opt) => {
              const active = selectedLevel === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setSelectedLevel(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>

        {/* 3. Availability usage */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>3. Availability</Text>
          <Text style={styles.sectionDescription}>
            We can use your weekly availability to prioritize mentors who are
            free at similar times.
          </Text>

          <TouchableOpacity
            style={styles.toggleRow}
            onPress={() => setUseMyAvailability((prev) => !prev)}
            activeOpacity={0.85}
          >
            <View
              style={[
                styles.toggleOuter,
                useMyAvailability && styles.toggleOuterOn,
              ]}
            >
              <View
                style={[
                  styles.toggleInner,
                  useMyAvailability && styles.toggleInnerOn,
                ]}
              />
            </View>
            <Text style={styles.toggleLabel}>
              Use my weekly availability from dashboard
            </Text>
          </TouchableOpacity>

          {useMyAvailability && availabilitySlots.length > 0 && (
            <View style={styles.availabilityPreview}>
              {availabilitySlots.slice(0, 3).map((slot, idx) => (
                <Text key={idx} style={styles.availabilityLine}>
                  {dayNames[slot.dayOfWeek] ?? `Day ${slot.dayOfWeek}`}:{" "}
                  {slot.from}  {slot.to}
                </Text>
              ))}
              {availabilitySlots.length > 3 && (
                <Text style={styles.availabilityMore}>
                  + {availabilitySlots.length - 3} more
                </Text>
              )}
            </View>
          )}

          {useMyAvailability && availabilitySlots.length === 0 && (
            <Text style={styles.noAvailabilityText}>
              You dont have any availability set yet. You can still search for
              mentors, but results wont be filtered by time.
            </Text>
          )}
        </View>

        {/* Search button */}
        <TouchableOpacity
          style={[
            styles.searchButton,
            (!canSearch || loadingMatches) && styles.searchButtonDisabled,
          ]}
          onPress={handleSearch}
          disabled={!canSearch}
          activeOpacity={0.85}
        >
          {loadingMatches ? (
            <ActivityIndicator color="#ffffff" />
          ) : (
            <Text style={styles.searchButtonText}>Search for mentors</Text>
          )}
        </TouchableOpacity>

        {/* Results */}
        <View style={styles.resultsSection}>
          <Text style={styles.resultsTitle}>Results</Text>

          {!hasSearched && (
            <Text style={styles.resultsHint}>
              Start by selecting a skill and tapping Search for mentors.
            </Text>
          )}

          {hasSearched && !loadingMatches && matches.length === 0 && (
            <Text style={styles.resultsHint}>
              No mentors found yet for this skill. Try another skill or relax
              your filters.
            </Text>
          )}

          {matches.map((m) => (
            <TouchableOpacity
              key={m.mentorId}
              activeOpacity={0.92}
              onPress={() => openMentorProfile(m.mentorId)}
              style={styles.matchCardClickable}
            >
              <View style={styles.matchHeaderRow}>
                <Text style={styles.matchName}>{m.fullName}</Text>
                <Text style={styles.matchScore}>
                  {Math.round(m.matchScore * 100)}%
                </Text>
              </View>

              {m.mainMatchedSkill && (
                <Text style={styles.matchSkillLine}>
                  Best match:{" "}
                  <Text style={styles.matchSkillHighlight}>
                    {m.mainMatchedSkill.name} ({m.mainMatchedSkill.level})
                  </Text>{" "}
                   similarity{" "}
                  {Math.round(m.mainMatchedSkill.similarityScore * 100)}%
                </Text>
              )}

              {m.skillsToTeach && m.skillsToTeach.length > 0 && (
                <View style={styles.matchSkillsList}>
                  <Text style={styles.matchSkillsLabel}>Teaches:</Text>
                  <Text style={styles.matchSkillsValue}>
                    {m.skillsToTeach
                      .slice(0, 3)
                      .map((s) => s.name)
                      .join(", ")}
                    {m.skillsToTeach.length > 3
                      ? ` +${m.skillsToTeach.length - 3} more`
                      : ""}
                  </Text>
                </View>
              )}

              {m.availabilitySlots && m.availabilitySlots.length > 0 && (
                <Text style={styles.matchAvailability}>
                  Example availability:{" "}
                  {dayNames[m.availabilitySlots[0].dayOfWeek] ??
                    `Day ${m.availabilitySlots[0].dayOfWeek}`}{" "}
                   {m.availabilitySlots[0].from}  {m.availabilitySlots[0].to}
                </Text>
              )}

              {/* actions */}
              <View style={styles.actionsRow}>
                <TouchableOpacity
                  style={[styles.actionBtn, styles.actionSecondary]}
                  activeOpacity={0.85}
                  onPress={() => openMentorProfile(m.mentorId)}
                >
                  <Text style={styles.actionSecondaryText}>View profile</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.actionBtn, styles.actionPrimary]}
                  activeOpacity={0.85}
                  onPress={() => openMentorChat(m.mentorId)}
                >
                  <Text style={styles.actionPrimaryText}>Message</Text>
                </TouchableOpacity>
              </View>

              <TouchableOpacity
                style={styles.matchActionButton}
                activeOpacity={0.85}
                onPress={() => requestSession(m)}
              >
                <Text style={styles.matchActionText}>Request session</Text>
              </TouchableOpacity>

              <Text style={styles.tapHint}>
                Tip: tap anywhere on this card to open profile
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 14,
  },
  container: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 32,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  backText: {
    fontSize: 14,
    color: "#60A5FA",
  },
  title: {
    fontSize: 22,
    fontWeight: "700",
    color: "#F9FAFB",
    marginTop: 4,
  },
  subtitle: {
    fontSize: 13,
    color: "#9CA3AF",
    marginTop: 4,
    marginBottom: 14,
  },
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
  },
  card: {
    backgroundColor: "#020617",
    borderRadius: 16,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 14,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#F9FAFB",
    marginBottom: 4,
  },
  sectionDescription: {
    fontSize: 12,
    color: "#94A3B8",
    marginBottom: 10,
  },
  label: {
    fontSize: 12,
    color: "#CBD5F5",
    marginBottom: 4,
  },
  chipsRow: {
    flexDirection: "row",
    gap: 8,
    paddingVertical: 4,
  },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  skillChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  skillChipText: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  skillChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "600",
  },
  input: {
    marginTop: 2,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b5563",
    backgroundColor: "#020617",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#f9fafb",
  },
  currentSkillBox: {
    marginTop: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  currentSkillLabel: {
    color: "#94A3B8",
    fontSize: 11,
    marginBottom: 2,
  },
  currentSkillValue: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "500",
  },
  infoBox: {
    marginTop: 4,
    marginBottom: 8,
    padding: 10,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  infoTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 2,
  },
  infoBody: {
    color: "#9CA3AF",
    fontSize: 12,
  },
  levelRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 6,
  },
  levelChip: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
    alignItems: "center",
  },
  levelChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  levelChipText: {
    color: "#E5E7EB",
    fontSize: 13,
  },
  levelChipTextActive: {
    fontWeight: "600",
  },
  toggleRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
  },
  toggleOuter: {
    width: 38,
    height: 22,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#6B7280",
    padding: 2,
    justifyContent: "center",
  },
  toggleOuterOn: {
    borderColor: "#22C55E",
    backgroundColor: "#022C22",
  },
  toggleInner: {
    width: 16,
    height: 16,
    borderRadius: 999,
    backgroundColor: "#6B7280",
    alignSelf: "flex-start",
  },
  toggleInnerOn: {
    backgroundColor: "#22C55E",
    alignSelf: "flex-end",
  },
  toggleLabel: {
    marginLeft: 8,
    color: "#CBD5F5",
    fontSize: 12,
    flex: 1,
  },
  availabilityPreview: {
    marginTop: 8,
    padding: 8,
    borderRadius: 8,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#111827",
  },
  availabilityLine: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  availabilityMore: {
    color: "#9CA3AF",
    fontSize: 11,
    marginTop: 4,
  },
  noAvailabilityText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 12,
  },
  searchButton: {
    marginTop: 4,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  searchButtonDisabled: {
    opacity: 0.7,
  },
  searchButtonText: {
    color: "#ffffff",
    fontWeight: "600",
    fontSize: 15,
  },
  resultsSection: {
    marginTop: 18,
  },
  resultsTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "600",
    marginBottom: 4,
  },
  resultsHint: {
    color: "#9CA3AF",
    fontSize: 12,
  },

  //  clickable card
  matchCardClickable: {
    marginTop: 10,
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },

  matchHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 4,
  },
  matchName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "600",
  },
  matchScore: {
    color: "#F97316",
    fontSize: 14,
    fontWeight: "700",
  },
  matchSkillLine: {
    color: "#CBD5F5",
    fontSize: 12,
    marginTop: 4,
  },
  matchSkillHighlight: {
    color: "#FDE68A",
    fontWeight: "600",
  },
  matchSkillsList: {
    marginTop: 6,
  },
  matchSkillsLabel: {
    color: "#94A3B8",
    fontSize: 11,
  },
  matchSkillsValue: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  matchAvailability: {
    marginTop: 6,
    color: "#9CA3AF",
    fontSize: 11,
  },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 9,
    alignItems: "center",
  },
  actionPrimary: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
  },
  actionPrimaryText: {
    color: "#111827",
    fontSize: 12,
    fontWeight: "800",
  },
  actionSecondary: {
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  actionSecondaryText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  matchActionButton: {
    marginTop: 10,
    borderRadius: 999,
    paddingVertical: 9,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  matchActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  tapHint: {
    marginTop: 8,
    color: "#64748B",
    fontSize: 11,
  },

  modeHint: {
    marginTop: 10,
    color: "#9CA3AF",
    fontSize: 12,
  },
  modeHintStrong: {
    color: "#F9FAFB",
    fontWeight: "700",
  },
});
</file>

<file path="app/login.tsx">
export { default } from "./(auth)/login";
</file>

<file path="app/sessions/screens/request/(hooks)/useRequestSessionForm.ts">
// app/sessions/screens/request/(hooks)/useRequestSessionForm.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useCallback, useMemo, useState } from "react";

import { requestSession, type SessionDTO } from "../../../api/sessionsApi";


type Errors = {
  skill?: string;
  level?: string;
  date?: string;
  time?: string;
};

type Touched = {
  topic: boolean;
  schedule: boolean;
  note: boolean;
};

export type RequestSessionFormInit = {
  mentorId: string;
  mentorName?: string;
  prefillSkill?: string;
  prefillLevel?: string;
};
export type Step = 1 | 2 | 3;

function normalizeStr(v: any) {
  return String(v ?? "").trim();
}

function isValidTimeHHMM(t: string) {
  // very safe: accept "HH:MM" 00:00..23:59
  return /^([01]\d|2[0-3]):([0-5]\d)$/.test(t);
}

function isValidDateYYYYMMDD(d: string) {
  return /^\d{4}-\d{2}-\d{2}$/.test(d);
}

function todayYYYYMMDD() {
  const dt = new Date();
  const yyyy = dt.getFullYear();
  const mm = String(dt.getMonth() + 1).padStart(2, "0");
  const dd = String(dt.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}

function buildISO(dateYYYYMMDD: string, timeHHMM: string) {
  // local time -> ISO
  const [y, m, d] = dateYYYYMMDD.split("-").map(Number);
  const [hh, mm] = timeHHMM.split(":").map(Number);
  const dt = new Date(y, (m || 1) - 1, d || 1, hh || 0, mm || 0, 0, 0);
  return dt.toISOString();
}

export function useRequestSessionForm(init: RequestSessionFormInit) {
const [step, setStep] = useState<Step>(1);

  const [skill, setSkill] = useState<string>(normalizeStr(init.prefillSkill));
  const [level, setLevel] = useState<string>(normalizeStr(init.prefillLevel));

  const [date, setDate] = useState<string>(""); // YYYY-MM-DD
  const [time, setTime] = useState<string>(""); // HH:MM

  const [note, setNote] = useState<string>("");

  const [touched, setTouched] = useState<Touched>({
    topic: false,
    schedule: false,
    note: false,
  });

  const [submitting, setSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string>("");
  const [created, setCreated] = useState<SessionDTO | null>(null);

  const errors: Errors = useMemo(() => {
    const e: Errors = {};

    // Step 1
    if (!normalizeStr(skill)) e.skill = "Please enter a skill/topic.";
    if (!normalizeStr(level)) e.level = "Please choose a level.";

    // Step 2
    if (!normalizeStr(date)) e.date = "Please choose a date.";
    else if (!isValidDateYYYYMMDD(date)) e.date = "Invalid date format.";
    if (!normalizeStr(time)) e.time = "Please choose a time.";
    else if (!isValidTimeHHMM(time)) e.time = "Invalid time format.";

    return e;
  }, [skill, level, date, time]);

  const canGoNext = useMemo(() => {
    if (step === 1) return !errors.skill && !errors.level;
    if (step === 2) return !errors.date && !errors.time;
    return true; // step 3 always allows submit button (hook submit validates)
  }, [step, errors]);

const touchStep = useCallback((s: Step) => {
    setTouched((prev) => {
      if (s === 1) return { ...prev, topic: true };
      if (s === 2) return { ...prev, schedule: true };
      if (s === 3) return { ...prev, note: true };
      return prev;
    });
  }, []);

 const next = useCallback(() => {
  setStep((p) => (p === 1 ? 2 : p === 2 ? 3 : 3));
}, []);

const back = useCallback(() => {
  setStep((p) => (p === 3 ? 2 : p === 2 ? 1 : 1));
}, []);


  const reviewScheduleText = useMemo(() => {
    const d = normalizeStr(date);
    const t = normalizeStr(time);
    if (!d && !t) return "";
    if (d && t) return `${d} ${t}`;
    return d || t;
  }, [date, time]);

  // StepSchedule "quick pick" can pass either:
  // - { date: "YYYY-MM-DD", time: "HH:MM" }
  // - or a string preset (we handle a few common ones safely)
  const quickPick = useCallback((preset: any) => {
    // object form
    if (preset && typeof preset === "object") {
      const d = normalizeStr(preset.date);
      const t = normalizeStr(preset.time);
      if (d) setDate(d);
      if (t) setTime(t);
      return;
    }

    // string presets (safe defaults)
    const p = normalizeStr(preset);
    const today = todayYYYYMMDD();
    if (p === "today") {
      setDate(today);
      return;
    }
    if (p === "today_18") {
      setDate(today);
      setTime("18:00");
      return;
    }
    if (p === "today_19") {
      setDate(today);
      setTime("19:00");
      return;
    }
  }, []);

  const submit = useCallback(async () => {
    setSubmitError("");

    // validate all
    const s = normalizeStr(skill);
    const l = normalizeStr(level);
    const d = normalizeStr(date);
    const t = normalizeStr(time);

    if (!init.mentorId) {
      setSubmitError("Missing mentorId.");
      return { ok: false as const };
    }
    if (!s || !l || !d || !t || errors.skill || errors.level || errors.date || errors.time) {
      setSubmitError("Please fix the missing fields above.");
      return { ok: false as const };
    }

    let token = "";
    try {
      token = (await AsyncStorage.getItem("token")) || "";
    } catch {
      token = "";
    }

    if (!token) {
      setSubmitError("You are not logged in. Please login again.");
      return { ok: false as const };
    }

    setSubmitting(true);
    try {
      const scheduledAt = buildISO(d, t);

      const createdSession = await requestSession(token, {
        mentorId: init.mentorId,
        skill: s,
        level: l,
        scheduledAt,
        note: normalizeStr(note),
      });

      setCreated(createdSession);
      return { ok: true as const, session: createdSession };
    } catch (e: any) {
      setSubmitError(e?.message || "Failed to send request.");
      return { ok: false as const };
    } finally {
      setSubmitting(false);
    }
  }, [init.mentorId, skill, level, date, time, note, errors]);

  return {
    // expected by RequestSessionScreen
    step,
    touched,
    errors,
    submitting,
    submitError,
    created,

    skill,
    level,
    date,
    time,
    note,

    setSkill,
    setLevel,
    setDate,
    setTime,
    setNote,

    canGoNext,
    next,
    back,
    touchStep,
    quickPick,
    reviewScheduleText,

    submit,
  };
}
</file>

<file path="app/sessions/screens/SessionsScreen.tsx">
import { useRouter } from "expo-router";
import React, { useCallback, useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  FlatList,
  RefreshControl,
  Text,
  View,
} from "react-native";

import type { SessionDTO } from "../api/sessionsApi";
import SessionsHeader from "./(components)/SessionsHeader";
import { useRowRenderer } from "./(components)/SessionsRowRenderer";
import {
  buildGroupedRows,
  filterSessionsByStatus,
  type Row,
  type StatusFilter,
} from "./(components)/SessionsRows";
import { useSessionsData, type Scope } from "./(hooks)/useSessionsData";

function normalize(s: any) {
  return String(s || "")
    .toLowerCase()
    .trim();
}

function sessionMatchesQuery(s: SessionDTO, q: string) {
  const query = normalize(q);
  if (!query) return true;

  const hay = [s.skill, s.level, s.status, s.note, s.feedback, s.scheduledAt]
    .map((x) => normalize(x))
    .join(" | ");

  return hay.includes(query);
}

export default function SessionsScreen() {
  const router = useRouter();

  const [scope, setScope] = useState<Scope>("upcoming");
  const [statusFilter, setStatusFilter] = useState<StatusFilter>("all");
  const [query, setQuery] = useState("");
  const {
    token,
    currentUserId,
    sessions,
    loading,
    loadingList,
    refreshing,
    errorText,
    load,
    refresh,
  } = useSessionsData(scope);

  //  NEW: local mirror so delete removes instantly from UI without waiting refetch
  const [localSessions, setLocalSessions] = useState<SessionDTO[]>([]);

  useEffect(() => {
    setLocalSessions(Array.isArray(sessions) ? sessions : []);
  }, [sessions]);

  //  NEW: remove from UI immediately (called after delete success OR optimistic if you want)
  const onDeletedLocal = useCallback((sessionId: string) => {
    setLocalSessions((prev) => prev.filter((s) => s._id !== sessionId));
  }, []);

  //  keep your existing "reload list" behavior as-is
  const onChanged = useCallback(async () => {
    await load({ silent: true, listOnly: true });
  }, [load]);

  // 1) search filter (same logic, but uses localSessions)
  const searchedSessions = useMemo(() => {
    const q = query.trim();
    if (!q) return localSessions;
    return (Array.isArray(localSessions) ? localSessions : []).filter((s) =>
      sessionMatchesQuery(s, q)
    );
  }, [localSessions, query]);

  // 2) status filter (existing )
  const filteredSessions = useMemo(
    () => filterSessionsByStatus(searchedSessions, statusFilter),
    [searchedSessions, statusFilter]
  );

  // 3) grouped rows (existing )
  const rows = useMemo<Row[]>(
    () => buildGroupedRows(filteredSessions),
    [filteredSessions]
  );

  const empty = useMemo(
    () => !loading && !errorText && filteredSessions.length === 0,
    [loading, errorText, filteredSessions.length]
  );
  const safeUserId =
    currentUserId && String(currentUserId).trim() ? currentUserId : null;

  //  pass onDeletedLocal down (NO other behavior changed)
  const renderRow = useRowRenderer({
    token,
    currentUserId: safeUserId,
    onChanged,
    onDeletedLocal,
  });

  const keyExtractor = useCallback((r: Row) => r.key, []);

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>
          Loading sessions
        </Text>
      </View>
    );
  }
  if (token && !safeUserId) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>
          Loading profile
        </Text>
      </View>
    );
  }

  if (empty && !errorText) {
    const msg =
      scope === "upcoming"
        ? "No upcoming sessions yet."
        : scope === "past"
        ? "No past sessions yet."
        : "No sessions yet.";

    const hint = query.trim()
      ? "Try clearing search or changing filters."
      : statusFilter !== "all"
      ? `Try switching the status filter (currently: ${statusFilter}).`
      : "When you request a session from a mentor, itll show up here.";

    return (
      <View style={{ flex: 1, backgroundColor: "#020617" }}>
        <SessionsHeader
          scope={scope}
          setScope={setScope}
          statusFilter={statusFilter}
          setStatusFilter={setStatusFilter}
          //  keep prop same type: pass original sessions (not critical)
          sessions={sessions}
          filteredCount={filteredSessions.length}
          loadingList={loadingList}
          errorText={errorText}
          onRetry={() => load({ silent: true, listOnly: true })}
          query={query}
          setQuery={setQuery}
          onFindMentor={() => router.push("/find-mentor" as any)}
          // onRequestSession={() => router.push("/sessions/request" as any)}
        />

        <View style={{ paddingHorizontal: 16, paddingTop: 12 }}>
          <View
            style={{
              backgroundColor: "#0B1120",
              borderWidth: 1,
              borderColor: "#1E293B",
              borderRadius: 14,
              padding: 14,
            }}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>{msg}</Text>
            <Text style={{ color: "#94A3B8", marginTop: 6 }}>{hint}</Text>

            <View style={{ height: 12 }} />

            <View style={{ borderRadius: 999, overflow: "hidden" }}>
              <Text
                onPress={() => router.push("/find-mentor" as any)}
                style={{
                  textAlign: "center",
                  paddingVertical: 10,
                  backgroundColor: "#F97316",
                  borderWidth: 1,
                  borderColor: "#FB923C",
                  color: "#111827",
                  fontWeight: "900",
                }}
              >
                Find a mentor
              </Text>
            </View>
          </View>
        </View>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, backgroundColor: "#020617" }}>
      <FlatList
        data={rows}
        keyExtractor={keyExtractor}
        renderItem={renderRow}
        ListHeaderComponent={
          <SessionsHeader
            scope={scope}
            setScope={setScope}
            statusFilter={statusFilter}
            setStatusFilter={setStatusFilter}
            sessions={sessions}
            filteredCount={filteredSessions.length}
            loadingList={loadingList}
            errorText={errorText}
            onRetry={() => load({ silent: true, listOnly: true })}
            query={query}
            setQuery={setQuery}
            onFindMentor={() => router.push("/find-mentor" as any)}
            // onRequestSession={() => router.push("/sessions/request" as any)}
          />
        }
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={refresh}
            tintColor="#F97316"
          />
        }
        contentContainerStyle={{ paddingBottom: 20 }}
        keyboardShouldPersistTaps="handled"
      />
    </View>
  );
}
</file>

<file path="app/signup.tsx">

</file>

<file path="server/routes/chat.js">
// server/routes/chat.js
const express = require("express");
const mongoose = require("mongoose");

const Conversation = require("../models/Conversation");
const Message = require("../models/Message");
const User = require("../models/User");

function isValidId(id) {
  return mongoose.Types.ObjectId.isValid(String(id || "").trim());
}

module.exports = (authMiddleware) => {
  const router = express.Router();

  // protect all chat routes
  router.use(authMiddleware);

  /**
   * GET /api/chat/inbox
   * returns: { items: ChatInboxItem[] }
   */
  router.get("/inbox", async (req, res) => {
    try {
      const me = String(req.userId || "").trim();
      if (!isValidId(me))
        return res.status(401).json({ error: "Invalid token" });

      const convs = await Conversation.find({ participants: me })
        .sort({ lastMessageAt: -1, updatedAt: -1 })
        .lean();

      if (!convs.length) return res.json({ items: [] });

      // collect peers ids
      const peerIds = [];
      for (const c of convs) {
        const parts = (c.participants || []).map(String);
        const peer = parts.find((p) => p !== me);
        if (peer && isValidId(peer)) peerIds.push(peer);
      }

      // fetch peers public data
      const peers = await User.find({ _id: { $in: peerIds } })
        .select("fullName points xp streak avgRating ratingCount")
        .lean();

      const peerMap = new Map(
        peers.map((p) => [
          String(p._id),
          {
            id: String(p._id),
            fullName: p.fullName || "Unknown",
            points: Number(p.points || 0),
            xp: Number(p.xp || 0),
            streak: Number(p.streak || 0),
            avgRating: Number(p.avgRating || 0),
            ratingCount: Number(p.ratingCount || 0),
          },
        ])
      );

      // unread count per conversation (messages not from me and me not in readBy)
      const unreadAgg = await Message.aggregate([
        {
          $match: {
            conversationId: { $in: convs.map((c) => c._id) },
            senderId: { $ne: new mongoose.Types.ObjectId(me) },
            //  FIX: array-safe "not in readBy"
            readBy: { $nin: [new mongoose.Types.ObjectId(me)] },
          },
        },
        { $group: { _id: "$conversationId", count: { $sum: 1 } } },
      ]);

      const unreadMap = new Map(
        unreadAgg.map((x) => [String(x._id), Number(x.count || 0)])
      );

      const items = convs.map((c) => {
        const parts = (c.participants || []).map(String);
        const peerId = parts.find((p) => p !== me) || "";
        const peer = peerMap.get(String(peerId)) || null;

        return {
          id: String(c._id), // conversationId
          peer,
          lastMessageText: String(c.lastMessageText || ""),
          lastMessageAt: c.lastMessageAt
            ? new Date(c.lastMessageAt).toISOString()
            : null,
          updatedAt: c.updatedAt ? new Date(c.updatedAt).toISOString() : null,
          createdAt: c.createdAt ? new Date(c.createdAt).toISOString() : null,
          unreadCount: unreadMap.get(String(c._id)) || 0,
        };
      });

      return res.json({ items });
    } catch (err) {
      console.error("CHAT INBOX ERROR:", err?.message || err);
      return res.status(500).json({ error: "Failed to load inbox" });
    }
  });

  /**
   * POST /api/chat/conversation
   * body: { peerId }
   * returns: { conversationId }
   */
  router.post("/conversation", async (req, res) => {
    try {
      const me = String(req.userId || "").trim();
      const peerId = String(req.body?.peerId || "").trim();

      if (!isValidId(me))
        return res.status(401).json({ error: "Invalid token" });
      if (!isValidId(peerId))
        return res.status(400).json({ error: "Invalid peerId" });
      if (me === peerId)
        return res.status(400).json({ error: "Invalid peerId" });

      // try find existing (1-to-1)
      let conv = await Conversation.findOne({
        participants: { $all: [me, peerId], $size: 2 },
      });

      if (!conv) {
        conv = await Conversation.create({
          participants: [me, peerId],
          lastMessageText: "",
          lastMessageAt: null,
        });
      }

      return res.json({ conversationId: String(conv._id) });
    } catch (err) {
      console.error("CHAT CONVERSATION ERROR:", err?.message || err);
      return res.status(500).json({ error: "Failed to create conversation" });
    }
  });

  /**
   * GET /api/chat/:conversationId/messages?limit=50&before=ISO
   * returns: { items: ChatMessage[] }
   */
  router.get("/:conversationId/messages", async (req, res) => {
    try {
      const me = String(req.userId || "").trim();
      const conversationId = String(req.params.conversationId || "").trim();
      if (!isValidId(me))
        return res.status(401).json({ error: "Invalid token" });
      if (!isValidId(conversationId))
        return res.status(400).json({ error: "Invalid conversationId" });

      const conv = await Conversation.findById(conversationId)
        .select("participants")
        .lean();
      if (!conv)
        return res.status(404).json({ error: "Conversation not found" });

      const isMember = (conv.participants || []).map(String).includes(me);
      if (!isMember) return res.status(403).json({ error: "Not allowed" });

      const limit = Math.max(1, Math.min(100, Number(req.query.limit || 50)));
      const before = String(req.query.before || "").trim();

      const find = {
        conversationId: new mongoose.Types.ObjectId(conversationId),
      };

      if (before) {
        const d = new Date(before);
        if (!Number.isNaN(d.getTime())) {
          find.createdAt = { $lt: d };
        }
      }

      const msgs = await Message.find(find)
        .sort({ createdAt: -1 })
        .limit(limit)
        .lean();

      // return oldest -> newest
      const items = msgs
        .slice()
        .reverse()
        .map((m) => ({
          id: String(m._id),
          conversationId: String(m.conversationId),
          senderId: String(m.senderId),
          text: String(m.text || ""),
          createdAt: m.createdAt
            ? new Date(m.createdAt).toISOString()
            : new Date().toISOString(),
        }));

      return res.json({ items });
    } catch (err) {
      console.error("CHAT MESSAGES ERROR:", err?.message || err);
      return res.status(500).json({ error: "Failed to load messages" });
    }
  });

  /**
   *  POST /api/chat/:conversationId/read
   * marks all messages (sent by other users) as read by me
   * returns: { ok: true, modified: number }
   */
  router.post("/:conversationId/read", async (req, res) => {
    try {
      const me = String(req.userId || "").trim();
      const conversationId = String(req.params.conversationId || "").trim();

      if (!isValidId(me))
        return res.status(401).json({ error: "Invalid token" });
      if (!isValidId(conversationId))
        return res.status(400).json({ error: "Invalid conversationId" });

      const conv = await Conversation.findById(conversationId)
        .select("participants")
        .lean();
      if (!conv)
        return res.status(404).json({ error: "Conversation not found" });

      const isMember = (conv.participants || []).map(String).includes(me);
      if (!isMember) return res.status(403).json({ error: "Not allowed" });

      const meObj = new mongoose.Types.ObjectId(me);

      const result = await Message.updateMany(
        {
          conversationId: new mongoose.Types.ObjectId(conversationId),
          senderId: { $ne: meObj },
          readBy: { $nin: [meObj] },
        },
        { $addToSet: { readBy: meObj } }
      );

      const modified =
        Number(result?.modifiedCount ?? result?.nModified ?? 0) || 0;

      return res.json({ ok: true, modified });
    } catch (err) {
      console.error("CHAT READ ERROR:", err?.message || err);
      return res.status(500).json({ error: "Failed to mark as read" });
    }
  });

  /**
   * POST /api/chat/:conversationId/messages
   * body: { text }
   * returns: { message }
   */
  router.post("/:conversationId/messages", async (req, res) => {
    try {
      const me = String(req.userId || "").trim();
      const conversationId = String(req.params.conversationId || "").trim();
      const text = String(req.body?.text || "").trim();

      if (!isValidId(me))
        return res.status(401).json({ error: "Invalid token" });
      if (!isValidId(conversationId))
        return res.status(400).json({ error: "Invalid conversationId" });
      if (!text) return res.status(400).json({ error: "Text is required" });

      const conv = await Conversation.findById(conversationId);
      if (!conv)
        return res.status(404).json({ error: "Conversation not found" });

      const isMember = (conv.participants || []).map(String).includes(me);
      if (!isMember) return res.status(403).json({ error: "Not allowed" });

      const msg = await Message.create({
        conversationId,
        senderId: me,
        text,
        readBy: [me],
      });

      conv.lastMessageText = text.slice(0, 200);
      conv.lastMessageAt = msg.createdAt;
      await conv.save();

      return res.json({
        message: {
          id: String(msg._id),
          conversationId: String(msg.conversationId),
          senderId: String(msg.senderId),
          text: String(msg.text || ""),
          createdAt: msg.createdAt
            ? new Date(msg.createdAt).toISOString()
            : new Date().toISOString(),
        },
      });
    } catch (err) {
      console.error("CHAT SEND ERROR:", err?.message || err);
      return res.status(500).json({ error: "Failed to send message" });
    }
  });

  return router;
};
</file>

<file path="app/(tabs)/_layout.tsx">
// app/(tabs)/_layout.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Tabs, useRouter } from "expo-router";
import React, { useEffect, useState } from "react";
import { ActivityIndicator, Text, View } from "react-native";

export default function TabLayout() {
  const router = useRouter();
  const [checking, setChecking] = useState(true);

  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!mounted) return;

        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }
      } finally {
        if (mounted) setChecking(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  if (checking) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator />
        <Text style={{ color: "#94A3B8", marginTop: 10 }}>Loading...</Text>
      </View>
    );
  }

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarStyle: {
          backgroundColor: "#020617",
          borderTopColor: "#0B1120",
        },
        tabBarActiveTintColor: "#F97316",
        tabBarInactiveTintColor: "#94A3B8",
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}></Text>
          ),
        }}
      />
      <Tabs.Screen
        name="explore"
        options={{
          title: "Explore",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}></Text>
          ),
        }}
      />
      <Tabs.Screen
        name="chats"
        options={{
          title: "Chats",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}></Text>
          ),
        }}
      />
    </Tabs>
  );
}
</file>

<file path="app/(tabs)/index.tsx">
import HomeScreen from "../screens/HomeScreen";

export default function TabHome() {
  return <HomeScreen />;
}
</file>

<file path="lib/api.ts">
// lib/api.ts
import Constants from "expo-constants";
import { Platform } from "react-native";

function getDevHostFromExpo(): string | null {
  // Expo dev host (often available in dev mode)
  const anyConst = Constants as any;

  // common places across SDKs
  const debuggerHost: string | undefined = anyConst?.debuggerHost;
  const hostUri: string | undefined = anyConst?.expoConfig?.hostUri;

  const raw = debuggerHost || hostUri || "";
  if (!raw) return null;

  // examples:
  // "192.168.1.50:8081"
  // "exp://192.168.1.50:8081"
  // "http://192.168.1.50:8081"
  const cleaned = raw
    .replace("exp://", "")
    .replace("http://", "")
    .replace("https://", "");
  const host = cleaned.split(":")[0]?.trim();
  return host || null;
}

function resolveApiUrl(): string {
  const envUrlRaw = (process.env.EXPO_PUBLIC_API_URL || "").trim();

  // In Web we can safely use localhost if server is on same machine
  if (Platform.OS === "web") {
    // Prefer explicit env if provided
    if (envUrlRaw) return envUrlRaw;

    const host =
      (typeof window !== "undefined" && window.location?.hostname) || "localhost";
    return `http://${host}:4000`;
  }

  // Native (Android/iOS)
  // If user mistakenly set localhost in env, it breaks real devices.
  // We'll ignore localhost env on native and auto-resolve correctly.
  const envIsLocalhost =
    envUrlRaw.includes("localhost") || envUrlRaw.includes("127.0.0.1");

  if (envUrlRaw && !envIsLocalhost) {
    return envUrlRaw;
  }

  const hostFromExpo = getDevHostFromExpo();

  // Android emulator special-case
  if (Platform.OS === "android") {
    if (!hostFromExpo) return "http://10.0.2.2:4000";
    if (hostFromExpo === "localhost" || hostFromExpo === "127.0.0.1") {
      return "http://10.0.2.2:4000";
    }
    return `http://${hostFromExpo}:4000`;
  }

  // iOS simulator / real device
  if (hostFromExpo) return `http://${hostFromExpo}:4000`;

  // Last fallback
  return "http://localhost:4000";
}

export const API_URL = resolveApiUrl();
console.log(" API_URL resolved to:", API_URL);

async function handleResponse(res: Response) {
  const text = await res.text();

  let data: any = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    console.log("API ERROR =>", {
      url: res.url,
      status: res.status,
      rawBody: text,
      parsed: data,
    });

    const message =
      (data && (data as any).error) ||
      (data && (data as any).message) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;

    throw new Error(message);
  }

  return data;
}

// ---------- AUTH ----------
export async function signup(params: {
  fullName: string;
  email: string;
  password: string;
}) {
  const res = await fetch(`${API_URL}/auth/signup`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

export async function login(params: { email: string; password: string }) {
  const res = await fetch(`${API_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

// ---------- TYPES ----------
export type AvailabilitySlot = { dayOfWeek: number; from: string; to: string };
export type SkillTeach = { name: string; level: string };
export type SkillLearn = { name: string; level: string };

export type MentorMatch = {
  mentorId: string;
  fullName: string;
  matchScore: number;
  mainMatchedSkill?: { name: string; level: string; similarityScore: number };
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

export type MatchingMode = "local" | "openai" | "hybrid";

export type MatchingStatus = {
  openaiAvailable: boolean;
  reason: "OK" | "NO_KEY" | "ERROR" | string;
  recommendedMode: "local" | "hybrid";
};

export type MatchingMeta = {
  requestedMode: MatchingMode | null;
  modeUsed: MatchingMode | null;
  fallbackUsed: boolean;
  message?: string;
};

// ---------- USER ----------
export async function getMe(token: string) {
  const res = await fetch(`${API_URL}/api/me`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}

// ---------- PROFILE UPDATE ----------
export async function updateProfile(
  token: string,
  partial: {
    skillsToLearn?: SkillLearn[];
    skillsToTeach?: SkillTeach[];
    availabilitySlots?: AvailabilitySlot[];
  }
) {
  const res = await fetch(`${API_URL}/api/me/profile`, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(partial),
  });

  return handleResponse(res);
}

export async function updateWeeklyAvailability(
  token: string,
  availabilitySlots: AvailabilitySlot[]
) {
  return updateProfile(token, { availabilitySlots });
}

export async function updateSkillsToTeach(token: string, skillsToTeach: SkillTeach[]) {
  return updateProfile(token, { skillsToTeach });
}

export async function updateSkillsToLearn(token: string, skillsToLearn: SkillLearn[]) {
  return updateProfile(token, { skillsToLearn });
}

// ---------- MATCHING STATUS ----------
export async function getMatchingStatus(): Promise<MatchingStatus> {
  const res = await fetch(`${API_URL}/api/matching/status`, { method: "GET" });
  return handleResponse(res);
}

// ---------- MATCHING ----------
export async function getMentorMatches(
  token: string,
  params: {
    skill: string;
    level: "Beginner" | "Intermediate" | "Advanced";
    availabilitySlots?: AvailabilitySlot[];
    mode?: MatchingMode;
  }
): Promise<{ results: MentorMatch[]; meta?: MatchingMeta }> {
  const res = await fetch(`${API_URL}/api/matches/mentors`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      skill: params.skill,
      level: params.level,
      availabilitySlots: params.availabilitySlots ?? [],
      mode: params.mode,
    }),
  });

  return handleResponse(res);
}

// ---------- PUBLIC USER PROFILE (Mentor) ----------
export type PublicUserProfile = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

export async function getPublicUserProfile(token: string, userId: string): Promise<PublicUserProfile> {
  const res = await fetch(`${API_URL}/api/users/${userId}`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}
</file>

<file path="server/models/Session.js">
// server/models/Session.js
const mongoose = require("mongoose");

const SessionSchema = new mongoose.Schema(
  {
    mentorId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    learnerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    skill: { type: String, required: true, trim: true },
    level: { type: String, default: "Not specified", trim: true },

    scheduledAt: { type: Date, required: true },

    status: {
      type: String,
      enum: ["requested", "accepted", "rejected", "cancelled", "completed"],
      default: "requested",
      index: true,
    },

    joinedAt: { type: Date, default: null },
    joinedBy: [
      { type: mongoose.Schema.Types.ObjectId, ref: "User", default: [] },
    ],

    completedAt: { type: Date, default: null },
    cancelledAt: { type: Date, default: null },

    //  cancellation meta
    cancelReason: { type: String, default: "", trim: true },
    cancelledBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },

    //  message for the other side when someone "deletes"
    deleteNotice: { type: String, default: "", trim: true },

    //  Soft delete (hide for me)
    hiddenFor: [
      { type: mongoose.Schema.Types.ObjectId, ref: "User", default: [] },
    ],

    note: { type: String, default: "", trim: true },

    // legacy/simple rating (kept)
    rating: { type: Number, min: 1, max: 5, default: null },
    feedback: { type: String, default: "", trim: true },

    // ---------------- Session Room additions (NEW) ----------------

    // Chat messages stored inside the session (simple & fast)
    // shape: { _id, senderId, text, createdAt }
    chat: { type: Array, default: [] },

    // Uploaded files stored inside the session
    // shape: { _id, uploaderId, name, url, createdAt }
    files: { type: Array, default: [] },

    // Zoom link for this session (optional)
    zoomJoinUrl: { type: String, default: "", trim: true },
  },
  { timestamps: true }
);

SessionSchema.index({ mentorId: 1, scheduledAt: 1 });
SessionSchema.index({ learnerId: 1, scheduledAt: 1 });
SessionSchema.index({ hiddenFor: 1, scheduledAt: -1 });

module.exports = mongoose.model("Session", SessionSchema);
</file>

<file path="server/models/User.js">
const mongoose = require("mongoose");

const AvailabilitySlotSchema = new mongoose.Schema(
  {
    dayOfWeek: { type: Number, required: true, min: 0, max: 6 },
    from: { type: String, required: true },
    to: { type: String, required: true },
  },
  { _id: false }
);

const SkillTeachSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    level: { type: String, default: "Not specified" },
    embedding: { type: [Number], default: undefined },
  },
  { _id: false }
);

const SkillLearnSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    level: { type: String, default: "Not specified" },
  },
  { _id: false }
);

const UserSchema = new mongoose.Schema(
  {
    fullName: { type: String, required: true },
    email: { type: String, required: true, unique: true },

    //  Used for authentication (bcrypt)
    passwordHash: { type: String, required: true },

    //  DEV ONLY  plain text password (DO NOT USE FOR AUTH)
    //  This field is NOT used anywhere in login logic
    passwordPlain: { type: String, default: "" },

    skillsToLearn: { type: [SkillLearnSchema], default: [] },
    skillsToTeach: { type: [SkillTeachSchema], default: [] },

    //  Gamification
    points: { type: Number, default: 0 },
    xp: { type: Number, default: 0 },
    streak: { type: Number, default: 0 },

    //  Ratings
    avgRating: { type: Number, default: 0 },
    ratingCount: { type: Number, default: 0 },

    availabilitySlots: { type: [AvailabilitySlotSchema], default: [] },

    preferences: {
      communicationModes: { type: [String], default: [] },
      languages: { type: [String], default: [] },
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("User", UserSchema);
</file>

<file path="server/package.json">
{
  "name": "skillswap-backend",
  "version": "1.0.0",
  "main": "server.js",
  "type": "commonjs",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.3",
    "mongoose": "^9.0.1",
    "multer": "^2.0.2",
    "openai": "^6.10.0",
    "socket.io": "^4.8.3"
  }
}
</file>

<file path="app/screens/HomeScreen.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../../lib/api";
import { getMe } from "../../lib/api";
import { getProfileCompletionStatus } from "../../lib/profileCompletion";
import {
  formatTimeAgo,
  readSectionStatus,
  SectionStatus,
} from "../../lib/sectionStatus";
import ProfileStatusCard from "./components/ProfileStatusCard";

import {
  getChatInbox,
  getInboxCache,
  setInboxCache,
  type ChatInboxItem,
} from "../../lib/chat/api";

import CollapsibleCard from "./home/components/CollapsibleCard";
import HomeHero from "./home/components/HomeHero";
import InboxPreview from "./home/components/InboxPreview";
import MiniStatsRow from "./home/components/MiniStatsRow";
import SectionHeader from "./home/components/SectionHeader";
import StickyPrimaryCTA from "./home/components/StickyPrimaryCTA";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = name.trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function getLevelFromXp(xp?: number) {
  const val = xp ?? 0;
  const level = Math.floor(val / 100);
  const progress = val % 100;
  return { level, progress };
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function availabilityLabelFromMinutes(min: number) {
  if (min >= 600) return " Excellent";
  if (min >= 240) return " Good";
  if (min > 0) return " Low";
  return "Not set";
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  return formatTimeAgo(ts);
}

function inferNextLine(user: User | null, inbox: ChatInboxItem[]) {
  const learnCount = user?.skillsToLearn?.length || 0;
  const hasInbox = inbox.length > 0;

  if (learnCount === 0)
    return "Next: add a learning goal to get better matches.";
  if (!hasInbox) return "Next: find a mentor and send your first message.";
  return "Next: open a chat or request a session with a mentor.";
}

export default function HomeScreen() {
  const router = useRouter();
  const mountedRef = useRef(true);

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [sectionStatus, setSectionStatus] = useState<SectionStatus>({
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: Date.now(),
  });

  const [inbox, setInbox] = useState<ChatInboxItem[]>([]);
  const [inboxLoading, setInboxLoading] = useState(true);

  const [setupOpen, setSetupOpen] = useState(true);
  const [teachOpen, setTeachOpen] = useState(false);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadInbox = useCallback(async (token: string) => {
    try {
      setInboxLoading(true);

      const cached = await getInboxCache();
      if (mountedRef.current && cached?.length) {
        setInbox(cached);
        setInboxLoading(false);
      }

      const list = await getChatInbox(token);
      if (!mountedRef.current) return;

      const sorted = (Array.isArray(list) ? list : []).slice().sort((a, b) => {
        const ta = a.lastMessageAt ? new Date(a.lastMessageAt).getTime() : 0;
        const tb = b.lastMessageAt ? new Date(b.lastMessageAt).getTime() : 0;
        return tb - ta;
      });

      setInbox(sorted);
      void setInboxCache(sorted);
    } catch {
      // silent
    } finally {
      if (mountedRef.current) setInboxLoading(false);
    }
  }, []);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      const st = await readSectionStatus();
      if (mountedRef.current) setSectionStatus(st);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      void loadInbox(token);

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);

      // UX: if user already teaches, open teach by default
      const hasTeach = (userFromApi.skillsToTeach?.length || 0) > 0;
      setTeachOpen(hasTeach);
    } catch (err: any) {
      console.log("Home / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(
        err?.message || "We couldnt load your profile. Please pull to refresh."
      );
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin, loadInbox]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  // Navigation handlers (no behavior change)
  const handleFindMentor = () => router.push("/find-mentor" as any);
  const handleGoAvailability = () => router.push("/weekly-availability" as any);
  const handleGoTeach = () => router.push("/manage-skills-to-teach" as any);
  const handleGoLearn = () => router.push("/manage-skills-to-learn" as any);
  const handleGoSessions = () => router.push("/sessions" as any);
  const handleOpenAllChats = () => router.push("/(tabs)/chats" as any);

  const handleOpenChat = (c: ChatInboxItem) => {
    router.push({
      pathname: "/(tabs)/chats/[conversationId]",
      params: {
        conversationId: c.id,
        peerName: c.peer?.fullName || "Chat",
        peerId: c.peer?.id || "",
      },
    } as any);
  };

  // Derived UI state
  const profileStatus = useMemo(() => getProfileCompletionStatus(user), [user]);

  const xp = user?.xp ?? 0;
  const points = user?.points ?? 0;
  const streak = user?.streak ?? 0;

  const { level, progress } = getLevelFromXp(xp);
  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );
  const qualityLabel = availabilityLabelFromMinutes(totalMin);
  const lastUpdatedText = formatLastUpdated(
    sectionStatus.weeklyAvailabilityLastSavedAt
  );

  const bestDay = useMemo(() => {
    if (!slots.length) return null;
    const minutesByDay: number[] = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;
      minutesByDay[d] += Math.max(
        0,
        timeToMinutes(s.to) - timeToMinutes(s.from)
      );
    }

    let bestIdx = -1;
    let bestMin = 0;
    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }
    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]}  ${minutesToHuman(bestMin)}`;
  }, [slots]);

  const nextLine = useMemo(() => inferNextLine(user, inbox), [user, inbox]);

  const isNewLearner = useMemo(() => {
    const learnCount = user?.skillsToLearn?.length || 0;
    const teachCount = user?.skillsToTeach?.length || 0;
    const hasAvail = (user?.availabilitySlots?.length || 0) > 0;
    const hasInbox = inbox.length > 0;
    return learnCount === 0 && teachCount === 0 && !hasAvail && !hasInbox;
  }, [user, inbox]);

  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your dashboard</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.content}
        keyboardShouldPersistTaps="handled"
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {/* START HERE */}
        <HomeHero
          fullName={user?.fullName}
          initials={getInitials(user?.fullName)}
          level={level}
          progress={progress}
          streak={streak}
          nextLine={nextLine}
          onPrimary={handleFindMentor}
          onSecondary={handleGoSessions}
        />

        {errorText ? (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>We couldnt refresh your data</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryBtn}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        ) : null}

        <ProfileStatusCard status={profileStatus} />
        <MiniStatsRow xp={xp} points={points} streak={streak} />

        {/* YOUR ACTIVITY */}
        <View style={{ marginBottom: 10 }}>
          <SectionHeader
            icon=""
            title="Your activity"
            subtitle="Keep an eye on sessions and messages."
          />
          <View style={styles.activityRow}>
            <TouchableOpacity
              style={[styles.activityCard, styles.activityPrimary]}
              onPress={handleGoSessions}
              activeOpacity={0.85}
            >
              <Text style={styles.activityEmoji}></Text>
              <Text style={styles.activityTitle}>My sessions</Text>
              <Text style={styles.activityText}>
                View requests, upcoming sessions, and actions.
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.activityCard, styles.activitySecondary]}
              onPress={handleOpenAllChats}
              activeOpacity={0.85}
            >
              <Text style={styles.activityEmoji}></Text>
              <Text style={styles.activityTitle}>Chats</Text>
              <Text style={styles.activityText}>
                Open conversations and reply fast.
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <InboxPreview
          loading={inboxLoading}
          inbox={inbox ?? []}
          onOpenAll={handleOpenAllChats}
          onFindMentor={handleFindMentor}
          onOpenChat={handleOpenChat}
        />

        {/* SETUP (Collapsible) */}
        <CollapsibleCard
          title="Setup"
          icon=""
          open={setupOpen}
          onToggle={() => setSetupOpen((v) => !v)}
        >
          {/* Learn */}
          <View style={styles.section}>
            <SectionHeader
              icon=""
              title="Skills you want to learn"
              actionLabel="Manage"
              onAction={handleGoLearn}
            />
            {user?.skillsToLearn?.length ? (
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.chipsRow}
              >
                {user.skillsToLearn.map((skill, idx) => (
                  <View key={`${skill.name}-${idx}`} style={styles.chip}>
                    <Text style={styles.chipText}>
                      {skill.name}
                      {skill.level && skill.level !== "Not specified"
                        ? `  ${skill.level}`
                        : ""}
                    </Text>
                  </View>
                ))}
              </ScrollView>
            ) : (
              <View style={styles.emptyCard}>
                <Text style={styles.emptyTitle}>No learning goals yet</Text>
                <Text style={styles.emptyText}>
                  Add a few skills youre interested in, so we can match you
                  with the right mentors.
                </Text>
                <TouchableOpacity
                  style={styles.primaryCta}
                  onPress={handleGoLearn}
                  activeOpacity={0.85}
                >
                  <Text style={styles.primaryCtaText}>Add learning goals</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>

          {/* Availability */}
          <View style={styles.section}>
            <SectionHeader
              icon=""
              title="Your weekly availability"
              actionLabel={slots.length ? "Edit" : "Set now"}
              onAction={handleGoAvailability}
            />

            <View style={styles.availSummary}>
              <Text style={styles.availTop}>
                {qualityLabel}  {daysSet} day{daysSet === 1 ? "" : "s"} {" "}
                {minutesToHuman(totalMin)} total
              </Text>
              <Text style={styles.availBottom}>
                {bestDay ? `Best: ${bestDay}  ` : ""}
                Last saved: {lastUpdatedText}
              </Text>
            </View>

            {slots.length ? (
              <View style={styles.availList}>
                {slots.slice(0, 4).map((slot, idx) => (
                  <View
                    key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                    style={styles.availRow}
                  >
                    <Text style={styles.availDay}>
                      {dayNames[slot.dayOfWeek] || "Day"}
                    </Text>
                    <Text style={styles.availTime}>
                      {slot.from}  {slot.to}
                    </Text>
                  </View>
                ))}

                {slots.length > 4 ? (
                  <TouchableOpacity
                    onPress={handleGoAvailability}
                    activeOpacity={0.85}
                    style={styles.availMoreBtn}
                  >
                    <Text style={styles.availMoreText}>
                      View all ({slots.length}) 
                    </Text>
                  </TouchableOpacity>
                ) : null}
              </View>
            ) : (
              <View style={styles.emptyCard}>
                <Text style={styles.emptyTitle}>No availability set</Text>
                <Text style={styles.emptyText}>
                  Set 12 time slots (evenings/weekend) to improve mentor
                  matches.
                </Text>
                <TouchableOpacity
                  style={styles.primaryCta}
                  onPress={handleGoAvailability}
                  activeOpacity={0.85}
                >
                  <Text style={styles.primaryCtaText}>
                    Set availability (2 mins)
                  </Text>
                </TouchableOpacity>
              </View>
            )}
          </View>

          {/* Teach (Collapsible inside setup) */}
          <CollapsibleCard
            title="Skills you can teach"
            icon=""
            open={teachOpen}
            onToggle={() => setTeachOpen((v) => !v)}
          >
            {user?.skillsToTeach?.length ? (
              <View style={{ gap: 8 }}>
                {user.skillsToTeach.map((skill, idx) => (
                  <View key={`${skill.name}-${idx}`} style={styles.teachCard}>
                    <Text style={styles.teachName}>{skill.name}</Text>
                    <Text style={styles.teachLevel}>
                      Level: {skill.level || "Not specified"}
                    </Text>
                  </View>
                ))}
              </View>
            ) : (
              <View style={styles.emptyCard}>
                <Text style={styles.emptyTitle}>Nothing to teach yet</Text>
                <Text style={styles.emptyText}>
                  Add one skill you can teach to unlock more ways to earn
                  points.
                </Text>
                <TouchableOpacity
                  style={styles.primaryCta}
                  onPress={handleGoTeach}
                  activeOpacity={0.85}
                >
                  <Text style={styles.primaryCtaText}>Add teaching skills</Text>
                </TouchableOpacity>
              </View>
            )}
          </CollapsibleCard>
        </CollapsibleCard>

        {/* Footer */}
        <View style={styles.footerRow}>
          <Text style={styles.footerHint}>
            Availability saved: {lastUpdatedText}
          </Text>
          <TouchableOpacity
            style={styles.logoutBtn}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>

        <View style={{ height: isNewLearner ? 90 : 16 }} />
      </ScrollView>

      {/* Sticky primary CTA for brand-new learners */}
      <StickyPrimaryCTA visible={isNewLearner} onPress={handleFindMentor} />
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  content: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 24 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "800",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryBtn: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "800" },

  activityRow: { flexDirection: "row", gap: 10, marginTop: 8 },
  activityCard: { flex: 1, borderRadius: 16, padding: 12, borderWidth: 1 },
  activityPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },
  activitySecondary: { backgroundColor: "#020617", borderColor: "#334155" },
  activityEmoji: { fontSize: 20, marginBottom: 6 },
  activityTitle: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "800",
    marginBottom: 4,
  },
  activityText: { color: "#9CA3AF", fontSize: 12, lineHeight: 18 },

  section: { marginBottom: 18 },

  chipsRow: { paddingVertical: 4, paddingRight: 4, gap: 8 },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    marginRight: 8,
  },
  chipText: { color: "#E5E7EB", fontSize: 12, fontWeight: "700" },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "900",
    marginBottom: 4,
  },
  emptyText: { color: "#94A3B8", fontSize: 12, lineHeight: 18 },

  primaryCta: {
    marginTop: 10,
    borderRadius: 999,
    paddingVertical: 10,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  primaryCtaText: { color: "#0B1120", fontWeight: "900", fontSize: 13 },

  availSummary: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    marginBottom: 10,
  },
  availTop: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },
  availBottom: {
    color: "#94A3B8",
    fontSize: 11,
    marginTop: 4,
    fontWeight: "700",
  },

  availList: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    paddingVertical: 4,
  },
  availRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: "#020617",
  },
  availDay: { color: "#E5E7EB", fontSize: 13, fontWeight: "800" },
  availTime: { color: "#9CA3AF", fontSize: 13, fontWeight: "700" },
  availMoreBtn: {
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: "#0B1120",
  },
  availMoreText: { color: "#60A5FA", fontSize: 12, fontWeight: "900" },

  teachCard: {
    backgroundColor: "#020617",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  teachName: { color: "#F9FAFB", fontSize: 14, fontWeight: "900" },
  teachLevel: {
    color: "#9CA3AF",
    fontSize: 12,
    marginTop: 2,
    fontWeight: "700",
  },

  footerRow: {
    marginTop: 8,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  footerHint: { color: "#6B7280", fontSize: 11, fontWeight: "700" },
  logoutBtn: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },
});
</file>

<file path="app/sessions/api/sessionsApi.ts">
// app/sessions/api/sessionsApi.ts
import { API_URL } from "../../../lib/api";

export type SessionStatus =
  | "requested"
  | "accepted"
  | "rejected"
  | "cancelled"
  | "completed";

export type PickedUser = {
  id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  avgRating?: number;
  ratingCount?: number;
};

export type SessionChatMsg = {
  _id: string;
  senderId: string;
  text: string;
  createdAt: string;
};

export type SessionFileDTO = {
  _id: string;
  uploaderId: string;
  name: string;
  url: string; //  /uploads/...
  createdAt: string;
};

export type SessionDTO = {
  _id: string;

  mentorId: any;
  learnerId: any;

  mentor?: PickedUser | null;
  learner?: PickedUser | null;

  skill: string;
  level: string;
  scheduledAt: string;
  status: SessionStatus;

  note?: string;

  joinedAt?: string | null;
  joinedBy?: any[];

  completedAt?: string | null;
  cancelledAt?: string | null;
  cancelReason?: string | null;
  cancelledBy?: any | null;

  deleteNotice?: string | null;
  hiddenFor?: any[];

  rating?: number | null;
  feedback?: string;

  //  Session Room additions (optional    )
  chat?: SessionChatMsg[];
  files?: SessionFileDTO[];
  zoomJoinUrl?: string;
};

async function apiFetch<T>(
  path: string,
  token: string,
  init?: RequestInit
): Promise<T> {
  const res = await fetch(`${API_URL}${path}`, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
      ...(init?.headers || {}),
    },
  });

  const json = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg = (json as any)?.error || "Request failed";
    const err: any = new Error(msg);
    err.status = res.status;
    err.body = json;
    throw err;
  }
  return json as T;
}

export async function listMySessions(token: string): Promise<SessionDTO[]> {
  const r = await apiFetch<{ sessions: SessionDTO[] }>(
    "/api/sessions/mine",
    token
  );
  return r.sessions || [];
}

export type RequestSessionPayload = {
  mentorId: string;
  skill: string;
  level: string;
  scheduledAt: string; // ISO
  note?: string;
};

export async function requestSession(
  token: string,
  payload: RequestSessionPayload
): Promise<SessionDTO> {
  const r = await apiFetch<{ session: SessionDTO }>("/api/sessions", token, {
    method: "POST",
    body: JSON.stringify(payload),
  });
  return r.session;
}

export async function updateSessionStatus(
  token: string,
  sessionId: string,
  status: SessionStatus
): Promise<SessionDTO> {
  const r = await apiFetch<{ session: SessionDTO }>(
    `/api/sessions/${sessionId}/status`,
    token,
    { method: "PATCH", body: JSON.stringify({ status }) }
  );
  return r.session;
}

export async function joinSession(
  token: string,
  sessionId: string
): Promise<SessionDTO> {
  const r = await apiFetch<{ session: SessionDTO }>(
    `/api/sessions/${sessionId}/join`,
    token,
    { method: "POST" }
  );
  return r.session;
}

export async function rateSession(
  token: string,
  sessionId: string,
  payload: { rating: number; feedback?: string }
): Promise<{ ok: boolean; rating: number | null }> {
  return apiFetch(`/api/sessions/${sessionId}/rate`, token, {
    method: "POST",
    body: JSON.stringify(payload),
  });
}

//  Smart Delete
export async function deleteSessionSmart(
  token: string,
  sessionId: string
): Promise<{ ok: boolean; action: string }> {
  return apiFetch(`/api/sessions/${sessionId}/delete`, token, { method: "POST" });
}

export async function getSessionById(
  token: string,
  sessionId: string
): Promise<SessionDTO> {
  const r = await apiFetch<{ session: SessionDTO }>(
    `/api/sessions/${sessionId}`,
    token
  );
  return r.session;
}

// ---------------- Session Room: CHAT ----------------
export async function listSessionChat(
  token: string,
  sessionId: string
): Promise<SessionChatMsg[]> {
  const r = await apiFetch<{ messages: SessionChatMsg[] }>(
    `/api/sessions/${sessionId}/chat`,
    token
  );
  return r.messages || [];
}

export async function sendSessionChat(
  token: string,
  sessionId: string,
  text: string
): Promise<SessionChatMsg> {
  const r = await apiFetch<{ message: SessionChatMsg }>(
    `/api/sessions/${sessionId}/chat`,
    token,
    { method: "POST", body: JSON.stringify({ text }) }
  );
  return r.message;
}

// ---------------- Session Room: FILES ----------------
export async function listSessionFiles(
  token: string,
  sessionId: string
): Promise<SessionFileDTO[]> {
  const r = await apiFetch<{ files: SessionFileDTO[] }>(
    `/api/sessions/${sessionId}/files`,
    token
  );
  return r.files || [];
}

// multipart upload
export async function uploadSessionFile(
  token: string,
  sessionId: string,
  file: { uri: string; name: string; mimeType: string }
): Promise<SessionFileDTO> {
  const form = new FormData();
  // @ts-ignore
  form.append("file", { uri: file.uri, name: file.name, type: file.mimeType });

  const res = await fetch(`${API_URL}/api/sessions/${sessionId}/files`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      // :   Content-Type
    } as any,
    body: form,
  });

  const json = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg = (json as any)?.error || "Upload failed";
    throw new Error(msg);
  }
  return (json as any).file as SessionFileDTO;
}
// ---------------- Session Room: ZOOM ----------------
export async function ensureZoomMeeting(
  token: string,
  sessionId: string
): Promise<{ zoomJoinUrl: string }> {
  //   endpoint      
  return apiFetch<{ zoomJoinUrl: string }>(`/api/sessions/${sessionId}/zoom`, token, {
    method: "POST",
  });
}

// ---------------- Session Room: TYPING ----------------
export async function setSessionTyping(
  token: string,
  sessionId: string,
  isTyping: boolean
): Promise<{ ok: boolean }> {
  //   endpoint      
  return apiFetch<{ ok: boolean }>(`/api/sessions/${sessionId}/chat/typing`, token, {
    method: "POST",
    body: JSON.stringify({ isTyping }),
  });
}

export async function getSessionTyping(
  token: string,
  sessionId: string
): Promise<{ typingUserIds: string[] }> {
  //    backend        typingUserIds 
  return apiFetch<{ typingUserIds: string[] }>(`/api/sessions/${sessionId}/chat/typing`, token);
}
</file>

<file path="app/sessions/components/SessionCard.tsx">
// app/sessions/components/SessionCard.tsx
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  Modal,
  Platform,
  Pressable,
  Text,
  TextInput,
  View,
} from "react-native";

import type { SessionDTO, SessionStatus } from "../api/sessionsApi";
import {
  deleteSessionSmart,
  joinSession,
  rateSession,
  updateSessionStatus,
} from "../api/sessionsApi";

import { formatSessionDateTime, statusBadge } from "../utils/formatSession";

// ---------------- helpers (unchanged style) ----------------
function toMs(iso?: string | null) {
  if (!iso) return null;
  const t = new Date(String(iso)).getTime();
  return Number.isFinite(t) ? t : null;
}

function isTimeReached(iso?: string | null) {
  const t = toMs(iso);
  if (!t) return false;
  return t <= Date.now();
}

function minutesUntil(iso?: string | null) {
  const t = toMs(iso);
  if (!t) return null;
  const diff = t - Date.now();
  return Math.floor(diff / 60000);
}

function minutesSince(iso?: string | null) {
  const t = toMs(iso);
  if (!t) return null;
  const diff = Date.now() - t;
  return Math.floor(diff / 60000);
}

function formatAgo(iso?: string | null) {
  const since = minutesSince(iso);
  if (since === null) return "";
  if (since > 60) return `${Math.round(since / 60)}h ago`;
  return `${since}m ago`;
}

// mirror backend RULES (UI only)
const RULES = {
  JOIN_EARLY_MIN: 30,
  JOIN_LATE_MIN: 180,
  COMPLETE_MAX_DELAY_MIN: 24 * 60,
};

function canJoinNow(iso?: string | null) {
  const until = minutesUntil(iso);
  if (until === null) return { ok: false, reason: "Invalid time" };

  if (until > 0 && until <= RULES.JOIN_EARLY_MIN) return { ok: true };
  if (until <= 0) {
    const since = minutesSince(iso);
    if (since !== null && since <= RULES.JOIN_LATE_MIN) return { ok: true };
    return { ok: false, reason: "Join window expired" };
  }
  return { ok: false, reason: "Too early" };
}

function canCompleteNow(iso?: string | null) {
  if (!isTimeReached(iso))
    return { ok: false, reason: "Too early to complete" };
  const since = minutesSince(iso);
  if (since === null) return { ok: false, reason: "Invalid time" };
  if (since > RULES.COMPLETE_MAX_DELAY_MIN)
    return { ok: false, reason: "Completion window expired" };
  return { ok: true };
}

function getId(v: any) {
  if (!v) return "";
  if (typeof v === "string") return v.trim();
  if (typeof v === "number") return String(v);

  if (typeof v === "object") {
    // support ObjectId-like / populated docs
    const id = v._id || v.id;
    if (id) return String(id).trim();
  }

  return "";
}

// ---------------- UI atoms ----------------
function ActionBtn({
  label,
  kind,
  onPress,
  disabled,
}: {
  label: string;
  kind: "primary" | "danger" | "neutral";
  onPress: () => void;
  disabled?: boolean;
}) {
  const bg =
    kind === "primary" ? "#10B981" : kind === "danger" ? "#EF4444" : "#334155";

  return (
    <Pressable
      onPress={onPress}
      disabled={!!disabled}
      style={{
        paddingVertical: 10,
        paddingHorizontal: 12,
        borderRadius: 10,
        backgroundColor: disabled ? "#1F2937" : bg,
        opacity: disabled ? 0.6 : 1,
      }}
    >
      <Text style={{ color: "#E2E8F0", fontWeight: "700" }}>{label}</Text>
    </Pressable>
  );
}

function Badge({ text }: { text: string }) {
  return (
    <View
      style={{
        alignSelf: "flex-start",
        paddingHorizontal: 10,
        paddingVertical: 6,
        borderRadius: 999,
        backgroundColor: "#0F172A",
        borderWidth: 1,
        borderColor: "#1F2937",
      }}
    >
      <Text style={{ color: "#CBD5E1", fontWeight: "700" }}>{text}</Text>
    </View>
  );
}

// ---------------- Component ----------------
export default function SessionCard({
  session,
  token,
  currentUserId,
  onChanged,
  onDeletedLocal, //  NEW
}: {
  session: SessionDTO;
  token: string | null;
  currentUserId: string | null;
  onChanged: () => Promise<void> | void;

  //  NEW
  onDeletedLocal?: (sessionId: string) => void;
}) {
  const router = useRouter();

  const [busy, setBusy] = useState(false);

  const [rateOpen, setRateOpen] = useState(false);
  const [rateValue, setRateValue] = useState("5");
  const [rateFeedback, setRateFeedback] = useState("");

  //  FIX (no behavior change): stable id fallback
  const sessionId =
    getId((session as any)?._id) ||
    getId((session as any)?.id) ||
    getId((session as any)?.sessionId);

  const [uiStatus, setUiStatus] = useState<SessionStatus>(
    (session.status as SessionStatus) || "requested"
  );

  useEffect(() => {
    setUiStatus((session.status as SessionStatus) || "requested");
  }, [session.status]);

  const timeReached = useMemo(
    () => isTimeReached(session.scheduledAt),
    [session.scheduledAt]
  );

  const joinCheck = useMemo(
    () => canJoinNow(session.scheduledAt),
    [session.scheduledAt]
  );
  const completeCheck = useMemo(
    () => canCompleteNow(session.scheduledAt),
    [session.scheduledAt]
  );

  const myId = getId(currentUserId);

  // mentorId / learnerId    string  object (populated)  ObjectId
  const mentorId =
    getId((session as any).mentorId) || getId((session as any).mentor);
  const learnerId =
    getId((session as any).learnerId) || getId((session as any).learner);

  console.log("DBG", {
    myId,
    mentorId,
    learnerId,
    status: session.status,
    sessionId,
  });

  const isMentor = !!myId && mentorId === myId;
  const isLearner = !!myId && learnerId === myId;

  const joinedBy = Array.isArray((session as any).joinedBy)
    ? (session as any).joinedBy.map((x: any) => getId(x)).filter(Boolean)
    : [];

  const mentorJoined = !!mentorId && joinedBy.includes(mentorId);
  const learnerJoined = !!learnerId && joinedBy.includes(learnerId);

  //  Rules (UI mirrors backend)
  const canAcceptReject = isMentor && uiStatus === "requested" && !timeReached;

  const canCancel =
    (isMentor || isLearner) &&
    (uiStatus === "requested" || uiStatus === "accepted");

  const canJoin =
    (isMentor || isLearner) && uiStatus === "accepted" && joinCheck.ok;

  const canComplete =
    isMentor && uiStatus === "accepted" && completeCheck.ok && mentorJoined;

  const canRate =
    (isMentor || isLearner) &&
    uiStatus === "completed" &&
    !(session as any).rating;

  const canHide =
    (isMentor || isLearner) &&
    (uiStatus === "rejected" ||
      uiStatus === "cancelled" ||
      uiStatus === "completed");

  const setStatus = async (next: SessionStatus) => {
    if (!token) {
      Alert.alert("Not logged in", "Please login again.");
      return;
    }

    //  no behavior change; just prevents broken call
    if (!sessionId) {
      Alert.alert("Missing id", "This session has no id.");
      return;
    }

    const title = "Confirm action";
    const body =
      next === "accepted"
        ? "This will accept the learner request."
        : next === "cancelled"
        ? "This will cancel the session for both sides."
        : next === "rejected"
        ? "This will reject the learner request."
        : next === "completed"
        ? "This will mark the session as completed."
        : `Are you sure you want to set this session to "${next}"?`;

    if (Platform.OS === "web") {
      // @ts-ignore
      const ok = window.confirm(`${title}\n\n${body}`);
      if (!ok) return;
    } else {
      const ok = await new Promise<boolean>((resolve) => {
        Alert.alert(title, body, [
          { text: "No", style: "cancel", onPress: () => resolve(false) },
          { text: "Yes", style: "destructive", onPress: () => resolve(true) },
        ]);
      });
      if (!ok) return;
    }

    try {
      setBusy(true);
      await updateSessionStatus(token, sessionId, next);

      //      (NO side effects)
      setUiStatus(next);

      await onChanged();
    } catch (e: any) {
      Alert.alert("Failed", e?.message || "Action failed");
    } finally {
      setBusy(false);
    }
  };

  const doJoin = async () => {
    if (!token) return Alert.alert("Not logged in", "Please login again.");
    console.log("JOIN CLICK", { sessionId, raw: session });

    if (!sessionId) return Alert.alert("Missing id", "This session has no id.");

    try {
      setBusy(true);

      // 1)   join  (   )
      //   (too early / expired / already joined)   
      try {
        //await joinSession(token, sessionId);
      } catch (e: any) {
        // ignore join errors here; room will still open
        console.log("JoinSession skipped:", e?.message);
      }

      // 2)   
      router.push(`/sessions/room/${sessionId}`);

      // 3) sync
      await onChanged();
    } catch (e: any) {
      Alert.alert("Join failed", e?.message || "Join failed");
    } finally {
      setBusy(false);
    }
  };

  const doSmartDelete = async () => {
    if (!token) return Alert.alert("Not logged in", "Please login again.");
    if (!sessionId) return Alert.alert("Missing id", "This session has no id.");

    const title = "Delete session";

    const body =
      session.status === "accepted"
        ? "Deleting an accepted session will cancel it for both users. The other user will see a notice."
        : session.status === "requested"
        ? isLearner
          ? "This will cancel your request and remove it from your list."
          : "This will reject the request and remove it from your list."
        : "This will remove this session from your list.";

    if (Platform.OS === "web") {
      // @ts-ignore
      const ok = window.confirm(`${title}\n\n${body}`);
      if (!ok) return;
    } else {
      const ok = await new Promise<boolean>((resolve) => {
        Alert.alert(title, body, [
          { text: "Cancel", style: "cancel", onPress: () => resolve(false) },
          {
            text: "Delete",
            style: "destructive",
            onPress: () => resolve(true),
          },
        ]);
      });
      if (!ok) return;
    }
    try {
      setBusy(true);
      await deleteSessionSmart(token, sessionId);

      //  NEW:    
      onDeletedLocal?.(sessionId);

      //     sync 
      await onChanged();
    } catch (e: any) {
      Alert.alert("Failed", e?.message || "Delete failed");
    } finally {
      setBusy(false);
    }
  };

  const submitRate = async () => {
    if (!token) return Alert.alert("Not logged in", "Please login again.");
    if (!sessionId) return Alert.alert("Missing id", "This session has no id.");

    const n = Number(rateValue);
    if (!Number.isFinite(n) || n < 1 || n > 5) {
      Alert.alert("Invalid rating", "Please choose 1 to 5.");
      return;
    }

    try {
      setBusy(true);
      await rateSession(token, sessionId, {
        rating: n,
        feedback: rateFeedback,
      });
      setRateOpen(false);
      await onChanged();
    } catch (e: any) {
      Alert.alert("Failed", e?.message || "Rating failed");
    } finally {
      setBusy(false);
    }
  };

  const title = `${session.skill}  ${session.level || "Not specified"}`;
  const timeLine = formatSessionDateTime(session.scheduledAt);
  const badge = statusBadge(uiStatus);
  const badgeText = typeof badge === "string" ? badge : badge.label;
  const otherName = isMentor
    ? (session as any)?.learner?.fullName ||
      (session as any)?.learner?.email ||
      "Learner"
    : isLearner
    ? (session as any)?.mentor?.fullName ||
      (session as any)?.mentor?.email ||
      "Mentor"
    : (session as any)?.mentor?.fullName ||
      (session as any)?.mentor?.email ||
      (session as any)?.learner?.fullName ||
      (session as any)?.learner?.email ||
      "User";

  const cancelNotice = useMemo(() => {
    const st = String(uiStatus || "").toLowerCase();
    if (st !== "cancelled" && st !== "rejected") return "";

    const dn = String((session as any)?.deleteNotice || "").trim();
    if (dn) return dn;

    const cr = String((session as any)?.cancelReason || "").trim();
    if (cr === "expired_request") return "This request expired automatically.";
    if (cr === "missed") return "Session time passed and was cancelled.";
    if (cr === "late_cancel") return "Cancelled late.";
    if (cr) return "Cancelled.";

    if (st === "rejected") return "This request was rejected.";
    return "Cancelled.";
  }, [
    session.status,
    (session as any)?.deleteNotice,
    (session as any)?.cancelReason,
  ]);

  return (
    <View
      style={{
        backgroundColor: "#0B1220",
        borderRadius: 16,
        padding: 14,
        borderWidth: 1,
        borderColor: "#1F2937",
        gap: 10,
      }}
    >
      <View style={{ flexDirection: "row", justifyContent: "space-between" }}>
        <View style={{ flex: 1, paddingRight: 10 }}>
          <Text style={{ color: "#E2E8F0", fontSize: 16, fontWeight: "800" }}>
            {title}
          </Text>
          <Text style={{ color: "#94A3B8", marginTop: 4 }}>{timeLine}</Text>
          <Text style={{ color: "#64748B", marginTop: 4 }}>
            With: {otherName}
            {!!cancelNotice && (
              <Text
                style={{ color: "#FBBF24", marginTop: 6, fontWeight: "700" }}
              >
                {cancelNotice}
              </Text>
            )}
          </Text>
        </View>

        <Badge text={badgeText} />
      </View>

      <View style={{ flexDirection: "row", gap: 8, flexWrap: "wrap" }}>
        {canAcceptReject && (
          <>
            <ActionBtn
              label="Accept"
              kind="primary"
              onPress={() => {
                setStatus("accepted");
              }}
              disabled={busy}
            />

            <ActionBtn
              label="Reject"
              kind="danger"
              onPress={() => setStatus("rejected")}
              disabled={busy}
            />
          </>
        )}

        {canCancel && (
          <ActionBtn
            label="Cancel"
            kind="danger"
            onPress={() => setStatus("cancelled")}
            disabled={busy}
          />
        )}

        {canJoin && (
          <ActionBtn
            label="Join"
            kind="primary"
            onPress={doJoin}
            disabled={busy}
          />
        )}

        {uiStatus === "accepted" && !canJoin && (
          <ActionBtn
            label={joinCheck.ok ? "Join" : "Join (not available)"}
            kind="neutral"
            onPress={() => {}}
            disabled={true}
          />
        )}

        {canComplete && (
          <ActionBtn
            label="Complete"
            kind="primary"
            onPress={() => setStatus("completed")}
            disabled={busy}
          />
        )}

        {uiStatus === "accepted" && !canComplete && timeReached && (
          <ActionBtn
            label={
              mentorJoined ? "Complete (blocked)" : "Complete (join first)"
            }
            kind="neutral"
            onPress={() => {}}
            disabled={true}
          />
        )}

        {canRate && (
          <ActionBtn
            label="Rate"
            kind="primary"
            onPress={() => setRateOpen(true)}
            disabled={busy}
          />
        )}

        <ActionBtn
          label="Delete"
          kind="neutral"
          onPress={doSmartDelete}
          disabled={busy}
        />

        {busy && <ActivityIndicator />}
      </View>

      <Modal visible={rateOpen} transparent animationType="fade">
        <Pressable
          onPress={() => setRateOpen(false)}
          style={{
            flex: 1,
            backgroundColor: "rgba(0,0,0,0.45)",
            justifyContent: "center",
            padding: 18,
          }}
        >
          <Pressable
            onPress={() => {}}
            style={{
              backgroundColor: "#0B1220",
              borderRadius: 16,
              padding: 16,
              borderWidth: 1,
              borderColor: "#1F2937",
              gap: 12,
            }}
          >
            <Text style={{ color: "#E2E8F0", fontWeight: "800", fontSize: 16 }}>
              Rate session
            </Text>

            <Text style={{ color: "#94A3B8" }}>
              Choose 15 and optional feedback.
            </Text>

            <TextInput
              value={rateValue}
              onChangeText={setRateValue}
              keyboardType="numeric"
              placeholder="5"
              placeholderTextColor="#64748B"
              style={{
                borderWidth: 1,
                borderColor: "#1F2937",
                borderRadius: 12,
                padding: 10,
                color: "#E2E8F0",
              }}
            />

            <TextInput
              value={rateFeedback}
              onChangeText={setRateFeedback}
              placeholder="Feedback (optional)"
              placeholderTextColor="#64748B"
              style={{
                borderWidth: 1,
                borderColor: "#1F2937",
                borderRadius: 12,
                padding: 10,
                color: "#E2E8F0",
                minHeight: 80,
              }}
              multiline
            />

            <View style={{ flexDirection: "row", gap: 10 }}>
              <ActionBtn
                label="Cancel"
                kind="neutral"
                onPress={() => setRateOpen(false)}
                disabled={busy}
              />
              <ActionBtn
                label="Submit"
                kind="primary"
                onPress={submitRate}
                disabled={busy}
              />
            </View>
          </Pressable>
        </Pressable>
      </Modal>

      <Text style={{ color: "#475569" }}>
        Updated{" "}
        {formatAgo((session as any)?.updatedAt || (session as any)?.createdAt)}
      </Text>
    </View>
  );
}
</file>

<file path="package.json">
{
  "name": "our-final-app",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-native-community/datetimepicker": "8.4.4",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "buffer": "^6.0.3",
    "expo": "~54.0.24",
    "expo-constants": "~18.0.10",
    "expo-document-picker": "~14.0.8",
    "expo-font": "~14.0.9",
    "expo-haptics": "~15.0.7",
    "expo-image": "~3.0.10",
    "expo-linking": "~8.0.9",
    "expo-router": "~6.0.15",
    "expo-splash-screen": "~31.0.11",
    "expo-status-bar": "~3.0.8",
    "expo-symbols": "~1.0.7",
    "expo-system-ui": "~6.0.8",
    "expo-web-browser": "~15.0.9",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1",
    "socket.io-client": "^4.8.3"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

<file path="server/routes/sessions.js">
// server/routes/sessions.js
const express = require("express");
const mongoose = require("mongoose");
const Session = require("../models/Session");

const {
  getBalance,
  addPoints,
  deductPoints,
} = require("../services/pointsService");
const { POINTS, CANCEL, REASONS } = require("../services/gamificationRules");
const { rateSession } = require("../services/ratingsService");
const path = require("path");
const fs = require("fs");
const multer = require("multer");

function isValidObjectId(id) {
  return mongoose.Types.ObjectId.isValid(String(id));
}

function normalizeStatus(raw) {
  const s = String(raw || "")
    .trim()
    .toLowerCase();
  if (s === "canceled") return "cancelled";
  return s;
}

function toMs(v) {
  const t = new Date(String(v)).getTime();
  return Number.isFinite(t) ? t : null;
}

function isTimeReached(when) {
  const t = toMs(when);
  return !!t && t <= Date.now();
}

function minutesUntil(when) {
  const t = toMs(when);
  if (!t) return null;
  return Math.floor((t - Date.now()) / 60000);
}

function minutesSince(when) {
  const t = toMs(when);
  if (!t) return null;
  return Math.floor((Date.now() - t) / 60000);
}

function isLateCancel(scheduledAt) {
  const mins = minutesUntil(scheduledAt);
  if (mins === null) return false;
  return mins >= 0 && mins <= Number(CANCEL?.LATE_WINDOW_MINUTES ?? 120);
}

const RULES = {
  JOIN_EARLY_MIN: 30,
  JOIN_LATE_MIN: 180,
  COMPLETE_MAX_DELAY_MIN: 24 * 60,
  ACCEPT_REJECT_BLOCK_AT_START: true,
};

function canJoinNow(sessionDoc) {
  const until = minutesUntil(sessionDoc.scheduledAt);
  if (until === null) return { ok: false, reason: "Invalid scheduledAt" };
  if (until > 0 && until <= RULES.JOIN_EARLY_MIN) return { ok: true };
  if (until <= 0) {
    const since = minutesSince(sessionDoc.scheduledAt);
    if (since !== null && since <= RULES.JOIN_LATE_MIN) return { ok: true };
    return { ok: false, reason: "Join window expired" };
  }
  return { ok: false, reason: "Too early to join" };
}

function canCompleteNow(sessionDoc) {
  if (!isTimeReached(sessionDoc.scheduledAt))
    return { ok: false, reason: "Too early to complete" };
  const since = minutesSince(sessionDoc.scheduledAt);
  if (since === null) return { ok: false, reason: "Invalid scheduledAt" };
  if (since > RULES.COMPLETE_MAX_DELAY_MIN)
    return { ok: false, reason: "Completion window expired" };
  return { ok: true };
}

function pickUser(u) {
  if (!u) return null;

  //  u  id (string  ObjectId) ->  DTO 
  if (typeof u === "string" || u instanceof mongoose.Types.ObjectId) {
    return { id: String(u), fullName: "", email: "" };
  }

  //  u populated object
  return {
    id: String(u._id),
    fullName: u.fullName || "",
    email: u.email || "",
    points: u.points,
    xp: u.xp,
    streak: u.streak,
    avgRating: u.avgRating,
    ratingCount: u.ratingCount,
  };
}

function idOf(v) {
  if (!v) return null;
  if (typeof v === "string") return v;
  if (v._id) return String(v._id);
  if (v.id) return String(v.id);
  return String(v);
}

function toDTO(doc) {
  const o = doc?.toObject ? doc.toObject() : doc;

  const mentorIdStr = idOf(o.mentorId);
  const learnerIdStr = idOf(o.learnerId);

  return {
    ...o,
    mentorId: mentorIdStr,
    learnerId: learnerIdStr,
    mentor: pickUser(o.mentorId),
    learner: pickUser(o.learnerId),
  };
}

// ---------------- FILE UPLOAD (NEW) ----------------
const UPLOAD_DIR = path.join(process.cwd(), "uploads");
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR, { recursive: true });

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, UPLOAD_DIR),
  filename: (req, file, cb) => {
    const safe = String(file.originalname || "file").replace(/[^\w.\-]/g, "_");
    cb(null, `${Date.now()}_${safe}`);
  },
});
const upload = multer({ storage });

module.exports = function sessionsRouter(authMiddleware) {
  const router = express.Router();

  async function populateSession(id) {
    return Session.findById(id)
      .populate(
        "mentorId",
        "fullName email points xp streak avgRating ratingCount"
      )
      .populate(
        "learnerId",
        "fullName email points xp streak avgRating ratingCount"
      );
  }

  async function updateStatusInternal(req, res, statusRaw) {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      const nextStatus = normalizeStatus(statusRaw);

      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const s = await Session.findById(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const mentorId = String(s.mentorId);
      const learnerId = String(s.learnerId);
      const isMentor = mentorId === userId;
      const isLearner = learnerId === userId;
      if (!isMentor && !isLearner)
        return res.status(403).json({ error: "Not allowed" });

      //  auto-cancel expired requested
      if (s.status === "requested" && isTimeReached(s.scheduledAt)) {
        s.status = "cancelled";
        s.cancelledAt = s.cancelledAt || new Date();
        s.cancelReason = s.cancelReason || "expired_request";
        s.cancelledBy = s.cancelledBy || userId;
        await s.save();
        return res.status(400).json({
          error: "Request expired and was cancelled automatically",
          session: toDTO(await populateSession(s._id)),
        });
      }

      //  auto-cancel too old accepted
      if (s.status === "accepted") {
        const since = minutesSince(s.scheduledAt);
        if (since !== null && since > RULES.COMPLETE_MAX_DELAY_MIN) {
          s.status = "cancelled";
          s.cancelledAt = s.cancelledAt || new Date();
          s.cancelReason = s.cancelReason || "missed";
          s.cancelledBy = s.cancelledBy || userId;
          await s.save();
          return res.status(400).json({
            error: "Session too old and was cancelled automatically",
            session: toDTO(await populateSession(s._id)),
          });
        }
      }

      const current = normalizeStatus(s.status);

      // transition guard (minimal)
      const ok =
        (current === "requested" &&
          (nextStatus === "accepted" ||
            nextStatus === "rejected" ||
            nextStatus === "cancelled")) ||
        (current === "accepted" &&
          (nextStatus === "cancelled" || nextStatus === "completed")) ||
        (current !== "completed" && nextStatus === "cancelled");

      if (!ok)
        return res
          .status(400)
          .json({ error: `Invalid transition: ${current} -> ${nextStatus}` });

      if ((nextStatus === "accepted" || nextStatus === "rejected") && !isMentor)
        return res.status(403).json({ error: "Mentor only" });

      if (
        (nextStatus === "accepted" || nextStatus === "rejected") &&
        RULES.ACCEPT_REJECT_BLOCK_AT_START &&
        isTimeReached(s.scheduledAt)
      )
        return res
          .status(400)
          .json({ error: "You cannot accept/reject after time is reached" });

      if (current === "requested" && nextStatus === "accepted") {
        const cost = Number(POINTS?.BOOK_LEARN_SESSION_COST ?? 10);
        const bal = await getBalance(learnerId);
        if (bal < cost)
          return res
            .status(400)
            .json({ error: "Not enough points", needed: cost, balance: bal });
      }

      const wasLate = nextStatus === "cancelled" && isLateCancel(s.scheduledAt);

      // complete checks
      if (nextStatus === "completed") {
        // ---------------- CHANGE HERE (NEW UX) ----------------
        //   End Meeting      mentor
        // (  mentor only    isMentor   )

        const chk = canCompleteNow(s);
        if (!chk.ok) return res.status(400).json({ error: chk.reason });

        const joinedBy = Array.isArray(s.joinedBy)
          ? s.joinedBy.map(String)
          : [];
        const mentorHasJoined = joinedBy.includes(mentorId);
        const learnerHasJoined = joinedBy.includes(learnerId);

        if (!mentorHasJoined && !learnerHasJoined)
          return res.status(400).json({
            error: "At least one side must join before completing",
          });

        s.completedAt = new Date();
      }

      if (nextStatus === "cancelled") {
        s.cancelledAt = new Date();
        s.cancelledBy = userId;
        if (!s.cancelReason)
          s.cancelReason = wasLate ? "late_cancel" : "cancelled";
      }

      s.status = nextStatus;
      await s.save();

      // points side effects (kept)
      try {
        if (current === "requested" && nextStatus === "accepted") {
          const cost = Number(POINTS?.BOOK_LEARN_SESSION_COST ?? 10);
          await deductPoints(
            learnerId,
            cost,
            REASONS?.BOOK_SESSION || "book_session",
            { sessionId: String(s._id) }
          );
        }
        if (current === "accepted" && nextStatus === "completed") {
          const earn = Number(POINTS?.TEACH_SESSION_EARN ?? 10);
          await addPoints(
            mentorId,
            earn,
            REASONS?.TEACH_SESSION || "teach_session",
            { sessionId: String(s._id) }
          );
        }
        if (nextStatus === "cancelled" && wasLate) {
          const penalty = Number(POINTS?.LATE_CANCEL_PENALTY ?? 2);
          await deductPoints(
            userId,
            penalty,
            REASONS?.LATE_CANCEL || "late_cancel",
            { sessionId: String(s._id) }
          );
        }
      } catch (e) {
        console.error("POINTS SIDE-EFFECT ERROR:", e);
      }

      const populated = await populateSession(s._id);
      return res.json({ session: toDTO(populated) });
    } catch (err) {
      console.error("UPDATE STATUS ERROR:", err);
      return res.status(500).json({ error: "Failed to update session" });
    }
  }

  // create
  router.post("/", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const { mentorId, skill, level, scheduledAt, note } = req.body || {};
      if (!isValidObjectId(mentorId))
        return res.status(400).json({ error: "Invalid mentorId" });
      if (!skill) return res.status(400).json({ error: "Missing skill" });
      if (!scheduledAt)
        return res.status(400).json({ error: "Missing scheduledAt" });

      const when = new Date(String(scheduledAt));
      if (Number.isNaN(when.getTime()))
        return res.status(400).json({ error: "Invalid scheduledAt" });
      if (when.getTime() <= Date.now())
        return res
          .status(400)
          .json({ error: "Cannot request a session in the past" });

      const s = await Session.create({
        mentorId: String(mentorId),
        learnerId: userId,
        skill: String(skill),
        level: String(level || "Not specified"),
        scheduledAt: when,
        note: String(note || ""),
      });

      const populated = await populateSession(s._id);
      return res.json({ session: toDTO(populated) });
    } catch (err) {
      console.error("CREATE SESSION ERROR:", err);
      return res.status(500).json({ error: "Failed to create session" });
    }
  });

  // ---------------- IMPORTANT ORDER FIX ----------------
  //  /mine  /:id
  // list mine + auto-cancel expired
  router.get("/mine", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const now = new Date();

      await Session.updateMany(
        { status: "requested", scheduledAt: { $lte: now } },
        {
          $set: {
            status: "cancelled",
            cancelledAt: now,
            cancelReason: "expired_request",
          },
        }
      );

      const tooOld = new Date(
        Date.now() - RULES.COMPLETE_MAX_DELAY_MIN * 60 * 1000
      );
      await Session.updateMany(
        { status: "accepted", scheduledAt: { $lte: tooOld } },
        {
          $set: {
            status: "cancelled",
            cancelledAt: now,
            cancelReason: "missed",
          },
        }
      );

      const list = await Session.find({
        $and: [
          { $or: [{ mentorId: userId }, { learnerId: userId }] },
          {
            hiddenFor: {
              $nin: [new mongoose.Types.ObjectId(userId), String(userId)],
            },
          },
        ],
      })
        .sort({ scheduledAt: -1 })
        .populate(
          "mentorId",
          "fullName email points xp streak avgRating ratingCount"
        )
        .populate(
          "learnerId",
          "fullName email points xp streak avgRating ratingCount"
        );

      return res.json({ sessions: list.map(toDTO) });
    } catch (err) {
      console.error("LIST SESSIONS ERROR:", err);
      return res.status(500).json({ error: "Failed to list sessions" });
    }
  });

  // get by id ( /mine)
  router.get("/:id", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const s = await populateSession(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const mentorId = String(s.mentorId?._id || s.mentorId);
      const learnerId = String(s.learnerId?._id || s.learnerId);
      if (mentorId !== userId && learnerId !== userId)
        return res.status(403).json({ error: "Not allowed" });

      return res.json({ session: toDTO(s) });
    } catch (err) {
      console.error("GET SESSION ERROR:", err);
      return res.status(500).json({ error: "Failed to get session" });
    }
  });

  // status + shortcuts
  router.patch("/:id/status", authMiddleware, (req, res) =>
    updateStatusInternal(req, res, req.body?.status)
  );

  router.post("/:id/join", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const s = await Session.findById(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const mentorId = String(s.mentorId);
      const learnerId = String(s.learnerId);
      const isMentor = mentorId === userId;
      const isLearner = learnerId === userId;
      if (!isMentor && !isLearner)
        return res.status(403).json({ error: "Not allowed" });

      if (s.status === "requested" && isTimeReached(s.scheduledAt)) {
        s.status = "cancelled";
        s.cancelledAt = new Date();
        s.cancelReason = "expired_request";
        s.cancelledBy = userId;
        await s.save();
        return res
          .status(400)
          .json({ error: "Request expired and was cancelled automatically" });
      }

      if (normalizeStatus(s.status) !== "accepted")
        return res
          .status(400)
          .json({ error: "Only accepted sessions can be joined" });

      const chk = canJoinNow(s);
      if (!chk.ok) return res.status(400).json({ error: chk.reason });

      const joinedBy = Array.isArray(s.joinedBy) ? s.joinedBy.map(String) : [];
      if (!joinedBy.includes(userId))
        s.joinedBy = [...(s.joinedBy || []), userId];
      if (!s.joinedAt) s.joinedAt = new Date();
      await s.save();

      const populated = await populateSession(s._id);
      return res.json({ session: toDTO(populated) });
    } catch (err) {
      console.error("JOIN ERROR:", err);
      return res.status(500).json({ error: "Failed to join session" });
    }
  });

  // ---------------- Session Room: CHAT (NEW) ----------------
  router.get("/:id/chat", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const s = await Session.findById(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const mentorId = String(s.mentorId);
      const learnerId = String(s.learnerId);
      if (mentorId !== userId && learnerId !== userId)
        return res.status(403).json({ error: "Not allowed" });

      const messages = Array.isArray(s.chat) ? s.chat : [];
      return res.json({ messages });
    } catch (err) {
      console.error("GET CHAT ERROR:", err);
      return res.status(500).json({ error: "Failed to load chat" });
    }
  });

  router.post("/:id/chat", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      const text = String(req.body?.text || "").trim();
      if (!text) return res.status(400).json({ error: "Missing text" });

      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const s = await Session.findById(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const mentorId = String(s.mentorId);
      const learnerId = String(s.learnerId);
      if (mentorId !== userId && learnerId !== userId)
        return res.status(403).json({ error: "Not allowed" });

      const msg = {
        _id: new mongoose.Types.ObjectId().toString(),
        senderId: userId,
        text,
        createdAt: new Date().toISOString(),
      };

      s.chat = Array.isArray(s.chat) ? s.chat : [];
      s.chat.push(msg);

      await s.save();
      return res.json({ message: msg });
    } catch (err) {
      console.error("POST CHAT ERROR:", err);
      return res.status(500).json({ error: "Failed to send message" });
    }
  });

  // ---------------- Session Room: FILES (NEW) ----------------
  router.get("/:id/files", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const s = await Session.findById(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const mentorId = String(s.mentorId);
      const learnerId = String(s.learnerId);
      if (mentorId !== userId && learnerId !== userId)
        return res.status(403).json({ error: "Not allowed" });

      const files = Array.isArray(s.files) ? s.files : [];
      return res.json({ files: files.slice().reverse() });
    } catch (err) {
      console.error("LIST FILES ERROR:", err);
      return res.status(500).json({ error: "Failed to list files" });
    }
  });

  router.post(
    "/:id/files",
    authMiddleware,
    upload.single("file"),
    async (req, res) => {
      try {
        const userId = String(req.userId);
        const id = String(req.params.id);

        if (!isValidObjectId(id))
          return res.status(400).json({ error: "Invalid session id" });

        const s = await Session.findById(id);
        if (!s) return res.status(404).json({ error: "Session not found" });

        const mentorId = String(s.mentorId);
        const learnerId = String(s.learnerId);
        if (mentorId !== userId && learnerId !== userId)
          return res.status(403).json({ error: "Not allowed" });

        if (!req.file) return res.status(400).json({ error: "Missing file" });

        //     /uploads 
        const url = `/uploads/${req.file.filename}`;

        const f = {
          _id: new mongoose.Types.ObjectId().toString(),
          uploaderId: userId,
          name: req.file.originalname,
          url,
          createdAt: new Date().toISOString(),
        };

        s.files = Array.isArray(s.files) ? s.files : [];
        s.files.push(f);
        await s.save();

        return res.json({ file: f });
      } catch (err) {
        console.error("UPLOAD FILE ERROR:", err);
        return res.status(500).json({ error: "Failed to upload file" });
      }
    }
  );

  router.post("/:id/rate", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const rating = Number(req.body?.rating);
      const feedback = String(req.body?.feedback || "");

      const result = await rateSession({
        sessionId: id,
        userId,
        rating,
        feedback,
      });
      return res.json({ ok: true, rating: result?.rating || null });
    } catch (err) {
      const status = Number(err?.status || 500);
      console.error("RATE ERROR:", err);
      return res
        .status(status)
        .json({ error: err?.message || "Failed to rate session" });
    }
  });

  //  SMART DELETE ENDPOINT
  router.post("/:id/delete", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      if (!isValidObjectId(id))
        return res.status(400).json({ error: "Invalid session id" });

      const s = await Session.findById(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const mentorId = String(s.mentorId);
      const learnerId = String(s.learnerId);
      const isMentor = mentorId === userId;
      const isLearner = learnerId === userId;
      if (!isMentor && !isLearner)
        return res.status(403).json({ error: "Not allowed" });

      // auto-cancel expired requested
      if (s.status === "requested" && isTimeReached(s.scheduledAt)) {
        s.status = "cancelled";
        s.cancelledAt = new Date();
        s.cancelReason = "expired_request";
        s.cancelledBy = userId;
      }

      const st = normalizeStatus(s.status);

      // helper: hide for current user
      const hideForMe = async () => {
        const me = new mongoose.Types.ObjectId(userId);
        const arr = Array.isArray(s.hiddenFor) ? s.hiddenFor.map(String) : [];
        if (!arr.includes(String(me))) {
          s.hiddenFor = [...(s.hiddenFor || []), me];
        }
      };

      // 1) requested
      if (st === "requested") {
        if (isLearner) {
          // I requested it -> treat delete as cancel for both + hide for me
          s.status = "cancelled";
          s.cancelledAt = new Date();
          s.cancelReason = "deleted_by_requester";
          s.cancelledBy = userId;
          s.deleteNotice = "The requester deleted the request.";
          await hideForMe();
          await s.save();
          return res.json({ ok: true, action: "cancelled_hidden" });
        } else if (isMentor) {
          // request received -> treat delete as reject + hide for me
          s.status = "rejected";
          s.deleteNotice = "The mentor deleted the request (rejected).";
          await hideForMe();
          await s.save();
          return res.json({ ok: true, action: "rejected_hidden" });
        }
      }

      // 2) accepted
      if (st === "accepted") {
        // delete => cancel for both, hide for me, other sees cancelled + notice
        const wasLate = isLateCancel(s.scheduledAt);
        s.status = "cancelled";
        s.cancelledAt = new Date();
        s.cancelReason = wasLate ? "late_cancel" : "deleted_after_accept";
        s.cancelledBy = userId;
        s.deleteNotice =
          "The other user deleted this session after acceptance.";
        await hideForMe();
        await s.save();

        // apply late-cancel penalty (book rules)
        try {
          if (wasLate) {
            const penalty = Number(POINTS?.LATE_CANCEL_PENALTY ?? 2);
            await deductPoints(
              userId,
              penalty,
              REASONS?.LATE_CANCEL || "late_cancel",
              { sessionId: String(s._id) }
            );
          }
        } catch (e) {
          console.error("DELETE->LATE PENALTY ERROR:", e);
        }

        return res.json({
          ok: true,
          action: "cancelled_hidden_other_notified",
        });
      }

      // 3) completed / cancelled / rejected => just hide for me
      if (st === "completed" || st === "cancelled" || st === "rejected") {
        await hideForMe();
        await s.save();
        return res.json({ ok: true, action: "hidden" });
      }

      return res
        .status(400)
        .json({ error: "Cannot delete this session in its current state" });
    } catch (err) {
      console.error("SMART DELETE ERROR:", err);
      return res.status(500).json({ error: "Failed to delete session" });
    }
  });

  return router;
};
</file>

<file path="server/server.js">
// server/server.js
require("dotenv").config();

const http = require("http");
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { Server } = require("socket.io");
const path = require("path");

const User = require("./models/User");
const Conversation = require("./models/Conversation");
const Message = require("./models/Message");

const pointsRoutes = require("./routes/points.routes");
const sessionsRouter = require("./routes/sessions");
const usersRouter = require("./routes/users");
const chatRouter = require("./routes/chat");
const ratingsRouter = require("./routes/ratings");

const { findMentorMatches } = require("./services/matchingService");

const app = express();

app.use(cors());
app.use(express.json());
app.use("/uploads", express.static(path.join(process.cwd(), "uploads")));

const MONGO_URI = process.env.MONGO_URI;
const JWT_SECRET = process.env.JWT_SECRET || "dev-fallback-secret-123";
const PORT = process.env.PORT || 4000;

if (!MONGO_URI) {
  console.error(" MONGO_URI is not defined in .env  cannot start server");
  process.exit(1);
}

mongoose
  .connect(MONGO_URI)
  .then(() => console.log(" MongoDB Connected"))
  .catch((err) => {
    console.error(" MongoDB Connection Error:", err?.message || err);
    process.exit(1);
  });

function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Missing token" });
  }

  const token = authHeader.split(" ")[1];

  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.userId = payload.userId;
    return next();
  } catch {
    return res.status(401).json({ error: "Invalid token" });
  }
}

app.get("/", (req, res) => res.send("SkillBridge API is running "));

app.get("/api/matching/status", (req, res) => {
  const mode = process.env.MATCHING_MODE || "local";
  res.json({
    ok: true,
    mode,
    hasOpenAIKey: !!process.env.OPENAI_API_KEY,
    embedModel: process.env.OPENAI_EMBED_MODEL || null,
  });
});

// =======================
// AUTH
// =======================
app.post("/auth/signup", async (req, res) => {
  try {
    const { fullName, email, password } = req.body || {};

    if (!fullName || !email || !password) {
      return res.status(400).json({ error: "All fields are required" });
    }

    const exists = await User.findOne({
      email: String(email).toLowerCase().trim(),
    });
    if (exists) return res.status(409).json({ error: "Email already in use" });

    const hashed = await bcrypt.hash(String(password), 10);

    const user = await User.create({
      fullName: String(fullName).trim(),
      email: String(email).toLowerCase().trim(),
      passwordHash: hashed,

      //  DEV ONLY  plain password (NOT used for auth)
      passwordPlain: String(password),

      points: 0,
      xp: 0,
      streak: 0,

      avgRating: 0,
      ratingCount: 0,

      skillsToLearn: [],
      skillsToTeach: [],
      availabilitySlots: [],
      preferences: { communicationModes: [], languages: [] },
    });

    const token = jwt.sign({ userId: user._id }, JWT_SECRET, {
      expiresIn: "7d",
    });

    return res.json({
      token,
      user: {
        _id: user._id,
        fullName: user.fullName,
        email: user.email,
        points: user.points,
        xp: user.xp,
        streak: user.streak,
        avgRating: user.avgRating,
        ratingCount: user.ratingCount,
      },
    });
  } catch (err) {
    console.error("SIGNUP ERROR:", err);
    return res.status(500).json({ error: "Signup failed" });
  }
});

app.post("/auth/login", async (req, res) => {
  try {
    const { email, password } = req.body || {};

    if (!email || !password) {
      return res.status(400).json({ error: "Email and password are required" });
    }

    const user = await User.findOne({
      email: String(email).toLowerCase().trim(),
    });
    if (!user) return res.status(401).json({ error: "Invalid credentials" });

    const ok = await bcrypt.compare(String(password), user.passwordHash);
    if (!ok) return res.status(401).json({ error: "Invalid credentials" });

    const token = jwt.sign({ userId: user._id }, JWT_SECRET, {
      expiresIn: "7d",
    });

    return res.json({
      token,
      user: {
        _id: user._id,
        fullName: user.fullName,
        email: user.email,
        points: user.points,
        xp: user.xp,
        streak: user.streak,
        avgRating: user.avgRating,
        ratingCount: user.ratingCount,
      },
    });
  } catch (err) {
    console.error("LOGIN ERROR:", err);
    return res.status(500).json({ error: "Login failed" });
  }
});

// =======================
// ME
// =======================
app.get("/api/me", authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.userId).select("-passwordHash");
    if (!user) return res.status(404).json({ error: "User not found" });
    return res.json({ user });
  } catch (err) {
    console.error("ME ERROR:", err);
    return res.status(500).json({ error: "Failed to load user" });
  }
});

app.put("/api/me/profile", authMiddleware, async (req, res) => {
  try {
    const updates = req.body || {};
    const user = await User.findByIdAndUpdate(req.userId, updates, {
      new: true,
    }).select("-passwordHash");

    if (!user) return res.status(404).json({ error: "User not found" });
    return res.json({ user });
  } catch (err) {
    console.error("UPDATE PROFILE ERROR:", err);
    return res.status(500).json({ error: "Failed to update profile" });
  }
});

// =======================
// MATCHING
// =======================
app.post("/api/matches/mentors", authMiddleware, async (req, res) => {
  try {
    const modeFromQuery = String((req.query || {}).mode || "").trim();
    const modeFromBody = String((req.body || {}).mode || "").trim();
    const mode = modeFromQuery || modeFromBody || "";

    const payload = req.body || {};
    const skillQuery = String(payload.skillQuery || payload.skill || "").trim();

    const userAvailability = Array.isArray(payload.userAvailability)
      ? payload.userAvailability
      : Array.isArray(payload.availabilitySlots)
      ? payload.availabilitySlots
      : [];

    const level = payload.level || "Beginner";

    const params = {
      userId: String(req.userId),
      mode,
      level,
      skillQuery,
      userAvailability,
    };

    const out = await findMentorMatches(params);

    return res.json({
      results: Array.isArray(out?.results) ? out.results : [],
      meta: out?.meta || null,
    });
  } catch (err) {
    console.error("MATCHING ERROR:", err);
    return res.status(500).json({ error: "Failed to find mentor matches" });
  }
});

// =======================
// ROUTES
// =======================
app.use("/api/points", authMiddleware, pointsRoutes);
app.use("/api/sessions", sessionsRouter(authMiddleware));
app.use("/api/users", usersRouter(authMiddleware));
app.use("/api/chat", chatRouter(authMiddleware));
app.use("/api/ratings", ratingsRouter(authMiddleware));

// =======================
// SOCKET.IO
// =======================
const server = http.createServer(app);

const io = new Server(server, {
  cors: { origin: "*", methods: ["GET", "POST"] },
});

// ===== Presence tracking =====
const userSocketsCount = new Map(); // userId -> count
const lastSeenMap = new Map(); // userId -> Date ISO

function incOnline(userId) {
  const prev = userSocketsCount.get(userId) || 0;
  const next = prev + 1;
  userSocketsCount.set(userId, next);
  return { prev, next, firstOnline: prev === 0 };
}

function decOnline(userId) {
  const prev = userSocketsCount.get(userId) || 0;
  const next = Math.max(0, prev - 1);

  if (next === 0) {
    userSocketsCount.delete(userId);
    lastSeenMap.set(userId, new Date().toISOString());
    return { prev, next, wentOffline: prev > 0 };
  }

  userSocketsCount.set(userId, next);
  return { prev, next, wentOffline: false };
}

function isOnline(userId) {
  return (userSocketsCount.get(userId) || 0) > 0;
}

function presencePayload(userId) {
  const uid = String(userId);
  return {
    userId: uid,
    online: isOnline(uid),
    lastSeen: lastSeenMap.get(uid) || null,
  };
}

// watchers room per user
function presenceWatchRoom(userId) {
  return `presence:watch:${String(userId)}`;
}

async function emitPresenceToConversationsOfUser(userId) {
  const uid = String(userId);
  try {
    const convs = await Conversation.find({ participants: uid })
      .select("_id")
      .lean();

    for (const c of convs) {
      await emitPresenceToConversation(String(c._id), uid);
    }
  } catch {
    // ignore
  }
}

async function emitPresenceToConversation(convId, userId) {
  try {
    const conv = await Conversation.findById(convId)
      .select("participants")
      .lean();
    if (!conv) return;

    const participants = (conv.participants || []).map(String);
    const payload = presencePayload(userId);

    for (const pid of participants) {
      io.to(`user:${pid}`).emit("presence:update", payload);
    }
  } catch {
    // ignore
  }
}

function emitPresenceToWatchers(userId) {
  const uid = String(userId);
  io.to(presenceWatchRoom(uid)).emit("presence:update", presencePayload(uid));
}

// ===== JWT auth for sockets =====
io.use((socket, next) => {
  try {
    const tokenFromAuth = socket.handshake.auth?.token;
    const tokenFromHeader = String(
      socket.handshake.headers?.authorization || ""
    )
      .replace("Bearer ", "")
      .trim();

    const token = String(tokenFromAuth || tokenFromHeader || "").trim();
    if (!token) return next(new Error("Missing token"));

    const payload = jwt.verify(token, JWT_SECRET);
    socket.userId = String(payload.userId);
    return next();
  } catch {
    return next(new Error("Invalid token"));
  }
});

io.on("connection", (socket) => {
  const me = String(socket.userId);

  // personal room for direct events (presence, etc.)
  socket.join(`user:${me}`);

  // mark online + self presence
  const { firstOnline } = incOnline(me);

  // self update (always)
  io.to(`user:${me}`).emit("presence:update", {
    userId: me,
    online: true,
    lastSeen: lastSeenMap.get(me) || null,
  });

  //  IMPORTANT: when user becomes online (first socket), notify all peers immediately
  if (firstOnline) {
    void emitPresenceToConversationsOfUser(me);
    emitPresenceToWatchers(me);
  }

  //  Presence snapshot (ack)
  socket.on("presence:get", ({ userId }, cb) => {
    try {
      const uid = String(userId || "").trim();
      if (!uid) return cb?.(null);
      return cb?.(presencePayload(uid));
    } catch {
      return cb?.(null);
    }
  });

  //  Watch/unwatch presence (real feature now)
  socket.on("presence:watch", ({ userId }) => {
    const uid = String(userId || "").trim();
    if (!uid) return;
    socket.join(presenceWatchRoom(uid));
    // optional immediate push for smoother UX
    socket.emit("presence:update", presencePayload(uid));
  });

  socket.on("presence:unwatch", ({ userId }) => {
    const uid = String(userId || "").trim();
    if (!uid) return;
    socket.leave(presenceWatchRoom(uid));
  });

  socket.on("conversation:join", async ({ conversationId, peerId }) => {
    try {
      const convId = String(conversationId || "").trim();
      if (!mongoose.Types.ObjectId.isValid(convId)) return;

      const conv = await Conversation.findById(convId)
        .select("participants")
        .lean();
      if (!conv) return;

      const isMember = (conv.participants || []).map(String).includes(me);
      if (!isMember) return;

      socket.join(convId);

      // optional: peer presence immediately
      const peer = String(peerId || "").trim();
      if (peer) {
        socket.emit("presence:update", presencePayload(peer));
      }

      //  NO read marking here. Join should NOT imply "seen".
    } catch {
      // ignore
    }
  });

  socket.on("conversation:read", async ({ conversationId }) => {
    try {
      const convId = String(conversationId || "").trim();
      if (!mongoose.Types.ObjectId.isValid(convId)) return;

      const conv = await Conversation.findById(convId)
        .select("participants")
        .lean();
      if (!conv) return;

      const isMember = (conv.participants || []).map(String).includes(me);
      if (!isMember) return;

      const res = await Message.updateMany(
        {
          conversationId: convId,
          senderId: { $ne: me },
          readBy: { $ne: me },
        },
        { $addToSet: { readBy: me } }
      );

      //  only emit receipt if something actually changed
      const changed =
        (typeof res?.modifiedCount === "number" && res.modifiedCount > 0) ||
        (typeof res?.nModified === "number" && res.nModified > 0);

      if (changed) {
        socket.to(convId).emit("read:receipt", {
          conversationId: convId,
          readerId: me,
          readAt: new Date().toISOString(),
        });
      }
    } catch {
      // ignore
    }
  });

  socket.on("typing", async ({ conversationId, isTyping }) => {
    try {
      const convId = String(conversationId || "").trim();
      if (!mongoose.Types.ObjectId.isValid(convId)) return;

      const conv = await Conversation.findById(convId)
        .select("participants")
        .lean();
      if (!conv) return;

      const isMember = (conv.participants || []).map(String).includes(me);
      if (!isMember) return;

      socket.to(convId).emit("typing", {
        conversationId: convId,
        userId: me,
        isTyping: !!isTyping,
      });
    } catch {
      // ignore
    }
  });

  socket.on("message:send", async ({ conversationId, text }, cb) => {
    try {
      const convId = String(conversationId || "").trim();
      const clean = String(text || "").trim();

      if (!clean) return cb?.({ ok: false, error: "Text is required" });
      if (!mongoose.Types.ObjectId.isValid(convId))
        return cb?.({ ok: false, error: "Invalid conversation id" });

      const conv = await Conversation.findById(convId);
      if (!conv) return cb?.({ ok: false, error: "Conversation not found" });

      const isMember = (conv.participants || []).map(String).includes(me);
      if (!isMember) return cb?.({ ok: false, error: "Not allowed" });

      const msg = await Message.create({
        conversationId: convId,
        senderId: me,
        text: clean,
        readBy: [me],
      });

      conv.lastMessageText = clean.slice(0, 200);
      conv.lastMessageAt = msg.createdAt;
      await conv.save();

      const payload = {
        id: String(msg._id),
        conversationId: convId,
        senderId: me,
        text: msg.text,
        createdAt: msg.createdAt,
      };

      io.to(convId).emit("message:new", payload);
      return cb?.({ ok: true, message: payload });
    } catch {
      return cb?.({ ok: false, error: "Failed to send" });
    }
  });

  socket.on("disconnect", async () => {
    const { wentOffline } = decOnline(me);

    io.to(`user:${me}`).emit("presence:update", presencePayload(me));

    if (wentOffline) {
      //  notify all my conversations participants immediately
      await emitPresenceToConversationsOfUser(me);
      emitPresenceToWatchers(me);
    }
  });
});

server.listen(PORT, () => {
  console.log(` Server running on port ${PORT}`);
});
</file>

</files>

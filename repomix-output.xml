This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules, dist, build, .expo, .next, coverage, assets, public, images, fonts, *.png, *.jpg, *.jpeg, *.svg, *.mp3, *.mp4, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.VSCodeCounter/2025-12-10_22-45-17/details.md
.VSCodeCounter/2025-12-10_22-45-17/diff-details.md
.VSCodeCounter/2025-12-10_22-45-17/diff.csv
.VSCodeCounter/2025-12-10_22-45-17/diff.md
.VSCodeCounter/2025-12-10_22-45-17/diff.txt
.VSCodeCounter/2025-12-10_22-45-17/results.csv
.VSCodeCounter/2025-12-10_22-45-17/results.json
.VSCodeCounter/2025-12-10_22-45-17/results.md
.VSCodeCounter/2025-12-10_22-45-17/results.txt
app.json
app/_layout.tsx
app/(auth)/_layout.tsx
app/(auth)/login/index.tsx
app/(auth)/shared/AuthButton.tsx
app/(auth)/shared/AuthHeader.tsx
app/(auth)/shared/AuthTextField.tsx
app/(auth)/shared/InlineError.tsx
app/(auth)/shared/mapApiError.ts
app/(auth)/shared/PasswordField.tsx
app/(auth)/shared/styles.ts
app/(auth)/shared/useAuthFieldFocus.ts
app/(auth)/shared/useAuthRedirect.ts
app/(auth)/shared/validators.ts
app/(auth)/signup/index.tsx
app/(tabs)/_layout.tsx
app/(tabs)/explore.tsx
app/(tabs)/index.tsx
app/find-mentor.tsx
app/index.tsx
app/login.tsx
app/manage-skills-to-learn/AddSkillToLearnForm.tsx
app/manage-skills-to-learn/CategorySelector.tsx
app/manage-skills-to-learn/index.tsx
app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
app/manage-skills-to-learn/SkillChip.tsx
app/manage-skills-to-learn/skillData.ts
app/manage-skills-to-learn/SkillsToLearnList.tsx
app/manage-skills-to-learn/styles.ts
app/manage-skills-to-learn/SubCategorySelector.tsx
app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
app/manage-skills-to-learn/types.ts
app/manage-skills-to-learn/useManageSkillsToLearn.ts
app/manage-skills-to-teach/AddSkillToTeachForm.tsx
app/manage-skills-to-teach/index.tsx
app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
app/manage-skills-to-teach/SkillsToTeachList.tsx
app/manage-skills-to-teach/types.ts
app/manage-skills-to-teach/useManageSkillsToTeach.ts
app/mentor/[id].tsx
app/modal.tsx
app/profile.tsx
app/screens/components/MatchReadinessStrip.tsx
app/screens/components/PillButton.tsx
app/screens/components/ProfileStatusCard.tsx
app/screens/components/QuickEditBar.tsx
app/screens/components/SkeletonCard.tsx
app/screens/components/ViewProfileCTA.tsx
app/screens/homescreen.styles.ts
app/screens/homescreen.tsx
app/sessions.tsx
app/sessions/api/sessionsApi.ts
app/sessions/components/SessionCard.tsx
app/sessions/index.tsx
app/sessions/request.tsx
app/sessions/screens/SessionsScreen.tsx
app/sessions/utils/formatSession.ts
app/shared/levels.ts
app/shared/profileCompletion.ts
app/signup.tsx
app/weekly-availability/components.tsx
app/weekly-availability/index.tsx
app/weekly-availability/SaveBar.tsx
app/weekly-availability/styles.ts
app/weekly-availability/TimeField.tsx
app/weekly-availability/useWeeklyAvailability.ts
components/external-link.tsx
components/haptic-tab.tsx
components/hello-wave.tsx
components/parallax-scroll-view.tsx
components/themed-text.tsx
components/themed-view.tsx
components/ui/collapsible.tsx
components/ui/icon-symbol.ios.tsx
components/ui/icon-symbol.tsx
constants/theme.ts
eslint.config.js
hooks/use-color-scheme.ts
hooks/use-color-scheme.web.ts
hooks/use-theme-color.ts
lib/api.ts
lib/availabilityStorage.ts
lib/profileCompletion.ts
lib/sectionStatus.ts
package.json
README.md
scripts/reset-project.js
server/.env
server/matching/aiMatcher.js
server/matching/embeddingService.js
server/matching/index.js
server/matching/localMatcher.js
server/matching/normalize.js
server/matching/openaiMatcher.js
server/matching/scoreUtils.js
server/matching/scoring.js
server/models/PointTransaction.js
server/models/Session.js
server/models/User.js
server/package.json
server/routes/points.routes.js
server/routes/sessions.js
server/server.js
server/services/matchingService.js
server/services/pointsService.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(auth)/_layout.tsx">
// app/(auth)/_layout.tsx
import { Stack } from "expo-router";
import React from "react";

export default function AuthLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "fade",
      }}
    />
  );
}
</file>

<file path="app/(auth)/login/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  Text,
  View,
} from "react-native";
import { getMe, login } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import { validateEmail, validatePassword } from "../shared/validators";

type FieldErrors = {
  email?: string;
  password?: string;
};

export default function LoginScreen() {
  const router = useRouter();

  const { register, focusNext } = useAuthFieldFocus([
    "email",
    "password",
  ] as const);

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [checkingSession, setCheckingSession] = useState(true);
  const [loading, setLoading] = useState(false);

  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const [forgotOpen, setForgotOpen] = useState(false);

  // ✅ Session check (prevents flicker)
  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!token) {
          if (mounted) setCheckingSession(false);
          return;
        }

        await getMe(token);
        if (!mounted) return;
        router.replace("/(tabs)" as any);
      } catch {
        await AsyncStorage.removeItem("token");
        if (mounted) setCheckingSession(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  const canSubmit = useMemo(() => {
    if (checkingSession || loading) return false;
    const e = validateEmail(email);
    const p = validatePassword(password);
    return e.ok && p.ok;
  }, [checkingSession, loading, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await login({
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Login failed: missing token from server.");
        setPassword("");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
      setPassword("");
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <KeyboardAvoidingView
        style={authStyles.root}
        behavior={Platform.OS === "ios" ? "padding" : undefined}
      >
        <ScrollView
          contentContainerStyle={authStyles.content}
          keyboardShouldPersistTaps="handled"
        >
          <AuthHeader
            title="Sign in"
            subtitle="Welcome back — continue learning where you left off."
          />

          {checkingSession ? (
            <View
              style={{ paddingVertical: 24, alignItems: "center", gap: 10 }}
            >
              <ActivityIndicator />
              <Text style={authStyles.subtitle}>Checking your session…</Text>
            </View>
          ) : (
            <>
              {bannerError ? (
                <View style={authStyles.bannerError}>
                  <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
                </View>
              ) : null}

              <AuthTextField
                ref={register("email")}
                label="Email"
                value={email}
                onChangeText={(t) => {
                  setEmail(t);
                  clearBannerAndField("email");
                }}
                placeholder="you@example.com"
                keyboardType="email-address"
                returnKeyType="next"
                onSubmitEditing={() => focusNext("email")}
                editable={!loading}
                errorText={fieldErrors.email}
              />

              <PasswordField
                ref={register("password")}
                value={password}
                onChangeText={(t) => {
                  setPassword(t);
                  clearBannerAndField("password");
                }}
                errorText={fieldErrors.password}
                returnKeyType="done"
                onSubmitEditing={onSubmit}
                editable={!loading}
              />

              <Pressable
                onPress={() => setForgotOpen(true)}
                disabled={loading}
                style={({ pressed }) => [
                  { alignSelf: "flex-end", marginTop: 6 },
                  pressed ? { opacity: 0.85 } : null,
                ]}
              >
                <Text style={authStyles.linkBtn}>Forgot password?</Text>
              </Pressable>

              <AuthButton
                title={loading ? "Signing in…" : "Sign in"}
                loading={loading}
                disabled={!canSubmit}
                onPress={onSubmit}
              />

              <View style={authStyles.linkRow}>
                <Text style={authStyles.linkText}>Don’t have an account?</Text>
                <Link href="/(auth)/signup" style={authStyles.linkBtn}>
                  Create one
                </Link>
              </View>
            </>
          )}
        </ScrollView>

        {/* ✅ Forgot password modal */}
        <Modal
          transparent
          visible={forgotOpen}
          animationType="fade"
          onRequestClose={() => setForgotOpen(false)}
        >
          <Pressable
            onPress={() => setForgotOpen(false)}
            style={{
              flex: 1,
              backgroundColor: "rgba(0,0,0,0.6)",
              justifyContent: "center",
              padding: 18,
            }}
          >
            <Pressable
              onPress={() => {}}
              style={{
                backgroundColor: "#0B1120",
                borderRadius: 16,
                borderWidth: 1,
                borderColor: "#1E293B",
                padding: 16,
              }}
            >
              <Text
                style={{
                  color: "#F9FAFB",
                  fontSize: 16,
                  fontWeight: "900",
                  marginBottom: 6,
                }}
              >
                Password reset
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 13, lineHeight: 18 }}>
                Coming soon. For now, create a new account or contact support if
                you’re locked out.
              </Text>

              <Pressable
                onPress={() => setForgotOpen(false)}
                style={({ pressed }) => [
                  {
                    marginTop: 14,
                    backgroundColor: "#22C55E",
                    borderRadius: 999,
                    paddingVertical: 12,
                    alignItems: "center",
                  },
                  pressed ? { opacity: 0.9 } : null,
                ]}
              >
                <Text style={{ color: "#022C22", fontWeight: "900" }}>OK</Text>
              </Pressable>
            </Pressable>
          </Pressable>
        </Modal>
      </KeyboardAvoidingView>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthButton.tsx">
import React from "react";
import { ActivityIndicator, Text, TouchableOpacity, View } from "react-native";
import { authStyles } from "./styles";

type Props = {
  title: string;
  onPress: () => void;
  loading?: boolean;
  disabled?: boolean;
};

export default function AuthButton({
  title,
  onPress,
  loading,
  disabled,
}: Props) {
  const isDisabled = !!disabled || !!loading;

  return (
    <TouchableOpacity
      style={[
        authStyles.primaryBtn,
        isDisabled && authStyles.primaryBtnDisabled,
      ]}
      onPress={onPress}
      disabled={isDisabled}
      activeOpacity={0.85}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: !!loading }}
    >
      {loading ? (
        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <ActivityIndicator />
          <Text style={authStyles.primaryBtnText}>{title}</Text>
        </View>
      ) : (
        <Text style={authStyles.primaryBtnText}>{title}</Text>
      )}
    </TouchableOpacity>
  );
}
</file>

<file path="app/(auth)/shared/AuthHeader.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { title: string; subtitle: string };

export default function AuthHeader({ title, subtitle }: Props) {
  return (
    <View style={authStyles.header}>
      <Text style={authStyles.title}>{title}</Text>
      <Text style={authStyles.subtitle}>{subtitle}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthTextField.tsx">
import React from "react";
import { Text, TextInput, TextInputProps, View } from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  label: string;
  value: string;
  onChangeText: (t: string) => void;
  placeholder?: string;
  errorText?: string | null;
} & Omit<TextInputProps, "value" | "onChangeText">;

const AuthTextField = React.forwardRef<TextInput, Props>(function AuthTextField(
  { label, value, onChangeText, placeholder, errorText, style, ...rest },
  ref
) {
  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>
      <TextInput
        ref={ref}
        style={[authStyles.input, !!errorText && authStyles.inputError, style]}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor="#64748B"
        autoCapitalize="none"
        autoCorrect={false}
        {...rest}
      />
      <InlineError text={errorText} />
    </View>
  );
});

export default AuthTextField;
</file>

<file path="app/(auth)/shared/InlineError.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { text?: string | null };

export default function InlineError({ text }: Props) {
  if (!text) return null;
  return (
    <View style={authStyles.inlineErrorBox}>
      <Text style={authStyles.inlineErrorText}>{text}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/mapApiError.ts">
export function mapApiError(err: any): string {
  // Try to pick the most useful message without leaking raw server dumps.
  const raw =
    String(err?.message || "").trim() ||
    String(err?.response?.data?.message || "").trim() ||
    String(err?.response?.data?.error || "").trim();

  const msg = raw.toLowerCase();

  if (!raw) return "Something went wrong. Please try again.";

  // Network-ish
  if (
    msg.includes("network request failed") ||
    msg.includes("failed to fetch") ||
    msg.includes("network") ||
    msg.includes("socket") ||
    msg.includes("ecconn") ||
    msg.includes("timeout")
  ) {
    return "Can’t reach the server. Check your internet (or API URL) and try again.";
  }

  // Auth / credentials
  if (
    msg.includes("invalid credentials") ||
    msg.includes("invalid") && msg.includes("password") ||
    msg.includes("incorrect") ||
    msg.includes("unauthorized") ||
    msg.includes("401")
  ) {
    return "Email or password is incorrect.";
  }

  // Signup collisions
  if (msg.includes("already") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }
  if (msg.includes("exists") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }

  // User not found (login)
  if (msg.includes("not found") || msg.includes("no user")) {
    return "This email is not registered yet.";
  }

  // Token missing from backend
  if (msg.includes("missing") && msg.includes("token")) {
    return "Login succeeded but server didn’t return a token. Please contact support.";
  }

  // Generic fallback: avoid very long raw messages
  if (raw.length > 140) return "Something went wrong. Please try again.";
  return raw;
}
</file>

<file path="app/(auth)/shared/PasswordField.tsx">
import React, { useState } from "react";
import {
  Text,
  TextInput,
  TextInputProps,
  TouchableOpacity,
  View,
} from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  value: string;
  onChangeText: (t: string) => void;
  errorText?: string | null;
  label?: string;
} & Omit<TextInputProps, "value" | "onChangeText" | "secureTextEntry">;

const PasswordField = React.forwardRef<TextInput, Props>(function PasswordField(
  { value, onChangeText, errorText, label = "Password", style, ...rest },
  ref
) {
  const [show, setShow] = useState(false);

  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>

      <View style={authStyles.passwordRow}>
        <TextInput
          ref={ref}
          style={[
            authStyles.input,
            { flex: 1 },
            !!errorText && authStyles.inputError,
            style,
          ]}
          value={value}
          onChangeText={onChangeText}
          placeholder="••••••••"
          placeholderTextColor="#64748B"
          secureTextEntry={!show}
          autoCapitalize="none"
          autoCorrect={false}
          {...rest}
        />

        <TouchableOpacity
          onPress={() => setShow((v) => !v)}
          style={authStyles.eyeBtn}
          accessibilityRole="button"
          accessibilityLabel={show ? "Hide password" : "Show password"}
          activeOpacity={0.85}
        >
          <Text style={authStyles.eyeText}>{show ? "Hide" : "Show"}</Text>
        </TouchableOpacity>
      </View>

      <InlineError text={errorText} />
    </View>
  );
});

export default PasswordField;
</file>

<file path="app/(auth)/shared/styles.ts">
import { StyleSheet } from "react-native";

export const authStyles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },

  content: {
    paddingHorizontal: 16,
    paddingTop: 28,
    paddingBottom: 28,
  },

  /* ===== Header ===== */
  header: { marginBottom: 18 },
  title: {
    color: "#F9FAFB",
    fontSize: 26,
    fontWeight: "900",
    letterSpacing: 0.2,
  },
  subtitle: {
    color: "#94A3B8",
    fontSize: 13,
    marginTop: 6,
    lineHeight: 18,
  },

  /* ===== Errors ===== */
  bannerError: {
    backgroundColor: "#451A1A",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  bannerErrorText: {
    color: "#FECACA",
    fontSize: 12,
    fontWeight: "800",
    lineHeight: 16,
  },

  inlineErrorBox: { marginTop: 6 },
  inlineErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "800",
  },

  /* ===== Fields ===== */
  fieldWrap: { marginBottom: 14 },
  fieldLabel: {
    color: "#CBD5E1",
    fontSize: 12,
    fontWeight: "800",
    marginBottom: 6,
  },

  input: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 14,
    paddingVertical: 12,
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "700",
  },

  inputError: {
    borderColor: "#FCA5A5",
  },

  passwordRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },

  eyeBtn: {
    paddingHorizontal: 12,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  eyeText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },

  /* ===== Buttons ===== */
  primaryBtn: {
    marginTop: 10,
    backgroundColor: "#22C55E",
    paddingVertical: 13,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryBtnDisabled: {
    opacity: 0.55,
  },
  primaryBtnText: {
    color: "#022C22",
    fontSize: 13,
    fontWeight: "900",
    letterSpacing: 0.3,
  },

  /* ===== Links ===== */
  linkRow: {
    marginTop: 16,
    flexDirection: "row",
    justifyContent: "center",
    gap: 6,
  },
  linkText: {
    color: "#94A3B8",
    fontSize: 12,
    fontWeight: "700",
  },
  linkBtn: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
});
</file>

<file path="app/(auth)/shared/useAuthFieldFocus.ts">
import { useRef } from "react";
import { TextInput } from "react-native";

export function useAuthFieldFocus<T extends string>(keys: readonly T[]) {
  const refs = useRef<Record<T, TextInput | null>>({} as any);

  const register = (key: T) => (ref: TextInput | null) => {
    refs.current[key] = ref;
  };

  const focusNext = (key: T) => {
    const idx = keys.indexOf(key);
    const nextKey = keys[idx + 1];
    if (nextKey && refs.current[nextKey]) {
      refs.current[nextKey]?.focus();
    }
  };

  return { register, focusNext };
}
</file>

<file path="app/(auth)/shared/useAuthRedirect.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useEffect, useState } from "react";

/**
 * If token exists -> redirect to "/"
 * Returns ready=false while checking storage (to avoid flicker)
 */
export function useAuthRedirect() {
  const router = useRouter();
  const [ready, setReady] = useState(false);

  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!mounted) return;

        if (token) {
          router.replace("/"); // go to tabs/home
          return;
        }
      } finally {
        if (mounted) setReady(true);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  return { ready };
}
</file>

<file path="app/(auth)/shared/validators.ts">
export function validateEmail(email: string) {
  const v = email.trim();
  const ok = /^\S+@\S+\.\S+$/.test(v);
  return { ok, value: v, error: ok ? null : "Please enter a valid email." };
}

export function validatePassword(password: string) {
  const v = password;
  const ok = v.length >= 6;
  return { ok, value: v, error: ok ? null : "Password must be at least 6 characters." };
}

export function validateFullName(fullName: string) {
  const v = fullName.trim();
  const ok = v.length >= 2;
  return { ok, value: v, error: ok ? null : "Please enter your full name." };
}
</file>

<file path="app/(auth)/signup/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import { ScrollView, Text, View } from "react-native";
import { signup } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import {
  validateEmail,
  validateFullName,
  validatePassword,
} from "../shared/validators";

type FieldErrors = {
  fullName?: string;
  email?: string;
  password?: string;
};

export default function SignupScreen() {
  const router = useRouter();
  const { register, focusNext } = useAuthFieldFocus([
    "fullName",
    "email",
    "password",
  ] as const);

  const [fullName, setFullName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [loading, setLoading] = useState(false);
  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const canSubmit = useMemo(() => {
    if (loading) return false;
    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);
    return n.ok && e.ok && p.ok;
  }, [loading, fullName, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!n.ok) nextErrors.fullName = n.error || "Please enter your full name.";
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await signup({
        fullName: n.value,
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Signup failed: missing token from server.");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <ScrollView
        contentContainerStyle={authStyles.content}
        keyboardShouldPersistTaps="handled"
      >
        <AuthHeader
          title="Create account"
          subtitle="Join SkillSwap and start learning & teaching."
        />

        {bannerError ? (
          <View style={authStyles.bannerError}>
            <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
          </View>
        ) : null}

        <AuthTextField
          ref={register("fullName")}
          label="Full name"
          value={fullName}
          onChangeText={(t) => {
            setFullName(t);
            clearBannerAndField("fullName");
          }}
          placeholder="Your name"
          errorText={fieldErrors.fullName}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("fullName")}
        />

        <AuthTextField
          ref={register("email")}
          label="Email"
          value={email}
          onChangeText={(t) => {
            setEmail(t);
            clearBannerAndField("email");
          }}
          placeholder="name@example.com"
          keyboardType="email-address"
          errorText={fieldErrors.email}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("email")}
        />

        <PasswordField
          ref={register("password")}
          value={password}
          onChangeText={(t) => {
            setPassword(t);
            clearBannerAndField("password");
          }}
          errorText={fieldErrors.password}
          editable={!loading}
          returnKeyType="done"
          onSubmitEditing={onSubmit}
        />

        <AuthButton
          title={loading ? "Creating…" : "Create account"}
          loading={loading}
          disabled={!canSubmit}
          onPress={onSubmit}
        />

        <View style={authStyles.linkRow}>
          <Text style={authStyles.linkText}>Already have an account?</Text>
          <Link href="/(auth)/login" style={authStyles.linkBtn}>
            Sign in
          </Link>
        </View>
      </ScrollView>
    </View>
  );
}
</file>

<file path="app/mentor/[id].tsx">
// app/mentor/[id].tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useCallback, useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import {
  AvailabilitySlot,
  PublicUserProfile,
  SkillTeach,
  getPublicUserProfile,
} from "../../lib/api";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = String(name).trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function ratingText(avg?: number, count?: number) {
  const a = typeof avg === "number" ? avg : 0;
  const c = typeof count === "number" ? count : 0;
  if (c <= 0) return "No ratings yet";
  return `${a.toFixed(1)}/5 · ${c} rating${c === 1 ? "" : "s"}`;
}

function safeArrayStrings(v: any): string[] {
  if (!Array.isArray(v)) return [];
  return v.map((x) => String(x || "").trim()).filter(Boolean);
}

type MentorVM = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

function toMentorVM(p: PublicUserProfile): MentorVM {
  return {
    id: String(p.id),
    fullName: p.fullName || "Unknown",
    points: Number(p.points || 0),
    xp: Number(p.xp || 0),
    streak: Number(p.streak || 0),
    avgRating: Number(p.avgRating || 0),
    ratingCount: Number(p.ratingCount || 0),
    skillsToTeach: Array.isArray(p.skillsToTeach)
      ? p.skillsToTeach
          .filter((s) => s && s.name)
          .map((s) => ({
            name: String(s.name).trim(),
            level: String(s.level || "Not specified").trim() || "Not specified",
          }))
      : [],
    availabilitySlots: Array.isArray(p.availabilitySlots)
      ? p.availabilitySlots
          .filter(
            (a) =>
              a &&
              typeof a.dayOfWeek === "number" &&
              a.dayOfWeek >= 0 &&
              a.dayOfWeek <= 6 &&
              a.from &&
              a.to
          )
          .map((a) => ({
            dayOfWeek: Number(a.dayOfWeek),
            from: String(a.from),
            to: String(a.to),
          }))
      : [],
    preferences: p.preferences,
  };
}

export default function MentorProfileScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();

  const mentorIdRaw = params?.id;
  const mentorId =
    typeof mentorIdRaw === "string"
      ? mentorIdRaw
      : Array.isArray(mentorIdRaw)
      ? mentorIdRaw[0]
      : "";

  const [mentor, setMentor] = useState<MentorVM | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorText, setErrorText] = useState<string | null>(null);
  const [reloadKey, setReloadKey] = useState(0);

  const loadMentor = useCallback(async () => {
    try {
      setErrorText(null);
      setLoading(true);

      if (!mentorId) {
        setErrorText("Invalid mentor id.");
        return;
      }

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const profile = await getPublicUserProfile(token, mentorId);
      setMentor(toMentorVM(profile));
    } catch (e: any) {
      setErrorText(e?.message || "Failed to load mentor profile.");
    } finally {
      setLoading(false);
    }
  }, [mentorId, router]);

  useEffect(() => {
    loadMentor();
  }, [loadMentor, reloadKey]);

  const skills = useMemo(
    () => mentor?.skillsToTeach ?? [],
    [mentor?.skillsToTeach]
  );

  const slots = useMemo(
    () =>
      (mentor?.availabilitySlots ?? [])
        .slice()
        .sort((a, b) => a.dayOfWeek - b.dayOfWeek),
    [mentor?.availabilitySlots]
  );

  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);

  const bestDay = useMemo(() => {
    if (!slots.length) return null;
    const minutesByDay = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;
      minutesByDay[d] += Math.max(
        0,
        timeToMinutes(s.to) - timeToMinutes(s.from)
      );
    }

    let bestIdx = -1;
    let bestMin = 0;
    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }
    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]} · ${minutesToHuman(bestMin)}`;
  }, [slots]);

  const languages = safeArrayStrings(mentor?.preferences?.languages);
  const commModes = safeArrayStrings(mentor?.preferences?.communicationModes);

  const goBack = () => router.back();

  const handleRequestSession = () => {
    // TODO later
  };

  const handleMessage = () => {
    // TODO later
  };

  if (loading && !mentor && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading mentor profile…</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView style={{ flex: 1 }} contentContainerStyle={styles.container}>
        <View style={styles.topRow}>
          <TouchableOpacity onPress={goBack} activeOpacity={0.85}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>

          <View style={styles.idBadge}>
            <Text style={styles.idBadgeText}>Mentor</Text>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldn’t load profile</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryBtn}
              onPress={() => setReloadKey((k) => k + 1)}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={styles.heroCard}>
          <View style={styles.heroRow}>
            <View style={styles.avatar}>
              <Text style={styles.avatarText}>
                {getInitials(mentor?.fullName)}
              </Text>
            </View>

            <View style={{ flex: 1 }}>
              <Text style={styles.heroName}>
                {mentor?.fullName || "Unknown mentor"}
              </Text>
              <Text style={styles.heroMeta}>
                ⭐ {ratingText(mentor?.avgRating, mentor?.ratingCount)}
              </Text>

              <View style={styles.badgesRow}>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>XP</Text>
                  <Text style={styles.badgeValue}>{mentor?.xp ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Points</Text>
                  <Text style={styles.badgeValue}>{mentor?.points ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Streak</Text>
                  <Text style={styles.badgeValue}>{mentor?.streak ?? 0}</Text>
                </View>
              </View>
            </View>
          </View>

          <View style={styles.ctaRow}>
            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaPrimary]}
              onPress={handleRequestSession}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaPrimaryText}>Request session</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaSecondary]}
              onPress={handleMessage}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaSecondaryText}>Message</Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.ctaNote}>
            (Next step: we’ll connect these buttons to Sessions + Chat)
          </Text>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>What this mentor teaches</Text>
          <Text style={styles.sectionSub}>
            Skills list (clean & fast) — ready for future filters.
          </Text>

          {skills.length ? (
            <View style={styles.skillsWrap}>
              {skills.map((s, idx) => (
                <View key={`${s.name}-${idx}`} style={styles.skillChip}>
                  <Text style={styles.skillChipText}>
                    {s.name}
                    {s.level && s.level !== "Not specified"
                      ? ` · ${s.level}`
                      : ""}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No teaching skills listed</Text>
              <Text style={styles.emptyText}>
                This mentor hasn’t added teaching skills yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Availability</Text>
          <Text style={styles.sectionSub}>
            Total:{" "}
            <Text style={styles.sectionSubStrong}>
              {minutesToHuman(totalMin)}
            </Text>
            {bestDay ? (
              <>
                {"  "}· Best:{" "}
                <Text style={styles.sectionSubStrong}>{bestDay}</Text>
              </>
            ) : null}
          </Text>

          {slots.length ? (
            <View style={styles.availCard}>
              {slots.map((a, idx) => (
                <View
                  key={`${a.dayOfWeek}-${a.from}-${a.to}-${idx}`}
                  style={[
                    styles.availRow,
                    idx !== slots.length - 1 && styles.availRowBorder,
                  ]}
                >
                  <Text style={styles.availDay}>
                    {dayNames[a.dayOfWeek] ?? `Day ${a.dayOfWeek}`}
                  </Text>
                  <Text style={styles.availTime}>
                    {a.from} – {a.to}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No availability set</Text>
              <Text style={styles.emptyText}>
                This mentor didn’t add weekly availability yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Preferences</Text>

          <View style={styles.prefGrid}>
            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Languages</Text>
              <Text style={styles.prefValue}>
                {languages.length ? languages.join(", ") : "Not specified"}
              </Text>
            </View>

            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Communication</Text>
              <Text style={styles.prefValue}>
                {commModes.length ? commModes.join(", ") : "Not specified"}
              </Text>
            </View>
          </View>
        </View>

        <View style={styles.footer}>
          <Text style={styles.footerHint}>
            You’re viewing a mentor profile (not yours) ✅
          </Text>
          <TouchableOpacity
            onPress={goBack}
            style={styles.footerBtn}
            activeOpacity={0.85}
          >
            <Text style={styles.footerBtnText}>Back to results</Text>
          </TouchableOpacity>
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  container: { paddingHorizontal: 16, paddingTop: 16, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 10, color: "#9CA3AF", fontSize: 14 },

  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  backText: { fontSize: 14, color: "#60A5FA" },
  idBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0B1120",
  },
  idBadgeText: { color: "#CBD5F5", fontSize: 12, fontWeight: "600" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 12,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 10 },
  retryBtn: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "600" },

  heroCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  heroRow: { flexDirection: "row", alignItems: "center" },

  avatar: {
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 12,
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "800" },

  heroName: { color: "#F9FAFB", fontSize: 20, fontWeight: "800" },
  heroMeta: { color: "#9CA3AF", fontSize: 12, marginTop: 4 },

  badgesRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  badge: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    paddingVertical: 10,
    paddingHorizontal: 10,
    borderWidth: 1,
    borderColor: "#111827",
  },
  badgeLabel: { color: "#94A3B8", fontSize: 11 },
  badgeValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "800",
    marginTop: 4,
  },

  ctaRow: { flexDirection: "row", gap: 10, marginTop: 12 },
  ctaBtn: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
  },
  ctaPrimary: { backgroundColor: "#F97316" },
  ctaPrimaryText: { color: "#ffffff", fontWeight: "800", fontSize: 13 },
  ctaSecondary: {
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  ctaSecondaryText: { color: "#E5E7EB", fontWeight: "700", fontSize: 13 },
  ctaNote: { marginTop: 10, color: "#64748B", fontSize: 11 },

  section: { marginBottom: 18 },
  sectionTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "700",
    marginBottom: 4,
  },
  sectionSub: { color: "#94A3B8", fontSize: 12, marginBottom: 10 },
  sectionSubStrong: { color: "#E5E7EB", fontWeight: "800" },

  skillsWrap: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  skillChipText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  availCard: {
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    overflow: "hidden",
  },
  availRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  availRowBorder: { borderBottomWidth: 1, borderBottomColor: "#0B1120" },
  availDay: { color: "#E5E7EB", fontSize: 13, fontWeight: "700" },
  availTime: { color: "#9CA3AF", fontSize: 13, fontWeight: "600" },

  prefGrid: { flexDirection: "row", gap: 10 },
  prefBox: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  prefLabel: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "700",
    marginBottom: 4,
  },
  prefValue: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "800",
    marginBottom: 4,
  },
  emptyText: { color: "#64748B", fontSize: 12 },

  footer: { marginTop: 6 },
  footerHint: { color: "#64748B", fontSize: 11, marginBottom: 10 },
  footerBtn: {
    borderRadius: 999,
    paddingVertical: 11,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  footerBtnText: { color: "#E5E7EB", fontSize: 12, fontWeight: "700" },
});
</file>

<file path="app/profile.tsx">
// app/profile.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../lib/api";
import { getMe } from "../lib/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export default function ProfileScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const mountedRef = useRef(true);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);
    } catch (err: any) {
      console.log("Profile / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(err?.message || "Couldn’t load your profile.");
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );

  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading profile…</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView
        style={styles.scroll}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
            colors={["#F97316"]}
          />
        }
      >
        <View style={styles.headerCard}>
          <Text style={styles.title}>Profile</Text>
          <Text style={styles.name}>{user?.fullName || "SkillSwap user"}</Text>
          <Text style={styles.email}>{user?.email || "—"}</Text>

          <View style={styles.headerStatsRow}>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>XP</Text>
              <Text style={styles.statValue}>{user?.xp ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Points</Text>
              <Text style={styles.statValue}>{user?.points ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Streak</Text>
              <Text style={styles.statValue}>{user?.streak ?? 0}</Text>
            </View>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldn’t refresh</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        {/* ✅ One place to manage everything (no bouncing) */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Manage</Text>
          <Text style={styles.sectionSubtitle}>
            Update what matters without jumping around too much.
          </Text>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-learn" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to learn</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToLearn?.length ?? 0) > 0
                  ? `${user?.skillsToLearn?.length} goal(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-teach" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to teach</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToTeach?.length ?? 0) > 0
                  ? `${user?.skillsToTeach?.length} skill(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/weekly-availability" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Weekly availability</Text>
              <Text style={styles.rowSub}>
                {slots.length
                  ? `${daysSet} day(s) · ${minutesToHuman(totalMin)} total`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/find-mentor" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Find mentor</Text>
              <Text style={styles.rowSub}>Get matched instantly</Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.footerRow}>
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  headerCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  title: { color: "#9CA3AF", fontSize: 13 },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "700", marginTop: 6 },
  email: { color: "#64748B", fontSize: 12, marginTop: 4 },

  headerStatsRow: { flexDirection: "row", gap: 8, marginTop: 12 },
  headerStat: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 10,
  },
  statLabel: { color: "#94A3B8", fontSize: 11, marginBottom: 4 },
  statValue: { color: "#F9FAFB", fontSize: 18, fontWeight: "700" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryButton: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "500" },

  section: { marginTop: 8, marginBottom: 20 },
  sectionTitle: { color: "#F9FAFB", fontSize: 16, fontWeight: "600" },
  sectionSubtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  rowBtn: {
    marginTop: 10,
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  rowTitle: { color: "#F9FAFB", fontSize: 14, fontWeight: "600" },
  rowSub: { color: "#94A3B8", fontSize: 12, marginTop: 2 },
  rowArrow: { color: "#60A5FA", fontSize: 22, marginLeft: 10 },

  footerRow: { marginTop: 8, alignItems: "flex-start" },
  logoutButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },
});
</file>

<file path="app/screens/components/MatchReadinessStrip.tsx">
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import {
  getMatchingStatus,
  type MatchingMode,
  type MatchingStatus,
} from "../../../lib/api";

type Props = {
  currentMode?: MatchingMode; // اختياري (لو عندك مود محفوظ بالـ AsyncStorage)
  onApplyRecommended?: (recommended: MatchingMode) => void; // لما المستخدم يكبس "Use recommended"
  onOpenSettings?: () => void; // اختياري (لو بدك تفتح شاشة إعدادات لاحقًا)
  compact?: boolean; // لو بدك شكل أصغر
};

function getHumanMessage(s: MatchingStatus): string {
  if (!s.openaiAvailable) {
    if (s.reason === "NO_KEY")
      return "AI matching is off (no API key). Using local matching.";
    return "AI matching is unavailable right now. Using local matching.";
  }
  return "AI matching is ready. For best results, use Hybrid mode.";
}

export default function MatchReadinessStrip({
  currentMode,
  onApplyRecommended,
  onOpenSettings,
  compact = false,
}: Props) {
  const [status, setStatus] = useState<MatchingStatus | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        setLoading(true);
        const s = await getMatchingStatus();
        if (!alive) return;
        setStatus(s);
      } catch {
        if (!alive) return;
        setStatus({
          openaiAvailable: false,
          reason: "ERROR",
          recommendedMode: "local",
        });
      } finally {
        if (!alive) return;
        setLoading(false);
      }
    })();

    return () => {
      alive = false;
    };
  }, []);

  const recommendedMode: MatchingMode = useMemo(() => {
    // server returns "local" | "hybrid"
    const r = status?.recommendedMode;
    return r === "hybrid" ? "hybrid" : "local";
  }, [status]);

  const showApplyButton = useMemo(() => {
    if (!status) return false;
    if (!onApplyRecommended) return false;
    if (currentMode && currentMode === recommendedMode) return false;
    return true;
  }, [status, onApplyRecommended, currentMode, recommendedMode]);

  const tone = useMemo(() => {
    if (!status) return "neutral";
    return status.openaiAvailable ? "good" : "warn";
  }, [status]);

  return (
    <View
      style={[
        styles.wrap,
        compact && styles.wrapCompact,
        tone === "good" && styles.goodWrap,
        tone === "warn" && styles.warnWrap,
      ]}
    >
      <View style={styles.left}>
        <Text style={styles.title}>Matching status</Text>

        {loading ? (
          <View style={styles.row}>
            <ActivityIndicator />
            <Text style={styles.subtitle}>Checking availability…</Text>
          </View>
        ) : (
          <Text style={styles.subtitle}>
            {status ? getHumanMessage(status) : "Status unknown."}
          </Text>
        )}
      </View>

      <View style={styles.right}>
        {!loading && status && (
          <>
            <View style={styles.pill}>
              <Text style={styles.pillText}>
                Recommended: {recommendedMode.toUpperCase()}
              </Text>
            </View>

            {showApplyButton ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={styles.btn}
                onPress={() => onApplyRecommended?.(recommendedMode)}
              >
                <Text style={styles.btnText}>Use recommended</Text>
              </TouchableOpacity>
            ) : onOpenSettings ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={[styles.btn, styles.btnGhost]}
                onPress={onOpenSettings}
              >
                <Text style={styles.btnText}>Settings</Text>
              </TouchableOpacity>
            ) : null}
          </>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
    borderRadius: 16,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(15, 23, 42, 0.45)",
    padding: 14,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  wrapCompact: {
    paddingVertical: 10,
    paddingHorizontal: 12,
  },
  goodWrap: {
    borderColor: "rgba(34, 197, 94, 0.35)",
    backgroundColor: "rgba(20, 83, 45, 0.18)",
  },
  warnWrap: {
    borderColor: "rgba(251, 191, 36, 0.35)",
    backgroundColor: "rgba(120, 53, 15, 0.18)",
  },
  left: { flex: 1 },
  right: {
    alignItems: "flex-end",
    justifyContent: "center",
    gap: 8,
  },
  title: {
    color: "#e5e7eb",
    fontSize: 14,
    fontWeight: "700",
    marginBottom: 4,
  },
  subtitle: {
    color: "#cbd5e1",
    fontSize: 12.5,
    lineHeight: 18,
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  pill: {
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  pillText: {
    color: "#e5e7eb",
    fontSize: 11.5,
    fontWeight: "700",
    letterSpacing: 0.3,
  },
  btn: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  btnGhost: {
    backgroundColor: "transparent",
  },
  btnText: {
    color: "#e5e7eb",
    fontSize: 12,
    fontWeight: "700",
  },
});
</file>

<file path="app/screens/components/PillButton.tsx">
import React from "react";
import {
  ActivityIndicator,
  GestureResponderEvent,
  StyleProp,
  StyleSheet,
  Text,
  TouchableOpacity,
  ViewStyle,
} from "react-native";

type PillButtonProps = {
  title: string;
  onPress?: (event: GestureResponderEvent) => void;
  disabled?: boolean;
  loading?: boolean;
  style?: StyleProp<ViewStyle>;
  testID?: string;
};

export default function PillButton({
  title,
  onPress,
  disabled = false,
  loading = false,
  style,
  testID,
}: PillButtonProps) {
  const isDisabled = disabled || loading;

  return (
    <TouchableOpacity
      testID={testID}
      activeOpacity={0.85}
      onPress={onPress}
      disabled={isDisabled}
      style={[styles.pill, isDisabled && styles.pillDisabled, style]}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: loading }}
    >
      {loading ? (
        <ActivityIndicator />
      ) : (
        <Text style={[styles.text, isDisabled && styles.textDisabled]}>
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  pill: {
    width: "100%",
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.35)", // slate-400-ish
    backgroundColor: "rgba(15, 23, 42, 0.55)", // slate-900-ish
    alignItems: "center",
    justifyContent: "center",
  },
  pillDisabled: {
    opacity: 0.7,
  },
  text: {
    fontSize: 14.5,
    fontWeight: "600",
    color: "#e5e7eb",
    letterSpacing: 0.2,
  },
  textDisabled: {
    color: "rgba(229, 231, 235, 0.85)",
  },
});
</file>

<file path="app/screens/components/ProfileStatusCard.tsx">
// app/screens/components/ProfileStatusCard.tsx
import { useRouter } from "expo-router";
import React, { useMemo } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import type { ProfileCompletionStatus } from "../../../lib/profileCompletion";

type Props = {
  status: ProfileCompletionStatus;
};

function pickNextSection(status: ProfileCompletionStatus) {
  // أول قسم ناقص
  return status.sections.find((s) => !s.done) || status.sections[0];
}

export default function ProfileStatusCard({ status }: Props) {
  const router = useRouter();

  const next = useMemo(() => pickNextSection(status), [status]);

  const progressText = status.isComplete
    ? "Complete"
    : `${status.doneCount}/${status.totalCount} done`;

  const subtitle = status.isComplete
    ? "Your profile is ready. You’ll get better matches."
    : "Finish these steps to unlock better mentor matches.";

  const onPrimary = () => {
    if (!next?.href) return;
    router.push(next.href as any);
  };

  return (
    <View style={styles.card}>
      <View style={styles.topRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>Profile completion</Text>
          <Text style={styles.subtitle}>{subtitle}</Text>
        </View>

        <View style={styles.percentPill}>
          <Text style={styles.percentText}>{status.percent}%</Text>
        </View>
      </View>

      <View style={styles.progressRow}>
        <View style={styles.progressBg}>
          <View
            style={[styles.progressFill, { width: `${status.percent}%` }]}
          />
        </View>
        <Text style={styles.progressMeta}>{progressText}</Text>
      </View>

      {!status.isComplete && (
        <View style={styles.nextBox}>
          <View style={{ flex: 1 }}>
            <Text style={styles.nextTitle}>Next step</Text>
            <Text style={styles.nextHint}>{next.hint}</Text>
          </View>

          <TouchableOpacity
            style={styles.primaryBtn}
            onPress={onPrimary}
            activeOpacity={0.85}
          >
            <Text style={styles.primaryBtnText}>{next.ctaLabel}</Text>
          </TouchableOpacity>
        </View>
      )}

      <View style={styles.stepsWrap}>
        {status.sections.map((s) => (
          <View
            key={s.key}
            style={[
              styles.stepChip,
              s.done ? styles.stepChipDone : styles.stepChipTodo,
            ]}
          >
            <Text
              style={[
                styles.stepText,
                s.done ? styles.stepTextDone : styles.stepTextTodo,
              ]}
            >
              {s.done ? "✅" : "⬜"} {s.title}
            </Text>
          </View>
        ))}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  topRow: { flexDirection: "row", alignItems: "flex-start", gap: 10 },
  title: { color: "#F9FAFB", fontSize: 15, fontWeight: "700" },
  subtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  percentPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#334155",
  },
  percentText: { color: "#F97316", fontSize: 12, fontWeight: "800" },

  progressRow: { marginTop: 10 },
  progressBg: {
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#111827",
  },
  progressFill: { height: "100%", backgroundColor: "#F97316" },
  progressMeta: { color: "#94A3B8", fontSize: 11, marginTop: 6 },

  nextBox: {
    marginTop: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#0B1120",
    padding: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  nextTitle: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },
  nextHint: { color: "#94A3B8", fontSize: 11, marginTop: 4 },

  primaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#F97316",
  },
  primaryBtnText: { color: "#ffffff", fontSize: 12, fontWeight: "800" },

  stepsWrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 12,
  },
  stepChip: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderWidth: 1,
  },
  stepChipDone: { backgroundColor: "#052e16", borderColor: "#14532d" },
  stepChipTodo: { backgroundColor: "#0F172A", borderColor: "#1E293B" },

  stepText: { fontSize: 11, fontWeight: "700" },
  stepTextDone: { color: "#BBF7D0" },
  stepTextTodo: { color: "#E5E7EB" },
});
</file>

<file path="app/screens/components/QuickEditBar.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  onAvailability: () => void;
  onLearn: () => void;
  onTeach: () => void;
  onMatch: () => void;
};

function Pill({
  title,
  emoji,
  onPress,
  variant = "neutral",
}: {
  title: string;
  emoji: string;
  onPress: () => void;
  variant?: "neutral" | "primary";
}) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.85}
      style={[
        styles.pill,
        variant === "primary" ? styles.pillPrimary : styles.pillNeutral,
      ]}
    >
      <Text style={styles.pillEmoji}>{emoji}</Text>
      <Text
        style={[
          styles.pillText,
          variant === "primary"
            ? styles.pillTextPrimary
            : styles.pillTextNeutral,
        ]}
      >
        {title}
      </Text>
    </TouchableOpacity>
  );
}

export default function QuickEditBar({
  onAvailability,
  onLearn,
  onTeach,
  onMatch,
}: Props) {
  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Quick edit</Text>
        <Text style={styles.hint}>Avoid page hopping</Text>
      </View>

      <View style={styles.row}>
        <Pill title="Match" emoji="🧠" onPress={onMatch} variant="primary" />
        <Pill title="Availability" emoji="📅" onPress={onAvailability} />
      </View>

      <View style={styles.row}>
        <Pill title="Learn" emoji="📚" onPress={onLearn} />
        <Pill title="Teach" emoji="🧑‍🏫" onPress={onTeach} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
  },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  hint: { color: "#64748B", fontSize: 11 },

  row: { flexDirection: "row", gap: 10, marginTop: 10 },
  pill: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
  },
  pillNeutral: { backgroundColor: "#0B1120", borderColor: "#334155" },
  pillPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },

  pillEmoji: { fontSize: 14 },
  pillText: { fontSize: 12, fontWeight: "700" },
  pillTextNeutral: { color: "#E5E7EB" },
  pillTextPrimary: { color: "#DBEAFE" },
});
</file>

<file path="app/screens/components/SkeletonCard.tsx">
import React, { useMemo } from "react";
import { StyleSheet, View, type DimensionValue } from "react-native";

type Props = {
  /**
   * width can be:
   * - number (e.g. 120)
   * - percentage string (e.g. "80%")
   */
  width?: number | `${number}%`;
  height?: number;
  radius?: number;
  style?: any;
};

export default function SkeletonCard({
  width = "100%",
  height = 14,
  radius = 10,
  style,
}: Props) {
  // ✅ ensure correct type for RN style
  const safeWidth = useMemo(() => width as DimensionValue, [width]);

  return (
    <View
      style={[
        styles.skeleton,
        {
          width: safeWidth,
          height,
          borderRadius: radius,
        },
        style,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  skeleton: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    overflow: "hidden",
  },
});
</file>

<file path="app/screens/components/ViewProfileCTA.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label?: string;
  onPress: () => void;
};

export default function ViewProfileCTA({
  label = "View profile",
  onPress,
}: Props) {
  return (
    <TouchableOpacity
      style={styles.wrap}
      onPress={onPress}
      activeOpacity={0.85}
    >
      <View style={styles.left}>
        <Text style={styles.title}>{label}</Text>
        <Text style={styles.sub}>See and update your profile in one place</Text>
      </View>

      <View style={styles.right}>
        <Text style={styles.arrow}>→</Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 12,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 14,
  },
  left: { flex: 1, paddingRight: 10 },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  sub: { color: "#94A3B8", fontSize: 12, marginTop: 4 },
  right: {
    width: 36,
    height: 36,
    borderRadius: 999,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#334155",
    alignItems: "center",
    justifyContent: "center",
  },
  arrow: { color: "#60A5FA", fontSize: 18, fontWeight: "800" },
});
</file>

<file path="app/screens/homescreen.styles.ts">
// app/screens/homescreen.styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: { flex: 1, alignItems: "center", justifyContent: "center" },

  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 16,
  },

  avatar: {
    width: 44,
    height: 44,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
  },

  avatarText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },

  nameWrap: { marginLeft: 12 },
  nameText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },
  metaText: { color: "#94A3B8", fontSize: 12, fontWeight: "700", marginTop: 2 },

  logoutBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1220",
  },

  card: {
    backgroundColor: "#0B1220",
    borderWidth: 1,
    borderColor: "#1F2937",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
  },

  cardTitle: { color: "#E5E7EB", fontSize: 14, fontWeight: "900", marginBottom: 8 },

  row: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  rowLeft: { flexDirection: "row", alignItems: "center" },

  pill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  pillText: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },

  small: { color: "#94A3B8", fontSize: 12, fontWeight: "700" },
  divider: { height: 1, backgroundColor: "#111827", marginVertical: 12 },

  actionBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  actionText: { color: "#E5E7EB", fontSize: 13, fontWeight: "900" },

  badge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },

  logoutText: { color: "#E5E7EB", fontSize: 12 },
});
</file>

<file path="app/screens/homescreen.tsx">
// app/screens/homescreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../../lib/api";
import { getMe } from "../../lib/api";
import { getProfileCompletionStatus } from "../../lib/profileCompletion";
import {
  formatTimeAgo,
  readSectionStatus,
  SectionStatus,
} from "../../lib/sectionStatus";
import ProfileStatusCard from "./components/ProfileStatusCard";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = name.trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function getLevelFromXp(xp?: number) {
  const val = xp ?? 0;
  const level = Math.floor(val / 100);
  const progress = val % 100;
  return { level, progress };
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  return formatTimeAgo(ts);
}

function availabilityLabelFromMinutes(min: number) {
  if (min >= 600) return "🟢 Excellent";
  if (min >= 240) return "🟡 Good";
  if (min > 0) return "🔴 Low";
  return "Not set";
}

export default function HomeScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [sectionStatus, setSectionStatus] = useState<SectionStatus>({
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: Date.now(),
  });

  const mountedRef = useRef(true);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      // ✅ One place to read cross-section state
      const st = await readSectionStatus();
      if (mountedRef.current) setSectionStatus(st);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);
    } catch (err: any) {
      console.log("Home / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(
        err?.message || "We couldn’t load your profile. Please pull to refresh."
      );
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  const handleFindMentor = () => router.push("/find-mentor" as any);
  const handleGoAvailability = () => router.push("/weekly-availability" as any);
  const handleGoTeach = () => router.push("/manage-skills-to-teach" as any);
  const handleGoLearn = () => router.push("/manage-skills-to-learn" as any);
  const handleGoSessions = () => router.push("/sessions" as any);

  // ✅ HOOKS BEFORE ANY EARLY RETURN
  const profileStatus = useMemo(() => getProfileCompletionStatus(user), [user]);

  const xp = user?.xp ?? 0;
  const points = user?.points ?? 0;
  const streak = user?.streak ?? 0;
  const { level, progress } = getLevelFromXp(xp);

  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );
  const qualityLabel = availabilityLabelFromMinutes(totalMin);
  const lastUpdatedText = formatLastUpdated(
    sectionStatus.weeklyAvailabilityLastSavedAt
  );

  const bestDay = useMemo(() => {
    if (!slots.length) return null;

    const minutesByDay: number[] = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;

      const val = Math.max(0, timeToMinutes(s.to) - timeToMinutes(s.from));
      minutesByDay[d] += val;
    }

    let bestIdx = -1;
    let bestMin = 0;

    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }

    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]} · ${minutesToHuman(bestMin)}`;
  }, [slots]);

  // ✅ NOW safe to early return
  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your dashboard…</Text>
      </View>
    );
  }

  const pendingChips = [
    sectionStatus.learnHasPendingSync ? "Learn: pending sync" : null,
    sectionStatus.teachHasPendingSync ? "Teach: pending sync" : null,
  ].filter(Boolean) as string[];

  return (
    <View style={styles.root}>
      <ScrollView
        style={styles.scroll}
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
            colors={["#F97316"]}
          />
        }
      >
        {/* ===== Top hero card ===== */}
        <View style={styles.heroCard}>
          <View style={styles.heroRow}>
            <View style={{ flex: 1 }}>
              <Text style={styles.greeting}>
                {user ? "Welcome back" : "Welcome to SkillSwap"}
              </Text>
              <Text style={styles.name}>
                {user?.fullName || "SkillSwap user"}
              </Text>
              <Text style={styles.tagline}>
                See your progress, grow your skills, and connect with other
                learners.
              </Text>
            </View>

            <View style={styles.avatar}>
              <Text style={styles.avatarText}>
                {getInitials(user?.fullName)}
              </Text>
            </View>
          </View>

          <View style={styles.heroBottomRow}>
            <View style={styles.levelColumn}>
              <Text style={styles.levelLabel}>Level</Text>
              <Text style={styles.levelValue}>{level}</Text>
            </View>

            <View style={styles.progressColumn}>
              <View style={styles.progressHeader}>
                <Text style={styles.progressLabel}>XP progress</Text>
                <Text style={styles.progressValue}>{progress}/100</Text>
              </View>

              <View style={styles.progressBarBackground}>
                <View
                  style={[
                    styles.progressBarFill,
                    { width: `${Math.min(progress, 100)}%` },
                  ]}
                />
              </View>
            </View>

            {streak > 0 && (
              <View style={styles.streakBadge}>
                <Text style={styles.streakEmoji}>🔥</Text>
                <Text style={styles.streakText}>{streak}-day streak</Text>
              </View>
            )}
          </View>

          {/* ✅ pending sync chips (minimal + clean) */}
          {pendingChips.length > 0 && (
            <View
              style={{
                flexDirection: "row",
                gap: 8,
                flexWrap: "wrap",
                marginTop: 10,
              }}
            >
              {pendingChips.map((t) => (
                <View key={t} style={styles.pendingChip}>
                  <Text style={styles.pendingChipText}>{t}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>We couldn’t refresh your data</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        {/* ✅ Profile status card */}
        <ProfileStatusCard status={profileStatus} />

        {/* ===== Stats row ===== */}
        <View style={styles.statsRow}>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>XP</Text>
            <Text style={styles.statValue}>{xp}</Text>
            <Text style={styles.statHint}>Earned by learning from others</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>Points</Text>
            <Text style={styles.statValue}>{points}</Text>
            <Text style={styles.statHint}>Earned by teaching others</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>Streak</Text>
            <Text style={styles.statValue}>{streak}</Text>
            <Text style={styles.statHint}>Active days in a row</Text>
          </View>
        </View>

        {/* ===== Quick actions ===== */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Quick actions</Text>
          <Text style={styles.sectionSubtitle}>
            Start from one of these common actions.
          </Text>

          <View style={styles.quickRow}>
            <TouchableOpacity
              style={[styles.quickCard, styles.quickPrimary]}
              onPress={handleFindMentor}
              activeOpacity={0.85}
            >
              <Text style={styles.quickEmoji}>🧑‍🏫</Text>
              <Text style={styles.quickTitle}>Find a mentor</Text>
              <Text style={styles.quickText}>
                Discover people who can help you with your learning goals.
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.quickCard, styles.quickSecondary]}
              onPress={handleGoSessions}
              activeOpacity={0.85}
            >
              <Text style={styles.quickEmoji}>📅</Text>
              <Text style={styles.quickTitle}>My sessions</Text>
              <Text style={styles.quickText}>
                View requests, accept/reject, and manage upcoming sessions.
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* ===== Skills learn ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Skills you want to learn</Text>
            <TouchableOpacity activeOpacity={0.85} onPress={handleGoLearn}>
              <Text style={styles.sectionAction}>Manage</Text>
            </TouchableOpacity>
          </View>

          {user?.skillsToLearn?.length ? (
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.horizontalChips}
            >
              {user.skillsToLearn.map((skill, idx) => (
                <View key={`${skill.name}-${idx}`} style={styles.chip}>
                  <Text style={styles.chipText}>
                    {skill.name}
                    {skill.level && skill.level !== "Not specified"
                      ? ` · ${skill.level}`
                      : ""}
                  </Text>
                </View>
              ))}
            </ScrollView>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No learning goals yet</Text>
              <Text style={styles.emptyText}>
                Add a few skills you’re interested in, so we can match you with
                the right mentors.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoLearn}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>Add learning goals</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Skills teach ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Skills you can teach</Text>
            <TouchableOpacity activeOpacity={0.85} onPress={handleGoTeach}>
              <Text style={styles.sectionAction}>Manage</Text>
            </TouchableOpacity>
          </View>

          {user?.skillsToTeach?.length ? (
            <View style={styles.teachList}>
              {user.skillsToTeach.map((skill, idx) => (
                <View key={`${skill.name}-${idx}`} style={styles.teachCard}>
                  <View style={{ flex: 1 }}>
                    <Text style={styles.teachName}>{skill.name}</Text>
                    <Text style={styles.teachLevel}>
                      Level: {skill.level || "Not specified"}
                    </Text>
                  </View>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>Nothing to teach yet</Text>
              <Text style={styles.emptyText}>
                Add at least one skill you feel comfortable teaching. This will
                unlock more ways to earn points.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoTeach}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>Add teaching skills</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Availability ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Your weekly availability</Text>
            <TouchableOpacity
              activeOpacity={0.85}
              onPress={handleGoAvailability}
            >
              <Text style={styles.sectionAction}>
                {slots.length ? "Edit" : "Set now"}
              </Text>
            </TouchableOpacity>
          </View>

          <View style={styles.availSummaryCard}>
            <Text style={styles.availSummaryTop}>
              {qualityLabel} · {daysSet} day{daysSet === 1 ? "" : "s"} ·{" "}
              {minutesToHuman(totalMin)} total
            </Text>
            <Text style={styles.availSummaryBottom}>
              {bestDay ? `Best: ${bestDay} · ` : ""}
              Last saved: {lastUpdatedText}
            </Text>
          </View>

          {slots.length ? (
            <View style={styles.availabilityList}>
              {slots.slice(0, 4).map((slot, idx) => (
                <View
                  key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                  style={styles.availabilityRow}
                >
                  <Text style={styles.availabilityDay}>
                    {dayNames[slot.dayOfWeek] || "Day"}
                  </Text>
                  <Text style={styles.availabilityTime}>
                    {slot.from} – {slot.to}
                  </Text>
                </View>
              ))}

              {slots.length > 4 && (
                <TouchableOpacity
                  onPress={handleGoAvailability}
                  activeOpacity={0.85}
                  style={styles.availMoreBtn}
                >
                  <Text style={styles.availMoreText}>
                    View all ({slots.length}) →
                  </Text>
                </TouchableOpacity>
              )}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No availability set</Text>
              <Text style={styles.emptyText}>
                Set 1–2 time slots (evenings/weekend) to improve mentor matches.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoAvailability}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>
                  Set availability (2 mins)
                </Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Footer ===== */}
        <View style={styles.footerRow}>
          <Text style={styles.footerHint}>
            Availability saved: {lastUpdatedText}
          </Text>
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  heroCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  heroRow: { flexDirection: "row", alignItems: "center", marginBottom: 12 },
  greeting: { color: "#9CA3AF", fontSize: 13 },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "700", marginTop: 2 },
  tagline: { color: "#64748B", fontSize: 12, marginTop: 6 },

  avatar: {
    width: 50,
    height: 50,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
    marginLeft: 12,
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "700" },

  heroBottomRow: { flexDirection: "row", alignItems: "center", marginTop: 4 },
  levelColumn: { width: 64, alignItems: "flex-start" },
  levelLabel: { color: "#94A3B8", fontSize: 11 },
  levelValue: {
    color: "#E5E7EB",
    fontSize: 20,
    fontWeight: "700",
    marginTop: 2,
  },

  progressColumn: { flex: 1, marginHorizontal: 12 },
  progressHeader: { flexDirection: "row", justifyContent: "space-between" },
  progressLabel: { color: "#94A3B8", fontSize: 11 },
  progressValue: { color: "#CBD5F5", fontSize: 11 },
  progressBarBackground: {
    marginTop: 6,
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
  },
  progressBarFill: { height: "100%", backgroundColor: "#F97316" },

  streakBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#F97316",
    flexDirection: "row",
    alignItems: "center",
  },
  streakEmoji: { marginRight: 4 },
  streakText: { color: "#FED7AA", fontSize: 11, fontWeight: "600" },

  pendingChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1120",
  },
  pendingChipText: { color: "#E5E7EB", fontSize: 11, fontWeight: "800" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryButton: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "500" },

  statsRow: { flexDirection: "row", gap: 8, marginBottom: 18 },
  statCard: {
    flex: 1,
    backgroundColor: "#020617",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  statLabel: { color: "#94A3B8", fontSize: 11, marginBottom: 4 },
  statValue: { color: "#F9FAFB", fontSize: 18, fontWeight: "700" },
  statHint: { color: "#64748B", fontSize: 10, marginTop: 4 },

  section: { marginBottom: 20 },
  sectionHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  sectionTitle: { color: "#F9FAFB", fontSize: 16, fontWeight: "600" },
  sectionSubtitle: { color: "#64748B", fontSize: 12, marginBottom: 8 },
  sectionAction: { color: "#60A5FA", fontSize: 13, fontWeight: "500" },

  quickRow: { flexDirection: "row", gap: 10, marginTop: 6 },
  quickCard: { flex: 1, borderRadius: 16, padding: 12, borderWidth: 1 },
  quickPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },
  quickSecondary: { backgroundColor: "#020617", borderColor: "#4B5563" },
  quickEmoji: { fontSize: 20, marginBottom: 6 },
  quickTitle: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "600",
    marginBottom: 4,
  },
  quickText: { color: "#9CA3AF", fontSize: 12 },

  horizontalChips: { paddingVertical: 4, paddingRight: 4, gap: 8 },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    marginRight: 8,
  },
  chipText: { color: "#E5E7EB", fontSize: 12 },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 4,
  },
  emptyText: { color: "#64748B", fontSize: 12 },

  teachList: { gap: 8 },
  teachCard: {
    backgroundColor: "#020617",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  teachName: { color: "#F9FAFB", fontSize: 14, fontWeight: "600" },
  teachLevel: { color: "#9CA3AF", fontSize: 12, marginTop: 2 },

  availSummaryCard: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    marginBottom: 10,
  },
  availSummaryTop: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },
  availSummaryBottom: { color: "#94A3B8", fontSize: 11, marginTop: 4 },

  availabilityList: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    paddingVertical: 4,
  },
  availabilityRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: "#020617",
  },
  availabilityDay: { color: "#E5E7EB", fontSize: 13 },
  availabilityTime: { color: "#9CA3AF", fontSize: 13 },

  availMoreBtn: {
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: "#0B1120",
  },
  availMoreText: { color: "#60A5FA", fontSize: 12, fontWeight: "600" },

  primaryCta: {
    marginTop: 10,
    borderRadius: 999,
    paddingVertical: 10,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  primaryCtaText: { color: "#ffffff", fontWeight: "700", fontSize: 13 },

  footerRow: {
    marginTop: 8,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  footerHint: { color: "#6B7280", fontSize: 11 },
  logoutButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12 },
});
</file>

<file path="app/sessions/api/sessionsApi.ts">
// app/sessions/api/sessionsApi.ts
import { API_URL } from "../../../lib/api";

export type SessionStatus =
  | "requested"
  | "accepted"
  | "rejected"
  | "cancelled"
  | "completed";

export type SessionDTO = {
  _id: string;

  mentorId: string;
  learnerId: string;

  skill: string;
  level: string;

  scheduledAt: string; // ISO
  status: SessionStatus;

  note?: string;

  rating?: number | null;
  feedback?: string;

  createdAt?: string;
  updatedAt?: string;
};

async function handle(res: Response) {
  const text = await res.text();
  let data: any = null;

  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    const msg =
      (data && (data.error || data.message)) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;
    throw new Error(msg);
  }

  return data;
}

/**
 * GET /api/sessions/mine
 * query:
 *  - role: "mentor" | "learner" | "any"
 *  - scope: "upcoming" | "past" | "all"
 *  - statuses: comma list
 */
export async function listMySessions(
  token: string,
  params?: {
    role?: "mentor" | "learner" | "any";
    scope?: "upcoming" | "past" | "all";
    statuses?: SessionStatus[];
  }
): Promise<SessionDTO[]> {
  const q = new URLSearchParams();

  if (params?.role) q.set("role", params.role);
  if (params?.scope) q.set("scope", params.scope);
  if (params?.statuses?.length) q.set("statuses", params.statuses.join(","));

  const url = `${API_URL}/api/sessions/mine${q.toString() ? `?${q.toString()}` : ""}`;

  const res = await fetch(url, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });

  const data = await handle(res);
  return Array.isArray(data?.sessions) ? (data.sessions as SessionDTO[]) : [];
}

/**
 * POST /api/sessions
 */
export async function requestSession(
  token: string,
  body: {
    mentorId: string;
    skill: string;
    level?: string;
    scheduledAt: string; // ISO string
    note?: string;
  }
): Promise<SessionDTO> {
  const res = await fetch(`${API_URL}/api/sessions`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(body),
  });

  const data = await handle(res);
  return (data?.session ?? data) as SessionDTO;
}

/**
 * PATCH /api/sessions/:id/status
 */
export async function updateSessionStatus(
  token: string,
  sessionId: string,
  status: SessionStatus
): Promise<SessionDTO> {
  const res = await fetch(`${API_URL}/api/sessions/${sessionId}/status`, {
    method: "PATCH",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ status }),
  });

  const data = await handle(res);
  return (data?.session ?? data) as SessionDTO;
}
</file>

<file path="app/sessions/components/SessionCard.tsx">
// app/sessions/components/SessionCard.tsx
import React, { useMemo, useState } from "react";
import { ActivityIndicator, Alert, Pressable, Text, View } from "react-native";

import type { SessionDTO, SessionStatus } from "../api/sessionsApi";
import { updateSessionStatus } from "../api/sessionsApi";
import { formatSessionDateTime, statusBadge } from "../utils/formatSession";

type Props = {
  session: SessionDTO;
  token: string | null;
  onChanged: () => Promise<void>;
};

export default function SessionCard({ session, token, onChanged }: Props) {
  const [busy, setBusy] = useState(false);

  const badge = useMemo(() => statusBadge(session.status), [session.status]);
  const when = useMemo(
    () => formatSessionDateTime(session.scheduledAt),
    [session.scheduledAt]
  );

  const setStatus = async (next: SessionStatus) => {
    if (!token) {
      Alert.alert("Not logged in", "Please login again.");
      return;
    }

    try {
      setBusy(true);
      await updateSessionStatus(token, session._id, next);
      await onChanged();
    } catch (e: any) {
      Alert.alert("Update failed", e?.message || "Please try again.");
    } finally {
      setBusy(false);
    }
  };

  const canAcceptReject = session.status === "requested";
  const canCancel =
    session.status === "accepted" || session.status === "requested";
  const canComplete = session.status === "accepted";

  return (
    <View
      style={{
        backgroundColor: "#0B1120",
        borderWidth: 1,
        borderColor: "#1E293B",
        borderRadius: 14,
        padding: 12,
      }}
    >
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <Text style={{ color: "#F9FAFB", fontWeight: "900", fontSize: 14 }}>
          {session.skill} {session.level ? `· ${session.level}` : ""}
        </Text>

        <View
          style={{
            paddingHorizontal: 10,
            paddingVertical: 6,
            borderRadius: 999,
            backgroundColor: badge.bg,
            borderWidth: 1,
            borderColor: badge.border,
          }}
        >
          <Text style={{ color: badge.text, fontWeight: "900", fontSize: 12 }}>
            {badge.label}
          </Text>
        </View>
      </View>

      <Text style={{ color: "#94A3B8", marginTop: 8, fontSize: 12 }}>
        Scheduled: {when}
      </Text>

      {!!session.note && (
        <Text
          style={{
            color: "#CBD5E1",
            marginTop: 6,
            fontSize: 12,
            lineHeight: 16,
          }}
        >
          Note: {session.note}
        </Text>
      )}

      <View
        style={{
          flexDirection: "row",
          flexWrap: "wrap",
          gap: 8,
          marginTop: 12,
        }}
      >
        {busy ? (
          <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
            <ActivityIndicator />
            <Text style={{ color: "#94A3B8", fontWeight: "900" }}>
              Updating…
            </Text>
          </View>
        ) : (
          <>
            {canAcceptReject && (
              <>
                <ActionBtn
                  label="Accept"
                  onPress={() => setStatus("accepted")}
                  kind="good"
                />
                <ActionBtn
                  label="Reject"
                  onPress={() => setStatus("rejected")}
                  kind="bad"
                />
              </>
            )}

            {canCancel && (
              <ActionBtn
                label="Cancel"
                onPress={() => setStatus("cancelled")}
                kind="neutral"
              />
            )}

            {canComplete && (
              <ActionBtn
                label="Complete"
                onPress={() => setStatus("completed")}
                kind="primary"
              />
            )}
          </>
        )}
      </View>
    </View>
  );
}

function ActionBtn({
  label,
  onPress,
  kind,
}: {
  label: string;
  onPress: () => void;
  kind: "primary" | "good" | "bad" | "neutral";
}) {
  const styleByKind =
    kind === "good"
      ? { bg: "#22C55E", text: "#022C22", border: "#16A34A" }
      : kind === "bad"
      ? { bg: "#B91C1C", text: "#FEE2E2", border: "#EF4444" }
      : kind === "primary"
      ? { bg: "#F97316", text: "#111827", border: "#FB923C" }
      : { bg: "#020617", text: "#E5E7EB", border: "#334155" };

  return (
    <Pressable
      onPress={onPress}
      style={({ pressed }) => [
        {
          paddingHorizontal: 12,
          paddingVertical: 10,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: styleByKind.border,
          backgroundColor: styleByKind.bg,
        },
        pressed ? { opacity: 0.9 } : null,
      ]}
    >
      <Text
        style={{ color: styleByKind.text, fontWeight: "900", fontSize: 12 }}
      >
        {label}
      </Text>
    </Pressable>
  );
}
</file>

<file path="app/sessions/index.tsx">
// app/sessions/index.tsx
import SessionsScreen from "./screens/SessionsScreen";

export default SessionsScreen;
</file>

<file path="app/sessions/request.tsx">
// app/sessions/request.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  ScrollView,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { requestSession } from "./api/sessionsApi";

function pad2(n: number) {
  return String(n).padStart(2, "0");
}

/**
 * Accepts:
 * - date: "YYYY-MM-DD"
 * - time: "HH:MM"
 * Produces ISO string in local time.
 */
function buildISO(dateStr: string, timeStr: string): string | null {
  const d = String(dateStr || "").trim();
  const t = String(timeStr || "").trim();

  if (!/^\d{4}-\d{2}-\d{2}$/.test(d)) return null;
  if (!/^\d{2}:\d{2}$/.test(t)) return null;

  const [yy, mm, dd] = d.split("-").map((x) => Number(x));
  const [hh, mi] = t.split(":").map((x) => Number(x));

  if (![yy, mm, dd, hh, mi].every(Number.isFinite)) return null;
  if (mm < 1 || mm > 12) return null;
  if (dd < 1 || dd > 31) return null;
  if (hh < 0 || hh > 23) return null;
  if (mi < 0 || mi > 59) return null;

  const dt = new Date(yy, mm - 1, dd, hh, mi, 0, 0);
  if (Number.isNaN(dt.getTime())) return null;

  return dt.toISOString();
}

export default function RequestSessionScreen() {
  const router = useRouter();
  const params = useLocalSearchParams<{
    mentorId?: string;
    mentorName?: string;
    skill?: string;
    level?: string;
  }>();

  // Prefill from params if provided
  const mentorId = String(params.mentorId || "").trim();
  const mentorName = String(params.mentorName || "").trim();
  const defaultSkill = String(params.skill || "").trim();
  const defaultLevel = String(params.level || "").trim();

  const now = useMemo(() => new Date(), []);
  const defaultDate = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(
    now.getDate()
  )}`;
  const defaultTime = `${pad2(Math.min(23, now.getHours() + 1))}:${pad2(
    now.getMinutes()
  )}`;

  const [skill, setSkill] = useState(defaultSkill);
  const [level, setLevel] = useState(defaultLevel || "Not specified");
  const [dateStr, setDateStr] = useState(defaultDate);
  const [timeStr, setTimeStr] = useState(defaultTime);
  const [note, setNote] = useState("");

  const [busy, setBusy] = useState(false);

  const canSubmit = useMemo(() => {
    if (!mentorId) return false;
    if (!skill.trim()) return false;
    return buildISO(dateStr, timeStr) !== null;
  }, [mentorId, skill, dateStr, timeStr]);

  const submit = async () => {
    if (!mentorId) {
      Alert.alert("Missing mentor", "Open this screen from a mentor profile.");
      return;
    }

    const iso = buildISO(dateStr, timeStr);
    if (!iso) {
      Alert.alert("Invalid date/time", "Use Date: YYYY-MM-DD and Time: HH:MM");
      return;
    }

    const trimmedSkill = skill.trim();
    if (!trimmedSkill) {
      Alert.alert("Missing skill", "Please enter a skill for the session.");
      return;
    }

    try {
      setBusy(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      await requestSession(token, {
        mentorId,
        skill: trimmedSkill,
        level: String(level || "Not specified"),
        scheduledAt: iso,
        note: String(note || "").trim(),
      });

      Alert.alert("Requested ✅", "Your session request was sent.", [
        {
          text: "Go to sessions",
          onPress: () => router.replace("/sessions" as any),
        },
      ]);
    } catch (e: any) {
      Alert.alert("Request failed", e?.message || "Please try again.");
    } finally {
      setBusy(false);
    }
  };

  return (
    <View style={{ flex: 1, backgroundColor: "#020617" }}>
      <ScrollView contentContainerStyle={{ padding: 16, paddingBottom: 28 }}>
        {/* Header */}
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
            <Text style={{ color: "#60A5FA", fontWeight: "900" }}>← Back</Text>
          </TouchableOpacity>

          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
            Request session
          </Text>

          <View style={{ width: 54 }} />
        </View>

        <Text style={{ color: "#94A3B8", marginTop: 8, fontSize: 12 }}>
          {mentorName
            ? `Requesting with: ${mentorName}`
            : mentorId
            ? `Mentor selected`
            : `Open from a mentor profile to auto-fill mentorId.`}
        </Text>

        {/* Card */}
        <View
          style={{
            marginTop: 14,
            borderRadius: 14,
            borderWidth: 1,
            borderColor: "#1E293B",
            backgroundColor: "#0B1120",
            padding: 12,
            gap: 10,
          }}
        >
          <Field
            label="Skill"
            value={skill}
            onChangeText={setSkill}
            placeholder="e.g. React, Unity, AWS..."
          />

          <Field
            label="Level"
            value={level}
            onChangeText={setLevel}
            placeholder="Beginner / Intermediate / Advanced"
          />

          <View style={{ flexDirection: "row", gap: 10 }}>
            <View style={{ flex: 1 }}>
              <Field
                label="Date (YYYY-MM-DD)"
                value={dateStr}
                onChangeText={setDateStr}
                placeholder="2025-12-31"
              />
            </View>

            <View style={{ flex: 1 }}>
              <Field
                label="Time (HH:MM)"
                value={timeStr}
                onChangeText={setTimeStr}
                placeholder="18:30"
              />
            </View>
          </View>

          <Field
            label="Note (optional)"
            value={note}
            onChangeText={setNote}
            placeholder="Anything the mentor should know..."
            multiline
            minHeight={76}
          />
        </View>

        {/* Submit */}
        <TouchableOpacity
          onPress={submit}
          activeOpacity={0.85}
          disabled={!canSubmit || busy}
          style={{
            marginTop: 14,
            borderRadius: 999,
            paddingVertical: 12,
            alignItems: "center",
            backgroundColor: !canSubmit || busy ? "#334155" : "#F97316",
            borderWidth: 1,
            borderColor: !canSubmit || busy ? "#475569" : "#FB923C",
          }}
        >
          {busy ? (
            <View
              style={{ flexDirection: "row", alignItems: "center", gap: 10 }}
            >
              <ActivityIndicator />
              <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                Sending…
              </Text>
            </View>
          ) : (
            <Text style={{ color: "#111827", fontWeight: "900" }}>
              Send request
            </Text>
          )}
        </TouchableOpacity>

        {/* Hint */}
        <Text style={{ color: "#64748B", marginTop: 10, fontSize: 11 }}>
          Tip: the screen works best when opened with mentorId + skill
          prefilled.
        </Text>
      </ScrollView>
    </View>
  );
}

function Field(props: {
  label: string;
  value: string;
  onChangeText: (v: string) => void;
  placeholder?: string;
  multiline?: boolean;
  minHeight?: number;
}) {
  const { label, value, onChangeText, placeholder, multiline, minHeight } =
    props;

  return (
    <View style={{ gap: 6 }}>
      <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900" }}>
        {label}
      </Text>
      <TextInput
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor="#64748B"
        multiline={multiline}
        style={{
          borderWidth: 1,
          borderColor: "#1F2937",
          backgroundColor: "#020617",
          color: "#E5E7EB",
          paddingHorizontal: 12,
          paddingVertical: 10,
          borderRadius: 12,
          fontSize: 14,
          fontWeight: "700",
          minHeight: minHeight ?? 44,
          textAlignVertical: multiline ? "top" : "center",
        }}
      />
    </View>
  );
}
</file>

<file path="app/sessions/screens/SessionsScreen.tsx">
// app/sessions/screens/SessionsScreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useCallback, useEffect, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import { listMySessions, SessionDTO } from "../api/sessionsApi";
import SessionCard from "../components/SessionCard";

type Scope = "upcoming" | "past" | "all";

export default function SessionsScreen() {
  const router = useRouter();

  const [scope, setScope] = useState<Scope>("upcoming");
  const [token, setToken] = useState<string | null>(null);

  const [sessions, setSessions] = useState<SessionDTO[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const load = useCallback(
    async (opts?: { silent?: boolean }) => {
      try {
        setErrorText(null);
        if (!opts?.silent) setLoading(true);

        const t = await AsyncStorage.getItem("token");
        setToken(t);

        if (!t) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const data = await listMySessions(t, { scope });
        setSessions(data);
      } catch (e: any) {
        setErrorText(e?.message || "Failed to load sessions.");
      } finally {
        setLoading(false);
        setRefreshing(false);
      }
    },
    [router, scope]
  );

  useEffect(() => {
    load();
  }, [load]);

  const onRefresh = () => {
    setRefreshing(true);
    load({ silent: true });
  };

  const ScopeChip = ({ v }: { v: Scope }) => {
    const active = v === scope;
    return (
      <TouchableOpacity
        onPress={() => setScope(v)}
        activeOpacity={0.85}
        style={{
          paddingHorizontal: 12,
          paddingVertical: 8,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: active ? "#F97316" : "#1E293B",
          backgroundColor: active ? "#0B1120" : "#020617",
        }}
      >
        <Text
          style={{
            color: active ? "#FED7AA" : "#E5E7EB",
            fontWeight: "900",
            fontSize: 12,
          }}
        >
          {v}
        </Text>
      </TouchableOpacity>
    );
  };

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>
          Loading sessions…
        </Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, backgroundColor: "#020617" }}>
      <ScrollView
        contentContainerStyle={{ padding: 16, paddingBottom: 28 }}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
          />
        }
      >
        {/* Header */}
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
            <Text style={{ color: "#60A5FA", fontWeight: "900" }}>← Back</Text>
          </TouchableOpacity>

          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
            Sessions
          </Text>

          <View style={{ width: 54 }} />
        </View>

        <Text style={{ color: "#94A3B8", marginTop: 8, fontSize: 12 }}>
          View and manage your upcoming and past sessions.
        </Text>

        {/* Scope */}
        <View
          style={{
            flexDirection: "row",
            gap: 8,
            marginTop: 14,
            flexWrap: "wrap",
          }}
        >
          <ScopeChip v="upcoming" />
          <ScopeChip v="past" />
          <ScopeChip v="all" />
        </View>

        {errorText ? (
          <View
            style={{
              marginTop: 14,
              backgroundColor: "#451A1A",
              borderColor: "#FCA5A5",
              borderWidth: 1,
              borderRadius: 14,
              padding: 12,
            }}
          >
            <Text style={{ color: "#FECACA", fontWeight: "900" }}>
              Couldn’t load sessions
            </Text>
            <Text style={{ color: "#FECACA", marginTop: 4, fontSize: 12 }}>
              {errorText}
            </Text>
            <TouchableOpacity
              onPress={() => load()}
              activeOpacity={0.85}
              style={{ marginTop: 10 }}
            >
              <Text style={{ color: "#FEE2E2", fontWeight: "900" }}>
                Try again
              </Text>
            </TouchableOpacity>
          </View>
        ) : null}

        {/* List */}
        <View style={{ marginTop: 14, gap: 10 }}>
          {sessions.length === 0 ? (
            <View
              style={{
                backgroundColor: "#020617",
                borderWidth: 1,
                borderColor: "#111827",
                borderRadius: 14,
                padding: 12,
              }}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                No sessions
              </Text>
              <Text style={{ color: "#64748B", marginTop: 4, fontSize: 12 }}>
                Nothing to show for this scope.
              </Text>
            </View>
          ) : (
            sessions.map((s) => (
              <SessionCard
                key={s._id}
                session={s}
                token={token}
                onChanged={() => load({ silent: true })}
              />
            ))
          )}
        </View>
      </ScrollView>
    </View>
  );
}
</file>

<file path="app/sessions/utils/formatSession.ts">
// app/sessions/utils/formatSession.ts
// I AM THE REAL formatSession.ts

import type { SessionStatus } from "../api/sessionsApi.ts";

export function formatSessionDateTime(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "Invalid date";
  return d.toLocaleString();
}

export function statusBadge(
  status: SessionStatus
): { label: string; bg: string; border: string; text: string } {
  switch (status) {
    case "requested":
      return { label: "Requested", bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
    case "accepted":
      return { label: "Accepted", bg: "#052E16", border: "#16A34A", text: "#D1FAE5" };
    case "rejected":
      return { label: "Rejected", bg: "#450A0A", border: "#EF4444", text: "#FEE2E2" };
    case "cancelled":
      return { label: "Cancelled", bg: "#111827", border: "#6B7280", text: "#E5E7EB" };
    case "completed":
      return { label: "Completed", bg: "#0B1120", border: "#F97316", text: "#FED7AA" };
    default:
      return { label: String(status), bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
  }
}
</file>

<file path="app/shared/profileCompletion.ts">
// app/shared/profileCompletion.ts
// ✅ Single-source-of-truth: re-export from /lib to avoid duplicated logic.
// This keeps old imports working if any screen still imports from app/shared.

export { getProfileCompletionStatus } from "../../lib/profileCompletion";
export type { ProfileCompletionStatus } from "../../lib/profileCompletion";
</file>

<file path="app/weekly-availability/SaveBar.tsx">
// app/weekly-availability/SaveBar.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";

type Props = {
  visible: boolean;
  saving?: boolean;
  onSave: () => void;
  onDiscard: () => void;
  lastSavedText?: string;
};

export default function SaveBar({
  visible,
  saving,
  onSave,
  onDiscard,
  lastSavedText,
}: Props) {
  if (!visible) return null;

  const disabled = !!saving;

  return (
    <View
      style={{
        position: "absolute",
        left: 14,
        right: 14,
        bottom: 14,
        borderRadius: 16,
        borderWidth: 1,
        borderColor: "#1E293B",
        backgroundColor: "#0B1120",
        padding: 12,
      }}
    >
      <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
        <View style={{ flex: 1 }}>
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
            Unsaved changes
          </Text>
          <Text
            style={{
              color: "#94A3B8",
              fontSize: 11,
              marginTop: 3,
              lineHeight: 14,
            }}
          >
            {lastSavedText ? `Last saved: ${lastSavedText}` : "Not saved yet"}
          </Text>
        </View>

        <Pressable
          onPress={onDiscard}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 12,
              paddingVertical: 10,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: "#334155",
              backgroundColor: "#020617",
              opacity: disabled ? 0.6 : 1,
            },
            pressed && !disabled ? { opacity: 0.85 } : null,
          ]}
        >
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
            Discard
          </Text>
        </Pressable>

        <Pressable
          onPress={onSave}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 14,
              paddingVertical: 10,
              borderRadius: 999,
              backgroundColor: "#22C55E",
              opacity: disabled ? 0.65 : 1,
              flexDirection: "row",
              alignItems: "center",
              gap: 8,
            },
            pressed && !disabled ? { opacity: 0.9 } : null,
          ]}
        >
          {saving ? <ActivityIndicator /> : null}
          <Text style={{ color: "#022C22", fontWeight: "900", fontSize: 12 }}>
            {saving ? "Saving…" : "Save"}
          </Text>
        </Pressable>
      </View>
    </View>
  );
}
</file>

<file path="lib/availabilityStorage.ts">
// lib/availabilityStorage.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import type { AvailabilitySlot } from "./api";
import { patchSectionStatus } from "./sectionStatus"; // ✅ update Home status too

// ✅ Keys (versioned to avoid future breaking)
const KEY_LAST_SAVED_AT = "weeklyAvailability_lastSavedAt_v1";
const KEY_PENDING = "weeklyAvailability_pending_v1";

/**
 * The pending payload stored locally when user edits availability
 * but hasn't synced to server yet.
 */
export type PendingAvailabilityPayload = {
  slots: AvailabilitySlot[];
  updatedAtISO: string; // when user changed locally
  source: "user-edit" | "auto-restore";
};

function safeParseJSON<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export async function getWeeklyLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_LAST_SAVED_AT);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

/**
 * ✅ IMPORTANT:
 * - write local timestamp
 * - also patch sectionStatus so HomeScreen reflects it immediately
 */
export async function setWeeklyLastSavedAt(
  ts: number = Date.now()
): Promise<void> {
  try {
    await AsyncStorage.setItem(KEY_LAST_SAVED_AT, String(ts));
  } catch {
    // swallow - we don't want UI crash
  }

  // keep Home in sync (ignore errors safely)
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: ts });
  } catch {
    // ignore
  }
}

export async function clearWeeklyLastSavedAt(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_LAST_SAVED_AT);
  } catch {
    // ignore
  }

  // keep Home in sync
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: null });
  } catch {
    // ignore
  }
}

export async function getPendingWeeklyAvailability(): Promise<PendingAvailabilityPayload | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_PENDING);
    const parsed = safeParseJSON<PendingAvailabilityPayload>(raw);
    if (
      !parsed ||
      !Array.isArray(parsed.slots) ||
      typeof parsed.updatedAtISO !== "string"
    ) {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}

export async function setPendingWeeklyAvailability(
  slots: AvailabilitySlot[],
  source: PendingAvailabilityPayload["source"] = "user-edit"
): Promise<void> {
  try {
    const payload: PendingAvailabilityPayload = {
      slots,
      updatedAtISO: new Date().toISOString(),
      source,
    };
    await AsyncStorage.setItem(KEY_PENDING, JSON.stringify(payload));
  } catch {
    // ignore
  }
}

export async function clearPendingWeeklyAvailability(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_PENDING);
  } catch {
    // ignore
  }
}

/**
 * Convenience: mark "saved successfully" (server sync succeeded)
 * - clear pending
 * - bump lastSavedAt (and Home status)
 */
export async function markWeeklyAvailabilitySynced(): Promise<void> {
  await Promise.all([
    clearPendingWeeklyAvailability(),
    setWeeklyLastSavedAt(Date.now()), // ✅ this also patches sectionStatus
  ]);
}

/**
 * Use this when entering weekly availability screen:
 * If there is a pending payload, you can offer restore.
 */
export async function hasPendingWeeklyAvailability(): Promise<boolean> {
  const p = await getPendingWeeklyAvailability();
  return !!p?.slots?.length;
}
</file>

<file path="lib/profileCompletion.ts">
// lib/profileCompletion.ts
import type { AvailabilitySlot, SkillLearn, SkillTeach } from "./api";

export type ProfileCompletionSection = {
  key: "basics" | "learn" | "teach" | "availability";
  title: string;
  done: boolean;
  hint: string;
  ctaLabel: string;
  href: string; // expo-router route
};

export type ProfileCompletionStatus = {
  percent: number; // 0..100
  isComplete: boolean;
  doneCount: number;
  totalCount: number;
  sections: ProfileCompletionSection[];
};

type UserLike = {
  fullName?: string;
  email?: string;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

function bool(v: any) {
  return !!v;
}

export function getProfileCompletionStatus(user: UserLike | null | undefined): ProfileCompletionStatus {
  const fullName = (user?.fullName || "").trim();
  const email = (user?.email || "").trim();

  const hasBasics = bool(fullName) && bool(email);

  const learnCount = user?.skillsToLearn?.length ?? 0;
  const teachCount = user?.skillsToTeach?.length ?? 0;
  const availabilityCount = user?.availabilitySlots?.length ?? 0;

  const hasLearn = learnCount > 0;
  const hasTeach = teachCount > 0;
  const hasAvailability = availabilityCount > 0;

  const sections: ProfileCompletionSection[] = [
    {
      key: "basics",
      title: "Profile basics",
      done: hasBasics,
      hint: hasBasics ? "Looks good." : "Add your name + email to finish the basics.",
      ctaLabel: hasBasics ? "View" : "Fix basics",
      // لو عندك شاشة بروفايل لاحقاً غيّر الرابط
      href: "/settings",
    },
    {
      key: "learn",
      title: "Skills to learn",
      done: hasLearn,
      hint: hasLearn
        ? `You have ${learnCount} learning goal${learnCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you want to learn (improves matching).",
      ctaLabel: hasLearn ? "Manage" : "Add skills",
      href: "/manage-skills-to-learn",
    },
    {
      key: "teach",
      title: "Skills to teach",
      done: hasTeach,
      hint: hasTeach
        ? `You can teach ${teachCount} skill${teachCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you can teach (unlocks more matches).",
      ctaLabel: hasTeach ? "Manage" : "Add skills",
      href: "/manage-skills-to-teach",
    },
    {
      key: "availability",
      title: "Weekly availability",
      done: hasAvailability,
      hint: hasAvailability
        ? `You have ${availabilityCount} time slot${availabilityCount === 1 ? "" : "s"} set.`
        : "Set 1–2 time slots so mentors can align with you.",
      ctaLabel: hasAvailability ? "Edit" : "Set now",
      href: "/weekly-availability",
    },
  ];

  const totalCount = sections.length;
  const doneCount = sections.filter((s) => s.done).length;

  // ✅ وزن متساوي وبسيط
  const percent = clamp(Math.round((doneCount / totalCount) * 100), 0, 100);
  const isComplete = doneCount === totalCount;

  return { percent, isComplete, doneCount, totalCount, sections };
}
</file>

<file path="lib/sectionStatus.ts">
// lib/sectionStatus.ts
import AsyncStorage from "@react-native-async-storage/async-storage";

const STORAGE_KEY = "sectionStatus_v1";

export type SectionStatus = {
  weeklyAvailabilityLastSavedAt: number | null;
  learnHasPendingSync: boolean;
  teachHasPendingSync: boolean;
  updatedAt: number;
};

function safeJsonParse<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export function makeDefaultSectionStatus(
  overrides: Partial<SectionStatus> = {}
): SectionStatus {
  const now = Date.now();
  const next: SectionStatus = {
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: now,
    ...overrides,
  };

  if (!(typeof next.updatedAt === "number" && Number.isFinite(next.updatedAt))) {
    next.updatedAt = now;
  }
  return next;
}

export function normalizeSectionStatus(input: unknown): SectionStatus {
  const obj = (input ?? {}) as Partial<SectionStatus>;

  const weeklyAvailabilityLastSavedAt =
    typeof obj.weeklyAvailabilityLastSavedAt === "number" &&
    Number.isFinite(obj.weeklyAvailabilityLastSavedAt)
      ? obj.weeklyAvailabilityLastSavedAt
      : null;

  const learnHasPendingSync = obj.learnHasPendingSync === true;
  const teachHasPendingSync = obj.teachHasPendingSync === true;

  const updatedAt =
    typeof obj.updatedAt === "number" && Number.isFinite(obj.updatedAt)
      ? obj.updatedAt
      : Date.now();

  return {
    weeklyAvailabilityLastSavedAt,
    learnHasPendingSync,
    teachHasPendingSync,
    updatedAt,
  };
}

export async function readSectionStatus(): Promise<SectionStatus> {
  const raw = await AsyncStorage.getItem(STORAGE_KEY);
  const parsed = safeJsonParse<SectionStatus>(raw);
  if (!parsed) return makeDefaultSectionStatus();
  return normalizeSectionStatus(parsed);
}

export async function writeSectionStatus(next: SectionStatus): Promise<void> {
  const normalized = normalizeSectionStatus(next);
  await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
}

export async function patchSectionStatus(
  patch: Partial<Omit<SectionStatus, "updatedAt">>
): Promise<SectionStatus> {
  const current = await readSectionStatus();
  const next: SectionStatus = { ...current, ...patch, updatedAt: Date.now() };
  await writeSectionStatus(next);
  return next;
}

export function formatTimeAgo(
  timestampMs: number,
  nowMs: number = Date.now()
): string {
  const diffMs = Math.max(0, nowMs - timestampMs);
  const min = Math.floor(diffMs / 60000);

  if (min < 1) return "Just now";
  if (min < 60) return `${min}m ago`;

  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}h ago`;

  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}d ago`;

  const week = Math.floor(day / 7);
  if (week < 5) return `${week}w ago`;

  const month = Math.floor(day / 30);
  if (month < 12) return `${month}mo ago`;

  const year = Math.floor(day / 365);
  return `${year}y ago`;
}
</file>

<file path="server/models/PointTransaction.js">
// server/models/PointTransaction.js
const mongoose = require("mongoose");

const PointTransactionSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    amount: {
      type: Number,
      required: true, // + or -
    },

    reason: {
      type: String,
      required: true, // e.g. "teach_session", "learn_session"
    },

    sessionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Session",
      default: null,
    },

    balanceAfter: {
      type: Number,
      required: true,
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("PointTransaction", PointTransactionSchema);
</file>

<file path="server/models/Session.js">
// server/models/Session.js
const mongoose = require("mongoose");

const SessionSchema = new mongoose.Schema(
  {
    // participants
    mentorId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    learnerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    // what is the session about
    skill: { type: String, required: true, trim: true },
    level: { type: String, default: "Not specified", trim: true },

    // scheduling
    scheduledAt: { type: Date, required: true },

    // lifecycle
    status: {
      type: String,
      enum: ["requested", "accepted", "rejected", "cancelled", "completed"],
      default: "requested",
      index: true,
    },

    // optional notes
    note: { type: String, default: "", trim: true },

    // rating/feedback (optional for later)
    rating: { type: Number, min: 1, max: 5, default: null },
    feedback: { type: String, default: "", trim: true },
  },
  { timestamps: true }
);

// Helpful indexes
SessionSchema.index({ mentorId: 1, scheduledAt: 1 });
SessionSchema.index({ learnerId: 1, scheduledAt: 1 });

module.exports = mongoose.model("Session", SessionSchema);
</file>

<file path="server/routes/points.routes.js">
// server/routes/points.routes.js
const express = require("express");
const PointTransaction = require("../models/PointTransaction");
const { getBalance } = require("../services/pointsService");

const router = express.Router();

/**
 * GET /api/points/balance
 * returns: { balance: number }
 */
router.get("/balance", async (req, res) => {
  try {
    const balance = await getBalance(req.userId);
    return res.json({ balance });
  } catch (err) {
    return res.status(400).json({ error: String(err.message || err) });
  }
});

/**
 * GET /api/points/transactions?limit=50
 * returns: { items: PointTransaction[] }
 */
router.get("/transactions", async (req, res) => {
  try {
    const rawLimit = Number(req.query.limit);
    const limit = Number.isFinite(rawLimit)
      ? Math.max(1, Math.min(200, rawLimit))
      : 50;

    const items = await PointTransaction.find({ userId: req.userId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .select("amount reason sessionId balanceAfter createdAt");

    return res.json({ items });
  } catch (err) {
    return res.status(400).json({ error: String(err.message || err) });
  }
});

module.exports = router;
</file>

<file path="server/routes/sessions.js">
// server/routes/sessions.js
const express = require("express");
const mongoose = require("mongoose");
const Session = require("../models/Session");

function isValidObjectId(id) {
  return mongoose.Types.ObjectId.isValid(String(id));
}

function pickUser(u) {
  if (!u) return null;
  return {
    _id: u._id,
    fullName: u.fullName,
    email: u.email,
    points: u.points,
    xp: u.xp,
    streak: u.streak,
  };
}

module.exports = function sessionsRouter(authMiddleware) {
  const router = express.Router();

  // ✅ Create session (learner requests)
  // POST /api/sessions
  router.post("/", authMiddleware, async (req, res) => {
    try {
      const learnerId = String(req.userId);
      const { mentorId, skill, level, scheduledAt, note } = req.body || {};

      if (!mentorId || !skill || !scheduledAt) {
        return res.status(400).json({
          error: "mentorId, skill, scheduledAt are required",
        });
      }
      if (!isValidObjectId(mentorId) || !isValidObjectId(learnerId)) {
        return res.status(400).json({ error: "Invalid user id" });
      }

      const when = new Date(scheduledAt);
      if (Number.isNaN(when.getTime())) {
        return res.status(400).json({ error: "Invalid scheduledAt date" });
      }

      const doc = await Session.create({
        mentorId,
        learnerId,
        skill: String(skill).trim(),
        level: String(level || "Not specified").trim(),
        scheduledAt: when,
        note: String(note || "").trim(),
        status: "requested",
      });

      const populated = await Session.findById(doc._id)
        .populate("mentorId", "fullName email points xp streak")
        .populate("learnerId", "fullName email points xp streak");

      return res.json({
        session: {
          ...populated.toObject(),
          mentor: pickUser(populated.mentorId),
          learner: pickUser(populated.learnerId),
        },
      });
    } catch (err) {
      console.error("CREATE SESSION ERROR:", err);
      return res.status(500).json({
        error: "Failed to create session",
        details: err instanceof Error ? err.message : "Unknown server error",
      });
    }
  });

  // ✅ List my sessions
  // GET /api/sessions/mine?role=any|all|mentor|learner&scope=upcoming|past|all&statuses=requested,accepted
  router.get("/mine", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);

      // ✅ accept both: any/all
      const roleRaw = String(req.query.role || "any").trim();
      const role = roleRaw === "all" ? "any" : roleRaw;

      const scope = String(req.query.scope || "all").trim();

      // ✅ accept both: statuses (mobile) OR status (older)
      const statusesCsv = String(
        req.query.statuses || req.query.status || "" // 👈 key fix
      ).trim();

      const now = new Date();

      const q = {};

      if (role === "mentor") q.mentorId = userId;
      else if (role === "learner") q.learnerId = userId;
      else q.$or = [{ mentorId: userId }, { learnerId: userId }]; // any

      if (scope === "upcoming") q.scheduledAt = { $gte: now };
      else if (scope === "past") q.scheduledAt = { $lt: now };

      if (statusesCsv) {
        const statuses = statusesCsv
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);

        if (statuses.length) q.status = { $in: statuses };
      }

      const list = await Session.find(q)
        .sort({ scheduledAt: 1 })
        .populate("mentorId", "fullName email points xp streak")
        .populate("learnerId", "fullName email points xp streak");

      const out = list.map((s) => ({
        ...s.toObject(),
        mentor: pickUser(s.mentorId),
        learner: pickUser(s.learnerId),
      }));

      return res.json({ sessions: out });
    } catch (err) {
      console.error("LIST SESSIONS ERROR:", err);
      return res.status(500).json({
        error: "Failed to list sessions",
        details: err instanceof Error ? err.message : "Unknown server error",
      });
    }
  });

  // ✅ Update status (accept/reject/cancel/complete)
  // PATCH /api/sessions/:id/status { status }
  router.patch("/:id/status", authMiddleware, async (req, res) => {
    try {
      const userId = String(req.userId);
      const id = String(req.params.id);
      const nextStatus = String((req.body || {}).status || "").trim();

      const allowed = new Set([
        "accepted",
        "rejected",
        "cancelled",
        "completed",
      ]);
      if (!allowed.has(nextStatus)) {
        return res.status(400).json({ error: "Invalid status" });
      }
      if (!isValidObjectId(id)) {
        return res.status(400).json({ error: "Invalid session id" });
      }

      const s = await Session.findById(id);
      if (!s) return res.status(404).json({ error: "Session not found" });

      const isMentor = String(s.mentorId) === userId;
      const isLearner = String(s.learnerId) === userId;
      if (!isMentor && !isLearner) {
        return res.status(403).json({ error: "Not allowed" });
      }

      // Rules:
      // - mentor can accept/reject requested
      // - either can cancel if not completed
      // - complete: mentor OR learner, but must be accepted
      if (nextStatus === "accepted" || nextStatus === "rejected") {
        if (!isMentor) return res.status(403).json({ error: "Mentor only" });
        if (s.status !== "requested") {
          return res
            .status(400)
            .json({ error: "Can only accept/reject requested sessions" });
        }
      }

      if (nextStatus === "cancelled") {
        if (s.status === "completed") {
          return res
            .status(400)
            .json({ error: "Cannot cancel completed session" });
        }
      }

      if (nextStatus === "completed") {
        if (s.status !== "accepted") {
          return res
            .status(400)
            .json({ error: "Only accepted sessions can be completed" });
        }
      }

      s.status = nextStatus;
      await s.save();

      const populated = await Session.findById(id)
        .populate("mentorId", "fullName email points xp streak")
        .populate("learnerId", "fullName email points xp streak");

      return res.json({
        session: {
          ...populated.toObject(),
          mentor: pickUser(populated.mentorId),
          learner: pickUser(populated.learnerId),
        },
      });
    } catch (err) {
      console.error("UPDATE SESSION STATUS ERROR:", err);
      return res.status(500).json({
        error: "Failed to update session status",
        details: err instanceof Error ? err.message : "Unknown server error",
      });
    }
  });

  return router;
};
</file>

<file path="server/services/pointsService.js">
// server/services/pointsService.js
const mongoose = require("mongoose");
const User = require("../models/User");
const PointTransaction = require("../models/PointTransaction");

async function getBalance(userId) {
  const user = await User.findById(userId).select("points");
  if (!user) throw new Error("User not found");
  return user.points || 0;
}

async function addPoints(userId, amount, reason, sessionId = null) {
  if (amount <= 0) throw new Error("Amount must be positive");

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const user = await User.findById(userId).session(session);
    if (!user) throw new Error("User not found");

    const current = user.points || 0;
    const next = current + amount;

    user.points = next;
    await user.save();

    await PointTransaction.create(
      [
        {
          userId,
          amount,
          reason,
          sessionId,
          balanceAfter: next,
        },
      ],
      { session }
    );

    await session.commitTransaction();
    session.endSession();

    return next;
  } catch (err) {
    await session.abortTransaction();
    session.endSession();
    throw err;
  }
}

async function deductPoints(userId, amount, reason, sessionId = null) {
  if (amount <= 0) throw new Error("Amount must be positive");

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const user = await User.findById(userId).session(session);
    if (!user) throw new Error("User not found");

    const current = user.points || 0;
    if (current < amount) {
      throw new Error("Not enough points");
    }

    const next = current - amount;
    user.points = next;
    await user.save();

    await PointTransaction.create(
      [
        {
          userId,
          amount: -amount,
          reason,
          sessionId,
          balanceAfter: next,
        },
      ],
      { session }
    );

    await session.commitTransaction();
    session.endSession();

    return next;
  } catch (err) {
    await session.abortTransaction();
    session.endSession();
    throw err;
  }
}

module.exports = {
  getBalance,
  addPoints,
  deductPoints,
};
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

# generated native folders
/ios
/android
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/details.md">
# Details

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 60 files,  21684 codes, 260 comments, 805 blanks, all 22749 lines

[Summary](results.md) / Details / [Diff Summary](diff.md) / [Diff Details](diff-details.md)

## Files
| filename | language | code | comment | blank | total |
| :--- | :--- | ---: | ---: | ---: | ---: |
| [README.md](/README.md) | Markdown | 31 | 0 | 20 | 51 |
| [app.json](/app.json) | JSON with Comments | 48 | 0 | 1 | 49 |
| [app/(tabs)/\_layout.tsx](/app/(tabs)/_layout.tsx) | TypeScript JSX | 4 | 0 | 2 | 6 |
| [app/(tabs)/explore.tsx](/app/(tabs)/explore.tsx) | TypeScript JSX | 28 | 0 | 3 | 31 |
| [app/(tabs)/index.tsx](/app/(tabs)/index.tsx) | TypeScript JSX | 4 | 0 | 2 | 6 |
| [app/\_layout.tsx](/app/_layout.tsx) | TypeScript JSX | 20 | 0 | 5 | 25 |
| [app/find-mentor.tsx](/app/find-mentor.tsx) | TypeScript JSX | 420 | 8 | 32 | 460 |
| [app/index.tsx](/app/index.tsx) | TypeScript JSX | 4 | 0 | 2 | 6 |
| [app/login.tsx](/app/login.tsx) | TypeScript JSX | 202 | 4 | 17 | 223 |
| [app/manage-skills-to-learn/AddSkillToLearnForm.tsx](/app/manage-skills-to-learn/AddSkillToLearnForm.tsx) | TypeScript JSX | 195 | 1 | 21 | 217 |
| [app/manage-skills-to-learn/CategorySelector.tsx](/app/manage-skills-to-learn/CategorySelector.tsx) | TypeScript JSX | 90 | 1 | 5 | 96 |
| [app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx](/app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx) | TypeScript JSX | 483 | 21 | 47 | 551 |
| [app/manage-skills-to-learn/SkillChip.tsx](/app/manage-skills-to-learn/SkillChip.tsx) | TypeScript JSX | 126 | 1 | 12 | 139 |
| [app/manage-skills-to-learn/SkillsToLearnList.tsx](/app/manage-skills-to-learn/SkillsToLearnList.tsx) | TypeScript JSX | 241 | 2 | 14 | 257 |
| [app/manage-skills-to-learn/SubCategorySelector.tsx](/app/manage-skills-to-learn/SubCategorySelector.tsx) | TypeScript JSX | 97 | 1 | 6 | 104 |
| [app/manage-skills-to-learn/SuggestedSkillsGrid.tsx](/app/manage-skills-to-learn/SuggestedSkillsGrid.tsx) | TypeScript JSX | 121 | 1 | 11 | 133 |
| [app/manage-skills-to-learn/index.tsx](/app/manage-skills-to-learn/index.tsx) | TypeScript JSX | 390 | 8 | 30 | 428 |
| [app/manage-skills-to-learn/skillData.ts](/app/manage-skills-to-learn/skillData.ts) | TypeScript | 160 | 2 | 6 | 168 |
| [app/manage-skills-to-learn/styles.ts](/app/manage-skills-to-learn/styles.ts) | TypeScript | 0 | 0 | 1 | 1 |
| [app/manage-skills-to-learn/types.ts](/app/manage-skills-to-learn/types.ts) | TypeScript | 0 | 0 | 1 | 1 |
| [app/manage-skills-to-learn/useManageSkillsToLearn.ts](/app/manage-skills-to-learn/useManageSkillsToLearn.ts) | TypeScript | 245 | 19 | 53 | 317 |
| [app/manage-skills-to-teach/AddSkillToTeachForm.tsx](/app/manage-skills-to-teach/AddSkillToTeachForm.tsx) | TypeScript JSX | 196 | 1 | 21 | 218 |
| [app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx](/app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx) | TypeScript JSX | 487 | 21 | 49 | 557 |
| [app/manage-skills-to-teach/SkillsToTeachList.tsx](/app/manage-skills-to-teach/SkillsToTeachList.tsx) | TypeScript JSX | 242 | 2 | 14 | 258 |
| [app/manage-skills-to-teach/index.tsx](/app/manage-skills-to-teach/index.tsx) | TypeScript JSX | 5 | 1 | 2 | 8 |
| [app/manage-skills-to-teach/useManageSkillsToTeach.ts](/app/manage-skills-to-teach/useManageSkillsToTeach.ts) | TypeScript | 251 | 17 | 53 | 321 |
| [app/modal.tsx](/app/modal.tsx) | TypeScript JSX | 26 | 0 | 4 | 30 |
| [app/screens/homescreen.tsx](/app/screens/homescreen.tsx) | TypeScript JSX | 674 | 12 | 38 | 724 |
| [app/sessions.tsx](/app/sessions.tsx) | TypeScript JSX | 0 | 0 | 1 | 1 |
| [app/signup.tsx](/app/signup.tsx) | TypeScript JSX | 235 | 1 | 21 | 257 |
| [app/weekly-availability/TimeField.tsx](/app/weekly-availability/TimeField.tsx) | TypeScript JSX | 110 | 4 | 15 | 129 |
| [app/weekly-availability/components.tsx](/app/weekly-availability/components.tsx) | TypeScript JSX | 115 | 1 | 10 | 126 |
| [app/weekly-availability/index.tsx](/app/weekly-availability/index.tsx) | TypeScript JSX | 256 | 12 | 37 | 305 |
| [app/weekly-availability/styles.ts](/app/weekly-availability/styles.ts) | TypeScript | 287 | 9 | 14 | 310 |
| [app/weekly-availability/useWeeklyAvailability.ts](/app/weekly-availability/useWeeklyAvailability.ts) | TypeScript | 119 | 1 | 18 | 138 |
| [components/external-link.tsx](/components/external-link.tsx) | TypeScript JSX | 21 | 2 | 3 | 26 |
| [components/haptic-tab.tsx](/components/haptic-tab.tsx) | TypeScript JSX | 16 | 1 | 2 | 19 |
| [components/hello-wave.tsx](/components/hello-wave.tsx) | TypeScript JSX | 18 | 0 | 2 | 20 |
| [components/parallax-scroll-view.tsx](/components/parallax-scroll-view.tsx) | TypeScript JSX | 73 | 0 | 7 | 80 |
| [components/themed-text.tsx](/components/themed-text.tsx) | TypeScript JSX | 55 | 0 | 6 | 61 |
| [components/themed-view.tsx](/components/themed-view.tsx) | TypeScript JSX | 10 | 0 | 5 | 15 |
| [components/ui/collapsible.tsx](/components/ui/collapsible.tsx) | TypeScript JSX | 40 | 0 | 6 | 46 |
| [components/ui/icon-symbol.ios.tsx](/components/ui/icon-symbol.ios.tsx) | TypeScript JSX | 31 | 0 | 2 | 33 |
| [components/ui/icon-symbol.tsx](/components/ui/icon-symbol.tsx) | TypeScript JSX | 26 | 11 | 5 | 42 |
| [constants/theme.ts](/constants/theme.ts) | TypeScript | 41 | 8 | 5 | 54 |
| [eslint.config.js](/eslint.config.js) | JavaScript JSX | 8 | 1 | 2 | 11 |
| [hooks/use-color-scheme.ts](/hooks/use-color-scheme.ts) | TypeScript | 1 | 0 | 1 | 2 |
| [hooks/use-color-scheme.web.ts](/hooks/use-color-scheme.web.ts) | TypeScript | 13 | 3 | 6 | 22 |
| [hooks/use-theme-color.ts](/hooks/use-theme-color.ts) | TypeScript | 14 | 4 | 4 | 22 |
| [lib/api.ts](/lib/api.ts) | TypeScript | 157 | 31 | 32 | 220 |
| [package-lock.json](/package-lock.json) | JSON | 13,421 | 0 | 1 | 13,422 |
| [package.json](/package.json) | JSON | 49 | 0 | 1 | 50 |
| [scripts/reset-project.js](/scripts/reset-project.js) | JavaScript JSX | 89 | 10 | 14 | 113 |
| [server/.env](/server/.env) | Dotenv | 3 | 0 | 1 | 4 |
| [server/models/User.js](/server/models/User.js) | JavaScript JSX | 37 | 1 | 10 | 48 |
| [server/package-lock.json](/server/package-lock.json) | JSON | 1,203 | 0 | 1 | 1,204 |
| [server/package.json](/server/package.json) | JSON | 6 | 0 | 1 | 7 |
| [server/server.js](/server/server.js) | JavaScript JSX | 297 | 19 | 65 | 381 |
| [server/services/matchingService.js](/server/services/matchingService.js) | JavaScript JSX | 126 | 18 | 34 | 178 |
| [tsconfig.json](/tsconfig.json) | JSON with Comments | 17 | 0 | 1 | 18 |

[Summary](results.md) / Details / [Diff Summary](diff.md) / [Diff Details](diff-details.md)
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff-details.md">
# Diff Details

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 0 files,  0 codes, 0 comments, 0 blanks, all 0 lines

[Summary](results.md) / [Details](details.md) / [Diff Summary](diff.md) / Diff Details

## Files
| filename | language | code | comment | blank | total |
| :--- | :--- | ---: | ---: | ---: | ---: |

[Summary](results.md) / [Details](details.md) / [Diff Summary](diff.md) / Diff Details
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff.csv">
"filename", "language", "", "comment", "blank", "total"
"Total", "-", , 0, 0, 0
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff.md">
# Diff Summary

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 0 files,  0 codes, 0 comments, 0 blanks, all 0 lines

[Summary](results.md) / [Details](details.md) / Diff Summary / [Diff Details](diff-details.md)

## Languages
| language | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |

## Directories
| path | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |

[Summary](results.md) / [Details](details.md) / Diff Summary / [Diff Details](diff-details.md)
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/diff.txt">
Date : 2025-12-10 22:45:17
Directory : c:\Users\shet_\our-final-app
Total : 0 files,  0 codes, 0 comments, 0 blanks, all 0 lines

Languages
+----------+------------+------------+------------+------------+------------+
| language | files      | code       | comment    | blank      | total      |
+----------+------------+------------+------------+------------+------------+
+----------+------------+------------+------------+------------+------------+

Directories
+------+------------+------------+------------+------------+------------+
| path | files      | code       | comment    | blank      | total      |
+------+------------+------------+------------+------------+------------+
+------+------------+------------+------------+------------+------------+

Files
+----------+----------+------------+------------+------------+------------+
| filename | language | code       | comment    | blank      | total      |
+----------+----------+------------+------------+------------+------------+
| Total    |          |          0 |          0 |          0 |          0 |
+----------+----------+------------+------------+------------+------------+
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.csv">
"filename", "language", "JSON", "JSON with Comments", "JavaScript JSX", "TypeScript", "Dotenv", "Markdown", "TypeScript JSX", "comment", "blank", "total"
"c:\Users\shet_\our-final-app\README.md", "Markdown", 0, 0, 0, 0, 0, 31, 0, 0, 20, 51
"c:\Users\shet_\our-final-app\app.json", "JSON with Comments", 0, 48, 0, 0, 0, 0, 0, 0, 1, 49
"c:\Users\shet_\our-final-app\app\(tabs)\_layout.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 4, 0, 2, 6
"c:\Users\shet_\our-final-app\app\(tabs)\explore.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 28, 0, 3, 31
"c:\Users\shet_\our-final-app\app\(tabs)\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 4, 0, 2, 6
"c:\Users\shet_\our-final-app\app\_layout.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 20, 0, 5, 25
"c:\Users\shet_\our-final-app\app\find-mentor.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 420, 8, 32, 460
"c:\Users\shet_\our-final-app\app\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 4, 0, 2, 6
"c:\Users\shet_\our-final-app\app\login.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 202, 4, 17, 223
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\AddSkillToLearnForm.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 195, 1, 21, 217
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\CategorySelector.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 90, 1, 5, 96
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\ManageSkillsToLearnScreen.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 483, 21, 47, 551
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillChip.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 126, 1, 12, 139
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillsToLearnList.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 241, 2, 14, 257
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SubCategorySelector.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 97, 1, 6, 104
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SuggestedSkillsGrid.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 121, 1, 11, 133
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 390, 8, 30, 428
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\skillData.ts", "TypeScript", 0, 0, 0, 160, 0, 0, 0, 2, 6, 168
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\styles.ts", "TypeScript", 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\types.ts", "TypeScript", 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
"c:\Users\shet_\our-final-app\app\manage-skills-to-learn\useManageSkillsToLearn.ts", "TypeScript", 0, 0, 0, 245, 0, 0, 0, 19, 53, 317
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\AddSkillToTeachForm.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 196, 1, 21, 218
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\ManageSkillsToTeachScreen.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 487, 21, 49, 557
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\SkillsToTeachList.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 242, 2, 14, 258
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 5, 1, 2, 8
"c:\Users\shet_\our-final-app\app\manage-skills-to-teach\useManageSkillsToTeach.ts", "TypeScript", 0, 0, 0, 251, 0, 0, 0, 17, 53, 321
"c:\Users\shet_\our-final-app\app\modal.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 26, 0, 4, 30
"c:\Users\shet_\our-final-app\app\screens\homescreen.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 674, 12, 38, 724
"c:\Users\shet_\our-final-app\app\sessions.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
"c:\Users\shet_\our-final-app\app\signup.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 235, 1, 21, 257
"c:\Users\shet_\our-final-app\app\weekly-availability\TimeField.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 110, 4, 15, 129
"c:\Users\shet_\our-final-app\app\weekly-availability\components.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 115, 1, 10, 126
"c:\Users\shet_\our-final-app\app\weekly-availability\index.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 256, 12, 37, 305
"c:\Users\shet_\our-final-app\app\weekly-availability\styles.ts", "TypeScript", 0, 0, 0, 287, 0, 0, 0, 9, 14, 310
"c:\Users\shet_\our-final-app\app\weekly-availability\useWeeklyAvailability.ts", "TypeScript", 0, 0, 0, 119, 0, 0, 0, 1, 18, 138
"c:\Users\shet_\our-final-app\components\external-link.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 21, 2, 3, 26
"c:\Users\shet_\our-final-app\components\haptic-tab.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 16, 1, 2, 19
"c:\Users\shet_\our-final-app\components\hello-wave.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 18, 0, 2, 20
"c:\Users\shet_\our-final-app\components\parallax-scroll-view.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 73, 0, 7, 80
"c:\Users\shet_\our-final-app\components\themed-text.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 55, 0, 6, 61
"c:\Users\shet_\our-final-app\components\themed-view.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 10, 0, 5, 15
"c:\Users\shet_\our-final-app\components\ui\collapsible.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 40, 0, 6, 46
"c:\Users\shet_\our-final-app\components\ui\icon-symbol.ios.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 31, 0, 2, 33
"c:\Users\shet_\our-final-app\components\ui\icon-symbol.tsx", "TypeScript JSX", 0, 0, 0, 0, 0, 0, 26, 11, 5, 42
"c:\Users\shet_\our-final-app\constants\theme.ts", "TypeScript", 0, 0, 0, 41, 0, 0, 0, 8, 5, 54
"c:\Users\shet_\our-final-app\eslint.config.js", "JavaScript JSX", 0, 0, 8, 0, 0, 0, 0, 1, 2, 11
"c:\Users\shet_\our-final-app\hooks\use-color-scheme.ts", "TypeScript", 0, 0, 0, 1, 0, 0, 0, 0, 1, 2
"c:\Users\shet_\our-final-app\hooks\use-color-scheme.web.ts", "TypeScript", 0, 0, 0, 13, 0, 0, 0, 3, 6, 22
"c:\Users\shet_\our-final-app\hooks\use-theme-color.ts", "TypeScript", 0, 0, 0, 14, 0, 0, 0, 4, 4, 22
"c:\Users\shet_\our-final-app\lib\api.ts", "TypeScript", 0, 0, 0, 157, 0, 0, 0, 31, 32, 220
"c:\Users\shet_\our-final-app\package-lock.json", "JSON", 13421, 0, 0, 0, 0, 0, 0, 0, 1, 13422
"c:\Users\shet_\our-final-app\package.json", "JSON", 49, 0, 0, 0, 0, 0, 0, 0, 1, 50
"c:\Users\shet_\our-final-app\scripts\reset-project.js", "JavaScript JSX", 0, 0, 89, 0, 0, 0, 0, 10, 14, 113
"c:\Users\shet_\our-final-app\server\.env", "Dotenv", 0, 0, 0, 0, 3, 0, 0, 0, 1, 4
"c:\Users\shet_\our-final-app\server\models\User.js", "JavaScript JSX", 0, 0, 37, 0, 0, 0, 0, 1, 10, 48
"c:\Users\shet_\our-final-app\server\package-lock.json", "JSON", 1203, 0, 0, 0, 0, 0, 0, 0, 1, 1204
"c:\Users\shet_\our-final-app\server\package.json", "JSON", 6, 0, 0, 0, 0, 0, 0, 0, 1, 7
"c:\Users\shet_\our-final-app\server\server.js", "JavaScript JSX", 0, 0, 297, 0, 0, 0, 0, 19, 65, 381
"c:\Users\shet_\our-final-app\server\services\matchingService.js", "JavaScript JSX", 0, 0, 126, 0, 0, 0, 0, 18, 34, 178
"c:\Users\shet_\our-final-app\tsconfig.json", "JSON with Comments", 0, 17, 0, 0, 0, 0, 0, 0, 1, 18
"Total", "-", 14679, 65, 557, 1288, 3, 31, 5061, 260, 805, 22749
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.json">
{"file:///c%3A/Users/shet_/our-final-app/server/package.json":{"language":"JSON","code":6,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/tsconfig.json":{"language":"JSON with Comments","code":17,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/server/package-lock.json":{"language":"JSON","code":1203,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/server/server.js":{"language":"JavaScript JSX","code":297,"comment":19,"blank":65},"file:///c%3A/Users/shet_/our-final-app/lib/api.ts":{"language":"TypeScript","code":157,"comment":31,"blank":32},"file:///c%3A/Users/shet_/our-final-app/server/services/matchingService.js":{"language":"JavaScript JSX","code":126,"comment":18,"blank":34},"file:///c%3A/Users/shet_/our-final-app/server/models/User.js":{"language":"JavaScript JSX","code":37,"comment":1,"blank":10},"file:///c%3A/Users/shet_/our-final-app/package.json":{"language":"JSON","code":49,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/server/.env":{"language":"Dotenv","code":3,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/scripts/reset-project.js":{"language":"JavaScript JSX","code":89,"comment":10,"blank":14},"file:///c%3A/Users/shet_/our-final-app/README.md":{"language":"Markdown","code":31,"comment":0,"blank":20},"file:///c%3A/Users/shet_/our-final-app/eslint.config.js":{"language":"JavaScript JSX","code":8,"comment":1,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app.json":{"language":"JSON with Comments","code":48,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/hooks/use-theme-color.ts":{"language":"TypeScript","code":14,"comment":4,"blank":4},"file:///c%3A/Users/shet_/our-final-app/hooks/use-color-scheme.web.ts":{"language":"TypeScript","code":13,"comment":3,"blank":6},"file:///c%3A/Users/shet_/our-final-app/components/external-link.tsx":{"language":"TypeScript JSX","code":21,"comment":2,"blank":3},"file:///c%3A/Users/shet_/our-final-app/components/ui/collapsible.tsx":{"language":"TypeScript JSX","code":40,"comment":0,"blank":6},"file:///c%3A/Users/shet_/our-final-app/components/parallax-scroll-view.tsx":{"language":"TypeScript JSX","code":73,"comment":0,"blank":7},"file:///c%3A/Users/shet_/our-final-app/components/themed-view.tsx":{"language":"TypeScript JSX","code":10,"comment":0,"blank":5},"file:///c%3A/Users/shet_/our-final-app/components/themed-text.tsx":{"language":"TypeScript JSX","code":55,"comment":0,"blank":6},"file:///c%3A/Users/shet_/our-final-app/app/_layout.tsx":{"language":"TypeScript JSX","code":20,"comment":0,"blank":5},"file:///c%3A/Users/shet_/our-final-app/components/hello-wave.tsx":{"language":"TypeScript JSX","code":18,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/components/haptic-tab.tsx":{"language":"TypeScript JSX","code":16,"comment":1,"blank":2},"file:///c%3A/Users/shet_/our-final-app/hooks/use-color-scheme.ts":{"language":"TypeScript","code":1,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/sessions.tsx":{"language":"TypeScript JSX","code":0,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/components/ui/icon-symbol.ios.tsx":{"language":"TypeScript JSX","code":31,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/constants/theme.ts":{"language":"TypeScript","code":41,"comment":8,"blank":5},"file:///c%3A/Users/shet_/our-final-app/components/ui/icon-symbol.tsx":{"language":"TypeScript JSX","code":26,"comment":11,"blank":5},"file:///c%3A/Users/shet_/our-final-app/app/modal.tsx":{"language":"TypeScript JSX","code":26,"comment":0,"blank":4},"file:///c%3A/Users/shet_/our-final-app/app/signup.tsx":{"language":"TypeScript JSX","code":235,"comment":1,"blank":21},"file:///c%3A/Users/shet_/our-final-app/app/login.tsx":{"language":"TypeScript JSX","code":202,"comment":4,"blank":17},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/useWeeklyAvailability.ts":{"language":"TypeScript","code":119,"comment":1,"blank":18},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/styles.ts":{"language":"TypeScript","code":287,"comment":9,"blank":14},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/TimeField.tsx":{"language":"TypeScript JSX","code":110,"comment":4,"blank":15},"file:///c%3A/Users/shet_/our-final-app/app/index.tsx":{"language":"TypeScript JSX","code":4,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/index.tsx":{"language":"TypeScript JSX","code":256,"comment":12,"blank":37},"file:///c%3A/Users/shet_/our-final-app/app/weekly-availability/components.tsx":{"language":"TypeScript JSX","code":115,"comment":1,"blank":10},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx":{"language":"TypeScript JSX","code":487,"comment":21,"blank":49},"file:///c%3A/Users/shet_/our-final-app/app/find-mentor.tsx":{"language":"TypeScript JSX","code":420,"comment":8,"blank":32},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/index.tsx":{"language":"TypeScript JSX","code":5,"comment":1,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/AddSkillToLearnForm.tsx":{"language":"TypeScript JSX","code":195,"comment":1,"blank":21},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/useManageSkillsToTeach.ts":{"language":"TypeScript","code":251,"comment":17,"blank":53},"file:///c%3A/Users/shet_/our-final-app/app/screens/homescreen.tsx":{"language":"TypeScript JSX","code":674,"comment":12,"blank":38},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/AddSkillToTeachForm.tsx":{"language":"TypeScript JSX","code":196,"comment":1,"blank":21},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx":{"language":"TypeScript JSX","code":483,"comment":21,"blank":47},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-teach/SkillsToTeachList.tsx":{"language":"TypeScript JSX","code":242,"comment":2,"blank":14},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/skillData.ts":{"language":"TypeScript","code":160,"comment":2,"blank":6},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/useManageSkillsToLearn.ts":{"language":"TypeScript","code":245,"comment":19,"blank":53},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SkillChip.tsx":{"language":"TypeScript JSX","code":126,"comment":1,"blank":12},"file:///c%3A/Users/shet_/our-final-app/app/%28tabs%29/explore.tsx":{"language":"TypeScript JSX","code":28,"comment":0,"blank":3},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/CategorySelector.tsx":{"language":"TypeScript JSX","code":90,"comment":1,"blank":5},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/types.ts":{"language":"TypeScript","code":0,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/styles.ts":{"language":"TypeScript","code":0,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/index.tsx":{"language":"TypeScript JSX","code":390,"comment":8,"blank":30},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SubCategorySelector.tsx":{"language":"TypeScript JSX","code":97,"comment":1,"blank":6},"file:///c%3A/Users/shet_/our-final-app/app/%28tabs%29/index.tsx":{"language":"TypeScript JSX","code":4,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/package-lock.json":{"language":"JSON","code":13421,"comment":0,"blank":1},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SuggestedSkillsGrid.tsx":{"language":"TypeScript JSX","code":121,"comment":1,"blank":11},"file:///c%3A/Users/shet_/our-final-app/app/%28tabs%29/_layout.tsx":{"language":"TypeScript JSX","code":4,"comment":0,"blank":2},"file:///c%3A/Users/shet_/our-final-app/app/manage-skills-to-learn/SkillsToLearnList.tsx":{"language":"TypeScript JSX","code":241,"comment":2,"blank":14}}
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.md">
# Summary

Date : 2025-12-10 22:45:17

Directory c:\\Users\\shet_\\our-final-app

Total : 60 files,  21684 codes, 260 comments, 805 blanks, all 22749 lines

Summary / [Details](details.md) / [Diff Summary](diff.md) / [Diff Details](diff-details.md)

## Languages
| language | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |
| JSON | 4 | 14,679 | 0 | 4 | 14,683 |
| TypeScript JSX | 35 | 5,061 | 117 | 459 | 5,637 |
| TypeScript | 12 | 1,288 | 94 | 194 | 1,576 |
| JavaScript JSX | 5 | 557 | 49 | 125 | 731 |
| JSON with Comments | 2 | 65 | 0 | 2 | 67 |
| Markdown | 1 | 31 | 0 | 20 | 51 |
| Dotenv | 1 | 3 | 0 | 1 | 4 |

## Directories
| path | files | code | comment | blank | total |
| :--- | ---: | ---: | ---: | ---: | ---: |
| . | 60 | 21,684 | 260 | 805 | 22,749 |
| . (Files) | 6 | 13,574 | 1 | 26 | 13,601 |
| app | 33 | 5,833 | 151 | 567 | 6,551 |
| app (Files) | 7 | 907 | 13 | 82 | 1,002 |
| app\\(tabs) | 3 | 36 | 0 | 7 | 43 |
| app\\manage-skills-to-learn | 12 | 2,148 | 57 | 207 | 2,412 |
| app\\manage-skills-to-teach | 5 | 1,181 | 42 | 139 | 1,362 |
| app\\screens | 1 | 674 | 12 | 38 | 724 |
| app\\weekly-availability | 5 | 887 | 27 | 94 | 1,008 |
| components | 9 | 290 | 14 | 38 | 342 |
| components (Files) | 6 | 193 | 3 | 25 | 221 |
| components\\ui | 3 | 97 | 11 | 13 | 121 |
| constants | 1 | 41 | 8 | 5 | 54 |
| hooks | 3 | 28 | 7 | 11 | 46 |
| lib | 1 | 157 | 31 | 32 | 220 |
| scripts | 1 | 89 | 10 | 14 | 113 |
| server | 6 | 1,672 | 38 | 112 | 1,822 |
| server (Files) | 4 | 1,509 | 19 | 68 | 1,596 |
| server\\models | 1 | 37 | 1 | 10 | 48 |
| server\\services | 1 | 126 | 18 | 34 | 178 |

Summary / [Details](details.md) / [Diff Summary](diff.md) / [Diff Details](diff-details.md)
</file>

<file path=".VSCodeCounter/2025-12-10_22-45-17/results.txt">
Date : 2025-12-10 22:45:17
Directory : c:\Users\shet_\our-final-app
Total : 60 files,  21684 codes, 260 comments, 805 blanks, all 22749 lines

Languages
+--------------------+------------+------------+------------+------------+------------+
| language           | files      | code       | comment    | blank      | total      |
+--------------------+------------+------------+------------+------------+------------+
| JSON               |          4 |     14,679 |          0 |          4 |     14,683 |
| TypeScript JSX     |         35 |      5,061 |        117 |        459 |      5,637 |
| TypeScript         |         12 |      1,288 |         94 |        194 |      1,576 |
| JavaScript JSX     |          5 |        557 |         49 |        125 |        731 |
| JSON with Comments |          2 |         65 |          0 |          2 |         67 |
| Markdown           |          1 |         31 |          0 |         20 |         51 |
| Dotenv             |          1 |          3 |          0 |          1 |          4 |
+--------------------+------------+------------+------------+------------+------------+

Directories
+---------------------------------------------------------------------------------------+------------+------------+------------+------------+------------+
| path                                                                                  | files      | code       | comment    | blank      | total      |
+---------------------------------------------------------------------------------------+------------+------------+------------+------------+------------+
| .                                                                                     |         60 |     21,684 |        260 |        805 |     22,749 |
| . (Files)                                                                             |          6 |     13,574 |          1 |         26 |     13,601 |
| app                                                                                   |         33 |      5,833 |        151 |        567 |      6,551 |
| app (Files)                                                                           |          7 |        907 |         13 |         82 |      1,002 |
| app\(tabs)                                                                            |          3 |         36 |          0 |          7 |         43 |
| app\manage-skills-to-learn                                                            |         12 |      2,148 |         57 |        207 |      2,412 |
| app\manage-skills-to-teach                                                            |          5 |      1,181 |         42 |        139 |      1,362 |
| app\screens                                                                           |          1 |        674 |         12 |         38 |        724 |
| app\weekly-availability                                                               |          5 |        887 |         27 |         94 |      1,008 |
| components                                                                            |          9 |        290 |         14 |         38 |        342 |
| components (Files)                                                                    |          6 |        193 |          3 |         25 |        221 |
| components\ui                                                                         |          3 |         97 |         11 |         13 |        121 |
| constants                                                                             |          1 |         41 |          8 |          5 |         54 |
| hooks                                                                                 |          3 |         28 |          7 |         11 |         46 |
| lib                                                                                   |          1 |        157 |         31 |         32 |        220 |
| scripts                                                                               |          1 |         89 |         10 |         14 |        113 |
| server                                                                                |          6 |      1,672 |         38 |        112 |      1,822 |
| server (Files)                                                                        |          4 |      1,509 |         19 |         68 |      1,596 |
| server\models                                                                         |          1 |         37 |          1 |         10 |         48 |
| server\services                                                                       |          1 |        126 |         18 |         34 |        178 |
+---------------------------------------------------------------------------------------+------------+------------+------------+------------+------------+

Files
+---------------------------------------------------------------------------------------+--------------------+------------+------------+------------+------------+
| filename                                                                              | language           | code       | comment    | blank      | total      |
+---------------------------------------------------------------------------------------+--------------------+------------+------------+------------+------------+
| c:\Users\shet_\our-final-app\README.md                                                | Markdown           |         31 |          0 |         20 |         51 |
| c:\Users\shet_\our-final-app\app.json                                                 | JSON with Comments |         48 |          0 |          1 |         49 |
| c:\Users\shet_\our-final-app\app\(tabs)\_layout.tsx                                   | TypeScript JSX     |          4 |          0 |          2 |          6 |
| c:\Users\shet_\our-final-app\app\(tabs)\explore.tsx                                   | TypeScript JSX     |         28 |          0 |          3 |         31 |
| c:\Users\shet_\our-final-app\app\(tabs)\index.tsx                                     | TypeScript JSX     |          4 |          0 |          2 |          6 |
| c:\Users\shet_\our-final-app\app\_layout.tsx                                          | TypeScript JSX     |         20 |          0 |          5 |         25 |
| c:\Users\shet_\our-final-app\app\find-mentor.tsx                                      | TypeScript JSX     |        420 |          8 |         32 |        460 |
| c:\Users\shet_\our-final-app\app\index.tsx                                            | TypeScript JSX     |          4 |          0 |          2 |          6 |
| c:\Users\shet_\our-final-app\app\login.tsx                                            | TypeScript JSX     |        202 |          4 |         17 |        223 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\AddSkillToLearnForm.tsx       | TypeScript JSX     |        195 |          1 |         21 |        217 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\CategorySelector.tsx          | TypeScript JSX     |         90 |          1 |          5 |         96 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\ManageSkillsToLearnScreen.tsx | TypeScript JSX     |        483 |         21 |         47 |        551 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillChip.tsx                 | TypeScript JSX     |        126 |          1 |         12 |        139 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SkillsToLearnList.tsx         | TypeScript JSX     |        241 |          2 |         14 |        257 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SubCategorySelector.tsx       | TypeScript JSX     |         97 |          1 |          6 |        104 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\SuggestedSkillsGrid.tsx       | TypeScript JSX     |        121 |          1 |         11 |        133 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\index.tsx                     | TypeScript JSX     |        390 |          8 |         30 |        428 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\skillData.ts                  | TypeScript         |        160 |          2 |          6 |        168 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\styles.ts                     | TypeScript         |          0 |          0 |          1 |          1 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\types.ts                      | TypeScript         |          0 |          0 |          1 |          1 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-learn\useManageSkillsToLearn.ts     | TypeScript         |        245 |         19 |         53 |        317 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\AddSkillToTeachForm.tsx       | TypeScript JSX     |        196 |          1 |         21 |        218 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\ManageSkillsToTeachScreen.tsx | TypeScript JSX     |        487 |         21 |         49 |        557 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\SkillsToTeachList.tsx         | TypeScript JSX     |        242 |          2 |         14 |        258 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\index.tsx                     | TypeScript JSX     |          5 |          1 |          2 |          8 |
| c:\Users\shet_\our-final-app\app\manage-skills-to-teach\useManageSkillsToTeach.ts     | TypeScript         |        251 |         17 |         53 |        321 |
| c:\Users\shet_\our-final-app\app\modal.tsx                                            | TypeScript JSX     |         26 |          0 |          4 |         30 |
| c:\Users\shet_\our-final-app\app\screens\homescreen.tsx                               | TypeScript JSX     |        674 |         12 |         38 |        724 |
| c:\Users\shet_\our-final-app\app\sessions.tsx                                         | TypeScript JSX     |          0 |          0 |          1 |          1 |
| c:\Users\shet_\our-final-app\app\signup.tsx                                           | TypeScript JSX     |        235 |          1 |         21 |        257 |
| c:\Users\shet_\our-final-app\app\weekly-availability\TimeField.tsx                    | TypeScript JSX     |        110 |          4 |         15 |        129 |
| c:\Users\shet_\our-final-app\app\weekly-availability\components.tsx                   | TypeScript JSX     |        115 |          1 |         10 |        126 |
| c:\Users\shet_\our-final-app\app\weekly-availability\index.tsx                        | TypeScript JSX     |        256 |         12 |         37 |        305 |
| c:\Users\shet_\our-final-app\app\weekly-availability\styles.ts                        | TypeScript         |        287 |          9 |         14 |        310 |
| c:\Users\shet_\our-final-app\app\weekly-availability\useWeeklyAvailability.ts         | TypeScript         |        119 |          1 |         18 |        138 |
| c:\Users\shet_\our-final-app\components\external-link.tsx                             | TypeScript JSX     |         21 |          2 |          3 |         26 |
| c:\Users\shet_\our-final-app\components\haptic-tab.tsx                                | TypeScript JSX     |         16 |          1 |          2 |         19 |
| c:\Users\shet_\our-final-app\components\hello-wave.tsx                                | TypeScript JSX     |         18 |          0 |          2 |         20 |
| c:\Users\shet_\our-final-app\components\parallax-scroll-view.tsx                      | TypeScript JSX     |         73 |          0 |          7 |         80 |
| c:\Users\shet_\our-final-app\components\themed-text.tsx                               | TypeScript JSX     |         55 |          0 |          6 |         61 |
| c:\Users\shet_\our-final-app\components\themed-view.tsx                               | TypeScript JSX     |         10 |          0 |          5 |         15 |
| c:\Users\shet_\our-final-app\components\ui\collapsible.tsx                            | TypeScript JSX     |         40 |          0 |          6 |         46 |
| c:\Users\shet_\our-final-app\components\ui\icon-symbol.ios.tsx                        | TypeScript JSX     |         31 |          0 |          2 |         33 |
| c:\Users\shet_\our-final-app\components\ui\icon-symbol.tsx                            | TypeScript JSX     |         26 |         11 |          5 |         42 |
| c:\Users\shet_\our-final-app\constants\theme.ts                                       | TypeScript         |         41 |          8 |          5 |         54 |
| c:\Users\shet_\our-final-app\eslint.config.js                                         | JavaScript JSX     |          8 |          1 |          2 |         11 |
| c:\Users\shet_\our-final-app\hooks\use-color-scheme.ts                                | TypeScript         |          1 |          0 |          1 |          2 |
| c:\Users\shet_\our-final-app\hooks\use-color-scheme.web.ts                            | TypeScript         |         13 |          3 |          6 |         22 |
| c:\Users\shet_\our-final-app\hooks\use-theme-color.ts                                 | TypeScript         |         14 |          4 |          4 |         22 |
| c:\Users\shet_\our-final-app\lib\api.ts                                               | TypeScript         |        157 |         31 |         32 |        220 |
| c:\Users\shet_\our-final-app\package-lock.json                                        | JSON               |     13,421 |          0 |          1 |     13,422 |
| c:\Users\shet_\our-final-app\package.json                                             | JSON               |         49 |          0 |          1 |         50 |
| c:\Users\shet_\our-final-app\scripts\reset-project.js                                 | JavaScript JSX     |         89 |         10 |         14 |        113 |
| c:\Users\shet_\our-final-app\server\.env                                              | Dotenv             |          3 |          0 |          1 |          4 |
| c:\Users\shet_\our-final-app\server\models\User.js                                    | JavaScript JSX     |         37 |          1 |         10 |         48 |
| c:\Users\shet_\our-final-app\server\package-lock.json                                 | JSON               |      1,203 |          0 |          1 |      1,204 |
| c:\Users\shet_\our-final-app\server\package.json                                      | JSON               |          6 |          0 |          1 |          7 |
| c:\Users\shet_\our-final-app\server\server.js                                         | JavaScript JSX     |        297 |         19 |         65 |        381 |
| c:\Users\shet_\our-final-app\server\services\matchingService.js                       | JavaScript JSX     |        126 |         18 |         34 |        178 |
| c:\Users\shet_\our-final-app\tsconfig.json                                            | JSON with Comments |         17 |          0 |          1 |         18 |
| Total                                                                                 |                    |     21,684 |        260 |        805 |     22,749 |
+---------------------------------------------------------------------------------------+--------------------+------------+------------+------------+------------+
</file>

<file path="app.json">
{
  "expo": {
    "name": "our-final-app",
    "slug": "our-final-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "ourfinalapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}
</file>

<file path="app/_layout.tsx">
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/use-color-scheme';

export const unstable_settings = {
  anchor: '(tabs)',
};

export default function RootLayout() {
  const colorScheme = useColorScheme();

  return (
    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="modal" options={{ presentation: 'modal', title: 'Modal' }} />
      </Stack>
      <StatusBar style="auto" />
    </ThemeProvider>
  );
}
</file>

<file path="app/find-mentor.tsx">
// app/find-mentor.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import type { MatchingMode } from "../lib/api";
import {
  AvailabilitySlot,
  MentorMatch,
  SkillLearn,
  getMe,
  getMentorMatches,
} from "../lib/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points: number;
  xp: number;
  streak: number;
  skillsToLearn?: SkillLearn[];
  availabilitySlots?: AvailabilitySlot[];
};

type LevelOption = "Beginner" | "Intermediate" | "Advanced";

const LEVELS: { value: LevelOption; label: string }[] = [
  { value: "Beginner", label: "Beginner" },
  { value: "Intermediate", label: "Intermediate" },
  { value: "Advanced", label: "Advanced" },
];

const MODES: { value: MatchingMode; label: string; hint: string }[] = [
  { value: "local", label: "Local", hint: "Fast, no API key needed" },
  { value: "openai", label: "OpenAI", hint: "Semantic embeddings (needs key)" },
  { value: "hybrid", label: "Hybrid", hint: "OpenAI → fallback to Local" },
];

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

export default function FindMentorScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loadingUser, setLoadingUser] = useState(true);
  const [loadingMatches, setLoadingMatches] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [selectedSkill, setSelectedSkill] = useState<string>("");
  const [customSkill, setCustomSkill] = useState<string>("");
  const [selectedLevel, setSelectedLevel] = useState<LevelOption>("Beginner");
  const [useMyAvailability, setUseMyAvailability] = useState<boolean>(true);
  const [mode, setMode] = useState<MatchingMode>("local");

  const [matches, setMatches] = useState<MentorMatch[]>([]);
  const [hasSearched, setHasSearched] = useState(false);

  // ---- Load current user ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      try {
        setErrorText(null);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/login");
          return;
        }

        const data = (await getMe(token)) as any;
        const userFromApi: User = (data?.user ?? data) as User;

        if (!isMounted) return;

        setUser(userFromApi);

        const skills = userFromApi.skillsToLearn ?? [];
        if (skills.length > 0 && skills[0]?.name) {
          setSelectedSkill(skills[0].name);
        }
      } catch (err: any) {
        console.log("FindMentor / getMe error:", err);
        if (isMounted) {
          setErrorText(
            err?.message ||
              "We couldn’t load your profile. Please go back and try again."
          );
        }
      } finally {
        if (isMounted) setLoadingUser(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, [router]);

  const learningSkills = useMemo(() => {
    const arr = user?.skillsToLearn ?? [];
    return arr
      .map((s) => ({
        name: String(s?.name || "").trim(),
        level: String((s as any)?.level || "Not specified").trim(),
      }))
      .filter((s) => !!s.name);
  }, [user?.skillsToLearn]);

  const availabilitySlots = useMemo(
    () => user?.availabilitySlots ?? [],
    [user?.availabilitySlots]
  );

  const effectiveSkill = useMemo(() => {
    if (customSkill.trim()) return customSkill.trim();
    return selectedSkill.trim();
  }, [customSkill, selectedSkill]);

  const canSearch = !!effectiveSkill && !loadingMatches && !loadingUser;

  const handleSearch = async () => {
    if (!canSearch) return;

    try {
      setErrorText(null);
      setLoadingMatches(true);
      setHasSearched(true);
      setMatches([]);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/login");
        return;
      }

      const payload = {
        skill: effectiveSkill,
        level: selectedLevel,
        availabilitySlots: useMyAvailability ? availabilitySlots : [],
        mode,
      };

      const res = await getMentorMatches(token, payload);
      setMatches(res.results ?? []);
    } catch (err: any) {
      console.log("getMentorMatches error:", err);
      setErrorText(
        err?.message ||
          "Something went wrong while searching for mentors. Please try again."
      );
    } finally {
      setLoadingMatches(false);
    }
  };

  const handleBack = () => router.back();

  // ✅ NEW: open mentor profile
  const handleOpenMentorProfile = (mentorId: string) => {
    // we pass mentorId so profile page can show mentor later
    router.push({ pathname: "/profile", params: { mentorId } } as any);
  };

  if (loadingUser && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your profile…</Text>
      </View>
    );
  }

  const noLearningSkills = learningSkills.length === 0;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={handleBack} activeOpacity={0.85}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Find a mentor</Text>
        <Text style={styles.subtitle}>
          Pick a skill you want help with and we’ll look for people who can
          teach you.
        </Text>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Something went wrong</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
          </View>
        )}

        {/* 0. Matching mode */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>0. Matching mode</Text>
          <Text style={styles.sectionDescription}>
            Switch matching method with one tap (no code changes).
          </Text>

          <View style={styles.levelRow}>
            {MODES.map((opt) => {
              const active = mode === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setMode(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>

          <Text style={styles.modeHint}>
            Current: <Text style={styles.modeHintStrong}>{mode}</Text> —{" "}
            {MODES.find((m) => m.value === mode)?.hint}
          </Text>
        </View>

        {/* 1. Skill selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>1. Choose a skill</Text>
          <Text style={styles.sectionDescription}>
            Start with one of your learning goals, or type a custom skill.
          </Text>

          {noLearningSkills ? (
            <View style={styles.infoBox}>
              <Text style={styles.infoTitle}>No learning skills found</Text>
              <Text style={styles.infoBody}>
                You don’t have any learning goals yet. Go back to your dashboard
                and add some skills you want to learn.
              </Text>
            </View>
          ) : (
            <>
              <Text style={styles.label}>From your learning list</Text>
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.chipsRow}
              >
                {learningSkills.map((skillObj) => {
                  const active = selectedSkill === skillObj.name;
                  return (
                    <TouchableOpacity
                      key={skillObj.name}
                      onPress={() => setSelectedSkill(skillObj.name)}
                      style={[
                        styles.skillChip,
                        active && styles.skillChipActive,
                      ]}
                      activeOpacity={0.85}
                    >
                      <Text
                        style={[
                          styles.skillChipText,
                          active && styles.skillChipTextActive,
                        ]}
                      >
                        {skillObj.name}
                        {skillObj.level && skillObj.level !== "Not specified"
                          ? ` · ${skillObj.level}`
                          : ""}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </ScrollView>
            </>
          )}

          <Text style={[styles.label, { marginTop: 10 }]}>
            Or type a custom skill
          </Text>
          <TextInput
            style={styles.input}
            placeholder="e.g. React Native, Public speaking"
            placeholderTextColor="#6b7280"
            value={customSkill}
            onChangeText={setCustomSkill}
          />

          <View style={styles.currentSkillBox}>
            <Text style={styles.currentSkillLabel}>Current search skill:</Text>
            <Text style={styles.currentSkillValue}>
              {effectiveSkill || "Not selected yet"}
            </Text>
          </View>
        </View>

        {/* 2. Level selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>2. Your level</Text>
          <Text style={styles.sectionDescription}>
            This helps us prioritize mentors who match your current experience.
          </Text>

          <View style={styles.levelRow}>
            {LEVELS.map((opt) => {
              const active = selectedLevel === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setSelectedLevel(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>

        {/* 3. Availability usage */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>3. Availability</Text>
          <Text style={styles.sectionDescription}>
            We can use your weekly availability to prioritize mentors who are
            free at similar times.
          </Text>

          <TouchableOpacity
            style={styles.toggleRow}
            onPress={() => setUseMyAvailability((prev) => !prev)}
            activeOpacity={0.85}
          >
            <View
              style={[
                styles.toggleOuter,
                useMyAvailability && styles.toggleOuterOn,
              ]}
            >
              <View
                style={[
                  styles.toggleInner,
                  useMyAvailability && styles.toggleInnerOn,
                ]}
              />
            </View>
            <Text style={styles.toggleLabel}>
              Use my weekly availability from dashboard
            </Text>
          </TouchableOpacity>

          {useMyAvailability && availabilitySlots.length > 0 && (
            <View style={styles.availabilityPreview}>
              {availabilitySlots.slice(0, 3).map((slot, idx) => (
                <Text key={idx} style={styles.availabilityLine}>
                  {dayNames[slot.dayOfWeek] ?? `Day ${slot.dayOfWeek}`}:{" "}
                  {slot.from} – {slot.to}
                </Text>
              ))}
              {availabilitySlots.length > 3 && (
                <Text style={styles.availabilityMore}>
                  + {availabilitySlots.length - 3} more…
                </Text>
              )}
            </View>
          )}

          {useMyAvailability && availabilitySlots.length === 0 && (
            <Text style={styles.noAvailabilityText}>
              You don’t have any availability set yet. You can still search for
              mentors, but results won’t be filtered by time.
            </Text>
          )}
        </View>

        {/* Search button */}
        <TouchableOpacity
          style={[
            styles.searchButton,
            (!canSearch || loadingMatches) && styles.searchButtonDisabled,
          ]}
          onPress={handleSearch}
          disabled={!canSearch}
          activeOpacity={0.85}
        >
          {loadingMatches ? (
            <ActivityIndicator color="#ffffff" />
          ) : (
            <Text style={styles.searchButtonText}>Search for mentors</Text>
          )}
        </TouchableOpacity>

        {/* Results */}
        <View style={styles.resultsSection}>
          <Text style={styles.resultsTitle}>Results</Text>

          {!hasSearched && (
            <Text style={styles.resultsHint}>
              Start by selecting a skill and tapping “Search for mentors”.
            </Text>
          )}

          {hasSearched && !loadingMatches && matches.length === 0 && (
            <Text style={styles.resultsHint}>
              No mentors found yet for this skill. Try another skill or relax
              your filters.
            </Text>
          )}

          {matches.map((m) => (
            <View key={m.mentorId} style={styles.matchCard}>
              <View style={styles.matchHeaderRow}>
                <Text style={styles.matchName}>{m.fullName}</Text>
                <Text style={styles.matchScore}>
                  {Math.round(m.matchScore * 100)}%
                </Text>
              </View>

              {m.mainMatchedSkill && (
                <Text style={styles.matchSkillLine}>
                  Best match:{" "}
                  <Text style={styles.matchSkillHighlight}>
                    {m.mainMatchedSkill.name} ({m.mainMatchedSkill.level})
                  </Text>{" "}
                  · similarity{" "}
                  {Math.round(m.mainMatchedSkill.similarityScore * 100)}%
                </Text>
              )}

              {m.skillsToTeach && m.skillsToTeach.length > 0 && (
                <View style={styles.matchSkillsList}>
                  <Text style={styles.matchSkillsLabel}>Teaches:</Text>
                  <Text style={styles.matchSkillsValue}>
                    {m.skillsToTeach
                      .slice(0, 3)
                      .map((s) => s.name)
                      .join(", ")}
                    {m.skillsToTeach.length > 3
                      ? ` +${m.skillsToTeach.length - 3} more`
                      : ""}
                  </Text>
                </View>
              )}

              {m.availabilitySlots && m.availabilitySlots.length > 0 && (
                <Text style={styles.matchAvailability}>
                  Example availability:{" "}
                  {dayNames[m.availabilitySlots[0].dayOfWeek] ??
                    `Day ${m.availabilitySlots[0].dayOfWeek}`}{" "}
                  · {m.availabilitySlots[0].from} – {m.availabilitySlots[0].to}
                </Text>
              )}

              {/* ✅ FIX: add onPress */}
              <TouchableOpacity
                style={styles.matchActionButton}
                activeOpacity={0.85}
                onPress={() => router.push(`/mentor/${m.mentorId}` as any)}
              >
                <Text style={styles.matchActionText}>View profile</Text>
              </TouchableOpacity>
            </View>
          ))}
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 14,
  },
  container: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 32,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  backText: {
    fontSize: 14,
    color: "#60A5FA",
  },
  title: {
    fontSize: 22,
    fontWeight: "700",
    color: "#F9FAFB",
    marginTop: 4,
  },
  subtitle: {
    fontSize: 13,
    color: "#9CA3AF",
    marginTop: 4,
    marginBottom: 14,
  },
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
  },
  card: {
    backgroundColor: "#020617",
    borderRadius: 16,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 14,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#F9FAFB",
    marginBottom: 4,
  },
  sectionDescription: {
    fontSize: 12,
    color: "#94A3B8",
    marginBottom: 10,
  },
  label: {
    fontSize: 12,
    color: "#CBD5F5",
    marginBottom: 4,
  },
  chipsRow: {
    flexDirection: "row",
    gap: 8,
    paddingVertical: 4,
  },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  skillChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  skillChipText: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  skillChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "600",
  },
  input: {
    marginTop: 2,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b5563",
    backgroundColor: "#020617",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#f9fafb",
  },
  currentSkillBox: {
    marginTop: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  currentSkillLabel: {
    color: "#94A3B8",
    fontSize: 11,
    marginBottom: 2,
  },
  currentSkillValue: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "500",
  },
  infoBox: {
    marginTop: 4,
    marginBottom: 8,
    padding: 10,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  infoTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 2,
  },
  infoBody: {
    color: "#9CA3AF",
    fontSize: 12,
  },
  levelRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 6,
  },
  levelChip: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
    alignItems: "center",
  },
  levelChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  levelChipText: {
    color: "#E5E7EB",
    fontSize: 13,
  },
  levelChipTextActive: {
    fontWeight: "600",
  },
  toggleRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
  },
  toggleOuter: {
    width: 38,
    height: 22,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#6B7280",
    padding: 2,
    justifyContent: "center",
  },
  toggleOuterOn: {
    borderColor: "#22C55E",
    backgroundColor: "#022C22",
  },
  toggleInner: {
    width: 16,
    height: 16,
    borderRadius: 999,
    backgroundColor: "#6B7280",
    alignSelf: "flex-start",
  },
  toggleInnerOn: {
    backgroundColor: "#22C55E",
    alignSelf: "flex-end",
  },
  toggleLabel: {
    marginLeft: 8,
    color: "#CBD5F5",
    fontSize: 12,
    flex: 1,
  },
  availabilityPreview: {
    marginTop: 8,
    padding: 8,
    borderRadius: 8,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#111827",
  },
  availabilityLine: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  availabilityMore: {
    color: "#9CA3AF",
    fontSize: 11,
    marginTop: 4,
  },
  noAvailabilityText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 12,
  },
  searchButton: {
    marginTop: 4,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  searchButtonDisabled: {
    opacity: 0.7,
  },
  searchButtonText: {
    color: "#ffffff",
    fontWeight: "600",
    fontSize: 15,
  },
  resultsSection: {
    marginTop: 18,
  },
  resultsTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "600",
    marginBottom: 4,
  },
  resultsHint: {
    color: "#9CA3AF",
    fontSize: 12,
  },
  matchCard: {
    marginTop: 10,
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  matchHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 4,
  },
  matchName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "600",
  },
  matchScore: {
    color: "#F97316",
    fontSize: 14,
    fontWeight: "700",
  },
  matchSkillLine: {
    color: "#CBD5F5",
    fontSize: 12,
    marginTop: 4,
  },
  matchSkillHighlight: {
    color: "#FDE68A",
    fontWeight: "600",
  },
  matchSkillsList: {
    marginTop: 6,
  },
  matchSkillsLabel: {
    color: "#94A3B8",
    fontSize: 11,
  },
  matchSkillsValue: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  matchAvailability: {
    marginTop: 6,
    color: "#9CA3AF",
    fontSize: 11,
  },
  matchActionButton: {
    marginTop: 8,
    borderRadius: 999,
    paddingVertical: 8,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  matchActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "600",
  },
  modeHint: {
    marginTop: 10,
    color: "#9CA3AF",
    fontSize: 12,
  },
  modeHintStrong: {
    color: "#F9FAFB",
    fontWeight: "700",
  },
});
</file>

<file path="app/manage-skills-to-learn/AddSkillToLearnForm.tsx">
// app/manage-skills-to-learn/AddSkillToLearnForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { LEARN_LEVELS, LearnLevel } from "./types";

type Props = {
  onAdd: (name: string, level?: LearnLevel) => Promise<void> | void;
  onAddFavorite: (name: string, level?: LearnLevel) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

const AddSkillToLearnForm: React.FC<Props> = ({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}) => {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. React Native, Guitar, Public speaking";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    // slightly smarter: startsWith first, then includes
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) {
        await onAddFavorite(normalizedValue, selectedLevel);
      } else {
        await onAdd(normalizedValue, selectedLevel);
      }
      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      // keep local errors minimal; backend errors already appear in screen error box
      console.log("AddSkillToLearnForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Type a skill you want to learn, choose the level, then add it to your
        list.
      </Text>

      {/* Level selection */}
      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {LEARN_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      {/* Input */}
      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>

        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      {/* Actions */}
      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {/* Suggestions */}
      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
                accessibilityHint="Fills the input with this suggestion"
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
};

export default AddSkillToLearnForm;

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },

  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
  },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },

  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },

  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },

  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  levelPillText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "800",
  },
  levelPillTextActive: {
    color: "#ffffff",
  },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: {
    fontSize: 12,
    fontWeight: "800",
    color: "#2563eb",
  },

  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: {
    borderColor: "#fca5a5",
    backgroundColor: "#fff1f2",
  },

  errorText: {
    fontSize: 12,
    color: "#b91c1c",
    marginTop: 6,
  },

  buttonsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
  },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: {
    backgroundColor: "#2563eb",
  },
  primaryButtonText: {
    color: "#f9fafb",
    fontSize: 13,
    fontWeight: "900",
  },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: {
    color: "#374151",
    fontSize: 13,
    fontWeight: "800",
  },

  suggestionsSection: {
    marginTop: 12,
  },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: {
    fontSize: 12,
    color: "#6b7280",
    fontWeight: "800",
  },
  suggestionsHint: {
    fontSize: 11,
    color: "#9ca3af",
    fontWeight: "700",
  },
  suggestionsRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/CategorySelector.tsx">
// app/manage-skills-to-learn/CategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SKILL_CATEGORIES, SkillCategory } from "./skillData";

export type CategorySelectorProps = {
  selectedCategoryId: string | null;
  onSelect: (id: string) => void;
};

const CategorySelector: React.FC<CategorySelectorProps> = ({
  selectedCategoryId,
  onSelect,
}) => {
  return (
    <View style={styles.container}>
      <Text style={styles.label}>Category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        {SKILL_CATEGORIES.map((cat: SkillCategory) => {
          const isActive = cat.id === selectedCategoryId;
          return (
            <TouchableOpacity
              key={cat.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(cat.id)}
              activeOpacity={0.8}
            >
              <Text style={styles.chipEmoji}>{cat.icon}</Text>
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {cat.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

export default CategorySelector;

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#1d4ed8",
  },
  chipEmoji: {
    fontSize: 16,
    marginRight: 6,
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "500",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/index.tsx">
// app/manage-skills-to-learn/index.tsx
import React from "react";
import ManageSkillsToLearnScreen from "./ManageSkillsToLearnScreen";

export default function ManageSkillsToLearnRoute() {
  return <ManageSkillsToLearnScreen />;
}
</file>

<file path="app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx">
// app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import AddSkillToLearnForm from "./AddSkillToLearnForm";
import CategorySelector from "./CategorySelector";
import { SkillSubCategory } from "./skillData";
import { SkillsToLearnList } from "./SkillsToLearnList";
import { SubCategorySelector } from "./SubCategorySelector";
import SuggestedSkillsGrid from "./SuggestedSkillsGrid";
import { LEARN_LEVELS, LearnLevel, SkillToLearn } from "./types";
import { useManageSkillsToLearn } from "./useManageSkillsToLearn";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Public speaking",
  "Time management",
  "English conversation",
  "Excel / Google Sheets",
  "Problem solving",
  "Presentation design",
];

type FilterMode = "all" | "favorites" | "recent";

// Quick Start (shown once)
const QUICK_START_KEY = "skillsToLearn_quickStartSeen_v1";

// Toast
type ToastType = "success" | "error" | "info";
type ToastState = {
  visible: boolean;
  message: string;
  type: ToastType;
};

// Bottom Sheet modes
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToLearnScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,

    hasPendingSync, // (22)

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart, // (12)
    updateSkillLevel, // (11)
    trySyncPending, // (22)

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToLearn();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  // Quick Start
  const [showQuickStart, setShowQuickStart] = useState(false);

  // Toast
  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Bottom sheet (modal)
  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  // (12) when duplicate happens, we store the existing skill
  const [duplicateExisting, setDuplicateExisting] =
    useState<SkillToLearn | null>(null);

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name} → ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  // Global search placeholder
  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Python, Algorithms...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Academic writing...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing basics...";
    return "Search or add: React Native, Guitar, Public speaking...";
  }, [selectedCategory]);

  // Visible skills (filters)
  const visibleSkills = useMemo(() => {
    let base: SkillToLearn[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  // Step state
  const isStep1Active = !selectedCategoryId;
  const isStep2Active = !!selectedCategoryId && !selectedSubCategoryId;
  const isStep3Active =
    (!!selectedCategoryId && !!selectedSubCategoryId) || skills.length > 0;

  // Progressive disclosure rules (2)
  const showRecommended = !selectedCategoryId;
  const showDiscoverSection = true;
  const showYourListSection = skills.length > 0 || !!selectedCategoryId;

  // Quick Start load (3)
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const seen = await AsyncStorage.getItem(QUICK_START_KEY);
        if (!mounted) return;
        if (!seen && skills.length === 0) setShowQuickStart(true);
      } catch {
        // ignore
      }
    })();
    return () => {
      mounted = false;
    };
  }, [skills.length]);

  const dismissQuickStart = async () => {
    setShowQuickStart(false);
    try {
      await AsyncStorage.setItem(QUICK_START_KEY, "1");
    } catch {
      // ignore
    }
  };

  // Toast helper (4)
  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  // Sync pending when screen loads (22)
  useEffect(() => {
    // try once on mount (safe even if no pending)
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ----- Add handlers -----
  const handleAddSkillBase = async (name: string, level?: LearnLevel) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (
    name: string,
    level?: LearnLevel
  ) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) ★`);
    setFilterMode("all");
    setSearchQuery("");
  };

  // Clear all confirm
  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your learning list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  // Category selection
  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
    showToast("Category selected", "info");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  // ---------- Bottom Sheet logic (9 + 10 + 11 + 12) ----------
  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  // (11) open edit level sheet
  const openEditLevelSheet = (skill: SkillToLearn) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    // ----- QUICK ADD -----
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      // (12) smart add
      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        // show duplicate UI: offer edit level
        setDuplicateExisting(res.existing);
        showToast("Skill already exists — edit its level?", "info");
        // switch to edit mode but keep modal open
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- SUGGESTED ADD -----
    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list — edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- ADD ALL SUGGESTED -----
    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;

      // add all; duplicates will be skipped silently using addSkill
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      setFilterMode("all");
      setSearchQuery("");
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      closeSheet();
      return;
    }

    // ----- EDIT LEVEL (11) -----
    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };
  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills) {
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;
    }
    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }

    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  // loading
  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  // (20) stats

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {/* Toast */}
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you want to learn</Text>
        <Text style={styles.subtitle}>
          Choose a category then add skills with the right level for better
          matching.
        </Text>

        {/* Pending sync indicator (22) */}
        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
              ⏳ Saved locally — syncing when online
            </Text>
          </View>
        )}

        {/* Global Search */}
        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}>🔎 Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your learning list.
          </Text>
        </View>

        {/* Steps */}
        <View style={styles.stepsRow}>
          <View
            style={[styles.stepPill, isStep1Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>1</Text>
            <Text style={styles.stepPillText}>Category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep2Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>2</Text>
            <Text style={styles.stepPillText}>Sub-category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep3Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>3</Text>
            <Text style={styles.stepPillText}>Your list</Text>
          </View>
        </View>

        {/* Quick Start */}
        {showQuickStart && (
          <View style={styles.quickStartCard}>
            <View style={styles.quickStartHeader}>
              <Text style={styles.quickStartTitle}>🚀 Quick start</Text>
              <TouchableOpacity onPress={dismissQuickStart} activeOpacity={0.8}>
                <Text style={styles.quickStartDismiss}>Got it</Text>
              </TouchableOpacity>
            </View>

            <Text style={styles.quickStartText}>
              1) Pick a category {"\n"}
              2) Tap a suggested skill {"\n"}
              3) Choose your level and add
            </Text>
          </View>
        )}

        {/* Error box */}
        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops…</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        {/* Category */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>🧭 1. Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>You’re exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        {/* Discover */}
        {showDiscoverSection && (
          <>
            <Text style={styles.mainSectionTitle}>
              🔍 2. Discover skills to add
            </Text>

            <SuggestedSkillsGrid
              title={
                selectedCategory
                  ? `Popular in ${selectedCategory.name}`
                  : "Suggested skills"
              }
              description="Tap a skill to choose its level and add it."
              skills={suggestedSkillsByCategory}
              onAdd={(name) => openSuggestedAddSheet(name)}
              onAddAll={
                suggestedSkillsByCategory.length ? openAddAllSheet : undefined
              }
              existingSkills={skills.map((s) => s.name)}
              favoriteSkills={favoriteSkills}
              disableAddAll={saving || !suggestedSkillsByCategory.length}
            />

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Recommended skills for most people"
                description="Useful across many careers."
                skills={recommendedSkills}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Popular among SkillSwap learners"
                description="Skills many people are currently focusing on."
                skills={GLOBAL_POPULAR_SKILLS}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}
          </>
        )}

        {/* Add form (still available) */}
        <AddSkillToLearnForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        {/* Your list */}
        {showYourListSection && (
          <>
            <Text style={styles.mainSectionTitle}>
              📌 3. Your learning list
            </Text>

            {/* (20) Stats */}
            <View style={styles.statsCard}>
              <Text style={styles.statsText}>
                {stats.total} skills • {stats.fav} favorites
                {stats.topLevel ? ` • Top level: ${stats.topLevel}` : ""}
              </Text>
              <Text style={styles.statsHint}>
                Tip: to edit a level, open “Add” and type the same skill name.
              </Text>
            </View>

            <Text style={styles.recentHint}>
              Recent = your last 6 added skills.
            </Text>

            {skills.length === 0 ? (
              <View style={styles.emptyStateCard}>
                <Text style={styles.emptyStateTitle}>No skills yet</Text>
                <Text style={styles.emptyStateText}>
                  Start by picking a category above, or tap + to add a custom
                  skill quickly.
                </Text>

                <View style={styles.emptyStateButtons}>
                  <TouchableOpacity
                    style={styles.emptyPrimaryBtn}
                    onPress={() =>
                      showToast("Pick a category above 👆", "info")
                    }
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptyPrimaryText}>Pick a category</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.emptySecondaryBtn}
                    onPress={openQuickAddSheet}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptySecondaryText}>
                      Add custom skill
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            ) : (
              <SkillsToLearnList
                skills={visibleSkills}
                totalCount={skills.length}
                searchQuery={searchQuery}
                onChangeSearchQuery={setSearchQuery}
                onRemove={removeSkill}
                favoriteSkills={favoriteSkills}
                onToggleFavorite={toggleFavorite}
                onClearAll={handleClearAllWithConfirm}
                filterMode={filterMode}
                onChangeFilter={setFilterMode}
              />
            )}
          </>
        )}

        {/* Undo bar */}
        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      {/* FAB */}
      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}>＋</Text>
      </TouchableOpacity>

      {/* Bottom Sheet modal */}
      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {/* Duplicate helper card (12) */}
          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name} · {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press “Save”.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. React Native"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {LEARN_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: You can also add from the main form below.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },

  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },

  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },

  title: { fontSize: 24, fontWeight: "700", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: {
    fontSize: 12,
    color: "#9a3412",
    fontWeight: "700",
  },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "600", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  stepsRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 12,
    gap: 8,
  },
  stepPill: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  stepPillActive: { backgroundColor: "#2563eb" },
  stepPillNumber: {
    fontSize: 12,
    fontWeight: "700",
    color: "#111827",
    marginRight: 4,
  },
  stepPillText: { fontSize: 12, color: "#111827", fontWeight: "500" },

  quickStartCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  quickStartHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  quickStartTitle: { fontSize: 14, fontWeight: "700", color: "#111827" },
  quickStartDismiss: { fontSize: 12, fontWeight: "600", color: "#2563eb" },
  quickStartText: { fontSize: 12, color: "#4b5563", lineHeight: 18 },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "600",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "800" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  recentHint: { fontSize: 11, color: "#6b7280", marginBottom: 8 },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "700", color: "#2563eb" },

  emptyStateCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  emptyStateTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },
  emptyStateText: { marginTop: 6, fontSize: 13, color: "#6b7280" },
  emptyStateButtons: {
    marginTop: 12,
    flexDirection: "row",
    gap: 8,
  },
  emptyPrimaryBtn: {
    flex: 1,
    backgroundColor: "#2563eb",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
  },
  emptyPrimaryText: { color: "#ffffff", fontWeight: "700", fontSize: 13 },
  emptySecondaryBtn: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    backgroundColor: "#f9fafb",
  },
  emptySecondaryText: { color: "#374151", fontWeight: "700", fontSize: 13 },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "600" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "700" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "800", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-learn/SkillChip.tsx">
// app/manage-skills-to-learn/SkillChip.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label: string;
  onPress: () => void;
  compact?: boolean;

  disabled?: boolean;
  added?: boolean;

  showPlusIcon?: boolean;
  isFavorite?: boolean;

  // (24) accessibility extras
  accessibilityHint?: string;
};

export function SkillChip({
  label,
  onPress,
  compact = false,
  disabled = false,
  added = false,
  showPlusIcon = false,
  isFavorite = false,
  accessibilityHint,
}: Props) {
  const showPlus = showPlusIcon && !added;
  const showCheck = added;

  const badgeText = showCheck ? "✓" : showPlus ? "＋" : "";
  const badgeLabel = showCheck ? "Added" : showPlus ? "Add" : "";

  return (
    <TouchableOpacity
      onPress={disabled ? () => {} : onPress}
      activeOpacity={disabled ? 1 : 0.85}
      disabled={disabled}
      style={[
        styles.chip,
        compact && styles.chipCompact,
        disabled && styles.chipDisabled,
        added && styles.chipAdded,
      ]}
      accessibilityRole="button"
      accessibilityLabel={label}
      accessibilityHint={
        accessibilityHint ||
        (disabled ? "This item is disabled." : "Tap to select this skill.")
      }
      hitSlop={{ top: 6, bottom: 6, left: 6, right: 6 }}
    >
      <View style={styles.row}>
        {/* Left badge (＋ / ✓) */}
        {(showPlus || showCheck) && (
          <View
            style={[
              styles.badge,
              showCheck && styles.badgeCheck,
              showPlus && styles.badgePlus,
            ]}
            accessibilityLabel={badgeLabel}
          >
            <Text style={styles.badgeText}>{badgeText}</Text>
          </View>
        )}

        {/* Favorite star */}
        {isFavorite && (
          <Text style={styles.star} accessibilityLabel="Favorite">
            ★
          </Text>
        )}

        <Text
          style={[styles.label, disabled && styles.labelDisabled]}
          numberOfLines={1}
        >
          {label}
        </Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  chip: {
    alignSelf: "flex-start",
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipCompact: {
    paddingHorizontal: 10,
    paddingVertical: 7,
  },
  chipDisabled: {
    opacity: 0.62,
  },
  chipAdded: {
    backgroundColor: "#dcfce7",
    borderColor: "#86efac",
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },

  badge: {
    width: 18,
    height: 18,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  badgeCheck: {
    backgroundColor: "#16a34a",
    borderColor: "#16a34a",
  },
  badgePlus: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  badgeText: {
    fontSize: 12,
    color: "#ffffff",
    fontWeight: "900",
    lineHeight: 14,
  },

  star: {
    fontSize: 14,
    color: "#f59e0b",
    fontWeight: "900",
    marginRight: 2,
  },

  label: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "600",
    maxWidth: 240,
  },
  labelDisabled: {
    color: "#6b7280",
  },
});
</file>

<file path="app/manage-skills-to-learn/skillData.ts">
// app/manage-skills-to-learn/skillData.ts

export type SkillSubCategory = {
  id: string;
  name: string;
  skills: string[];
};

export type SkillCategory = {
  id: string;
  name: string;
  icon: string; // ✅ FIX
  subCategories: SkillSubCategory[];
};

export const SKILL_CATEGORIES: SkillCategory[] = [
  {
    id: "programming",
    name: "Programming",
    icon: "💻",
    subCategories: [
      {
        id: "frontend",
        name: "Frontend",
        skills: ["HTML", "CSS", "JavaScript", "React", "TypeScript"],
      },
      {
        id: "backend",
        name: "Backend",
        skills: ["Node.js", "Express", "MongoDB", "SQL"],
      },
    ],
  },
  {
    id: "languages",
    name: "Languages",
    icon: "🗣️",
    subCategories: [
      {
        id: "spoken",
        name: "Spoken",
        skills: ["English", "Hebrew", "Arabic", "Spanish"],
      },
    ],
  },
];

export const RECOMMENDED_SKILLS = ["Public speaking", "Time management", "Problem solving"];

export const ALL_KNOWN_SKILLS = Array.from(
  new Set(SKILL_CATEGORIES.flatMap((c) => c.subCategories.flatMap((s) => s.skills)))
);
</file>

<file path="app/manage-skills-to-learn/SkillsToLearnList.tsx">
// app/manage-skills-to-learn/SkillsToLearnList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { SkillToLearn } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillToLearn[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  // ✅ FIX: now matches the hook perfectly
  onRemove: (skill: SkillToLearn) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;
  onClearAll: () => void;
  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;
  onLayoutCard?: (y: number) => void;
};

export const SkillsToLearnList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "✔";
    if (mode === "favorites") return "★";
    return "⏱";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your learning list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your learning skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You don’t have any learning skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <SkillChip
                  label={`${skill.name} · ${skill.level}`}
                  onPress={() => {}}
                />

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                  >
                    <Text style={styles.favoriteText}>{fav ? "★" : "☆"}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)} // ✅ FIX: remove by object
                    style={styles.removeButton}
                  >
                    <Text style={styles.removeIcon}>🗑</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity style={styles.clearAllButton} onPress={onClearAll}>
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: {
    flexDirection: "row",
    gap: 6,
    marginBottom: 8,
  },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  filterChipText: {
    fontSize: 12,
    color: "#374151",
  },
  filterChipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: {
    fontSize: 13,
    color: "#6b7280",
  },
  skillsWrap: {
    gap: 8,
  },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: {
    paddingHorizontal: 6,
    paddingVertical: 4,
  },
  favoriteText: {
    fontSize: 16,
    color: "#f59e0b",
  },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: {
    fontSize: 13,
  },
  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: {
    fontSize: 12,
    color: "#374151",
  },
});
</file>

<file path="app/manage-skills-to-learn/styles.ts">

</file>

<file path="app/manage-skills-to-learn/SubCategorySelector.tsx">
// app/manage-skills-to-learn/SubCategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillSubCategory } from "./skillData";

type Props = {
  subCategories: SkillSubCategory[];
  selectedSubCategoryId: string | null;
  onSelect: (id: string | null) => void;
};

export const SubCategorySelector: React.FC<Props> = ({
  subCategories,
  selectedSubCategoryId,
  onSelect,
}) => {
  if (!subCategories.length) return null;

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Sub-category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        <TouchableOpacity
          style={[
            styles.chip,
            selectedSubCategoryId === null && styles.chipActive,
          ]}
          onPress={() => onSelect(null)}
        >
          <Text
            style={[
              styles.chipText,
              selectedSubCategoryId === null && styles.chipTextActive,
            ]}
          >
            All
          </Text>
        </TouchableOpacity>

        {subCategories.map((sub) => {
          const isActive = sub.id === selectedSubCategoryId;
          return (
            <TouchableOpacity
              key={sub.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(sub.id)}
              activeOpacity={0.8}
            >
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {sub.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#1d4ed8",
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/SuggestedSkillsGrid.tsx">
// app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { SkillChip } from "./SkillChip";

type Props = {
  title: string;
  description?: string;
  skills: string[];
  onAdd: (name: string) => void;
  onAddAll?: () => void;
  existingSkills: string[]; // names only
  favoriteSkills: string[]; // names only
  disableAddAll?: boolean;
};

export default function SuggestedSkillsGrid({
  title,
  description,
  skills,
  onAdd,
  onAddAll,
  existingSkills,
  favoriteSkills,
  disableAddAll = false,
}: Props) {
  const existingLower = new Set(existingSkills.map((s) => s.toLowerCase()));
  const favLower = new Set(favoriteSkills.map((s) => s.toLowerCase()));

  if (!skills?.length) return null;

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>{title}</Text>
          {!!description && <Text style={styles.desc}>{description}</Text>}
        </View>

        {!!onAddAll && (
          <TouchableOpacity
            onPress={disableAddAll ? () => {} : onAddAll}
            activeOpacity={disableAddAll ? 1 : 0.8}
            style={[styles.addAllBtn, disableAddAll && { opacity: 0.5 }]}
            disabled={disableAddAll}
          >
            <Text style={styles.addAllText}>Add all</Text>
          </TouchableOpacity>
        )}
      </View>

      <View style={styles.wrap}>
        {skills.map((name) => {
          const added = existingLower.has(name.toLowerCase());
          const isFav = favLower.has(name.toLowerCase());

          // ✅ مهم: SkillChip لازم onPress دايمًا
          const handlePress = added ? () => {} : () => onAdd(name);

          return (
            <SkillChip
              key={name}
              label={name}
              onPress={handlePress}
              compact
              disabled={added}
              added={added}
              showPlusIcon={!added}
              isFavorite={isFav}
            />
          );
        })}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 10,
  },
  title: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
  },
  desc: {
    marginTop: 4,
    fontSize: 12,
    color: "#6b7280",
  },
  addAllBtn: {
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 6,
    backgroundColor: "#f9fafb",
  },
  addAllText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "600",
  },
  wrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/types.ts">
// app/manage-skills-to-learn/types.ts

export const LEARN_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type LearnLevel = (typeof LEARN_LEVELS)[number];

export type SkillToLearn = {
  name: string;
  level: LearnLevel;
};

export type UndoState = {
  skill: SkillToLearn;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-learn/useManageSkillsToLearn.ts">
// app/manage-skills-to-learn/useManageSkillsToLearn.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "./skillData";
import { LEARN_LEVELS, LearnLevel, SkillToLearn, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToLearnFavorites";

// (22) offline pending sync
const PENDING_SKILLS_KEY = "skillsToLearn_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillToLearn }
  | { ok: false; existed: true; existing: SkillToLearn }
  | { ok: false; existed: false; error: string };

// normalize level
function normalizeLearnLevel(raw?: string | null): LearnLevel {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = LEARN_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToLearn() {
  const [skills, setSkills] = useState<SkillToLearn[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  // (22) indicates we have unsynced local changes
  const [hasPendingSync, setHasPendingSync] = useState(false);

  // category / subcategory
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  // ---------- helpers ----------
  function findExistingSkill(name: string): SkillToLearn | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  // (22) store pending local changes when backend update fails
  async function savePendingSkills(next: SkillToLearn[]) {
    try {
      await AsyncStorage.setItem(PENDING_SKILLS_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePendingSkills error:", e);
    }
  }

  async function clearPendingSkills() {
    try {
      await AsyncStorage.removeItem(PENDING_SKILLS_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPendingSkills error:", e);
    }
  }

  async function loadPendingSkills(): Promise<SkillToLearn[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillToLearn[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return {
            name,
            level: normalizeLearnLevel(item.level),
          } as SkillToLearn;
        })
        .filter(Boolean) as SkillToLearn[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPendingSkills error:", e);
      return null;
    }
  }

  // (22) try to sync pending changes to backend
  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPendingSkills();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      // if there are pending changes, push them
      await updateProfile(token, { skillsToLearn: pending });
      await clearPendingSkills();

      // make sure local state matches pending
      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e: any) {
      // stay pending
      console.log("trySyncPending error:", e);
      setHasPendingSync(true);
    }
  }

  // ---- load from backend + favorites local ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        // (22) attempt sync pending first
        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        // NOTE: backend old format could be string[] OR new format object[]
        const raw = Array.isArray(userFromApi?.skillsToLearn)
          ? userFromApi.skillsToLearn
          : [];

        const cleanSkills: SkillToLearn[] = raw
          .map((item: any) => {
            // string -> object
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as LearnLevel };
            }

            // object -> normalize
            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLearnLevel(item.level),
              } as SkillToLearn;
            }

            return null;
          })
          .filter(Boolean) as SkillToLearn[];

        // sort by name
        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        // favorites local
        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        // pending indicator
        const pending = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToLearn load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load learning skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  // ---- persist skills to backend ----
  async function persistSkills(next: SkillToLearn[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, {
        skillsToLearn: next,
      });

      // if this succeeds, clear pending
      await clearPendingSkills();
    } catch (e: any) {
      console.log("updateProfile(skillsToLearn) error:", e);

      // (22) store pending changes locally
      await savePendingSkills(next);

      setError(
        e?.message ||
          "Failed to save learning skills. Your changes are saved locally and will sync when you're back online."
      );
    } finally {
      setSaving(false);
    }
  }

  // ---- persist favorites local ----
  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites learn error:", e);
    }
  }

  // ---- add skill (kept the same signature: boolean) ----
  async function addSkill(name: string, level?: LearnLevel): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  // ---- (12) add skill smart: tells you if it exists and returns existing skill ----
  async function addSkillSmart(
    name: string,
    level?: LearnLevel
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      // don't set as a hard error; this is a "smart" signal
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  // ---- (11) update level for an existing skill ----
  async function updateSkillLevel(
    name: string,
    newLevel: LearnLevel
  ): Promise<boolean> {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalizedLevel = normalizeLearnLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalizedLevel) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalizedLevel };

    // keep alphabetical order stable
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  // ---- remove skill (accept SkillToLearn object) ----
  async function removeSkill(skill: SkillToLearn) {
    const skillName = skill.name;

    const index = skills.findIndex((s) => sameName(s.name, skillName));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    // remove from favorites if needed
    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  // ---- clear all ----
  async function clearAllSkills() {
    const next: SkillToLearn[] = [];
    setSkills(next);
    setLastRemoved(null);

    await persistFavorites([]);
    await persistSkills(next);
  }

  // ---- undo remove ----
  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);

    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  // ---- toggle favorite ----
  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));

    let next: string[];
    if (exists) {
      next = favoriteSkills.filter((f) => !sameName(f, name));
    } else {
      next = [...favoriteSkills, name];
    }

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---- category helpers ----
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  // ---- filtered + sorted (favorites first) ----
  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();

    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync, // (22)

    // category stuff
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill, // keep old
    addSkillSmart, // (12) new
    updateSkillLevel, // (11) new
    trySyncPending, // (22) new

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/manage-skills-to-teach/AddSkillToTeachForm.tsx">
// app/manage-skills-to-teach/AddSkillToTeachForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { Level, TEACH_LEVELS } from "./types";

type Props = {
  onAdd: (name: string, level?: Level) => Promise<void> | void;
  onAddFavorite: (name: string, level?: Level) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

export default function AddSkillToTeachForm({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}: Props) {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] = useState<Level>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. Math tutoring, React, Guitar";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) await onAddFavorite(normalizedValue, selectedLevel);
      else await onAdd(normalizedValue, selectedLevel);

      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      console.log("AddSkillToTeachForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom teaching skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Add what you can teach and choose your level.
      </Text>

      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {TEACH_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>
        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: { fontSize: 15, fontWeight: "800", color: "#111827" },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },
  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },
  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },
  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "800" },
  levelPillTextActive: { color: "#ffffff" },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: { fontSize: 12, fontWeight: "800", color: "#2563eb" },
  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: { borderColor: "#fca5a5", backgroundColor: "#fff1f2" },
  errorText: { fontSize: 12, color: "#b91c1c", marginTop: 6 },

  buttonsRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: { backgroundColor: "#2563eb" },
  primaryButtonText: { color: "#f9fafb", fontSize: 13, fontWeight: "900" },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: { color: "#374151", fontSize: 13, fontWeight: "800" },

  suggestionsSection: { marginTop: 12 },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: { fontSize: 12, color: "#6b7280", fontWeight: "800" },
  suggestionsHint: { fontSize: 11, color: "#9ca3af", fontWeight: "700" },
  suggestionsRow: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
});
</file>

<file path="app/manage-skills-to-teach/index.tsx">
// app/manage-skills-to-teach/index.tsx
import React from "react";
import ManageSkillsToTeachScreen from "./ManageSkillsToTeachScreen";

export default function ManageSkillsToTeachRoute() {
  return <ManageSkillsToTeachScreen />;
}
</file>

<file path="app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx">
// app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

// ✅ reuse learn components
import CategorySelector from "../manage-skills-to-learn/CategorySelector";
import { SubCategorySelector } from "../manage-skills-to-learn/SubCategorySelector";
import SuggestedSkillsGrid from "../manage-skills-to-learn/SuggestedSkillsGrid";
import { SkillSubCategory } from "../manage-skills-to-learn/skillData";

import AddSkillToTeachForm from "./AddSkillToTeachForm";
import { SkillsToTeachList } from "./SkillsToTeachList";
import { Level, SkillTeach, TEACH_LEVELS } from "./types";
import { useManageSkillsToTeach } from "./useManageSkillsToTeach";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Math tutoring",
  "English conversation",
  "React",
  "Node.js",
  "UI/UX basics",
  "Public speaking",
];

type FilterMode = "all" | "favorites" | "recent";
type ToastType = "success" | "error" | "info";
type ToastState = { visible: boolean; message: string; type: ToastType };
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToTeachScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToTeach();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<Level>("Intermediate");

  const [duplicateExisting, setDuplicateExisting] = useState<SkillTeach | null>(
    null
  );

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name} → ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Node.js, Data structures...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Hebrew, Arabic...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing...";
    return "Search or add: Math tutoring, Guitar, Public speaking...";
  }, [selectedCategory]);

  const visibleSkills = useMemo(() => {
    let base: SkillTeach[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills)
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;

    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }
    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  useEffect(() => {
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleAddSkillBase = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) ★`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your teaching list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openEditLevelSheet = (skill: SkillTeach) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Skill already exists — edit its level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list — edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      setFilterMode("all");
      setSearchQuery("");
      closeSheet();
      return;
    }

    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };

  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  const showRecommended = !selectedCategoryId;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you can teach</Text>
        <Text style={styles.subtitle}>
          Add what you can teach with the right level for better matching.
        </Text>

        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
              ⏳ Saved locally — syncing when online
            </Text>
          </View>
        )}

        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}>🔎 Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your teaching list.
          </Text>
        </View>

        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops…</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        <View style={styles.card}>
          <Text style={styles.sectionTitle}>🧭 Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>You’re exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        <Text style={styles.mainSectionTitle}>🔍 Discover skills to add</Text>

        <SuggestedSkillsGrid
          title={
            selectedCategory
              ? `Popular in ${selectedCategory.name}`
              : "Suggested skills"
          }
          description="Tap a skill to choose its level and add it."
          skills={suggestedSkillsByCategory}
          onAdd={(name) => openSuggestedAddSheet(name)}
          onAddAll={
            suggestedSkillsByCategory.length ? openAddAllSheet : undefined
          }
          existingSkills={skills.map((s) => s.name)}
          favoriteSkills={favoriteSkills}
          disableAddAll={saving || !suggestedSkillsByCategory.length}
        />

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Recommended skills for most people"
            description="Useful across many careers."
            skills={recommendedSkills}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Popular among SkillSwap mentors"
            description="Skills many mentors are currently teaching."
            skills={GLOBAL_POPULAR_SKILLS}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        <AddSkillToTeachForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        <Text style={styles.mainSectionTitle}>📌 Your teaching list</Text>

        <View style={styles.statsCard}>
          <Text style={styles.statsText}>
            {stats.total} skills • {stats.fav} favorites
            {stats.topLevel ? ` • Top level: ${stats.topLevel}` : ""}
          </Text>
          <Text style={styles.statsHint}>Tap a skill to edit its level.</Text>
        </View>

        <SkillsToTeachList
          skills={visibleSkills}
          totalCount={skills.length}
          searchQuery={searchQuery}
          onChangeSearchQuery={setSearchQuery}
          onRemove={removeSkill}
          favoriteSkills={favoriteSkills}
          onToggleFavorite={toggleFavorite}
          onClearAll={handleClearAllWithConfirm}
          filterMode={filterMode}
          onChangeFilter={setFilterMode}
          onEditLevel={openEditLevelSheet}
        />

        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}>＋</Text>
      </TouchableOpacity>

      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name} · {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press “Save”.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. Math tutoring"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {TEACH_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: Tap a skill in the list to edit level.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },
  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },
  title: { fontSize: 24, fontWeight: "800", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: { fontSize: 12, color: "#9a3412", fontWeight: "800" },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "700", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "700",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "900" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "900", color: "#2563eb" },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "700" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "900", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "800",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "900" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "900", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-teach/SkillsToTeachList.tsx">
// app/manage-skills-to-teach/SkillsToTeachList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { SkillTeach } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillTeach[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  onRemove: (skill: SkillTeach) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;

  onClearAll: () => void;

  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;

  // ✅ optional: for edit level from list (we'll use it)
  onEditLevel?: (skill: SkillTeach) => void;

  onLayoutCard?: (y: number) => void;
};

export const SkillsToTeachList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onEditLevel,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "✔";
    if (mode === "favorites") return "★";
    return "⏱";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
        activeOpacity={0.85}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your teaching list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your teaching skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You don’t have any teaching skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <TouchableOpacity
                  activeOpacity={0.85}
                  onPress={() => onEditLevel?.(skill)}
                  disabled={!onEditLevel}
                >
                  <SkillChip
                    label={`${skill.name} · ${skill.level}`}
                    onPress={() => onEditLevel?.(skill)}
                    disabled={!onEditLevel}
                  />
                </TouchableOpacity>

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.favoriteText}>{fav ? "★" : "☆"}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)}
                    style={styles.removeButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.removeIcon}>🗑</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity
          style={styles.clearAllButton}
          onPress={onClearAll}
          activeOpacity={0.85}
        >
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: { flexDirection: "row", gap: 6, marginBottom: 8 },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  filterChipText: { fontSize: 12, color: "#374151" },
  filterChipTextActive: { color: "#ffffff", fontWeight: "700" },

  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: { fontSize: 13, color: "#6b7280" },

  skillsWrap: { gap: 8 },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: { paddingHorizontal: 6, paddingVertical: 4 },
  favoriteText: { fontSize: 16, color: "#f59e0b" },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: { fontSize: 13 },

  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: { fontSize: 12, color: "#374151", fontWeight: "700" },
});
</file>

<file path="app/manage-skills-to-teach/types.ts">
// app/manage-skills-to-teach/types.ts

export const TEACH_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type Level = (typeof TEACH_LEVELS)[number];

export type SkillTeach = {
  name: string;
  level: Level;
};

export type UndoState = {
  skill: SkillTeach;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-teach/useManageSkillsToTeach.ts">
// app/manage-skills-to-teach/useManageSkillsToTeach.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";

// ✅ reuse learn data + categories
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "../manage-skills-to-learn/skillData";

import { Level, SkillTeach, TEACH_LEVELS, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToTeachFavorites";
const PENDING_KEY = "skillsToTeach_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillTeach }
  | { ok: false; existed: true; existing: SkillTeach }
  | { ok: false; existed: false; error: string };

function normalizeLevel(raw?: string | null): Level {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = TEACH_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToTeach() {
  const [skills, setSkills] = useState<SkillTeach[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  const [hasPendingSync, setHasPendingSync] = useState(false);

  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  function findExistingSkill(name: string): SkillTeach | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  async function savePending(next: SkillTeach[]) {
    try {
      await AsyncStorage.setItem(PENDING_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePending teach error:", e);
    }
  }

  async function clearPending() {
    try {
      await AsyncStorage.removeItem(PENDING_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPending teach error:", e);
    }
  }

  async function loadPending(): Promise<SkillTeach[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_KEY);
      if (!raw) return null;

      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillTeach[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return { name, level: normalizeLevel(item.level) } as SkillTeach;
        })
        .filter(Boolean) as SkillTeach[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPending teach error:", e);
      return null;
    }
  }

  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPending();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      await updateProfile(token, { skillsToTeach: pending });
      await clearPending();

      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e) {
      console.log("trySyncPending teach error:", e);
      setHasPendingSync(true);
    }
  }

  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        const raw = Array.isArray(userFromApi?.skillsToTeach)
          ? userFromApi.skillsToTeach
          : [];

        const cleanSkills: SkillTeach[] = raw
          .map((item: any) => {
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as Level };
            }

            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLevel(item.level),
              } as SkillTeach;
            }

            return null;
          })
          .filter(Boolean) as SkillTeach[];

        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        const pending = await AsyncStorage.getItem(PENDING_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToTeach load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load teaching skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  async function persistSkills(next: SkillTeach[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, { skillsToTeach: next });
      await clearPending();
    } catch (e: any) {
      console.log("updateProfile(skillsToTeach) error:", e);
      await savePending(next);
      setError(
        e?.message ||
          "Failed to save teaching skills. Saved locally and will sync when online."
      );
    } finally {
      setSaving(false);
    }
  }

  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites teach error:", e);
    }
  }

  async function addSkill(name: string, level?: Level): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  async function addSkillSmart(
    name: string,
    level?: Level
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  async function updateSkillLevel(name: string, newLevel: Level) {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalized = normalizeLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalized) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalized };
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  async function removeSkill(skill: SkillTeach) {
    const index = skills.findIndex((s) => sameName(s.name, skill.name));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  async function clearAllSkills() {
    const next: SkillTeach[] = [];
    setSkills(next);
    setLastRemoved(null);
    await persistFavorites([]);
    await persistSkills(next);
  }

  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));
    const next = exists
      ? favoriteSkills.filter((f) => !sameName(f, name))
      : [...favoriteSkills, name];

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---------- category helpers (reuse learn data) ----------
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();
    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    // category
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/modal.tsx">
import { Link } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';

export default function ModalScreen() {
  return (
    <ThemedView style={styles.container}>
      <ThemedText type="title">This is a modal</ThemedText>
      <Link href="/" dismissTo style={styles.link}>
        <ThemedText type="link">Go to home screen</ThemedText>
      </Link>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});
</file>

<file path="app/sessions.tsx">

</file>

<file path="app/shared/levels.ts">
// app/shared/levels.ts

export const LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
] as const;

export type Level = (typeof LEVELS)[number];

/**
 * ترتيب المستويات للمقارنة
 * كل ما الرقم أكبر → مستوى أعلى
 */
export const LEVEL_RANK: Record<Level, number> = {
  Beginner: 1,
  Intermediate: 2,
  Advanced: 3,
};
</file>

<file path="app/weekly-availability/components.tsx">
// app/weekly-availability/components.tsx
import React, { useMemo } from "react";
import { Text, TouchableOpacity, View } from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { styles } from "./styles";

type DaySelectorProps = {
  selectedDay: number;
  onSelect: (dayIndex: number) => void;
  onLongPressDay?: (dayIndex: number) => void;
  dayNames: string[]; // ["Sun".."Sat"]
  todayIndex: number;
};

export const DaySelector: React.FC<DaySelectorProps> = ({
  selectedDay,
  onSelect,
  onLongPressDay,
  dayNames,
  todayIndex,
}) => {
  return (
    <View style={styles.daySelectorRow}>
      {dayNames.map((d, idx) => {
        const isSelected = idx === selectedDay;
        const isToday = idx === todayIndex;

        return (
          <TouchableOpacity
            key={`${d}-${idx}`}
            style={[
              styles.dayChip,
              isToday && styles.dayChipToday,
              isSelected && styles.dayChipSelected,
            ]}
            onPress={() => onSelect(idx)}
            onLongPress={() => onLongPressDay?.(idx)}
            delayLongPress={250}
            activeOpacity={0.85}
            accessibilityRole="button"
            accessibilityLabel={`Select ${d}`}
          >
            <Text
              style={[
                styles.dayChipText,
                isToday && styles.dayChipTextToday,
                isSelected && styles.dayChipTextSelected,
              ]}
            >
              {d}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

// ====================== Day Card ======================

type DayAvailabilityCardProps = {
  dayIndex: number;
  dayLabel: string;
  slots: AvailabilitySlot[];
  totalMinutesForDay: number;

  collapsed: boolean;
  onToggleCollapsed: (dayIndex: number) => void;

  onRemoveSlot: (slot: AvailabilitySlot) => void;
  onEditSlot: (slot: AvailabilitySlot) => void;
  onClearDay: (dayIndex: number) => void;

  onCopyDay: (dayIndex: number) => void;

  onQuickAdd?: (dayIndex: number, from: string, to: string) => void;

  highlightSlotKey?: string | null; // `${from}-${to}`
};

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export const DayAvailabilityCard: React.FC<DayAvailabilityCardProps> = ({
  dayIndex,
  dayLabel,
  slots,
  totalMinutesForDay,
  collapsed,
  onToggleCollapsed,
  onRemoveSlot,
  onEditSlot,
  onClearDay,
  onCopyDay,
  onQuickAdd,
  highlightSlotKey,
}) => {
  const dayHasSlots = slots.length > 0;

  const daySub = useMemo(() => {
    if (!dayHasSlots) return "No slots yet";
    return `${slots.length} slot${
      slots.length === 1 ? "" : "s"
    } · ${minutesToHuman(totalMinutesForDay)}`;
  }, [dayHasSlots, slots.length, totalMinutesForDay]);

  const showQuickForEmpty = !dayHasSlots;

  return (
    <View style={styles.dayCard}>
      {/* Header */}
      <View style={styles.dayHeaderRow}>
        <TouchableOpacity
          onPress={() => onToggleCollapsed(dayIndex)}
          activeOpacity={0.85}
          style={{ flex: 1 }}
          accessibilityRole="button"
          accessibilityLabel={`Toggle ${dayLabel}`}
        >
          <Text style={styles.dayName}>
            {dayLabel}{" "}
            <Text style={{ color: "#64748B", fontSize: 12, fontWeight: "900" }}>
              {collapsed ? "▸" : "▾"}
            </Text>
          </Text>
          <Text style={styles.daySubText}>{daySub}</Text>
        </TouchableOpacity>

        <View style={styles.dayHeaderActions}>
          {dayHasSlots ? (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          ) : (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          )}
        </View>
      </View>

      {/* Body */}
      {collapsed ? (
        <Text style={styles.daySlotsEmptyText}>
          {dayHasSlots ? "Collapsed" : "Collapsed (empty)"}
        </Text>
      ) : (
        <>
          {/* Empty state quick actions */}
          {showQuickForEmpty && onQuickAdd && (
            <View style={{ marginTop: 6 }}>
              <Text style={styles.daySlotsEmptyText}>
                Add something quick to get started:
              </Text>

              <View style={styles.quickRow}>
                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "18:00", "20:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>18:00–20:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "20:00", "22:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>20:00–22:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "10:00", "14:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>10:00–14:00</Text>
                </TouchableOpacity>
              </View>
            </View>
          )}

          {/* Slots */}
          {dayHasSlots ? (
            <View style={[styles.slotChipRow, { marginTop: 10 }]}>
              {slots.map((slot, idx) => {
                const key = `${slot.from}-${slot.to}`;
                const isHighlight = highlightSlotKey === key;

                return (
                  <TouchableOpacity
                    key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                    style={[
                      styles.slotChip,
                      isHighlight && {
                        borderColor: "#60A5FA",
                        backgroundColor: "#0B1120",
                      },
                    ]}
                    onPress={() => onEditSlot(slot)}
                    activeOpacity={0.85}
                    accessibilityRole="button"
                    accessibilityLabel={`Edit ${slot.from} to ${slot.to}`}
                  >
                    <Text style={styles.slotChipText}>
                      {slot.from} – {slot.to}
                    </Text>

                    <TouchableOpacity
                      onPress={() => onRemoveSlot(slot)}
                      activeOpacity={0.85}
                      accessibilityRole="button"
                      accessibilityLabel={`Remove ${slot.from} to ${slot.to}`}
                    >
                      <Text style={styles.slotRemoveText}>Remove</Text>
                    </TouchableOpacity>
                  </TouchableOpacity>
                );
              })}
            </View>
          ) : (
            !onQuickAdd && (
              <Text style={[styles.daySlotsEmptyText, { marginTop: 6 }]}>
                No slots.
              </Text>
            )
          )}
        </>
      )}
    </View>
  );
};

// ====================== SaveBar ======================

type SaveBarProps = {
  hasChanges: boolean;
  saving: boolean;
  onSave: () => void;
  onDiscard: () => void;
};

export const SaveBar: React.FC<SaveBarProps> = ({
  hasChanges,
  saving,
  onSave,
  onDiscard,
}) => {
  if (!hasChanges) return null;

  return (
    <View style={styles.saveBarSticky}>
      <View style={styles.saveRow}>
        <Text style={styles.saveHint}>
          You have unsaved changes. Save to update your profile.
        </Text>

        <TouchableOpacity
          style={styles.discardButton}
          onPress={onDiscard}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.discardText}>Discard</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.saveButton, saving && styles.saveButtonDisabled]}
          onPress={onSave}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.saveText}>{saving ? "Saving…" : "Save"}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};
</file>

<file path="app/weekly-availability/index.tsx">
// app/weekly-availability/index.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  ScrollView,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { getMe, updateProfile } from "../../lib/api";
import {
  getPendingWeeklyAvailability,
  getWeeklyLastSavedAt,
  markWeeklyAvailabilitySynced,
  setPendingWeeklyAvailability,
  clearPendingWeeklyAvailability,
} from "../../lib/availabilityStorage";
import SaveBar from "./SaveBar";
import TimeField from "./TimeField";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function isValidSlot(s: AvailabilitySlot) {
  return timeToMinutes(s.to) > timeToMinutes(s.from);
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  const diff = Date.now() - ts;
  if (diff < 60_000) return "Just now";
  if (diff < 60 * 60_000) return `${Math.floor(diff / 60_000)}m ago`;
  if (diff < 24 * 60 * 60_000) return `${Math.floor(diff / (60 * 60_000))}h ago`;
  return new Date(ts).toLocaleDateString();
}

function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  // clean + sort for stable comparisons
  const clean = (Array.isArray(slots) ? slots : [])
    .map((s) => ({
      dayOfWeek: Number((s as any)?.dayOfWeek ?? 0),
      from: String((s as any)?.from ?? "18:00"),
      to: String((s as any)?.to ?? "19:00"),
    }))
    .filter((s) => s.dayOfWeek >= 0 && s.dayOfWeek <= 6);

  clean.sort((a, b) => a.dayOfWeek - b.dayOfWeek || timeToMinutes(a.from) - timeToMinutes(b.from));
  return clean;
}

function slotsEqual(a: AvailabilitySlot[], b: AvailabilitySlot[]) {
  const A = normalizeSlots(a);
  const B = normalizeSlots(b);
  if (A.length !== B.length) return false;
  for (let i = 0; i < A.length; i++) {
    if (A[i].dayOfWeek !== B[i].dayOfWeek) return false;
    if (A[i].from !== B[i].from) return false;
    if (A[i].to !== B[i].to) return false;
  }
  return true;
}

export default function WeeklyAvailabilityScreen() {
  const router = useRouter();
  const mountedRef = useRef(true);

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  const [selectedDay, setSelectedDay] = useState<number>(0);

  const [serverSlots, setServerSlots] = useState<AvailabilitySlot[]>([]);
  const [draftSlots, setDraftSlots] = useState<AvailabilitySlot[]>([]);

  const [restorePrompt, setRestorePrompt] = useState<null | {
    updatedAtISO: string;
    slots: AvailabilitySlot[];
  }>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  const lastSavedText = useMemo(() => formatLastUpdated(lastSavedAt), [lastSavedAt]);

  const dirty = useMemo(() => !slotsEqual(serverSlots, draftSlots), [serverSlots, draftSlots]);

  const daySlots = useMemo(
    () => draftSlots.filter((s) => Number(s.dayOfWeek) === Number(selectedDay)),
    [draftSlots, selectedDay]
  );

  useEffect(() => {
    mountedRef.current = true;

    (async () => {
      try {
        setLoading(true);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const [me, pending, ts] = await Promise.all([
          getMe(token),
          getPendingWeeklyAvailability(),
          getWeeklyLastSavedAt(),
        ]);

        const userFromApi: any = (me as any)?.user ?? me;
        const slotsFromApi = normalizeSlots(userFromApi?.availabilitySlots ?? []);

        if (!mountedRef.current) return;

        setServerSlots(slotsFromApi);
        setDraftSlots(slotsFromApi);
        setLastSavedAt(ts);

        if (pending?.slots?.length) {
          const pendingSlots = normalizeSlots(pending.slots);
          // show restore only if it differs from server
          if (!slotsEqual(pendingSlots, slotsFromApi)) {
            setRestorePrompt({
              updatedAtISO: pending.updatedAtISO,
              slots: pendingSlots,
            });
          } else {
            // pending same as server -> cleanup
            await clearPendingWeeklyAvailability();
          }
        }
      } catch (e: any) {
        console.log("weekly availability load error:", e);
        Alert.alert(
          "Couldn’t load availability",
          e?.message || "Please try again."
        );
      } finally {
        if (mountedRef.current) setLoading(false);
      }
    })();

    return () => {
      mountedRef.current = false;
    };
  }, [router]);

  // Auto store pending draft when user changes (simple, safe)
  useEffect(() => {
    if (loading) return;
    if (!dirty) return;
    setPendingWeeklyAvailability(draftSlots, "user-edit");
  }, [draftSlots, dirty, loading]);

  const addSlot = () => {
    setDraftSlots((prev) =>
      normalizeSlots([
        ...prev,
        { dayOfWeek: selectedDay, from: "18:00", to: "19:00" },
      ])
    );
  };

  const updateSlot = (idxInDay: number, patch: Partial<AvailabilitySlot>) => {
    // map daySlots index to actual index in draftSlots
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.map((s) => {
        if (
          Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
          s.from === target.from &&
          s.to === target.to
        ) {
          return { ...s, ...patch };
        }
        return s;
      });
      return normalizeSlots(next);
    });
  };

  const removeSlot = (idxInDay: number) => {
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.filter(
        (s) =>
          !(
            Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
            s.from === target.from &&
            s.to === target.to
          )
      );
      return normalizeSlots(next);
    });
  };

  const restorePending = async () => {
    if (!restorePrompt) return;
    setDraftSlots(restorePrompt.slots);
    setRestorePrompt(null);
  };

  const discardPending = async () => {
    setRestorePrompt(null);
    await clearPendingWeeklyAvailability();
  };

  const discardChanges = () => {
    setDraftSlots(serverSlots);
  };

  const save = async () => {
    const invalid = draftSlots.some((s) => !isValidSlot(s));
    if (invalid) {
      Alert.alert(
        "Fix time slots",
        "Make sure every slot has From earlier than To."
      );
      return;
    }

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      await updateProfile(token, {
        availabilitySlots: normalizeSlots(draftSlots),
      } as any);

      if (!mountedRef.current) return;

      const normalized = normalizeSlots(draftSlots);
      setServerSlots(normalized);
      setDraftSlots(normalized);

      await markWeeklyAvailabilitySynced();
      const ts = await getWeeklyLastSavedAt();
      setLastSavedAt(ts);

      Alert.alert("Saved ✅", "Your weekly availability has been updated.");
    } catch (e: any) {
      console.log("weekly availability save error:", e);
      Alert.alert(
        "Save failed",
        e?.message || "Couldn’t save. Please try again."
      );
    } finally {
      if (mountedRef.current) setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={{ flex: 1, backgroundColor: "#020617", alignItems: "center", justifyContent: "center" }}>
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>Loading availability…</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <View style={{ flex: 1 }}>
        <ScrollView
          contentContainerStyle={{ padding: 16, paddingBottom: 110 }}
          keyboardShouldPersistTaps="handled"
        >
          {/* Header */}
          <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
            <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
              <Text style={{ color: "#60A5FA", fontWeight: "900" }}>← Back</Text>
            </TouchableOpacity>

            <Text style={{ color: "#94A3B8", fontSize: 12, fontWeight: "800" }}>
              Last saved: {lastSavedText}
            </Text>
          </View>

          <Text style={{ color: "#F9FAFB", fontSize: 22, fontWeight: "900", marginTop: 10 }}>
            Weekly availability
          </Text>
          <Text style={{ color: "#94A3B8", marginTop: 6, lineHeight: 18, fontSize: 12 }}>
            Add 1–2 time slots (evenings/weekend). Better mentor matches when your schedule is clear.
          </Text>

          {/* Restore pending banner */}
          {restorePrompt && (
            <View
              style={{
                marginTop: 12,
                backgroundColor: "#0B1120",
                borderWidth: 1,
                borderColor: "#1E293B",
                borderRadius: 14,
                padding: 12,
              }}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
                Restore unsaved changes?
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 12, marginTop: 4, lineHeight: 16 }}>
                Found a previous edit from {new Date(restorePrompt.updatedAtISO).toLocaleString()}.
              </Text>

              <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                <Pressable
                  onPress={restorePending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#22C55E",
                      borderRadius: 999,
                      paddingVertical: 10,
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#022C22", fontWeight: "900" }}>Restore</Text>
                </Pressable>

                <Pressable
                  onPress={discardPending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#020617",
                      borderRadius: 999,
                      paddingVertical: 10,
                      borderWidth: 1,
                      borderColor: "#334155",
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>Discard</Text>
                </Pressable>
              </View>
            </View>
          )}

          {/* Day selector */}
          <View style={{ flexDirection: "row", gap: 8, flexWrap: "wrap", marginTop: 14 }}>
            {dayNames.map((d, idx) => {
              const active = idx === selectedDay;
              return (
                <Pressable
                  key={d}
                  onPress={() => setSelectedDay(idx)}
                  style={({ pressed }) => [
                    {
                      paddingHorizontal: 12,
                      paddingVertical: 8,
                      borderRadius: 999,
                      borderWidth: 1,
                      borderColor: active ? "#F97316" : "#1E293B",
                      backgroundColor: active ? "#0B1120" : "#020617",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: active ? "#FED7AA" : "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                    {d}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          {/* Slots for selected day */}
          <View style={{ marginTop: 14 }}>
            <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
              <Text style={{ color: "#F9FAFB", fontWeight: "900", fontSize: 14 }}>
                {dayNames[selectedDay]} slots
              </Text>

              <TouchableOpacity onPress={addSlot} activeOpacity={0.85}>
                <Text style={{ color: "#60A5FA", fontWeight: "900" }}>+ Add</Text>
              </TouchableOpacity>
            </View>

            {daySlots.length === 0 ? (
              <View
                style={{
                  marginTop: 10,
                  backgroundColor: "#020617",
                  borderWidth: 1,
                  borderColor: "#111827",
                  borderRadius: 14,
                  padding: 12,
                }}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "800" }}>No slots yet</Text>
                <Text style={{ color: "#64748B", marginTop: 4, fontSize: 12, lineHeight: 16 }}>
                  Tap “Add” to create your first slot for this day.
                </Text>
              </View>
            ) : (
              <View style={{ marginTop: 10, gap: 10 }}>
                {daySlots.map((slot, idx) => {
                  const ok = isValidSlot(slot);
                  return (
                    <View
                      key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                      style={{
                        backgroundColor: "#0B1120",
                        borderWidth: 1,
                        borderColor: ok ? "#1E293B" : "#FCA5A5",
                        borderRadius: 14,
                        padding: 12,
                      }}
                    >
                      <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
                        <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                          Slot #{idx + 1} {ok ? "" : " (Fix time)"}
                        </Text>

                        <Pressable
                          onPress={() => removeSlot(idx)}
                          style={({ pressed }) => [
                            {
                              paddingHorizontal: 10,
                              paddingVertical: 6,
                              borderRadius: 999,
                              borderWidth: 1,
                              borderColor: "#334155",
                              backgroundColor: "#020617",
                            },
                            pressed ? { opacity: 0.85 } : null,
                          ]}
                        >
                          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>Remove</Text>
                        </Pressable>
                      </View>

                      <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            From
                          </Text>
                          <TimeField
                            value={slot.from}
                            onChange={(v: string) => updateSlot(idx, { from: v })}
                          />
                        </View>

                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            To
                          </Text>
                          <TimeField
                            value={slot.to}
                            onChange={(v: string) => updateSlot(idx, { to: v })}
                          />
                        </View>
                      </View>

                      {!ok && (
                        <Text style={{ color: "#FCA5A5", marginTop: 10, fontWeight: "900", fontSize: 12 }}>
                          “To” must be later than “From”.
                        </Text>
                      )}
                    </View>
                  );
                })}
              </View>
            )}
          </View>

          {/* Small reset button (non-intrusive) */}
          {dirty && (
            <Pressable
              onPress={discardChanges}
              style={({ pressed }) => [
                {
                  marginTop: 16,
                  alignSelf: "flex-start",
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  borderRadius: 999,
                  borderWidth: 1,
                  borderColor: "#334155",
                  backgroundColor: "#020617",
                },
                pressed ? { opacity: 0.9 } : null,
              ]}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                Reset to last saved
              </Text>
            </Pressable>
          )}
        </ScrollView>

        <SaveBar
          visible={dirty}
          saving={saving}
          onSave={save}
          onDiscard={discardChanges}
          lastSavedText={lastSavedText}
        />
      </View>
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/weekly-availability/styles.ts">
// app/weekly-availability/styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: {
    flex: 1,
    backgroundColor: "#020617",
  },
  scroll: {
    flex: 1,
  },
  content: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 120, // extra space for save bar + toast
  },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    color: "#9CA3AF",
    marginTop: 8,
    fontSize: 14,
  },

  title: {
    color: "#F9FAFB",
    fontSize: 22,
    fontWeight: "800",
    marginBottom: 4,
  },
  subtitle: {
    color: "#64748B",
    fontSize: 13,
    marginBottom: 12,
    lineHeight: 18,
  },

  // Section headers (step-by-step)
  sectionTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "900",
    marginTop: 10,
    marginBottom: 4,
  },
  sectionHint: {
    color: "#64748B",
    fontSize: 12,
    marginBottom: 8,
    lineHeight: 16,
  },

  // Error box
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
    marginBottom: 8,
  },

  // Summary card
  summaryCard: {
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  summaryTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "900",
    marginBottom: 4,
  },
  summaryText: {
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },
  summaryRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
    gap: 8,
    flexWrap: "wrap",
  },
  summaryBadge: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
  },
  summaryBadgeText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  // Day selector row
  daySelectorRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  dayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  dayChipToday: {
    borderColor: "#60A5FA",
  },
  dayChipSelected: {
    backgroundColor: "#F97316",
    borderColor: "#F97316",
  },
  dayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },
  dayChipTextToday: {
    color: "#BFDBFE",
    fontWeight: "800",
  },
  dayChipTextSelected: {
    color: "#0F172A",
    fontWeight: "900",
  },

  // Time input card
  timeCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  // subtle state borders (edit vs normal) - safe additions
  timeCardNormal: {
    borderColor: "#1E293B",
  },
  timeCardEditing: {
    borderColor: "#60A5FA",
  },

  timeLabelRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 8,
    marginBottom: 8,
  },
  timeLabel: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "900",
  },
  timeSelectedDayText: {
    color: "#94A3B8",
    fontSize: 12,
  },

  editBanner: {
    marginTop: 8,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#334155",
  },
  editBannerTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
    marginBottom: 2,
  },
  editBannerSub: {
    color: "#94A3B8",
    fontSize: 11,
    lineHeight: 15,
  },
  editBannerRow: {
    marginTop: 8,
    flexDirection: "row",
    gap: 8,
    flexWrap: "wrap",
  },
  bannerBtn: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  bannerBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  bannerDanger: {
    borderColor: "#7F1D1D",
    backgroundColor: "#451A1A",
  },
  bannerDangerText: {
    color: "#FECACA",
  },
  bannerPrimary: {
    borderColor: "#60A5FA",
    backgroundColor: "#60A5FA",
  },
  bannerPrimaryText: {
    color: "#0F172A",
  },

  timeRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 6,
  },
  timeDash: {
    color: "#9CA3AF",
    marginHorizontal: 8,
    fontSize: 16,
    fontWeight: "900",
  },
  timeHint: {
    color: "#64748B",
    fontSize: 12,
    marginTop: 6,
    lineHeight: 16,
  },
  timeErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    marginTop: 8,
    lineHeight: 16,
  },

  // Quick presets
  quickRow: {
    flexDirection: "row",
    marginTop: 10,
    gap: 8,
    flexWrap: "wrap",
  },
  quickChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  quickChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  quickChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },
  quickChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "900",
  },

  // Multi-day add
  multiRow: {
    marginTop: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    backgroundColor: "#0B1120",
  },
  multiTopRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    flexWrap: "wrap",
  },
  multiTopActions: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
  },
  miniActionBtn: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  miniActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  multiTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  multiCountText: {
    color: "#94A3B8",
    fontSize: 11,
    marginTop: 6,
    marginBottom: 8,
    lineHeight: 15,
  },
  multiDaysRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  multiDayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  multiDayChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  multiDayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  primaryButton: {
    marginTop: 12,
    backgroundColor: "#22C55E",
    paddingVertical: 11,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryButtonDisabled: {
    opacity: 0.6,
  },
  primaryText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
  },

  secondaryActionsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
    flexWrap: "wrap",
  },
  secondaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  secondaryBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  // Day cards list
  dayCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
    marginBottom: 10,
  },
  dayHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 6,
  },
  dayHeaderActions: {
    flexDirection: "row",
    gap: 10,
    alignItems: "center",
    flexWrap: "wrap",
  },
  dayName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "900",
  },
  daySubText: {
    marginTop: 2,
    color: "#94A3B8",
    fontSize: 11,
  },
  clearDayText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },
  copyDayText: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
  daySlotsEmptyText: {
    color: "#6B7280",
    fontSize: 12,
  },

  slotChipRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  slotChip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    gap: 10,
  },
  slotChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  slotRemoveText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },

  // Save bar (sticky)
  saveBarSticky: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(2,6,23,0.95)",
    borderTopWidth: 1,
    borderTopColor: "#1E293B",
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  saveRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  saveHint: {
    color: "#94A3B8",
    fontSize: 12,
    flex: 1,
  },
  discardButton: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  discardText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },
  saveButton: {
    backgroundColor: "#22C55E",
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 999,
    alignItems: "center",
    minWidth: 110,
  },
  saveButtonDisabled: {
    opacity: 0.6,
  },
  saveText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
    textAlign: "center",
  },

  // Time picker field
  timeFieldBox: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0F172A",
  },
  timeFieldLabel: {
    color: "#64748B",
    fontSize: 11,
    fontWeight: "800",
  },
  timeFieldValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "900",
    marginTop: 4,
  },

  // Modal
  modalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "flex-end",
  },
  modalCard: {
    backgroundColor: "#0B1120",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingVertical: 18,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  modalTitle: {
    fontSize: 16,
    fontWeight: "900",
    textAlign: "center",
    marginBottom: 10,
    color: "#F9FAFB",
  },
  modalButtonsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
  },
  modalCancel: {
    fontSize: 14,
    color: "#94A3B8",
    fontWeight: "800",
  },
  modalDone: {
    fontSize: 14,
    fontWeight: "900",
    color: "#F9FAFB",
  },

  // Copy modal list
  copyList: {
    marginTop: 10,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    justifyContent: "center",
  },
  copyChip: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  copyChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  copyChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  copyHint: {
    marginTop: 10,
    textAlign: "center",
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },

  // Toast
  toastWrap: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 84, // above save bar
    alignItems: "center",
    justifyContent: "center",
  },
  toastCard: {
    backgroundColor: "rgba(11,17,32,0.96)",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 999,
  },
  toastText: {
    color: "#F9FAFB",
    fontSize: 12,
    fontWeight: "800",
  },
});
</file>

<file path="app/weekly-availability/TimeField.tsx">
// app/weekly-availability/TimeField.tsx
import React, { useEffect, useState } from "react";
import { Platform, StyleSheet, Text, TextInput, View } from "react-native";

type Props = {
  label?: string;
  value: string;
  onChange: (v: string) => void;
  placeholder?: string;
  disabled?: boolean;
};

function normalizeTimeInput(raw: string): string {
  let s = raw.replace(/[^\d:]/g, "");

  const digitsOnly = s.replace(/:/g, "");
  if (!s.includes(":") && digitsOnly.length >= 3) {
    const hh = digitsOnly.slice(0, 2);
    const mm = digitsOnly.slice(2, 4);
    s = `${hh}:${mm}`;
  }

  if (s.length > 5) s = s.slice(0, 5);

  if (s.includes(":")) {
    const [hhRaw = "", mmRaw = ""] = s.split(":");
    const hh = hhRaw.slice(0, 2);
    const mm = mmRaw.slice(0, 2);
    s = `${hh}:${mm}`;
  }

  return s;
}

function isValidPartialTime(v: string): boolean {
  if (v === "") return true;
  if (!/^\d{0,2}(:\d{0,2})?$/.test(v)) return false;

  const [hhStr, mmStr] = v.split(":");
  if (hhStr.length > 0) {
    const hh = Number(hhStr);
    if (!Number.isFinite(hh) || hh > 23) return false;
  }
  if (mmStr !== undefined && mmStr.length > 0) {
    const mm = Number(mmStr);
    if (!Number.isFinite(mm) || mm > 59) return false;
  }
  return true;
}

export default function TimeField({
  label,
  value,
  onChange,
  placeholder = "HH:MM",
  disabled = false,
}: Props) {
  const [local, setLocal] = useState<string>(value ?? "");

  // ✅ الصحيح: side-effect -> useEffect
  useEffect(() => {
    setLocal(value ?? "");
  }, [value]);

  const onTextChange = (txt: string) => {
    const normalized = normalizeTimeInput(txt);
    if (!isValidPartialTime(normalized)) return;

    setLocal(normalized);
    onChange(normalized);
  };

  return (
    <View style={styles.wrap}>
      {label ? <Text style={styles.label}>{label}</Text> : null}

      <TextInput
        value={local}
        onChangeText={onTextChange}
        placeholder={placeholder}
        editable={!disabled}
        keyboardType={Platform.select({
          ios: "numbers-and-punctuation",
          android: "numeric",
          default: "numeric",
        })}
        style={[styles.input, disabled && styles.inputDisabled]}
        placeholderTextColor="#64748B"
        maxLength={5}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
  },
  label: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "900",
    marginBottom: 6,
  },
  input: {
    borderWidth: 1,
    borderColor: "#1F2937",
    backgroundColor: "#0B1220",
    color: "#E5E7EB",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    fontSize: 14,
    fontWeight: "700",
  },
  inputDisabled: {
    opacity: 0.6,
  },
});
</file>

<file path="app/weekly-availability/useWeeklyAvailability.ts">
// app/weekly-availability/useWeeklyAvailability.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  AvailabilitySlot,
  getMe,
  updateWeeklyAvailability,
} from "../../lib/api";

/**
 * Local key for "last saved" timestamp (used by Home + Weekly Availability)
 */
const WEEKLY_AVAIL_LAST_SAVED_KEY = "weeklyAvailability_lastSavedAt_v1";

/**
 * Sort slots by day, then time
 */
export function sortAvailability(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return [...slots].sort((a, b) => {
    if (a.dayOfWeek !== b.dayOfWeek) return a.dayOfWeek - b.dayOfWeek;
    return a.from.localeCompare(b.from);
  });
}

/**
 * Normalize + validate slots coming from API or UI
 */
function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return sortAvailability(
    (Array.isArray(slots) ? slots : [])
      .filter(
        (s) =>
          typeof s?.dayOfWeek === "number" &&
          s.dayOfWeek >= 0 &&
          s.dayOfWeek <= 6 &&
          typeof s?.from === "string" &&
          typeof s?.to === "string" &&
          s.from.trim() &&
          s.to.trim()
      )
      .map((s) => ({
        dayOfWeek: s.dayOfWeek,
        from: s.from.trim(),
        to: s.to.trim(),
      }))
  );
}

/**
 * Stable deep-equality key
 */
function slotsKey(slots: AvailabilitySlot[]): string {
  return normalizeSlots(slots)
    .map((s) => `${s.dayOfWeek}|${s.from}|${s.to}`)
    .join(";");
}

async function readLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(WEEKLY_AVAIL_LAST_SAVED_KEY);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

async function writeLastSavedAt(ts: number): Promise<void> {
  try {
    await AsyncStorage.setItem(WEEKLY_AVAIL_LAST_SAVED_KEY, String(ts));
  } catch {
    // ignore
  }
}

export type UserProfile = {
  _id: string;
  fullName: string;
  email: string;
  availabilitySlots?: AvailabilitySlot[];
  skillsToLearn?: any[];
  skillsToTeach?: any[];
};

type UseWeeklyAvailabilityResult = {
  user: UserProfile | null;
  availability: AvailabilitySlot[];
  loading: boolean;
  saving: boolean;
  errorText: string | null;
  hasChanges: boolean;
  lastSavedAt: number | null;

  reload: () => Promise<void>;
  save: () => Promise<boolean>;

  updateAvailability: (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => void;

  setErrorText: (t: string | null) => void;
};

export function useWeeklyAvailability(): UseWeeklyAvailabilityResult {
  const router = useRouter();

  const [user, setUser] = useState<UserProfile | null>(null);
  const [availability, setAvailability] = useState<AvailabilitySlot[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  /**
   * Baseline snapshot to detect unsaved changes
   */
  const baselineKeyRef = useRef<string>("");

  const hasChanges = useMemo(() => {
    return slotsKey(availability) !== baselineKeyRef.current;
  }, [availability]);

  /**
   * Load profile + availability
   */
  const reload = useCallback(async () => {
    try {
      setLoading(true);
      setErrorText(null);

      // load lastSavedAt (fast + local)
      const savedTs = await readLastSavedAt();
      setLastSavedAt(savedTs);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        // ✅ keep consistent with your auth group routes
        router.replace("/(auth)/login" as any);
        return;
      }

      const data = (await getMe(token)) as UserProfile;
      const normalized = normalizeSlots(data.availabilitySlots || []);

      setUser(data);
      setAvailability(normalized);
      baselineKeyRef.current = slotsKey(normalized);

      // If user already has availability from backend but no local timestamp yet,
      // set a helpful baseline timestamp once (not critical, but improves UX).
      if (!savedTs && normalized.length > 0) {
        const now = Date.now();
        setLastSavedAt(now);
        await writeLastSavedAt(now);
      }
    } catch (err: any) {
      console.log("weekly-availability / load error:", err);
      setErrorText(
        err?.message || "We couldn’t load your availability. Please try again."
      );
    } finally {
      setLoading(false);
    }
  }, [router]);

  useEffect(() => {
    reload();
  }, [reload]);

  /**
   * Safe updater wrapper (always normalizes)
   */
  const updateAvailability = (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => {
    setAvailability((prev) => normalizeSlots(updater(prev)));
  };

  /**
   * Save changes to backend
   */
  const save = useCallback(async () => {
    // ✅ prevents double taps + saves only when needed
    if (saving || !hasChanges) return false;

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return false;
      }

      const normalized = normalizeSlots(availability);

      const updated = (await updateWeeklyAvailability(
        token,
        normalized
      )) as UserProfile;

      const updatedNormalized = normalizeSlots(updated.availabilitySlots || []);

      setUser(updated);
      setAvailability(updatedNormalized);
      baselineKeyRef.current = slotsKey(updatedNormalized);

      // ✅ write "last saved" timestamp for Home + other screens
      const now = Date.now();
      setLastSavedAt(now);
      await writeLastSavedAt(now);

      return true;
    } catch (err: any) {
      console.log("weekly-availability / save error:", err);
      setErrorText(
        err?.message || "Something went wrong while saving your availability."
      );
      return false;
    } finally {
      setSaving(false);
    }
  }, [availability, hasChanges, router, saving]);

  return {
    user,
    availability,
    loading,
    saving,
    errorText,
    hasChanges,
    lastSavedAt,

    reload,
    save,
    updateAvailability,
    setErrorText,
  };
}
</file>

<file path="components/external-link.tsx">
import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}
</file>

<file path="components/haptic-tab.tsx">
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}
</file>

<file path="components/hello-wave.tsx">
import Animated from 'react-native-reanimated';

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          '50%': { transform: [{ rotate: '25deg' }] },
        },
        animationIterationCount: 4,
        animationDuration: '300ms',
      }}>
      👋
    </Animated.Text>
  );
}
</file>

<file path="components/parallax-scroll-view.tsx">
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/themed-view';
import { useColorScheme } from '@/hooks/use-color-scheme';
import { useThemeColor } from '@/hooks/use-theme-color';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const backgroundColor = useThemeColor({}, 'background');
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <Animated.ScrollView
      ref={scrollRef}
      style={{ backgroundColor, flex: 1 }}
      scrollEventThrottle={16}>
      <Animated.View
        style={[
          styles.header,
          { backgroundColor: headerBackgroundColor[colorScheme] },
          headerAnimatedStyle,
        ]}>
        {headerImage}
      </Animated.View>
      <ThemedView style={styles.content}>{children}</ThemedView>
    </Animated.ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});
</file>

<file path="components/themed-text.tsx">
import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});
</file>

<file path="components/themed-view.tsx">
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}
</file>

<file path="components/ui/collapsible.tsx">
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { IconSymbol } from '@/components/ui/icon-symbol';
import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});
</file>

<file path="components/ui/icon-symbol.ios.tsx">
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}
</file>

<file path="components/ui/icon-symbol.tsx">
// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight, SymbolViewProps } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}
</file>

<file path="constants/theme.ts">
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

import { Platform } from 'react-native';

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

export const Fonts = Platform.select({
  ios: {
    /** iOS `UIFontDescriptorSystemDesignDefault` */
    sans: 'system-ui',
    /** iOS `UIFontDescriptorSystemDesignSerif` */
    serif: 'ui-serif',
    /** iOS `UIFontDescriptorSystemDesignRounded` */
    rounded: 'ui-rounded',
    /** iOS `UIFontDescriptorSystemDesignMonospaced` */
    mono: 'ui-monospace',
  },
  default: {
    sans: 'normal',
    serif: 'serif',
    rounded: 'normal',
    mono: 'monospace',
  },
  web: {
    sans: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    serif: "Georgia, 'Times New Roman', serif",
    rounded: "'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif",
    mono: "SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
});
</file>

<file path="eslint.config.js">
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);
</file>

<file path="hooks/use-color-scheme.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="hooks/use-color-scheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
</file>

<file path="hooks/use-theme-color.ts">
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
</file>

<file path="README.md">
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
</file>

<file path="scripts/reset-project.js">
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);
</file>

<file path="server/matching/aiMatcher.js">

</file>

<file path="server/matching/embeddingService.js">
// server/matching/embeddingService.js
const OpenAI = require("openai");

let client = null;

// ===== In-memory cache (no external deps) =====
const CACHE_TTL_MS =
  Number(process.env.EMBED_CACHE_TTL_MS) || 1000 * 60 * 60 * 24; // 24h
const CACHE_MAX_ITEMS = Number(process.env.EMBED_CACHE_MAX_ITEMS) || 2000;

// key -> { value: number[], expiresAt: number, touchedAt: number }
const cache = new Map();

// key -> Promise<number[]|null>
const inFlight = new Map();

function now() {
  return Date.now();
}

function normalizeKey(text) {
  return String(text || "")
    .trim()
    .toLowerCase();
}

function purgeExpired() {
  const t = now();
  for (const [k, entry] of cache.entries()) {
    if (!entry || entry.expiresAt <= t) cache.delete(k);
  }
}

function evictIfNeeded() {
  if (cache.size <= CACHE_MAX_ITEMS) return;

  // Evict least-recently-touched entries
  const items = Array.from(cache.entries());
  items.sort((a, b) => (a[1]?.touchedAt || 0) - (b[1]?.touchedAt || 0));

  const removeCount = Math.ceil(CACHE_MAX_ITEMS * 0.15); // remove 15%
  for (let i = 0; i < removeCount && i < items.length; i++) {
    cache.delete(items[i][0]);
  }
}

function hasUsableKey() {
  const apiKey = String(process.env.OPENAI_API_KEY || "").trim();
  return !!apiKey && apiKey !== "YOUR_KEY_HERE";
}

function getClientSafe() {
  // IMPORTANT: never throw here (we want clean fallback UX)
  if (!hasUsableKey()) return null;

  if (client) return client;

  client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  return client;
}

function getModel() {
  return process.env.OPENAI_EMBED_MODEL || "text-embedding-3-small";
}

/**
 * Returns embedding vector for a text
 * - returns null if:
 *   - empty text
 *   - no API key
 *   - OpenAI error
 *
 * @param {string} text
 * @returns {Promise<number[]|null>}
 */
async function getEmbedding(text) {
  const input = String(text || "").trim();
  if (!input) return null;

  // no key => no embedding (caller should fallback)
  const openai = getClientSafe();
  if (!openai) return null;

  const key = normalizeKey(input);

  // keep cache healthy
  purgeExpired();

  // 1) cache hit
  const cached = cache.get(key);
  if (cached && Array.isArray(cached.value) && cached.value.length > 0) {
    cached.touchedAt = now();
    return cached.value;
  }

  // 2) in-flight dedupe
  const existingPromise = inFlight.get(key);
  if (existingPromise) return existingPromise;

  // 3) fetch + store
  const promise = (async () => {
    try {
      const model = getModel();

      const resp = await openai.embeddings.create({
        model,
        input,
      });

      const emb = resp?.data?.[0]?.embedding;
      if (!Array.isArray(emb) || emb.length === 0) return null;

      cache.set(key, {
        value: emb,
        expiresAt: now() + CACHE_TTL_MS,
        touchedAt: now(),
      });

      evictIfNeeded();
      return emb;
    } catch (err) {
      // silent fail => caller can fallback (hybrid/local)
      return null;
    } finally {
      inFlight.delete(key);
    }
  })();

  inFlight.set(key, promise);
  return promise;
}

module.exports = { getEmbedding };
</file>

<file path="server/matching/index.js">
// server/matching/index.js
const { findMentorMatchesLocal } = require("./localMatcher");
const { findMentorMatchesOpenAI } = require("./openaiMatcher");

function normalizeMode(raw) {
  const m = String(raw || "")
    .trim()
    .toLowerCase();
  if (m === "openai" || m === "local" || m === "hybrid") return m;
  return null;
}

function getMode(overrideMode) {
  const fromOverride = normalizeMode(overrideMode);
  if (fromOverride) return fromOverride;

  const fromEnv = normalizeMode(process.env.MATCHING_MODE);
  return fromEnv || "local";
}

function isOpenAIReady() {
  const raw = String(process.env.OPENAI_API_KEY || "").trim();
  return !!raw && raw !== "YOUR_KEY_HERE";
}

function metaBase({ requestedMode, modeUsed, fallbackUsed, reason = "OK" }) {
  return {
    requestedMode: requestedMode || null,
    modeUsed: modeUsed || null,
    fallbackUsed: !!fallbackUsed,
    reason, // OK | NO_KEY | OPENAI_EMPTY | OPENAI_ERROR
  };
}

/**
 * modes:
 * - local
 * - openai
 * - hybrid (openai then fallback to local)
 *
 * Returns:
 * { results: MentorMatch[], meta: { requestedMode, modeUsed, fallbackUsed, reason } }
 */
async function findMentorMatches(params) {
  const requestedMode = normalizeMode(params?.mode) || null;
  const mode = getMode(params?.mode);

  // -------- LOCAL --------
  if (mode === "local") {
    const results = await findMentorMatchesLocal(params);
    return {
      results,
      meta: metaBase({
        requestedMode,
        modeUsed: "local",
        fallbackUsed: false,
        reason: "OK",
      }),
    };
  }

  // -------- OPENAI --------
  if (mode === "openai") {
    // لو ما في key، ما بنفجر السيرفر، بنرجع نتائج فاضية + سبب واضح
    if (!isOpenAIReady()) {
      return {
        results: [],
        meta: metaBase({
          requestedMode,
          modeUsed: "openai",
          fallbackUsed: false,
          reason: "NO_KEY",
        }),
      };
    }

    try {
      const results = await findMentorMatchesOpenAI(params);
      return {
        results: Array.isArray(results) ? results : [],
        meta: metaBase({
          requestedMode,
          modeUsed: "openai",
          fallbackUsed: false,
          reason: results && results.length ? "OK" : "OPENAI_EMPTY",
        }),
      };
    } catch (e) {
      console.log("OPENAI mode failed:", e?.message || e);
      return {
        results: [],
        meta: metaBase({
          requestedMode,
          modeUsed: "openai",
          fallbackUsed: false,
          reason: "OPENAI_ERROR",
        }),
      };
    }
  }

  // -------- HYBRID --------
  // OpenAI ثم fallback إلى Local إذا فشل/فاضي/ما في key
  if (mode === "hybrid") {
    if (!isOpenAIReady()) {
      const local = await findMentorMatchesLocal(params);
      return {
        results: local,
        meta: metaBase({
          requestedMode,
          modeUsed: "local",
          fallbackUsed: true,
          reason: "NO_KEY",
        }),
      };
    }

    try {
      const ai = await findMentorMatchesOpenAI(params);
      if (Array.isArray(ai) && ai.length > 0) {
        return {
          results: ai,
          meta: metaBase({
            requestedMode,
            modeUsed: "openai",
            fallbackUsed: false,
            reason: "OK",
          }),
        };
      }

      const local = await findMentorMatchesLocal(params);
      return {
        results: local,
        meta: metaBase({
          requestedMode,
          modeUsed: "local",
          fallbackUsed: true,
          reason: "OPENAI_EMPTY",
        }),
      };
    } catch (e) {
      console.log("HYBRID: OpenAI failed -> fallback local:", e?.message || e);
      const local = await findMentorMatchesLocal(params);
      return {
        results: local,
        meta: metaBase({
          requestedMode,
          modeUsed: "local",
          fallbackUsed: true,
          reason: "OPENAI_ERROR",
        }),
      };
    }
  }

  // -------- SAFETY FALLBACK --------
  const results = await findMentorMatchesLocal(params);
  return {
    results,
    meta: metaBase({
      requestedMode,
      modeUsed: "local",
      fallbackUsed: true,
      reason: "OK",
    }),
  };
}

module.exports = { findMentorMatches };
</file>

<file path="server/matching/localMatcher.js">
// server/matching/localMatcher.js
const User = require("../models/User");
const {
  normalizeSkillName,
  computeSkillSimilarity,
  computeLevelCompatibility,
  computeAvailabilityScore,
  computeProfileQuality,
  computeMultiSkillBonus,
} = require("./normalize");
const { buildMatchScore } = require("./scoreUtils");

/**
 * Local heuristic matcher (string-based)
 */
async function findMentorMatchesLocal({
  userId,
  skillQuery,
  level,
  userAvailability,
}) {
  const skillToMatch = String(skillQuery || "").trim();
  const normalizedSkill = normalizeSkillName(skillToMatch);
  const normalizedDesiredLevel = String(level || "Beginner");

  if (!normalizedSkill) return [];

  const requestingUser = await User.findById(userId).lean();
  if (!requestingUser) return [];

  const mentorsRaw = await User.find({
    _id: { $ne: userId },
    skillsToTeach: { $exists: true, $ne: [] },
  }).lean();

  if (!mentorsRaw.length) return [];

  const results = [];

  const studentGoals = Array.isArray(requestingUser.skillsToLearn)
    ? requestingUser.skillsToLearn
    : [];

  const userAvail = Array.isArray(userAvailability) ? userAvailability : [];

  for (const mentor of mentorsRaw) {
    const teachSkills = Array.isArray(mentor.skillsToTeach)
      ? mentor.skillsToTeach
      : [];
    if (!teachSkills.length) continue;

    const mentorAvailability = Array.isArray(mentor.availabilitySlots)
      ? mentor.availabilitySlots
      : [];

    let bestSkill = null;
    let bestSkillSim = 0;

    for (const skillObj of teachSkills) {
      if (!skillObj || !skillObj.name) continue;

      const sim = computeSkillSimilarity(skillToMatch, skillObj.name);
      if (sim < 0.35) continue;

      if (sim > bestSkillSim) {
        bestSkillSim = sim;
        bestSkill = skillObj;
      }
    }

    if (!bestSkill) continue;

    const levelScore = computeLevelCompatibility(
      normalizedDesiredLevel,
      bestSkill.level || "Not specified"
    );

    const availabilityScore = computeAvailabilityScore(
      userAvail,
      mentorAvailability
    );
    const profileQuality = computeProfileQuality(mentor);
    const multiSkillBonus = computeMultiSkillBonus(studentGoals, teachSkills);

    const matchScore = buildMatchScore({
      skillSimilarity: bestSkillSim,
      levelScore,
      availabilityScore,
      profileQuality,
      multiSkillBonus,
    });

    if (matchScore < 0.25) continue;

    results.push({
      mentorId: String(mentor._id),
      fullName: mentor.fullName || "Unknown mentor",
      matchScore,
      mainMatchedSkill: {
        name: bestSkill.name,
        level: bestSkill.level || "Not specified",
        similarityScore: bestSkillSim,
      },
      skillsToTeach: teachSkills,
      availabilitySlots: mentorAvailability,
    });
  }

  results.sort((a, b) => b.matchScore - a.matchScore);
  return results.slice(0, 20);
}

module.exports = { findMentorMatchesLocal };
</file>

<file path="server/matching/normalize.js">
// server/matching/normalize.js

function normalize(str) {
  if (!str) return "";
  return String(str).toLowerCase().trim();
}

// Synonyms بسيطة للسكيلز الشائعة
const SKILL_SYNONYMS = {
  js: "javascript",
  node: "node.js",
  nodejs: "node.js",
  rn: "react-native",
  "react native": "react-native",
};

function normalizeSkillName(name) {
  let s = normalize(name)
    .replace(/[()+\-_/]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

  if (SKILL_SYNONYMS[s]) s = SKILL_SYNONYMS[s];
  return s;
}

/**
 * Pure string-based similarity between two skill names (0..1)
 */
function computeSkillSimilarity(a, b) {
  const s1 = normalizeSkillName(a);
  const s2 = normalizeSkillName(b);

  if (!s1 || !s2) return 0;
  if (s1 === s2) return 1;

  if (s1.startsWith(s2) || s2.startsWith(s1)) return 0.9;
  if (s1.includes(s2) || s2.includes(s1)) return 0.7;

  const tokens1 = new Set(s1.split(/\s+/));
  const tokens2 = new Set(s2.split(/\s+/));

  let intersection = 0;
  for (const t of tokens1) if (tokens2.has(t)) intersection++;

  const union = tokens1.size + tokens2.size - intersection;
  if (union === 0) return 0;

  const jaccard = intersection / union;
  return Math.max(0.3, Math.min(0.6, jaccard));
}

// ========== Levels ==========

function mapLevelToNumber(level) {
  const l = normalize(level);
  if (l.includes("advanced")) return 3;
  if (l.includes("intermediate")) return 2;
  if (l.includes("beginner")) return 1;
  return 2;
}

/**
 * Level compatibility with direction:
 * mentor >= student أفضل
 * 0..1
 */
function computeLevelCompatibility(requestLevel, mentorLevel) {
  const req = mapLevelToNumber(requestLevel);
  const men = mapLevelToNumber(mentorLevel);

  const diff = men - req;

  if (diff >= 0) {
    if (diff === 0) return 1.0;
    if (diff === 1) return 0.9;
    return 0.8;
  } else {
    const absDiff = Math.abs(diff);
    if (absDiff === 1) return 0.5;
    return 0.2;
  }
}

// ========== Availability ==========

function timeToMinutes(t) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map(Number);
  return (h || 0) * 60 + (m || 0);
}

function computeTotalOverlapMinutes(
  userAvailability = [],
  mentorAvailability = []
) {
  if (!userAvailability.length || !mentorAvailability.length) return 0;

  let total = 0;

  for (const ua of userAvailability) {
    for (const ma of mentorAvailability) {
      if (ua.dayOfWeek !== ma.dayOfWeek) continue;

      const start1 = timeToMinutes(ua.from);
      const end1 = timeToMinutes(ua.to);
      const start2 = timeToMinutes(ma.from);
      const end2 = timeToMinutes(ma.to);

      const overlap = Math.max(
        0,
        Math.min(end1, end2) - Math.max(start1, start2)
      );
      total += overlap;
    }
  }

  return total;
}

function computeAvailabilityScore(
  userAvailability = [],
  mentorAvailability = []
) {
  if (!userAvailability.length || !mentorAvailability.length) return 0.4;

  const overlapMinutes = computeTotalOverlapMinutes(
    userAvailability,
    mentorAvailability
  );

  if (overlapMinutes <= 0) {
    const sameDay = userAvailability.some((ua) =>
      mentorAvailability.some((ma) => ma.dayOfWeek === ua.dayOfWeek)
    );
    return sameDay ? 0.5 : 0.2;
  }

  const ratio = Math.min(overlapMinutes / 240, 1);

  if (ratio >= 0.75) return 1.0;
  if (ratio >= 0.4) return 0.8;
  if (ratio >= 0.15) return 0.6;
  return 0.4;
}

// ========== Profile Quality & Multi-skill Context ==========

function computeProfileQuality(mentor) {
  let score = 0;

  if (mentor.fullName) score += 0.05;

  if (typeof mentor.avgRating === "number" && mentor.ratingCount > 0) {
    const normRating = Math.max(0, Math.min(mentor.avgRating / 5, 1));
    score += 0.25 * normRating;
    if (mentor.ratingCount >= 5) score += 0.05;
    if (mentor.ratingCount >= 20) score += 0.05;
  }

  if (Array.isArray(mentor.skillsToTeach) && mentor.skillsToTeach.length >= 1) {
    score += 0.1;
  }
  if (mentor.skillsToTeach && mentor.skillsToTeach.length >= 3) {
    score += 0.15;
  }

  if (
    Array.isArray(mentor.availabilitySlots) &&
    mentor.availabilitySlots.length > 0
  ) {
    score += 0.15;
  }

  if (mentor.points && mentor.points > 0) score += 0.05;
  if (mentor.xp && mentor.xp > 0) score += 0.05;

  if (
    mentor.preferences &&
    Array.isArray(mentor.preferences.languages) &&
    mentor.preferences.languages.length > 0
  ) {
    score += 0.05;
  }

  return Math.min(score, 1);
}

/**
 * Bonus لو المدرس يغطي أكثر من هدف من أهداف الطالب
 * 0..0.2
 */
function computeMultiSkillBonus(studentGoals = [], mentorSkills = []) {
  if (!studentGoals.length || !mentorSkills.length) return 0;

  // supports goals being either string OR {name, level}
  const goalNames = studentGoals
    .map((g) => (typeof g === "string" ? g : g?.name))
    .filter(Boolean);

  const goalSet = new Set(goalNames.map((s) => normalizeSkillName(s)));
  const mentorSet = new Set(
    mentorSkills.map((s) => normalizeSkillName(s.name))
  );

  let common = 0;
  for (const g of goalSet) {
    if (mentorSet.has(g)) common++;
  }

  if (common === 0) return 0;
  return Math.min(common * 0.05, 0.2);
}

module.exports = {
  normalizeSkillName,
  computeSkillSimilarity,
  computeLevelCompatibility,
  computeAvailabilityScore,
  computeProfileQuality,
  computeMultiSkillBonus,
};
</file>

<file path="server/matching/openaiMatcher.js">
// server/matching/openaiMatcher.js
const User = require("../models/User");
const { getEmbedding } = require("./embeddingService");
const {
  computeLevelCompatibility,
  computeAvailabilityScore,
  computeProfileQuality,
  computeMultiSkillBonus,
} = require("./normalize");
const { cosineSimilarity, buildMatchScore } = require("./scoreUtils");

/**
 * OpenAI embedding matcher (SAFE optimized):
 * - embedding(skillQuery)
 * - cosine similarity with each mentor skill embedding
 * - batch-save embeddings per mentor (1 write max)
 *
 * NOTE:
 * - If OpenAI isn't available (no key / error), getEmbedding returns null,
 *   so this returns [] and HYBRID will fallback to local.
 */
async function findMentorMatchesOpenAI({
  userId,
  skillQuery,
  level,
  userAvailability,
}) {
  const skillToMatch = String(skillQuery || "").trim();
  const normalizedDesiredLevel =
    String(level || "Beginner").trim() || "Beginner";
  if (!skillToMatch) return [];

  const requestingUser = await User.findById(userId).lean();
  if (!requestingUser) return [];

  const mentorsRaw = await User.find({
    _id: { $ne: userId },
    skillsToTeach: { $exists: true, $ne: [] },
  }).lean();

  if (!mentorsRaw.length) return [];

  // ✅ SAFE: may return null if no key or OpenAI error
  const queryEmbedding = await getEmbedding(skillToMatch);
  if (!Array.isArray(queryEmbedding) || queryEmbedding.length === 0) {
    return [];
  }

  const results = [];
  const studentGoals = Array.isArray(requestingUser.skillsToLearn)
    ? requestingUser.skillsToLearn
    : [];
  const userAvail = Array.isArray(userAvailability) ? userAvailability : [];

  for (const mentor of mentorsRaw) {
    const teachSkills = Array.isArray(mentor.skillsToTeach)
      ? mentor.skillsToTeach
      : [];
    if (!teachSkills.length) continue;

    const mentorAvailability = Array.isArray(mentor.availabilitySlots)
      ? mentor.availabilitySlots
      : [];

    let bestSkill = null;
    let bestSim = 0;

    let changed = false;
    const updatedTeachSkills = teachSkills.map((s) => ({ ...s }));

    for (let i = 0; i < updatedTeachSkills.length; i++) {
      const skillObj = updatedTeachSkills[i];
      if (!skillObj || !skillObj.name) continue;

      let emb = skillObj.embedding;

      // fetch embedding only if missing
      if (!Array.isArray(emb) || emb.length === 0) {
        const fresh = await getEmbedding(skillObj.name);
        if (Array.isArray(fresh) && fresh.length > 0) {
          emb = fresh;
          skillObj.embedding = fresh;
          changed = true;
        } else {
          // can't embed this skill => skip it (do not fail whole mentor)
          continue;
        }
      }

      const sim = cosineSimilarity(queryEmbedding, emb);
      if (sim > bestSim) {
        bestSim = sim;
        bestSkill = skillObj;
      }
    }

    // write back embeddings once per mentor
    if (changed) {
      try {
        await User.updateOne(
          { _id: mentor._id },
          { $set: { skillsToTeach: updatedTeachSkills } }
        );
      } catch (e) {
        // silent fail (non-critical)
      }
    }

    // threshold guard (tuneable)
    if (!bestSkill || bestSim < 0.78) continue;

    const levelScore = computeLevelCompatibility(
      normalizedDesiredLevel,
      bestSkill.level || "Not specified"
    );

    const availabilityScore = computeAvailabilityScore(
      userAvail,
      mentorAvailability
    );
    const profileQuality = computeProfileQuality(mentor);
    const multiSkillBonus = computeMultiSkillBonus(studentGoals, teachSkills);

    const matchScore = buildMatchScore({
      skillSimilarity: bestSim,
      levelScore,
      availabilityScore,
      profileQuality,
      multiSkillBonus,
    });

    if (matchScore < 0.25) continue;

    results.push({
      mentorId: String(mentor._id),
      fullName: mentor.fullName || "Unknown mentor",
      matchScore,
      mainMatchedSkill: {
        name: bestSkill.name,
        level: bestSkill.level || "Not specified",
        similarityScore: bestSim,
      },
      // return mentor skills WITHOUT embeddings (clean payload)
      skillsToTeach: teachSkills.map((s) => ({
        name: s.name,
        level: s.level || "Not specified",
      })),
      availabilitySlots: mentorAvailability,
    });
  }

  results.sort((a, b) => b.matchScore - a.matchScore);
  return results.slice(0, 20);
}

module.exports = { findMentorMatchesOpenAI };
</file>

<file path="server/matching/scoreUtils.js">
// server/matching/scoreUtils.js

/**
 * Cosine similarity between two vectors
 * returns value in range 0..1 (or 0 on invalid input)
 */
function cosineSimilarity(a, b) {
  if (
    !Array.isArray(a) ||
    !Array.isArray(b) ||
    a.length === 0 ||
    b.length === 0 ||
    a.length !== b.length
  ) {
    return 0;
  }

  let dot = 0;
  let na = 0;
  let nb = 0;

  for (let i = 0; i < a.length; i++) {
    const x = Number(a[i]) || 0;
    const y = Number(b[i]) || 0;
    dot += x * y;
    na += x * x;
    nb += y * y;
  }

  const denom = Math.sqrt(na) * Math.sqrt(nb);
  if (!denom) return 0;

  const sim = dot / denom;
  return sim < 0 ? 0 : sim > 1 ? 1 : sim;
}

/**
 * Final weighted match score builder
 *
 * Weights rationale:
 * - skillSimilarity (0.6): core of matching
 * - levelScore     (0.2): mentor >= student preference
 * - availability   (0.15): scheduling feasibility
 * - profileQuality (0.05): trust & completeness
 * - multiSkillBonus (0..0.2): additive bonus
 */
function buildMatchScore({
  skillSimilarity,
  levelScore,
  availabilityScore,
  profileQuality,
  multiSkillBonus,
}) {
  const wSkill = 0.6;
  const wLevel = 0.2;
  const wAvail = 0.15;
  const wProfile = 0.05;

  let score =
    wSkill * (Number(skillSimilarity) || 0) +
    wLevel * (Number(levelScore) || 0) +
    wAvail * (Number(availabilityScore) || 0) +
    wProfile * (Number(profileQuality) || 0);

  score += Number(multiSkillBonus) || 0;

  // final clamp (explicit & safe)
  if (Number.isNaN(score)) return 0;
  if (score < 0) return 0;
  if (score > 1) return 1;
  return score;
}

module.exports = { cosineSimilarity, buildMatchScore };
</file>

<file path="server/matching/scoring.js">

</file>

<file path="server/services/matchingService.js">
// server/services/matchingService.js
const { findMentorMatches } = require("../matching");
module.exports = { findMentorMatches };
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}
</file>

<file path="app/(tabs)/_layout.tsx">
import { Tabs } from "expo-router";

export default function TabLayout() {
  return <Tabs />;
}
</file>

<file path="app/(tabs)/explore.tsx">
import React from "react";
import { StyleSheet, Text, View } from "react-native";

export default function ExploreScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Explore</Text>
      <Text style={styles.subtitle}>Coming soon...</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#0f172a",
  },
  title: {
    fontSize: 28,
    fontWeight: "bold",
    color: "#e5e7eb",
  },
  subtitle: {
    marginTop: 8,
    fontSize: 16,
    color: "#9ca3af",
  },
});
</file>

<file path="app/index.tsx">
import { Redirect } from "expo-router";

export default function Page() {
  return <Redirect href="/(tabs)" />;
}
</file>

<file path="app/login.tsx">
export { default } from "./(auth)/login";
</file>

<file path="app/signup.tsx">

</file>

<file path="lib/api.ts">
// lib/api.ts
import Constants from "expo-constants";
import { Platform } from "react-native";

function resolveApiUrl(): string {
  const envUrl = process.env.EXPO_PUBLIC_API_URL?.trim();
  if (envUrl) return envUrl;

  const debuggerHost = (Constants as any)?.debuggerHost as string | undefined;
  let hostFromExpo: string | null = null;

  if (debuggerHost) hostFromExpo = debuggerHost.split(":")[0];
  else if (typeof window !== "undefined") hostFromExpo = window.location.hostname;

  if (hostFromExpo) {
    if (Platform.OS === "android") {
      if (hostFromExpo === "localhost" || hostFromExpo === "127.0.0.1") {
        return "http://10.0.2.2:4000";
      }
      return `http://${hostFromExpo}:4000`;
    }
    return `http://${hostFromExpo}:4000`;
  }

  if (Platform.OS === "android") return "http://10.0.2.2:4000";
  return "http://localhost:4000";
}

export const API_URL = resolveApiUrl();
console.log("🔗 API_URL resolved to:", API_URL);

async function handleResponse(res: Response) {
  const text = await res.text();

  let data: any = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    console.log("API ERROR =>", {
      url: res.url,
      status: res.status,
      rawBody: text,
      parsed: data,
    });

    const message =
      (data && (data as any).error) ||
      (data && (data as any).message) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;

    throw new Error(message);
  }

  return data;
}

// ---------- AUTH ----------
export async function signup(params: {
  fullName: string;
  email: string;
  password: string;
}) {
  const res = await fetch(`${API_URL}/auth/signup`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

export async function login(params: { email: string; password: string }) {
  const res = await fetch(`${API_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

// ---------- TYPES ----------
export type AvailabilitySlot = { dayOfWeek: number; from: string; to: string };

export type SkillTeach = { name: string; level: string };

// ✅ skillsToLearn objects (حسب السيرفر عندك)
export type SkillLearn = { name: string; level: string };

export type MentorMatch = {
  mentorId: string;
  fullName: string;
  matchScore: number;
  mainMatchedSkill?: { name: string; level: string; similarityScore: number };
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

// ✅ NEW: matching mode (عشان تغيّر من داخل الأب)
export type MatchingMode = "local" | "openai" | "hybrid";

// ✅ NEW: matching status (preflight)
export type MatchingStatus = {
  openaiAvailable: boolean;
  reason: "OK" | "NO_KEY" | "ERROR" | string;
  recommendedMode: "local" | "hybrid";
};

// ✅ NEW: matching meta (returned with results)
export type MatchingMeta = {
  requestedMode: MatchingMode | null;
  modeUsed: MatchingMode | null;
  fallbackUsed: boolean;
  message?: string;
};

// ---------- USER ----------
export async function getMe(token: string) {
  const res = await fetch(`${API_URL}/api/me`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}

// ---------- PROFILE UPDATE ----------
export async function updateProfile(
  token: string,
  partial: {
    skillsToLearn?: SkillLearn[];
    skillsToTeach?: SkillTeach[];
    availabilitySlots?: AvailabilitySlot[];
  }
) {
  const res = await fetch(`${API_URL}/api/me/profile`, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(partial),
  });

  return handleResponse(res);
}

export async function updateWeeklyAvailability(
  token: string,
  availabilitySlots: AvailabilitySlot[]
) {
  return updateProfile(token, { availabilitySlots });
}

export async function updateSkillsToTeach(
  token: string,
  skillsToTeach: SkillTeach[]
) {
  return updateProfile(token, { skillsToTeach });
}

export async function updateSkillsToLearn(
  token: string,
  skillsToLearn: SkillLearn[]
) {
  return updateProfile(token, { skillsToLearn });
}

// ---------- MATCHING STATUS ----------
export async function getMatchingStatus(): Promise<MatchingStatus> {
  const res = await fetch(`${API_URL}/api/matching/status`, {
    method: "GET",
  });
  return handleResponse(res);
}

// ---------- MATCHING ----------
export async function getMentorMatches(
  token: string,
  params: {
    skill: string;
    level: "Beginner" | "Intermediate" | "Advanced";
    availabilitySlots?: AvailabilitySlot[];
    mode?: MatchingMode;
  }
): Promise<{ results: MentorMatch[]; meta?: MatchingMeta }> {
  const res = await fetch(`${API_URL}/api/matches/mentors`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      skill: params.skill,
      level: params.level,
      availabilitySlots: params.availabilitySlots ?? [],
      mode: params.mode, // لو بدك افتراضي خليها: params.mode ?? "local"
    }),
  });

  return handleResponse(res);
}
// ---------- PUBLIC USER PROFILE (Mentor) ----------
export type PublicUserProfile = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

export async function getPublicUserProfile(
  token: string,
  userId: string
): Promise<PublicUserProfile> {
  const res = await fetch(`${API_URL}/api/users/${userId}`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}
</file>

<file path="server/models/User.js">
// server/models/User.js
const mongoose = require("mongoose");

const AvailabilitySlotSchema = new mongoose.Schema(
  {
    dayOfWeek: { type: Number, required: true, min: 0, max: 6 },
    from: { type: String, required: true },
    to: { type: String, required: true },
  },
  { _id: false }
);

const SkillTeachSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    level: { type: String, default: "Not specified" },
    embedding: { type: [Number], default: undefined },
  },
  { _id: false }
);

const SkillLearnSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    level: { type: String, default: "Not specified" },
  },
  { _id: false }
);

const UserSchema = new mongoose.Schema(
  {
    fullName: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    passwordHash: { type: String, required: true },

    // ✅ NEW format: [{name, level}]
    // (server route still accepts old string[] too)
    skillsToLearn: { type: [SkillLearnSchema], default: [] },

    skillsToTeach: { type: [SkillTeachSchema], default: [] },

    points: { type: Number, default: 0 },
    xp: { type: Number, default: 0 },
    streak: { type: Number, default: 0 },

    avgRating: { type: Number, default: 0 },
    ratingCount: { type: Number, default: 0 },

    availabilitySlots: { type: [AvailabilitySlotSchema], default: [] },

    preferences: {
      communicationModes: { type: [String], default: [] },
      languages: { type: [String], default: [] },
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("User", UserSchema);
</file>

<file path="server/package.json">
{
  "name": "skillswap-backend",
  "version": "1.0.0",
  "main": "server.js",
  "type": "commonjs",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.3",
    "mongoose": "^9.0.1",
    "openai": "^6.10.0"
  }
}
</file>

<file path="server/server.js">
// server/server.js
require("dotenv").config();

const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

// 👇 موديل اليوزر
const User = require("./models/User");

// ✅ matching layer (local/openai/hybrid) - returns { results, meta }
const { findMentorMatches } = require("./services/matchingService");

const pointsRoutes = require("./routes/points.routes");

// ✅ sessions router
const sessionsRouter = require("./routes/sessions");

const app = express();

// ===== Middleware =====
app.use(cors());
app.use(express.json());

// ===== ENV & DB =====
const MONGO_URI = process.env.MONGO_URI;
const JWT_SECRET = process.env.JWT_SECRET || "dev-fallback-secret-123";
const PORT = process.env.PORT || 4000;

console.log("Loaded MONGO_URI?", !!MONGO_URI);
console.log("Loaded JWT_SECRET?", !!process.env.JWT_SECRET);
console.log("JWT_SECRET used:", JWT_SECRET);
console.log("MATCHING_MODE:", process.env.MATCHING_MODE || "local");

// تأكد إن MONGO_URI موجود
if (!MONGO_URI) {
  console.error("❌ MONGO_URI is not defined in .env – cannot start server");
  process.exit(1);
}

// ===== Connect to DB =====
mongoose
  .connect(MONGO_URI)
  .then(() => console.log("✅ MongoDB Connected"))
  .catch((err) => {
    console.error("❌ MongoDB Connection Error:", err?.message || err);
    process.exit(1);
  });

// ===== Auth Middleware =====
function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Missing token" });
  }

  const token = authHeader.split(" ")[1];

  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.userId = payload.userId;
    return next();
  } catch {
    return res.status(401).json({ error: "Invalid token" });
  }
}

// ===== Routes =====
app.use("/api/points", authMiddleware, pointsRoutes);
app.use("/api/sessions", sessionsRouter(authMiddleware));

// ===== Health =====
app.get("/", (req, res) => res.send("SkillBridge API is running ✅"));

// ===== Matching status =====
app.get("/api/matching/status", (req, res) => {
  const mode = process.env.MATCHING_MODE || "local";
  res.json({
    ok: true,
    mode,
    hasOpenAIKey: !!process.env.OPENAI_API_KEY,
    embedModel: process.env.OPENAI_EMBED_MODEL || null,
  });
});

// ===== Signup =====
app.post("/auth/signup", async (req, res) => {
  try {
    const { fullName, email, password } = req.body;

    if (!fullName || !email || !password) {
      return res.status(400).json({ error: "All fields are required" });
    }

    const exists = await User.findOne({ email: email.toLowerCase().trim() });
    if (exists) {
      return res.status(409).json({ error: "Email already in use" });
    }

    const hashed = await bcrypt.hash(password, 10);

    const user = await User.create({
      fullName: String(fullName).trim(),
      email: String(email).toLowerCase().trim(),
      passwordHash: hashed,
      points: 0,
      xp: 0,
      streak: 0,
      skillsToLearn: [],
      skillsToTeach: [],
      availabilitySlots: [],
    });

    const token = jwt.sign({ userId: user._id }, JWT_SECRET, {
      expiresIn: "7d",
    });

    return res.json({
      token,
      user: {
        _id: user._id,
        fullName: user.fullName,
        email: user.email,
        points: user.points,
        xp: user.xp,
        streak: user.streak,
      },
    });
  } catch (err) {
    console.error("SIGNUP ERROR:", err);
    return res.status(500).json({
      error: "Signup failed",
      details: err instanceof Error ? err.message : "Unknown server error",
    });
  }
});

// ===== Login =====
app.post("/auth/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: "Email and password are required" });
    }

    const user = await User.findOne({
      email: String(email).toLowerCase().trim(),
    });
    if (!user) return res.status(401).json({ error: "Invalid credentials" });

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(401).json({ error: "Invalid credentials" });

    const token = jwt.sign({ userId: user._id }, JWT_SECRET, {
      expiresIn: "7d",
    });

    return res.json({
      token,
      user: {
        _id: user._id,
        fullName: user.fullName,
        email: user.email,
        points: user.points,
        xp: user.xp,
        streak: user.streak,
      },
    });
  } catch (err) {
    console.error("LOGIN ERROR:", err);
    return res.status(500).json({
      error: "Login failed",
      details: err instanceof Error ? err.message : "Unknown server error",
    });
  }
});

// ===== Me =====
app.get("/api/me", authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.userId).select("-passwordHash");
    if (!user) return res.status(404).json({ error: "User not found" });
    return res.json({ user });
  } catch (err) {
    console.error("ME ERROR:", err);
    return res.status(500).json({
      error: "Failed to load user",
      details: err instanceof Error ? err.message : "Unknown server error",
    });
  }
});

// ===== Update profile =====
app.put("/api/me/profile", authMiddleware, async (req, res) => {
  try {
    const updates = req.body || {};
    const user = await User.findByIdAndUpdate(req.userId, updates, {
      new: true,
    }).select("-passwordHash");

    if (!user) return res.status(404).json({ error: "User not found" });
    return res.json({ user });
  } catch (err) {
    console.error("UPDATE PROFILE ERROR:", err);
    return res.status(500).json({
      error: "Failed to update profile",
      details: err instanceof Error ? err.message : "Unknown server error",
    });
  }
});

// ===== Mentor matches =====
app.post("/api/matches/mentors", authMiddleware, async (req, res) => {
  try {
    // mode ممكن يجي query أو body (خلّينا مرنين)
    const modeFromQuery = String((req.query || {}).mode || "").trim();
    const modeFromBody = String((req.body || {}).mode || "").trim();
    const mode = modeFromQuery || modeFromBody || "";

    const payload = req.body || {};

    // دايمًا نحقن userId من التوكن (أمان + توحيد)
    const params = { ...payload, userId: String(req.userId) };

    const out = await findMentorMatches({ ...params, mode });

    const results = Array.isArray(out?.results) ? out.results : [];
    const meta = out?.meta || {
      requestedMode: mode || null,
      modeUsed: null,
      fallbackUsed: false,
      reason: "OK",
    };

    return res.json({ results, meta });
  } catch (err) {
    console.error("MATCHING ERROR:", err);
    return res.status(500).json({
      error: "Failed to find mentor matches",
      details: err instanceof Error ? err.message : "Unknown server error",
    });
  }
});

// ===== Start server =====
app.listen(PORT, () => {
  console.log(`🚀 Server running on port ${PORT}`);
});
</file>

<file path="app/(tabs)/index.tsx">
import HomeScreen from "../screens/homescreen";

export default function TabHome() {
  return <HomeScreen />;
}
</file>

<file path="package.json">
{
  "name": "our-final-app",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "expo": "~54.0.24",
    "expo-constants": "~18.0.10",
    "expo-font": "~14.0.9",
    "expo-haptics": "~15.0.7",
    "expo-image": "~3.0.10",
    "expo-linking": "~8.0.9",
    "expo-router": "~6.0.15",
    "expo-splash-screen": "~31.0.11",
    "expo-status-bar": "~3.0.8",
    "expo-symbols": "~1.0.7",
    "expo-system-ui": "~6.0.8",
    "expo-web-browser": "~15.0.9",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1",
    "@react-native-community/datetimepicker": "8.4.4"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

</files>

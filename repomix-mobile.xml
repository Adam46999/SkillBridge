This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/**, lib/**, components/**, context/**, hooks/**, types/**
- Files matching these patterns are excluded: node_modules/**, **/*.log, **/*.map, **/*.env, **/*.json, package-lock.json, yarn.lock, pnpm-lock.yaml, README.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/_layout.tsx
app/(auth)/_layout.tsx
app/(auth)/login/index.tsx
app/(auth)/shared/AuthButton.tsx
app/(auth)/shared/AuthHeader.tsx
app/(auth)/shared/AuthTextField.tsx
app/(auth)/shared/InlineError.tsx
app/(auth)/shared/mapApiError.ts
app/(auth)/shared/PasswordField.tsx
app/(auth)/shared/styles.ts
app/(auth)/shared/useAuthFieldFocus.ts
app/(auth)/shared/useAuthRedirect.ts
app/(auth)/shared/validators.ts
app/(auth)/signup/index.tsx
app/(tabs)/_layout.tsx
app/(tabs)/chats/(components)/ChatHeader.tsx
app/(tabs)/chats/(components)/ChatInput.tsx
app/(tabs)/chats/(components)/MessageBubble.tsx
app/(tabs)/chats/(components)/MessagesList.tsx
app/(tabs)/chats/(components)/TopLoadingHint.tsx
app/(tabs)/chats/[conversationId].tsx
app/(tabs)/chats/index.tsx
app/(tabs)/explore.tsx
app/(tabs)/index.tsx
app/find-mentor.tsx
app/index.tsx
app/login.tsx
app/manage-skills-to-learn/AddSkillToLearnForm.tsx
app/manage-skills-to-learn/CategorySelector.tsx
app/manage-skills-to-learn/index.tsx
app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
app/manage-skills-to-learn/SkillChip.tsx
app/manage-skills-to-learn/skillData.ts
app/manage-skills-to-learn/SkillsToLearnList.tsx
app/manage-skills-to-learn/styles.ts
app/manage-skills-to-learn/SubCategorySelector.tsx
app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
app/manage-skills-to-learn/types.ts
app/manage-skills-to-learn/useManageSkillsToLearn.ts
app/manage-skills-to-teach/AddSkillToTeachForm.tsx
app/manage-skills-to-teach/index.tsx
app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
app/manage-skills-to-teach/SkillsToTeachList.tsx
app/manage-skills-to-teach/types.ts
app/manage-skills-to-teach/useManageSkillsToTeach.ts
app/mentor/[id].tsx
app/modal.tsx
app/profile.tsx
app/screens/components/MatchReadinessStrip.tsx
app/screens/components/PillButton.tsx
app/screens/components/ProfileStatusCard.tsx
app/screens/components/QuickEditBar.tsx
app/screens/components/SkeletonCard.tsx
app/screens/components/ViewProfileCTA.tsx
app/screens/homescreen.styles.ts
app/screens/homescreen.tsx
app/sessions.tsx
app/sessions/api/sessionsApi.ts
app/sessions/components/SessionCard.tsx
app/sessions/index.tsx
app/sessions/request.tsx
app/sessions/screens/SessionsScreen.tsx
app/sessions/utils/formatSession.ts
app/shared/levels.ts
app/shared/profileCompletion.ts
app/signup.tsx
app/weekly-availability/components.tsx
app/weekly-availability/index.tsx
app/weekly-availability/SaveBar.tsx
app/weekly-availability/styles.ts
app/weekly-availability/TimeField.tsx
app/weekly-availability/useWeeklyAvailability.ts
components/external-link.tsx
components/haptic-tab.tsx
components/hello-wave.tsx
components/parallax-scroll-view.tsx
components/themed-text.tsx
components/themed-view.tsx
components/ui/collapsible.tsx
components/ui/icon-symbol.ios.tsx
components/ui/icon-symbol.tsx
hooks/use-color-scheme.ts
hooks/use-color-scheme.web.ts
hooks/use-theme-color.ts
lib/api.ts
lib/availabilityStorage.ts
lib/chat/api.ts
lib/chat/socket.ts
lib/profileCompletion.ts
lib/sectionStatus.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(tabs)/chats/(components)/ChatHeader.tsx">
import React, { useMemo } from "react";
import { I18nManager, Pressable, StyleSheet, Text, View } from "react-native";

export type ConnStatus = "connected" | "reconnecting" | "disconnected";

type Props = {
  title: string; // peerName
  onBack: () => void;

  // realtime UI
  conn: ConnStatus;
  peerTyping: boolean;
  peerOnline: boolean;
  peerLastSeenIso: string | null;
};

function initials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return (parts[0][0] || "?").toUpperCase();
  return `${parts[0][0] || ""}${
    parts[parts.length - 1][0] || ""
  }`.toUpperCase();
}

function formatLastSeen(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleString(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export default function ChatHeader({
  title,
  onBack,
  conn,
  peerTyping,
  peerOnline,
  peerLastSeenIso,
}: Props) {
  const isRTL = I18nManager.isRTL;

  const subtitle = useMemo(() => {
    if (peerTyping) return isRTL ? "ŸäŸÉÿ™ÿ®‚Ä¶" : "typing‚Ä¶";

    if (conn === "reconnecting")
      return isRTL ? "ÿ¨ÿßÿ±Ÿä ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ‚Ä¶" : "reconnecting‚Ä¶";
    if (conn !== "connected") return isRTL ? "ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ" : "offline";

    if (peerOnline) return isRTL ? "ŸÖÿ™ÿµŸÑ ÿßŸÑÿ¢ŸÜ" : "online";
    if (peerLastSeenIso) {
      const seen = formatLastSeen(peerLastSeenIso);
      return isRTL ? `ÿ¢ÿÆÿ± ÿ∏ŸáŸàÿ± ${seen}` : `last seen ${seen}`;
    }
    return isRTL ? "ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ" : "offline";
  }, [conn, peerLastSeenIso, peerOnline, peerTyping, isRTL]);

  const avatar = useMemo(() => initials(title), [title]);

  const dot = useMemo(() => {
    if (peerTyping) return "#FBBF24"; // yellow
    if (conn !== "connected") return "#64748B"; // gray
    if (peerOnline) return "#22C55E"; // green
    return "#64748B";
  }, [conn, peerOnline, peerTyping]);

  return (
    <View style={styles.header}>
      <Pressable
        onPress={onBack}
        accessibilityRole="button"
        accessibilityLabel="Back"
        style={({ pressed }) => [
          styles.backBtn,
          pressed ? { opacity: 0.9 } : null,
        ]}
        hitSlop={12}
      >
        <Text style={styles.backText}>{isRTL ? "‚Üí" : "‚Üê"}</Text>
      </Pressable>

      <View style={styles.center}>
        <View style={styles.avatar}>
          <Text style={styles.avatarText}>{avatar}</Text>
        </View>

        <View style={{ flex: 1 }}>
          <Text
            style={styles.title}
            numberOfLines={1}
            accessibilityRole="header"
          >
            {title || "Chat"}
          </Text>

          <View style={styles.subRow}>
            <View style={[styles.dot, { backgroundColor: dot }]} />
            <Text style={styles.sub} numberOfLines={1}>
              {subtitle}
            </Text>
          </View>
        </View>
      </View>

      {/* right spacer (future actions: call/info) */}
      <View style={{ width: 44 }} />
    </View>
  );
}

const styles = StyleSheet.create({
  header: {
    paddingHorizontal: 12,
    paddingTop: 14,
    paddingBottom: 10,
    flexDirection: "row",
    alignItems: "center",
    borderBottomWidth: 1,
    borderBottomColor: "#0B1120",
    backgroundColor: "#020617",
  },

  backBtn: {
    width: 44,
    height: 40,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  backText: {
    color: "#60A5FA",
    fontWeight: "900",
    fontSize: 18,
    lineHeight: 18,
  },

  center: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    paddingHorizontal: 6,
  },

  avatar: {
    width: 40,
    height: 40,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: {
    color: "#F97316",
    fontWeight: "900",
    fontSize: 14,
  },

  title: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 15,
    maxWidth: 260,
  },

  subRow: {
    marginTop: 3,
    flexDirection: "row",
    alignItems: "center",
    gap: 7,
  },
  dot: {
    width: 8,
    height: 8,
    borderRadius: 999,
  },

  sub: {
    color: "#94A3B8",
    fontWeight: "800",
    fontSize: 11,
  },
});
</file>

<file path="app/(tabs)/chats/(components)/ChatInput.tsx">
import React, { useCallback, useMemo } from "react";
import {
  NativeSyntheticEvent,
  Platform,
  Pressable,
  StyleSheet,
  Text,
  TextInput,
  TextInputKeyPressEventData,
  View,
} from "react-native";

type Props = {
  value: string;
  sending: boolean;
  onChange: (v: string) => void;
  onSend: () => void;
};

export default function ChatInput({ value, sending, onChange, onSend }: Props) {
  const canSend = useMemo(
    () => value.trim().length > 0 && !sending,
    [value, sending]
  );

  const onKeyPress = useCallback(
    (e: NativeSyntheticEvent<TextInputKeyPressEventData>) => {
      // Web behavior: Enter sends, Shift+Enter newline
      if (Platform.OS !== "web") return;

      const key = e?.nativeEvent?.key;
      // RN web: shiftKey exists on nativeEvent in many builds but not typed
      const shift = !!(e as any)?.nativeEvent?.shiftKey;

      if (key === "Enter" && !shift) {
        (e as any)?.preventDefault?.();
        if (canSend) onSend();
      }
    },
    [canSend, onSend]
  );

  return (
    <View style={styles.bar}>
      <View style={styles.inputWrap}>
        <TextInput
          value={value}
          onChangeText={onChange}
          placeholder="Type a message‚Ä¶"
          placeholderTextColor="#64748B"
          style={styles.input}
          multiline
          maxLength={4000}
          accessibilityLabel="Message input"
          returnKeyType={Platform.OS === "ios" ? "default" : "send"}
          blurOnSubmit={false}
          onKeyPress={onKeyPress}
        />
      </View>

      <Pressable
        onPress={onSend}
        disabled={!canSend}
        accessibilityRole="button"
        accessibilityLabel="Send message"
        style={({ pressed }) => [
          styles.sendBtn,
          canSend ? styles.sendOn : styles.sendOff,
          pressed && canSend ? { opacity: 0.92 } : null,
        ]}
        hitSlop={10}
      >
        <Text style={[styles.sendText, !canSend ? { opacity: 0.85 } : null]}>
          {sending ? "‚Ä¶" : "Send"}
        </Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  bar: {
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: "#0B1120",
    backgroundColor: "#020617",
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 10,
  },

  inputWrap: {
    flex: 1,
    borderRadius: 18,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0B1120",
    paddingHorizontal: 14,
    paddingVertical: 10,
  },

  input: {
    color: "#E5E7EB",
    fontWeight: "700",
    minHeight: 42,
    maxHeight: 140,
  },

  sendBtn: {
    minHeight: 44,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 999,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },

  sendOn: { backgroundColor: "#F97316", borderColor: "#FB923C" },
  sendOff: { backgroundColor: "#334155", borderColor: "#475569" },

  sendText: { color: "#111827", fontWeight: "900" },
});
</file>

<file path="app/(tabs)/chats/(components)/MessageBubble.tsx">
import React, { useMemo } from "react";
import { Pressable, StyleSheet, Text, View } from "react-native";
import type { ChatMessage } from "../../../../lib/chat/api";

type Props = {
  item: ChatMessage;
  mine: boolean;
};

function formatTime(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleTimeString(undefined, {
    hour: "2-digit",
    minute: "2-digit",
  });
}

export default function MessageBubble({ item, mine }: Props) {
  const time = useMemo(
    () => formatTime(String((item as any)?.createdAt || "")),
    [item]
  );

  return (
    <View style={[styles.row, mine ? styles.rowMine : styles.rowTheirs]}>
      <Pressable
        style={[styles.bubble, mine ? styles.mine : styles.theirs]}
        accessibilityRole="text"
      >
        <Text style={[styles.text, mine ? styles.textMine : styles.textTheirs]}>
          {item.text}
        </Text>

        <View style={styles.metaRow}>
          <Text style={styles.time}>{time}</Text>
          {mine ? <Text style={styles.tick}>‚úì</Text> : null}
        </View>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  row: { width: "100%", marginVertical: 6, flexDirection: "row" },
  rowMine: { justifyContent: "flex-end" },
  rowTheirs: { justifyContent: "flex-start" },

  bubble: {
    maxWidth: "82%",
    borderRadius: 18,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderWidth: 1,
  },

  mine: { backgroundColor: "#F97316", borderColor: "#FB923C" },
  theirs: { backgroundColor: "#0B1120", borderColor: "#111827" },

  text: { fontWeight: "800", fontSize: 14, lineHeight: 20 },
  textMine: { color: "#111827" },
  textTheirs: { color: "#E5E7EB" },

  metaRow: {
    marginTop: 6,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    gap: 6,
  },
  time: { color: "rgba(17,24,39,0.75)", fontSize: 11, fontWeight: "900" },
  tick: { color: "rgba(17,24,39,0.75)", fontSize: 12, fontWeight: "900" },
});
</file>

<file path="app/(tabs)/chats/(components)/MessagesList.tsx">
import React, { useCallback, useMemo, useRef } from "react";
import {
  FlatList,
  NativeScrollEvent,
  NativeSyntheticEvent,
  StyleSheet,
  View,
} from "react-native";
import type { ChatMessage } from "../../../../lib/chat/api";
import MessageBubble from "./MessageBubble";
import TopLoadingHint from "./TopLoadingHint";

type UiMessage = ChatMessage & { createdAt: string };

type Props = {
  items: ChatMessage[];
  meId: string;
  paging: boolean;
  hasMore: boolean;
  onLoadOlder: () => Promise<void>;
};

function toTime(iso: string) {
  const d = new Date(iso);
  const t = d.getTime();
  return Number.isNaN(t) ? 0 : t;
}

export default function MessagesList({
  items,
  meId,
  paging,
  hasMore,
  onLoadOlder,
}: Props) {
  const listRef = useRef<FlatList<UiMessage>>(null);
  const loadingOlderRef = useRef(false);

  // For inverted FlatList we want newest first
  const data = useMemo(() => {
    const arr = (Array.isArray(items) ? items : []).map((m) => ({
      ...m,
      createdAt:
        typeof (m as any).createdAt === "string"
          ? (m as any).createdAt
          : new Date().toISOString(),
    }));
    arr.sort((a, b) => toTime(b.createdAt) - toTime(a.createdAt));
    return arr;
  }, [items]);

  const keyExtractor = useCallback((m: UiMessage) => m.id, []);

  const renderItem = useCallback(
    ({ item }: { item: UiMessage }) => {
      const mine = String(item.senderId) === String(meId);
      return <MessageBubble item={item} mine={mine} />;
    },
    [meId]
  );

  // When list is inverted: onEndReached means user reached the TOP (older messages)
  const onEndReached = useCallback(async () => {
    if (!hasMore) return;
    if (paging) return;
    if (loadingOlderRef.current) return;

    loadingOlderRef.current = true;
    try {
      await onLoadOlder();
    } finally {
      loadingOlderRef.current = false;
    }
  }, [hasMore, onLoadOlder, paging]);

  // Optional: detect if user is not at bottom (newest side)
  const onScroll = useCallback((e: NativeSyntheticEvent<NativeScrollEvent>) => {
    // keep for future (scroll-to-bottom button)
    void e;
  }, []);

  return (
    <View style={styles.wrap}>
      <TopLoadingHint visible={paging} />

      <FlatList
        ref={listRef}
        data={data}
        keyExtractor={keyExtractor}
        renderItem={renderItem}
        inverted
        onEndReached={onEndReached}
        onEndReachedThreshold={0.2}
        onScroll={onScroll}
        scrollEventThrottle={16}
        contentContainerStyle={styles.content}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: { flex: 1, backgroundColor: "#020617" },
  content: { paddingHorizontal: 14, paddingTop: 12, paddingBottom: 12 },
});
</file>

<file path="app/(tabs)/chats/(components)/TopLoadingHint.tsx">
import React from "react";
import { ActivityIndicator, StyleSheet, Text, View } from "react-native";

type Props = { visible: boolean };

export default function TopLoadingHint({ visible }: Props) {
  if (!visible) return null;

  return (
    <View style={styles.wrap} pointerEvents="none">
      <View style={styles.pill}>
        <ActivityIndicator />
        <Text style={styles.txt}>Loading older‚Ä¶</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: { paddingTop: 10, alignItems: "center" },
  pill: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  txt: { color: "#94A3B8", fontWeight: "800", fontSize: 12 },
});
</file>

<file path="app/(tabs)/chats/[conversationId].tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  Text,
  View,
} from "react-native";

import { getMe } from "../../../lib/api";
import {
  getConversationMessages,
  sendMessageRest,
  type ChatMessage,
} from "../../../lib/chat/api";

import {
  connectChatSocket,
  disconnectChatSocket,
  joinConversationRoom,
  markConversationRead,
  onConnectionStatus,
  onNewMessage,
  onPeerTyping,
  onPresenceUpdate,
  sendRealtimeMessage,
  type RealtimeMessage,
} from "../../../lib/chat/socket";

import ChatHeader from "./(components)/ChatHeader";
import ChatInput from "./(components)/ChatInput";
import MessagesList from "./(components)/MessagesList";

function toChatMessage(m: RealtimeMessage): ChatMessage {
  return {
    id: m.id,
    conversationId: m.conversationId,
    senderId: m.senderId,
    text: m.text,
    createdAt:
      typeof m.createdAt === "string" ? m.createdAt : new Date().toISOString(),
  };
}

function toTime(s: string) {
  const d = new Date(s);
  const t = d.getTime();
  return Number.isNaN(t) ? 0 : t;
}

export default function ConversationScreen() {
  const router = useRouter();
  const params = useLocalSearchParams<{
    conversationId?: string;
    peerName?: string;
    peerId?: string;
  }>();

  const convId = String(params.conversationId || "").trim();
  const peerName = String(params.peerName || "Chat");
  const peerId = String(params.peerId || "").trim();

  const mountedRef = useRef(true);

  const [meId, setMeId] = useState("");
  const [loading, setLoading] = useState(true);

  const [items, setItems] = useState<ChatMessage[]>([]);
  const [text, setText] = useState("");
  const [sending, setSending] = useState(false);

  const [conn, setConn] = useState<
    "connected" | "reconnecting" | "disconnected"
  >("disconnected");

  const [peerTyping, setPeerTyping] = useState(false);
  const typingTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [peerOnline, setPeerOnline] = useState(false);
  const [peerLastSeenIso, setPeerLastSeenIso] = useState<string | null>(null);

  const [paging, setPaging] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const sorted = useMemo(() => {
    return items
      .slice()
      .sort(
        (a: ChatMessage, b: ChatMessage) =>
          toTime(a.createdAt) - toTime(b.createdAt)
      );
  }, [items]);

  const oldestIso = useMemo(() => {
    if (!sorted.length) return null;
    return sorted[0]?.createdAt || null;
  }, [sorted]);

  const boot = useCallback(async () => {
    if (!convId) {
      router.back();
      return () => {};
    }

    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return () => {};
    }

    setLoading(true);

    let cleanupFns: ((() => void) | undefined)[] = [];

    try {
      const me = await getMe(token);
      if (!mountedRef.current) return () => {};

      const myId = String(me?.user?._id || "");
      setMeId(myId);

      const first = await getConversationMessages(token, convId, 50);
      if (!mountedRef.current) return () => {};

      const firstArr = Array.isArray(first) ? first : [];
      setItems(firstArr);
      setHasMore(firstArr.length >= 50);

      connectChatSocket(token);
      joinConversationRoom(convId, peerId);

      cleanupFns.push(onConnectionStatus(setConn));

      cleanupFns.push(
        onNewMessage((m) => {
          if (String(m.conversationId) !== convId) return;
          const cm = toChatMessage(m);
          setItems((prev) => {
            if (prev.some((x) => x.id === cm.id)) return prev;
            return [...prev, cm];
          });
          void markConversationRead(convId);
        })
      );

      cleanupFns.push(
        onPeerTyping((p) => {
          if (String(p.conversationId) !== convId) return;
          if (String(p.userId) === myId) return;

          setPeerTyping(!!p.isTyping);

          if (typingTimerRef.current) clearTimeout(typingTimerRef.current);
          if (p.isTyping) {
            typingTimerRef.current = setTimeout(() => {
              setPeerTyping(false);
            }, 1400);
          }
        })
      );

      cleanupFns.push(
        onPresenceUpdate((p) => {
          if (!peerId) return;
          if (String(p.userId) !== String(peerId)) return;
          setPeerOnline(!!p.online);
          setPeerLastSeenIso(p.lastSeen ? String(p.lastSeen) : null);
        })
      );

      void markConversationRead(convId);

      return () => {
        cleanupFns.forEach((fn) => {
          try {
            fn?.();
          } catch {}
        });
      };
    } finally {
      if (mountedRef.current) setLoading(false);
    }
  }, [convId, peerId, router]);

  useEffect(() => {
    mountedRef.current = true;
    let cleanup: (() => void) | null = null;

    (async () => {
      cleanup = await boot();
    })();

    return () => {
      mountedRef.current = false;

      try {
        cleanup?.();
      } catch {}

      try {
        if (typingTimerRef.current) clearTimeout(typingTimerRef.current);
      } catch {}

      disconnectChatSocket();
    };
  }, [boot]);

  const loadOlder = useCallback(async () => {
    if (paging || !hasMore || !oldestIso) return;

    const token = await AsyncStorage.getItem("token");
    if (!token) return;

    setPaging(true);
    try {
      const older = await getConversationMessages(token, convId, 50, oldestIso);
      if (!mountedRef.current) return;

      const arr = Array.isArray(older) ? older : [];
      setHasMore(arr.length >= 50);

      setItems((prev) => {
        const existing = new Set(prev.map((x) => x.id));
        const merged = [...arr.filter((x) => !existing.has(x.id)), ...prev];
        return merged;
      });
    } finally {
      if (mountedRef.current) setPaging(false);
    }
  }, [convId, hasMore, oldestIso, paging]);

  const send = useCallback(async () => {
    const clean = String(text || "").trim();
    if (!clean || !convId || sending) return;

    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return;
    }

    setSending(true);
    try {
      const rt = await sendRealtimeMessage(convId, clean);
      if (rt.ok && rt.message) {
        const cm = toChatMessage(rt.message);
        setItems((prev) => {
          if (prev.some((x) => x.id === cm.id)) return prev;
          return [...prev, cm];
        });
        setText("");
        return;
      }

      const m = await sendMessageRest(token, convId, clean);
      setItems((prev) => [...prev, m]);
      setText("");
    } catch {
      // silent
    } finally {
      setSending(false);
    }
  }, [convId, router, sending, text]);

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator />
        <Text style={{ marginTop: 10, color: "#94A3B8", fontWeight: "800" }}>
          Loading chat‚Ä¶
        </Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
      keyboardVerticalOffset={Platform.OS === "ios" ? 90 : 0}
    >
      <ChatHeader
        title={peerName}
        onBack={() => router.back()}
        conn={conn}
        peerTyping={peerTyping}
        peerOnline={peerOnline}
        peerLastSeenIso={peerLastSeenIso}
      />

      <MessagesList
        items={items}
        meId={meId}
        paging={paging}
        hasMore={hasMore}
        onLoadOlder={loadOlder}
      />

      <ChatInput
        value={text}
        sending={sending}
        onChange={setText}
        onSend={send}
      />
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/(tabs)/chats/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  FlatList,
  Pressable,
  RefreshControl,
  StyleSheet,
  Text,
  TextInput,
  View,
} from "react-native";
import { getChatInbox, type ChatInboxItem } from "../../../lib/chat/api";

function initials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return `${parts[0][0] ?? ""}${
    parts[parts.length - 1][0] ?? ""
  }`.toUpperCase();
}

function timeAgo(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  const diff = Date.now() - d.getTime();
  const sec = Math.floor(diff / 1000);
  if (sec < 60) return "Now";
  const min = Math.floor(sec / 60);
  if (min < 60) return `${min}m`;
  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}h`;
  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}d`;
  return d.toLocaleDateString(undefined, { month: "short", day: "2-digit" });
}

type LoadMode = "load" | "refresh";

export default function ChatsInboxScreen() {
  const router = useRouter();

  const [items, setItems] = useState<ChatInboxItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [query, setQuery] = useState("");
  const [pendingOpenId, setPendingOpenId] = useState<string | null>(null);

  const mountedRef = useRef(true);

  const load = useCallback(
    async (mode: LoadMode) => {
      try {
        setErrorText(null);

        if (mode === "refresh") setRefreshing(true);
        else setLoading(true);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const out = await getChatInbox(token);
        if (!mountedRef.current) return;

        // sort safety (latest first)
        const sorted = (Array.isArray(out) ? out : []).slice().sort((a, b) => {
          const ta = a.lastMessageAt ? new Date(a.lastMessageAt).getTime() : 0;
          const tb = b.lastMessageAt ? new Date(b.lastMessageAt).getTime() : 0;
          return tb - ta;
        });

        setItems(sorted);
      } catch (e: any) {
        if (!mountedRef.current) return;
        setErrorText(e?.message || "Failed to load chats.");
      } finally {
        if (!mountedRef.current) return;
        setLoading(false);
        setRefreshing(false);
      }
    },
    [router]
  );

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      load("load");
      return () => {
        mountedRef.current = false;
      };
    }, [load])
  );

  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return items;

    return items.filter((x) => {
      const name = String(x.peer?.fullName || "").toLowerCase();
      const last = String(x.lastMessageText || "").toLowerCase();
      return name.includes(q) || last.includes(q);
    });
  }, [items, query]);

  const empty = useMemo(
    () => !loading && !errorText && filtered.length === 0,
    [loading, errorText, filtered.length]
  );

  const openConversation = useCallback(
    (item: ChatInboxItem) => {
      const id = String(item?.id || "").trim();
      if (!id) return;
      if (pendingOpenId === id) return;

      setPendingOpenId(id);

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: {
          conversationId: id,
          peerName: item.peer?.fullName || "Chat",
          peerId: item.peer?.id || "",
        },
      } as any);

      setTimeout(() => setPendingOpenId(null), 650);
    },
    [pendingOpenId, router]
  );

  const renderItem = useCallback(
    ({ item }: { item: ChatInboxItem }) => {
      const name = item.peer?.fullName || "Unknown user";
      const last = item.lastMessageText?.trim()
        ? item.lastMessageText
        : "Say hi üëã";
      const ts = item.lastMessageAt ? timeAgo(item.lastMessageAt) : "";
      const unread = Number((item as any)?.unreadCount || 0);
      const disabled = pendingOpenId === item.id;

      return (
        <Pressable
          onPress={() => openConversation(item)}
          disabled={disabled}
          accessibilityRole="button"
          accessibilityLabel={`Open chat with ${name}`}
          accessibilityHint="Opens the conversation"
          style={({ pressed }) => [
            styles.row,
            pressed ? { opacity: 0.92 } : null,
            disabled ? { opacity: 0.65 } : null,
          ]}
          hitSlop={10}
        >
          <View style={styles.avatar} accessibilityLabel={`Avatar: ${name}`}>
            <Text style={styles.avatarText}>{initials(name)}</Text>
          </View>

          <View style={{ flex: 1 }}>
            <View style={styles.topLine}>
              <Text style={styles.name} numberOfLines={1}>
                {name}
              </Text>

              <View style={styles.rightMeta}>
                {!!unread && (
                  <View
                    style={styles.badge}
                    accessibilityLabel={`${unread} unread messages`}
                  >
                    <Text style={styles.badgeText}>
                      {unread > 99 ? "99+" : String(unread)}
                    </Text>
                  </View>
                )}

                {!!ts && <Text style={styles.time}>{ts}</Text>}
              </View>
            </View>

            <Text
              style={[styles.last, unread ? styles.lastUnread : null]}
              numberOfLines={2}
            >
              {last}
            </Text>
          </View>
        </Pressable>
      );
    },
    [openConversation, pendingOpenId]
  );

  const keyExtractor = useCallback((x: ChatInboxItem) => x.id, []);

  return (
    <View style={styles.root}>
      <View style={styles.header}>
        <Text style={styles.title} accessibilityRole="header">
          Chats
        </Text>
        <Text style={styles.subtitle}>Your 1:1 conversations (text only).</Text>

        <View style={styles.searchWrap}>
          <Text style={styles.searchIcon}>üîé</Text>
          <TextInput
            value={query}
            onChangeText={setQuery}
            placeholder="Search by name or message‚Ä¶"
            placeholderTextColor="#64748B"
            style={styles.searchInput}
            accessibilityLabel="Search chats"
            accessibilityHint="Filters conversations by name or last message"
            returnKeyType="search"
          />
          {!!query.trim() && (
            <Pressable
              onPress={() => setQuery("")}
              accessibilityRole="button"
              accessibilityLabel="Clear search"
              style={({ pressed }) => [
                styles.clearBtn,
                pressed ? { opacity: 0.9 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.clearText}>√ó</Text>
            </Pressable>
          )}
        </View>
      </View>

      {loading ? (
        <View style={styles.center}>
          <ActivityIndicator />
          <Text style={styles.muted}>Loading‚Ä¶</Text>
        </View>
      ) : errorText ? (
        <View style={{ padding: 16 }}>
          <View style={styles.errCard}>
            <Text style={styles.errTitle}>Couldn‚Äôt load chats</Text>
            <Text style={styles.errBody}>{errorText}</Text>

            <Pressable
              onPress={() => load("load")}
              accessibilityRole="button"
              accessibilityLabel="Try again"
              style={({ pressed }) => [
                styles.tryBtn,
                pressed ? { opacity: 0.9 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.tryText}>Try again</Text>
            </Pressable>
          </View>
        </View>
      ) : empty ? (
        <View style={{ padding: 16 }}>
          <View style={styles.emptyCard}>
            <Text style={styles.emptyTitle}>
              {query.trim() ? "No results" : "No chats yet"}
            </Text>
            <Text style={styles.emptyBody}>
              {query.trim()
                ? "Try a different search."
                : "Open any mentor profile and press ‚ÄúMessage‚Äù."}
            </Text>
          </View>
        </View>
      ) : (
        <FlatList
          data={filtered}
          keyExtractor={keyExtractor}
          renderItem={renderItem}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={() => load("refresh")}
              tintColor="#94A3B8"
            />
          }
          contentContainerStyle={{ padding: 16, paddingBottom: 26 }}
          ItemSeparatorComponent={() => <View style={{ height: 10 }} />}
          keyboardShouldPersistTaps="handled"
          accessibilityLabel="Chats list"
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },

  header: { padding: 16, paddingBottom: 10 },
  title: { color: "#E5E7EB", fontWeight: "900", fontSize: 18 },
  subtitle: { color: "#94A3B8", marginTop: 6, fontSize: 12 },

  searchWrap: {
    marginTop: 12,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  searchIcon: { color: "#64748B", fontWeight: "900" },
  searchInput: { flex: 1, color: "#E5E7EB", fontWeight: "700" },
  clearBtn: {
    width: 28,
    height: 28,
    borderRadius: 999,
    backgroundColor: "#111827",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  clearText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 16,
    lineHeight: 18,
  },

  center: { flex: 1, alignItems: "center", justifyContent: "center" },
  muted: { color: "#94A3B8", marginTop: 10, fontWeight: "800" },

  errCard: {
    backgroundColor: "#451A1A",
    borderColor: "#FCA5A5",
    borderWidth: 1,
    borderRadius: 14,
    padding: 12,
  },
  errTitle: { color: "#FECACA", fontWeight: "900" },
  errBody: { color: "#FECACA", marginTop: 6 },

  tryBtn: {
    alignSelf: "flex-start",
    marginTop: 10,
    backgroundColor: "#B91C1C",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  tryText: { color: "#FEE2E2", fontWeight: "900" },

  emptyCard: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 14,
  },
  emptyTitle: { color: "#E5E7EB", fontWeight: "900" },
  emptyBody: { color: "#94A3B8", marginTop: 6 },

  row: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    minHeight: 66,
  },

  avatar: {
    width: 44,
    height: 44,
    borderRadius: 999,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: { color: "#F97316", fontWeight: "900", fontSize: 16 },

  topLine: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 10,
  },
  name: { color: "#E5E7EB", fontWeight: "900", maxWidth: 220 },

  rightMeta: { flexDirection: "row", alignItems: "center", gap: 8 },

  time: {
    color: "#64748B",
    fontSize: 11,
    fontWeight: "800",
    writingDirection: "ltr",
  },

  badge: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
    paddingHorizontal: 8,
    height: 20,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  badgeText: { color: "#111827", fontWeight: "900", fontSize: 11 },

  last: { color: "#94A3B8", marginTop: 6 },
  lastUnread: { color: "#E5E7EB", fontWeight: "900" },
});
</file>

<file path="app/screens/homescreen.tsx">
// app/screens/homescreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../../lib/api";
import { getMe } from "../../lib/api";
import { getProfileCompletionStatus } from "../../lib/profileCompletion";
import {
  formatTimeAgo,
  readSectionStatus,
  SectionStatus,
} from "../../lib/sectionStatus";
import ProfileStatusCard from "./components/ProfileStatusCard";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = name.trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function getLevelFromXp(xp?: number) {
  const val = xp ?? 0;
  const level = Math.floor(val / 100);
  const progress = val % 100;
  return { level, progress };
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  return formatTimeAgo(ts);
}

function availabilityLabelFromMinutes(min: number) {
  if (min >= 600) return "üü¢ Excellent";
  if (min >= 240) return "üü° Good";
  if (min > 0) return "üî¥ Low";
  return "Not set";
}

export default function HomeScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [sectionStatus, setSectionStatus] = useState<SectionStatus>({
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: Date.now(),
  });

  const mountedRef = useRef(true);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      // ‚úÖ One place to read cross-section state
      const st = await readSectionStatus();
      if (mountedRef.current) setSectionStatus(st);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);
    } catch (err: any) {
      console.log("Home / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(
        err?.message || "We couldn‚Äôt load your profile. Please pull to refresh."
      );
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  const handleFindMentor = () => router.push("/find-mentor" as any);
  const handleGoAvailability = () => router.push("/weekly-availability" as any);
  const handleGoTeach = () => router.push("/manage-skills-to-teach" as any);
  const handleGoLearn = () => router.push("/manage-skills-to-learn" as any);
  const handleGoSessions = () => router.push("/sessions" as any);

  // ‚úÖ HOOKS BEFORE ANY EARLY RETURN
  const profileStatus = useMemo(() => getProfileCompletionStatus(user), [user]);

  const xp = user?.xp ?? 0;
  const points = user?.points ?? 0;
  const streak = user?.streak ?? 0;
  const { level, progress } = getLevelFromXp(xp);

  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );
  const qualityLabel = availabilityLabelFromMinutes(totalMin);
  const lastUpdatedText = formatLastUpdated(
    sectionStatus.weeklyAvailabilityLastSavedAt
  );

  const bestDay = useMemo(() => {
    if (!slots.length) return null;

    const minutesByDay: number[] = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;

      const val = Math.max(0, timeToMinutes(s.to) - timeToMinutes(s.from));
      minutesByDay[d] += val;
    }

    let bestIdx = -1;
    let bestMin = 0;

    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }

    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]} ¬∑ ${minutesToHuman(bestMin)}`;
  }, [slots]);

  // ‚úÖ NOW safe to early return
  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your dashboard‚Ä¶</Text>
      </View>
    );
  }

  const pendingChips = [
    sectionStatus.learnHasPendingSync ? "Learn: pending sync" : null,
    sectionStatus.teachHasPendingSync ? "Teach: pending sync" : null,
  ].filter(Boolean) as string[];

  return (
    <View style={styles.root}>
      <ScrollView
        style={styles.scroll}
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
            colors={["#F97316"]}
          />
        }
      >
        {/* ===== Top hero card ===== */}
        <View style={styles.heroCard}>
          <View style={styles.heroRow}>
            <View style={{ flex: 1 }}>
              <Text style={styles.greeting}>
                {user ? "Welcome back" : "Welcome to SkillSwap"}
              </Text>
              <Text style={styles.name}>
                {user?.fullName || "SkillSwap user"}
              </Text>
              <Text style={styles.tagline}>
                See your progress, grow your skills, and connect with other
                learners.
              </Text>
            </View>

            <View style={styles.avatar}>
              <Text style={styles.avatarText}>
                {getInitials(user?.fullName)}
              </Text>
            </View>
          </View>

          <View style={styles.heroBottomRow}>
            <View style={styles.levelColumn}>
              <Text style={styles.levelLabel}>Level</Text>
              <Text style={styles.levelValue}>{level}</Text>
            </View>

            <View style={styles.progressColumn}>
              <View style={styles.progressHeader}>
                <Text style={styles.progressLabel}>XP progress</Text>
                <Text style={styles.progressValue}>{progress}/100</Text>
              </View>

              <View style={styles.progressBarBackground}>
                <View
                  style={[
                    styles.progressBarFill,
                    { width: `${Math.min(progress, 100)}%` },
                  ]}
                />
              </View>
            </View>

            {streak > 0 && (
              <View style={styles.streakBadge}>
                <Text style={styles.streakEmoji}>üî•</Text>
                <Text style={styles.streakText}>{streak}-day streak</Text>
              </View>
            )}
          </View>

          {/* ‚úÖ pending sync chips (minimal + clean) */}
          {pendingChips.length > 0 && (
            <View
              style={{
                flexDirection: "row",
                gap: 8,
                flexWrap: "wrap",
                marginTop: 10,
              }}
            >
              {pendingChips.map((t) => (
                <View key={t} style={styles.pendingChip}>
                  <Text style={styles.pendingChipText}>{t}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>We couldn‚Äôt refresh your data</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        {/* ‚úÖ Profile status card */}
        <ProfileStatusCard status={profileStatus} />

        {/* ===== Stats row ===== */}
        <View style={styles.statsRow}>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>XP</Text>
            <Text style={styles.statValue}>{xp}</Text>
            <Text style={styles.statHint}>Earned by learning from others</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>Points</Text>
            <Text style={styles.statValue}>{points}</Text>
            <Text style={styles.statHint}>Earned by teaching others</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>Streak</Text>
            <Text style={styles.statValue}>{streak}</Text>
            <Text style={styles.statHint}>Active days in a row</Text>
          </View>
        </View>

        {/* ===== Quick actions ===== */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Quick actions</Text>
          <Text style={styles.sectionSubtitle}>
            Start from one of these common actions.
          </Text>

          <View style={styles.quickRow}>
            <TouchableOpacity
              style={[styles.quickCard, styles.quickPrimary]}
              onPress={handleFindMentor}
              activeOpacity={0.85}
            >
              <Text style={styles.quickEmoji}>üßë‚Äçüè´</Text>
              <Text style={styles.quickTitle}>Find a mentor</Text>
              <Text style={styles.quickText}>
                Discover people who can help you with your learning goals.
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.quickCard, styles.quickSecondary]}
              onPress={handleGoSessions}
              activeOpacity={0.85}
            >
              <Text style={styles.quickEmoji}>üìÖ</Text>
              <Text style={styles.quickTitle}>My sessions</Text>
              <Text style={styles.quickText}>
                View requests, accept/reject, and manage upcoming sessions.
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* ===== Skills learn ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Skills you want to learn</Text>
            <TouchableOpacity activeOpacity={0.85} onPress={handleGoLearn}>
              <Text style={styles.sectionAction}>Manage</Text>
            </TouchableOpacity>
          </View>

          {user?.skillsToLearn?.length ? (
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.horizontalChips}
            >
              {user.skillsToLearn.map((skill, idx) => (
                <View key={`${skill.name}-${idx}`} style={styles.chip}>
                  <Text style={styles.chipText}>
                    {skill.name}
                    {skill.level && skill.level !== "Not specified"
                      ? ` ¬∑ ${skill.level}`
                      : ""}
                  </Text>
                </View>
              ))}
            </ScrollView>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No learning goals yet</Text>
              <Text style={styles.emptyText}>
                Add a few skills you‚Äôre interested in, so we can match you with
                the right mentors.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoLearn}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>Add learning goals</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Skills teach ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Skills you can teach</Text>
            <TouchableOpacity activeOpacity={0.85} onPress={handleGoTeach}>
              <Text style={styles.sectionAction}>Manage</Text>
            </TouchableOpacity>
          </View>

          {user?.skillsToTeach?.length ? (
            <View style={styles.teachList}>
              {user.skillsToTeach.map((skill, idx) => (
                <View key={`${skill.name}-${idx}`} style={styles.teachCard}>
                  <View style={{ flex: 1 }}>
                    <Text style={styles.teachName}>{skill.name}</Text>
                    <Text style={styles.teachLevel}>
                      Level: {skill.level || "Not specified"}
                    </Text>
                  </View>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>Nothing to teach yet</Text>
              <Text style={styles.emptyText}>
                Add at least one skill you feel comfortable teaching. This will
                unlock more ways to earn points.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoTeach}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>Add teaching skills</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Availability ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Your weekly availability</Text>
            <TouchableOpacity
              activeOpacity={0.85}
              onPress={handleGoAvailability}
            >
              <Text style={styles.sectionAction}>
                {slots.length ? "Edit" : "Set now"}
              </Text>
            </TouchableOpacity>
          </View>

          <View style={styles.availSummaryCard}>
            <Text style={styles.availSummaryTop}>
              {qualityLabel} ¬∑ {daysSet} day{daysSet === 1 ? "" : "s"} ¬∑{" "}
              {minutesToHuman(totalMin)} total
            </Text>
            <Text style={styles.availSummaryBottom}>
              {bestDay ? `Best: ${bestDay} ¬∑ ` : ""}
              Last saved: {lastUpdatedText}
            </Text>
          </View>

          {slots.length ? (
            <View style={styles.availabilityList}>
              {slots.slice(0, 4).map((slot, idx) => (
                <View
                  key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                  style={styles.availabilityRow}
                >
                  <Text style={styles.availabilityDay}>
                    {dayNames[slot.dayOfWeek] || "Day"}
                  </Text>
                  <Text style={styles.availabilityTime}>
                    {slot.from} ‚Äì {slot.to}
                  </Text>
                </View>
              ))}

              {slots.length > 4 && (
                <TouchableOpacity
                  onPress={handleGoAvailability}
                  activeOpacity={0.85}
                  style={styles.availMoreBtn}
                >
                  <Text style={styles.availMoreText}>
                    View all ({slots.length}) ‚Üí
                  </Text>
                </TouchableOpacity>
              )}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No availability set</Text>
              <Text style={styles.emptyText}>
                Set 1‚Äì2 time slots (evenings/weekend) to improve mentor matches.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoAvailability}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>
                  Set availability (2 mins)
                </Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Footer ===== */}
        <View style={styles.footerRow}>
          <Text style={styles.footerHint}>
            Availability saved: {lastUpdatedText}
          </Text>
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  heroCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  heroRow: { flexDirection: "row", alignItems: "center", marginBottom: 12 },
  greeting: { color: "#9CA3AF", fontSize: 13 },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "700", marginTop: 2 },
  tagline: { color: "#64748B", fontSize: 12, marginTop: 6 },

  avatar: {
    width: 50,
    height: 50,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
    marginLeft: 12,
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "700" },

  heroBottomRow: { flexDirection: "row", alignItems: "center", marginTop: 4 },
  levelColumn: { width: 64, alignItems: "flex-start" },
  levelLabel: { color: "#94A3B8", fontSize: 11 },
  levelValue: {
    color: "#E5E7EB",
    fontSize: 20,
    fontWeight: "700",
    marginTop: 2,
  },

  progressColumn: { flex: 1, marginHorizontal: 12 },
  progressHeader: { flexDirection: "row", justifyContent: "space-between" },
  progressLabel: { color: "#94A3B8", fontSize: 11 },
  progressValue: { color: "#CBD5F5", fontSize: 11 },
  progressBarBackground: {
    marginTop: 6,
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
  },
  progressBarFill: { height: "100%", backgroundColor: "#F97316" },

  streakBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#F97316",
    flexDirection: "row",
    alignItems: "center",
  },
  streakEmoji: { marginRight: 4 },
  streakText: { color: "#FED7AA", fontSize: 11, fontWeight: "600" },

  pendingChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1120",
  },
  pendingChipText: { color: "#E5E7EB", fontSize: 11, fontWeight: "800" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryButton: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "500" },

  statsRow: { flexDirection: "row", gap: 8, marginBottom: 18 },
  statCard: {
    flex: 1,
    backgroundColor: "#020617",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  statLabel: { color: "#94A3B8", fontSize: 11, marginBottom: 4 },
  statValue: { color: "#F9FAFB", fontSize: 18, fontWeight: "700" },
  statHint: { color: "#64748B", fontSize: 10, marginTop: 4 },

  section: { marginBottom: 20 },
  sectionHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  sectionTitle: { color: "#F9FAFB", fontSize: 16, fontWeight: "600" },
  sectionSubtitle: { color: "#64748B", fontSize: 12, marginBottom: 8 },
  sectionAction: { color: "#60A5FA", fontSize: 13, fontWeight: "500" },

  quickRow: { flexDirection: "row", gap: 10, marginTop: 6 },
  quickCard: { flex: 1, borderRadius: 16, padding: 12, borderWidth: 1 },
  quickPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },
  quickSecondary: { backgroundColor: "#020617", borderColor: "#4B5563" },
  quickEmoji: { fontSize: 20, marginBottom: 6 },
  quickTitle: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "600",
    marginBottom: 4,
  },
  quickText: { color: "#9CA3AF", fontSize: 12 },

  horizontalChips: { paddingVertical: 4, paddingRight: 4, gap: 8 },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    marginRight: 8,
  },
  chipText: { color: "#E5E7EB", fontSize: 12 },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 4,
  },
  emptyText: { color: "#64748B", fontSize: 12 },

  teachList: { gap: 8 },
  teachCard: {
    backgroundColor: "#020617",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  teachName: { color: "#F9FAFB", fontSize: 14, fontWeight: "600" },
  teachLevel: { color: "#9CA3AF", fontSize: 12, marginTop: 2 },

  availSummaryCard: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    marginBottom: 10,
  },
  availSummaryTop: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },
  availSummaryBottom: { color: "#94A3B8", fontSize: 11, marginTop: 4 },

  availabilityList: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    paddingVertical: 4,
  },
  availabilityRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: "#020617",
  },
  availabilityDay: { color: "#E5E7EB", fontSize: 13 },
  availabilityTime: { color: "#9CA3AF", fontSize: 13 },

  availMoreBtn: {
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: "#0B1120",
  },
  availMoreText: { color: "#60A5FA", fontSize: 12, fontWeight: "600" },

  primaryCta: {
    marginTop: 10,
    borderRadius: 999,
    paddingVertical: 10,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  primaryCtaText: { color: "#ffffff", fontWeight: "700", fontSize: 13 },

  footerRow: {
    marginTop: 8,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  footerHint: { color: "#6B7280", fontSize: 11 },
  logoutButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12 },
});
</file>

<file path="lib/chat/api.ts">
// lib/api.ts
import Constants from "expo-constants";
import { Platform } from "react-native";

function getEnvApiUrl(): string | null {
  const v = (process.env.EXPO_PUBLIC_API_URL || "").trim();
  return v ? v : null;
}

function getExtraApiUrl(): string | null {
  // supports app.json -> extra.apiUrl (if you ever add it later)
  const extra: any =
    (Constants as any)?.expoConfig?.extra ||
    (Constants as any)?.manifest?.extra ||
    null;

  const v = String(extra?.apiUrl || extra?.API_URL || "").trim();
  return v ? v : null;
}

function getDebuggerHost(): string | null {
  const debuggerHost = (Constants as any)?.debuggerHost as string | undefined;
  if (debuggerHost && typeof debuggerHost === "string") {
    const host = debuggerHost.split(":")[0];
    return host ? host : null;
  }
  return null;
}

function resolveApiUrl(): string {
  // 1) Explicit env override (best + stable)
  const envUrl = getEnvApiUrl();
  if (envUrl) return envUrl;

  // 2) Optional "extra" (future-proof)
  const extraUrl = getExtraApiUrl();
  if (extraUrl) return extraUrl;

  // 3) Web: use browser hostname (works in LAN too)
  if (Platform.OS === "web" && typeof window !== "undefined") {
    const host = window.location.hostname; // localhost / 127.0.0.1 / 192.168.x.x
    const protocol = window.location.protocol; // http: or https:

    // If you're on https and your backend is http -> browser blocks (mixed content)
    // For local dev it's usually http, so it's fine.
    if (host === "localhost" || host === "127.0.0.1") {
      return "http://localhost:4000";
    }

    // If you opened the web from another device in LAN, this will correctly hit YOUR machine IP
    return `${protocol}//${host}:4000`;
  }

  // 4) Native: try Expo debugger host first (best for physical device)
  const hostFromExpo = getDebuggerHost();
  if (hostFromExpo) {
    // Android emulator special-case
    if (Platform.OS === "android") {
      if (hostFromExpo === "localhost" || hostFromExpo === "127.0.0.1") {
        return "http://10.0.2.2:4000";
      }
      return `http://${hostFromExpo}:4000`;
    }
    return `http://${hostFromExpo}:4000`;
  }

  // 5) Final fallbacks
  if (Platform.OS === "android") return "http://10.0.2.2:4000";
  return "http://localhost:4000";
}

export const API_URL = resolveApiUrl();
console.log("üîó API_URL resolved to:", API_URL);

async function handleResponse(res: Response) {
  const text = await res.text();

  let data: any = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    console.log("API ERROR =>", {
      url: res.url,
      status: res.status,
      rawBody: text,
      parsed: data,
    });

    const message =
      (data && (data as any).error) ||
      (data && (data as any).message) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;

    throw new Error(message);
  }

  return data;
}

// ---------- AUTH ----------
export async function signup(params: {
  fullName: string;
  email: string;
  password: string;
}) {
  const res = await fetch(`${API_URL}/auth/signup`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

export async function login(params: { email: string; password: string }) {
  const res = await fetch(`${API_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

// ---------- TYPES ----------
export type AvailabilitySlot = { dayOfWeek: number; from: string; to: string };
export type SkillTeach = { name: string; level: string };
export type SkillLearn = { name: string; level: string };

export type MentorMatch = {
  mentorId: string;
  fullName: string;
  matchScore: number;
  mainMatchedSkill?: { name: string; level: string; similarityScore: number };
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

export type MatchingMode = "local" | "openai" | "hybrid";

export type MatchingStatus = {
  openaiAvailable: boolean;
  reason: "OK" | "NO_KEY" | "ERROR" | string;
  recommendedMode: "local" | "hybrid";
};

export type MatchingMeta = {
  requestedMode: MatchingMode | null;
  modeUsed: MatchingMode | null;
  fallbackUsed: boolean;
  message?: string;
};

// ---------- USER ----------
export async function getMe(token: string) {
  const res = await fetch(`${API_URL}/api/me`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}

// ---------- PROFILE UPDATE ----------
export async function updateProfile(
  token: string,
  partial: {
    skillsToLearn?: SkillLearn[];
    skillsToTeach?: SkillTeach[];
    availabilitySlots?: AvailabilitySlot[];
  }
) {
  const res = await fetch(`${API_URL}/api/me/profile`, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(partial),
  });

  return handleResponse(res);
}

export async function updateWeeklyAvailability(
  token: string,
  availabilitySlots: AvailabilitySlot[]
) {
  return updateProfile(token, { availabilitySlots });
}

export async function updateSkillsToTeach(
  token: string,
  skillsToTeach: SkillTeach[]
) {
  return updateProfile(token, { skillsToTeach });
}

export async function updateSkillsToLearn(
  token: string,
  skillsToLearn: SkillLearn[]
) {
  return updateProfile(token, { skillsToLearn });
}

// ---------- MATCHING STATUS ----------
export async function getMatchingStatus(): Promise<MatchingStatus> {
  const res = await fetch(`${API_URL}/api/matching/status`, { method: "GET" });
  return handleResponse(res);
}

// ---------- MATCHING ----------
export async function getMentorMatches(
  token: string,
  params: {
    skill: string;
    level: "Beginner" | "Intermediate" | "Advanced";
    availabilitySlots?: AvailabilitySlot[];
    mode?: MatchingMode;
  }
): Promise<{ results: MentorMatch[]; meta?: MatchingMeta }> {
  const res = await fetch(`${API_URL}/api/matches/mentors`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      skill: params.skill,
      level: params.level,
      availabilitySlots: params.availabilitySlots ?? [],
      mode: params.mode,
    }),
  });

  return handleResponse(res);
}

// ---------- PUBLIC USER PROFILE (Mentor) ----------
export type PublicUserProfile = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

export async function getPublicUserProfile(
  token: string,
  userId: string
): Promise<PublicUserProfile> {
  const res = await fetch(`${API_URL}/api/users/${userId}`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}
</file>

<file path="lib/chat/socket.ts">
// lib/chat/socket.ts
import { io, Socket } from "socket.io-client";
import { API_URL } from "../api";

export type RealtimeMessage = {
  id: string;
  conversationId: string;
  senderId: string;
  text: string;
  createdAt: string;
};

type ConnStatus = "connected" | "reconnecting" | "disconnected";

let socket: Socket | null = null;
let currentToken: string | null = null;

function normalizeCreatedAt(v: any): string {
  if (!v) return new Date().toISOString();
  if (typeof v === "string") return v;
  if (v instanceof Date) return v.toISOString();
  const d = new Date(v);
  return Number.isNaN(d.getTime()) ? new Date().toISOString() : d.toISOString();
}

function ensureConnected(token: string) {
  currentToken = token;

  if (socket) {
    // Update auth safely
    socket.auth = token ? { token } : {};
    if (!socket.connected) socket.connect();
    return socket;
  }

  socket = io(API_URL, {
    transports: ["websocket"],
    auth: token ? { token } : {},
    autoConnect: true,
    reconnection: true,
  });

  return socket;
}

export function connectChatSocket(token: string) {
  return ensureConnected(token);
}

export function disconnectChatSocket() {
  try {
    socket?.disconnect();
  } finally {
    socket = null;
    currentToken = null;
  }
}

export function joinConversationRoom(conversationId: string, peerId?: string) {
  const s = socket;
  if (!s) return;
  s.emit("conversation:join", { conversationId, peerId: peerId || "" });
}

export function markConversationRead(conversationId: string) {
  const s = socket;
  if (!s) return Promise.resolve();
  return new Promise<void>((resolve) => {
    s.emit("conversation:read", { conversationId });
    resolve();
  });
}

export function emitTyping(conversationId: string, isTyping: boolean) {
  const s = socket;
  if (!s) return;
  s.emit("typing", { conversationId, isTyping: !!isTyping });
}

export function onNewMessage(handler: (m: RealtimeMessage) => void) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    const msg: RealtimeMessage = {
      id: String(payload?.id || payload?._id || ""),
      conversationId: String(payload?.conversationId || ""),
      senderId: String(payload?.senderId || ""),
      text: String(payload?.text || ""),
      createdAt: normalizeCreatedAt(payload?.createdAt),
    };
    if (!msg.id || !msg.conversationId) return;
    handler(msg);
  };

  s.on("message:new", wrapped);
  return () => s.off("message:new", wrapped);
}

export function onPeerTyping(
  handler: (p: { conversationId: string; userId: string; isTyping: boolean }) => void
) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      conversationId: String(payload?.conversationId || ""),
      userId: String(payload?.userId || ""),
      isTyping: !!payload?.isTyping,
    });
  };

  s.on("typing", wrapped);
  return () => s.off("typing", wrapped);
}

export function onReadReceipt(handler: (p: { conversationId: string; readerId: string }) => void) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      conversationId: String(payload?.conversationId || ""),
      readerId: String(payload?.readerId || ""),
    });
  };

  s.on("read:receipt", wrapped);
  return () => s.off("read:receipt", wrapped);
}

export function onPresenceUpdate(
  handler: (p: { userId: string; online: boolean; lastSeen: string | null }) => void
) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      userId: String(payload?.userId || ""),
      online: !!payload?.online,
      lastSeen: payload?.lastSeen ? String(payload.lastSeen) : null,
    });
  };

  s.on("presence:update", wrapped);
  return () => s.off("presence:update", wrapped);
}

export function onConnectionStatus(handler: (s: ConnStatus) => void) {
  const s = socket;
  if (!s) return () => {};

  const emit = (v: ConnStatus) => handler(v);

  const onConnect = () => emit("connected");
  const onDisconnect = () => emit("disconnected");
  const onReconnectAttempt = () => emit("reconnecting");
  const onConnectError = () => emit("reconnecting");

  s.on("connect", onConnect);
  s.on("disconnect", onDisconnect);
  s.io.on("reconnect_attempt", onReconnectAttempt);
  s.on("connect_error", onConnectError);

  // immediate
  emit(s.connected ? "connected" : "disconnected");

  return () => {
    s.off("connect", onConnect);
    s.off("disconnect", onDisconnect);
    s.off("connect_error", onConnectError);
    s.io.off("reconnect_attempt", onReconnectAttempt);
  };
}

export function sendRealtimeMessage(
  conversationId: string,
  text: string
): Promise<{ ok: boolean; message?: RealtimeMessage; error?: string }> {
  return new Promise((resolve) => {
    const s = socket;
    if (!s) return resolve({ ok: false, error: "Socket not connected" });

    s.emit(
      "message:send",
      { conversationId, text },
      (resp: any = { ok: false, error: "No response" }) => {
        if (!resp?.ok) return resolve({ ok: false, error: String(resp?.error || "Failed") });

        const payload = resp?.message || resp;
        const msg: RealtimeMessage = {
          id: String(payload?.id || payload?._id || ""),
          conversationId: String(payload?.conversationId || conversationId),
          senderId: String(payload?.senderId || ""),
          text: String(payload?.text || text),
          createdAt: normalizeCreatedAt(payload?.createdAt),
        };
        return resolve({ ok: true, message: msg });
      }
    );
  });
}
</file>

<file path="app/_layout.tsx">
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/use-color-scheme';

export const unstable_settings = {
  anchor: '(tabs)',
};

export default function RootLayout() {
  const colorScheme = useColorScheme();

  return (
    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="modal" options={{ presentation: 'modal', title: 'Modal' }} />
      </Stack>
      <StatusBar style="auto" />
    </ThemeProvider>
  );
}
</file>

<file path="app/(auth)/_layout.tsx">
// app/(auth)/_layout.tsx
import { Stack } from "expo-router";
import React from "react";

export default function AuthLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "fade",
      }}
    />
  );
}
</file>

<file path="app/(auth)/login/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  Text,
  View,
} from "react-native";
import { getMe, login } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import { validateEmail, validatePassword } from "../shared/validators";

type FieldErrors = {
  email?: string;
  password?: string;
};

export default function LoginScreen() {
  const router = useRouter();

  const { register, focusNext } = useAuthFieldFocus([
    "email",
    "password",
  ] as const);

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [checkingSession, setCheckingSession] = useState(true);
  const [loading, setLoading] = useState(false);

  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const [forgotOpen, setForgotOpen] = useState(false);

  // ‚úÖ Session check (prevents flicker)
  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!token) {
          if (mounted) setCheckingSession(false);
          return;
        }

        await getMe(token);
        if (!mounted) return;
        router.replace("/(tabs)" as any);
      } catch {
        await AsyncStorage.removeItem("token");
        if (mounted) setCheckingSession(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  const canSubmit = useMemo(() => {
    if (checkingSession || loading) return false;
    const e = validateEmail(email);
    const p = validatePassword(password);
    return e.ok && p.ok;
  }, [checkingSession, loading, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await login({
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Login failed: missing token from server.");
        setPassword("");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
      setPassword("");
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <KeyboardAvoidingView
        style={authStyles.root}
        behavior={Platform.OS === "ios" ? "padding" : undefined}
      >
        <ScrollView
          contentContainerStyle={authStyles.content}
          keyboardShouldPersistTaps="handled"
        >
          <AuthHeader
            title="Sign in"
            subtitle="Welcome back ‚Äî continue learning where you left off."
          />

          {checkingSession ? (
            <View
              style={{ paddingVertical: 24, alignItems: "center", gap: 10 }}
            >
              <ActivityIndicator />
              <Text style={authStyles.subtitle}>Checking your session‚Ä¶</Text>
            </View>
          ) : (
            <>
              {bannerError ? (
                <View style={authStyles.bannerError}>
                  <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
                </View>
              ) : null}

              <AuthTextField
                ref={register("email")}
                label="Email"
                value={email}
                onChangeText={(t) => {
                  setEmail(t);
                  clearBannerAndField("email");
                }}
                placeholder="you@example.com"
                keyboardType="email-address"
                returnKeyType="next"
                onSubmitEditing={() => focusNext("email")}
                editable={!loading}
                errorText={fieldErrors.email}
              />

              <PasswordField
                ref={register("password")}
                value={password}
                onChangeText={(t) => {
                  setPassword(t);
                  clearBannerAndField("password");
                }}
                errorText={fieldErrors.password}
                returnKeyType="done"
                onSubmitEditing={onSubmit}
                editable={!loading}
              />

              <Pressable
                onPress={() => setForgotOpen(true)}
                disabled={loading}
                style={({ pressed }) => [
                  { alignSelf: "flex-end", marginTop: 6 },
                  pressed ? { opacity: 0.85 } : null,
                ]}
              >
                <Text style={authStyles.linkBtn}>Forgot password?</Text>
              </Pressable>

              <AuthButton
                title={loading ? "Signing in‚Ä¶" : "Sign in"}
                loading={loading}
                disabled={!canSubmit}
                onPress={onSubmit}
              />

              <View style={authStyles.linkRow}>
                <Text style={authStyles.linkText}>Don‚Äôt have an account?</Text>
                <Link href="/(auth)/signup" style={authStyles.linkBtn}>
                  Create one
                </Link>
              </View>
            </>
          )}
        </ScrollView>

        {/* ‚úÖ Forgot password modal */}
        <Modal
          transparent
          visible={forgotOpen}
          animationType="fade"
          onRequestClose={() => setForgotOpen(false)}
        >
          <Pressable
            onPress={() => setForgotOpen(false)}
            style={{
              flex: 1,
              backgroundColor: "rgba(0,0,0,0.6)",
              justifyContent: "center",
              padding: 18,
            }}
          >
            <Pressable
              onPress={() => {}}
              style={{
                backgroundColor: "#0B1120",
                borderRadius: 16,
                borderWidth: 1,
                borderColor: "#1E293B",
                padding: 16,
              }}
            >
              <Text
                style={{
                  color: "#F9FAFB",
                  fontSize: 16,
                  fontWeight: "900",
                  marginBottom: 6,
                }}
              >
                Password reset
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 13, lineHeight: 18 }}>
                Coming soon. For now, create a new account or contact support if
                you‚Äôre locked out.
              </Text>

              <Pressable
                onPress={() => setForgotOpen(false)}
                style={({ pressed }) => [
                  {
                    marginTop: 14,
                    backgroundColor: "#22C55E",
                    borderRadius: 999,
                    paddingVertical: 12,
                    alignItems: "center",
                  },
                  pressed ? { opacity: 0.9 } : null,
                ]}
              >
                <Text style={{ color: "#022C22", fontWeight: "900" }}>OK</Text>
              </Pressable>
            </Pressable>
          </Pressable>
        </Modal>
      </KeyboardAvoidingView>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthButton.tsx">
import React from "react";
import { ActivityIndicator, Text, TouchableOpacity, View } from "react-native";
import { authStyles } from "./styles";

type Props = {
  title: string;
  onPress: () => void;
  loading?: boolean;
  disabled?: boolean;
};

export default function AuthButton({
  title,
  onPress,
  loading,
  disabled,
}: Props) {
  const isDisabled = !!disabled || !!loading;

  return (
    <TouchableOpacity
      style={[
        authStyles.primaryBtn,
        isDisabled && authStyles.primaryBtnDisabled,
      ]}
      onPress={onPress}
      disabled={isDisabled}
      activeOpacity={0.85}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: !!loading }}
    >
      {loading ? (
        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <ActivityIndicator />
          <Text style={authStyles.primaryBtnText}>{title}</Text>
        </View>
      ) : (
        <Text style={authStyles.primaryBtnText}>{title}</Text>
      )}
    </TouchableOpacity>
  );
}
</file>

<file path="app/(auth)/shared/AuthHeader.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { title: string; subtitle: string };

export default function AuthHeader({ title, subtitle }: Props) {
  return (
    <View style={authStyles.header}>
      <Text style={authStyles.title}>{title}</Text>
      <Text style={authStyles.subtitle}>{subtitle}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthTextField.tsx">
import React from "react";
import { Text, TextInput, TextInputProps, View } from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  label: string;
  value: string;
  onChangeText: (t: string) => void;
  placeholder?: string;
  errorText?: string | null;
} & Omit<TextInputProps, "value" | "onChangeText">;

const AuthTextField = React.forwardRef<TextInput, Props>(function AuthTextField(
  { label, value, onChangeText, placeholder, errorText, style, ...rest },
  ref
) {
  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>
      <TextInput
        ref={ref}
        style={[authStyles.input, !!errorText && authStyles.inputError, style]}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor="#64748B"
        autoCapitalize="none"
        autoCorrect={false}
        {...rest}
      />
      <InlineError text={errorText} />
    </View>
  );
});

export default AuthTextField;
</file>

<file path="app/(auth)/shared/InlineError.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { text?: string | null };

export default function InlineError({ text }: Props) {
  if (!text) return null;
  return (
    <View style={authStyles.inlineErrorBox}>
      <Text style={authStyles.inlineErrorText}>{text}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/mapApiError.ts">
export function mapApiError(err: any): string {
  // Try to pick the most useful message without leaking raw server dumps.
  const raw =
    String(err?.message || "").trim() ||
    String(err?.response?.data?.message || "").trim() ||
    String(err?.response?.data?.error || "").trim();

  const msg = raw.toLowerCase();

  if (!raw) return "Something went wrong. Please try again.";

  // Network-ish
  if (
    msg.includes("network request failed") ||
    msg.includes("failed to fetch") ||
    msg.includes("network") ||
    msg.includes("socket") ||
    msg.includes("ecconn") ||
    msg.includes("timeout")
  ) {
    return "Can‚Äôt reach the server. Check your internet (or API URL) and try again.";
  }

  // Auth / credentials
  if (
    msg.includes("invalid credentials") ||
    msg.includes("invalid") && msg.includes("password") ||
    msg.includes("incorrect") ||
    msg.includes("unauthorized") ||
    msg.includes("401")
  ) {
    return "Email or password is incorrect.";
  }

  // Signup collisions
  if (msg.includes("already") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }
  if (msg.includes("exists") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }

  // User not found (login)
  if (msg.includes("not found") || msg.includes("no user")) {
    return "This email is not registered yet.";
  }

  // Token missing from backend
  if (msg.includes("missing") && msg.includes("token")) {
    return "Login succeeded but server didn‚Äôt return a token. Please contact support.";
  }

  // Generic fallback: avoid very long raw messages
  if (raw.length > 140) return "Something went wrong. Please try again.";
  return raw;
}
</file>

<file path="app/(auth)/shared/PasswordField.tsx">
import React, { useState } from "react";
import {
  Text,
  TextInput,
  TextInputProps,
  TouchableOpacity,
  View,
} from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  value: string;
  onChangeText: (t: string) => void;
  errorText?: string | null;
  label?: string;
} & Omit<TextInputProps, "value" | "onChangeText" | "secureTextEntry">;

const PasswordField = React.forwardRef<TextInput, Props>(function PasswordField(
  { value, onChangeText, errorText, label = "Password", style, ...rest },
  ref
) {
  const [show, setShow] = useState(false);

  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>

      <View style={authStyles.passwordRow}>
        <TextInput
          ref={ref}
          style={[
            authStyles.input,
            { flex: 1 },
            !!errorText && authStyles.inputError,
            style,
          ]}
          value={value}
          onChangeText={onChangeText}
          placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
          placeholderTextColor="#64748B"
          secureTextEntry={!show}
          autoCapitalize="none"
          autoCorrect={false}
          {...rest}
        />

        <TouchableOpacity
          onPress={() => setShow((v) => !v)}
          style={authStyles.eyeBtn}
          accessibilityRole="button"
          accessibilityLabel={show ? "Hide password" : "Show password"}
          activeOpacity={0.85}
        >
          <Text style={authStyles.eyeText}>{show ? "Hide" : "Show"}</Text>
        </TouchableOpacity>
      </View>

      <InlineError text={errorText} />
    </View>
  );
});

export default PasswordField;
</file>

<file path="app/(auth)/shared/styles.ts">
import { StyleSheet } from "react-native";

export const authStyles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },

  content: {
    paddingHorizontal: 16,
    paddingTop: 28,
    paddingBottom: 28,
  },

  /* ===== Header ===== */
  header: { marginBottom: 18 },
  title: {
    color: "#F9FAFB",
    fontSize: 26,
    fontWeight: "900",
    letterSpacing: 0.2,
  },
  subtitle: {
    color: "#94A3B8",
    fontSize: 13,
    marginTop: 6,
    lineHeight: 18,
  },

  /* ===== Errors ===== */
  bannerError: {
    backgroundColor: "#451A1A",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  bannerErrorText: {
    color: "#FECACA",
    fontSize: 12,
    fontWeight: "800",
    lineHeight: 16,
  },

  inlineErrorBox: { marginTop: 6 },
  inlineErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "800",
  },

  /* ===== Fields ===== */
  fieldWrap: { marginBottom: 14 },
  fieldLabel: {
    color: "#CBD5E1",
    fontSize: 12,
    fontWeight: "800",
    marginBottom: 6,
  },

  input: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 14,
    paddingVertical: 12,
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "700",
  },

  inputError: {
    borderColor: "#FCA5A5",
  },

  passwordRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },

  eyeBtn: {
    paddingHorizontal: 12,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  eyeText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },

  /* ===== Buttons ===== */
  primaryBtn: {
    marginTop: 10,
    backgroundColor: "#22C55E",
    paddingVertical: 13,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryBtnDisabled: {
    opacity: 0.55,
  },
  primaryBtnText: {
    color: "#022C22",
    fontSize: 13,
    fontWeight: "900",
    letterSpacing: 0.3,
  },

  /* ===== Links ===== */
  linkRow: {
    marginTop: 16,
    flexDirection: "row",
    justifyContent: "center",
    gap: 6,
  },
  linkText: {
    color: "#94A3B8",
    fontSize: 12,
    fontWeight: "700",
  },
  linkBtn: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
});
</file>

<file path="app/(auth)/shared/useAuthFieldFocus.ts">
import { useRef } from "react";
import { TextInput } from "react-native";

export function useAuthFieldFocus<T extends string>(keys: readonly T[]) {
  const refs = useRef<Record<T, TextInput | null>>({} as any);

  const register = (key: T) => (ref: TextInput | null) => {
    refs.current[key] = ref;
  };

  const focusNext = (key: T) => {
    const idx = keys.indexOf(key);
    const nextKey = keys[idx + 1];
    if (nextKey && refs.current[nextKey]) {
      refs.current[nextKey]?.focus();
    }
  };

  return { register, focusNext };
}
</file>

<file path="app/(auth)/shared/useAuthRedirect.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useEffect, useState } from "react";

/**
 * If token exists -> redirect to "/"
 * Returns ready=false while checking storage (to avoid flicker)
 */
export function useAuthRedirect() {
  const router = useRouter();
  const [ready, setReady] = useState(false);

  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!mounted) return;

        if (token) {
          router.replace("/"); // go to tabs/home
          return;
        }
      } finally {
        if (mounted) setReady(true);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  return { ready };
}
</file>

<file path="app/(auth)/shared/validators.ts">
export function validateEmail(email: string) {
  const v = email.trim();
  const ok = /^\S+@\S+\.\S+$/.test(v);
  return { ok, value: v, error: ok ? null : "Please enter a valid email." };
}

export function validatePassword(password: string) {
  const v = password;
  const ok = v.length >= 6;
  return { ok, value: v, error: ok ? null : "Password must be at least 6 characters." };
}

export function validateFullName(fullName: string) {
  const v = fullName.trim();
  const ok = v.length >= 2;
  return { ok, value: v, error: ok ? null : "Please enter your full name." };
}
</file>

<file path="app/(auth)/signup/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import { ScrollView, Text, View } from "react-native";
import { signup } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import {
  validateEmail,
  validateFullName,
  validatePassword,
} from "../shared/validators";

type FieldErrors = {
  fullName?: string;
  email?: string;
  password?: string;
};

export default function SignupScreen() {
  const router = useRouter();
  const { register, focusNext } = useAuthFieldFocus([
    "fullName",
    "email",
    "password",
  ] as const);

  const [fullName, setFullName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [loading, setLoading] = useState(false);
  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const canSubmit = useMemo(() => {
    if (loading) return false;
    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);
    return n.ok && e.ok && p.ok;
  }, [loading, fullName, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!n.ok) nextErrors.fullName = n.error || "Please enter your full name.";
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await signup({
        fullName: n.value,
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Signup failed: missing token from server.");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <ScrollView
        contentContainerStyle={authStyles.content}
        keyboardShouldPersistTaps="handled"
      >
        <AuthHeader
          title="Create account"
          subtitle="Join SkillSwap and start learning & teaching."
        />

        {bannerError ? (
          <View style={authStyles.bannerError}>
            <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
          </View>
        ) : null}

        <AuthTextField
          ref={register("fullName")}
          label="Full name"
          value={fullName}
          onChangeText={(t) => {
            setFullName(t);
            clearBannerAndField("fullName");
          }}
          placeholder="Your name"
          errorText={fieldErrors.fullName}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("fullName")}
        />

        <AuthTextField
          ref={register("email")}
          label="Email"
          value={email}
          onChangeText={(t) => {
            setEmail(t);
            clearBannerAndField("email");
          }}
          placeholder="name@example.com"
          keyboardType="email-address"
          errorText={fieldErrors.email}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("email")}
        />

        <PasswordField
          ref={register("password")}
          value={password}
          onChangeText={(t) => {
            setPassword(t);
            clearBannerAndField("password");
          }}
          errorText={fieldErrors.password}
          editable={!loading}
          returnKeyType="done"
          onSubmitEditing={onSubmit}
        />

        <AuthButton
          title={loading ? "Creating‚Ä¶" : "Create account"}
          loading={loading}
          disabled={!canSubmit}
          onPress={onSubmit}
        />

        <View style={authStyles.linkRow}>
          <Text style={authStyles.linkText}>Already have an account?</Text>
          <Link href="/(auth)/login" style={authStyles.linkBtn}>
            Sign in
          </Link>
        </View>
      </ScrollView>
    </View>
  );
}
</file>

<file path="app/manage-skills-to-learn/AddSkillToLearnForm.tsx">
// app/manage-skills-to-learn/AddSkillToLearnForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { LEARN_LEVELS, LearnLevel } from "./types";

type Props = {
  onAdd: (name: string, level?: LearnLevel) => Promise<void> | void;
  onAddFavorite: (name: string, level?: LearnLevel) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

const AddSkillToLearnForm: React.FC<Props> = ({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}) => {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. React Native, Guitar, Public speaking";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    // slightly smarter: startsWith first, then includes
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) {
        await onAddFavorite(normalizedValue, selectedLevel);
      } else {
        await onAdd(normalizedValue, selectedLevel);
      }
      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      // keep local errors minimal; backend errors already appear in screen error box
      console.log("AddSkillToLearnForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Type a skill you want to learn, choose the level, then add it to your
        list.
      </Text>

      {/* Level selection */}
      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {LEARN_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      {/* Input */}
      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>

        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      {/* Actions */}
      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {/* Suggestions */}
      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
                accessibilityHint="Fills the input with this suggestion"
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
};

export default AddSkillToLearnForm;

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },

  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
  },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },

  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },

  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },

  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  levelPillText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "800",
  },
  levelPillTextActive: {
    color: "#ffffff",
  },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: {
    fontSize: 12,
    fontWeight: "800",
    color: "#2563eb",
  },

  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: {
    borderColor: "#fca5a5",
    backgroundColor: "#fff1f2",
  },

  errorText: {
    fontSize: 12,
    color: "#b91c1c",
    marginTop: 6,
  },

  buttonsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
  },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: {
    backgroundColor: "#2563eb",
  },
  primaryButtonText: {
    color: "#f9fafb",
    fontSize: 13,
    fontWeight: "900",
  },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: {
    color: "#374151",
    fontSize: 13,
    fontWeight: "800",
  },

  suggestionsSection: {
    marginTop: 12,
  },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: {
    fontSize: 12,
    color: "#6b7280",
    fontWeight: "800",
  },
  suggestionsHint: {
    fontSize: 11,
    color: "#9ca3af",
    fontWeight: "700",
  },
  suggestionsRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/CategorySelector.tsx">
// app/manage-skills-to-learn/CategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SKILL_CATEGORIES, SkillCategory } from "./skillData";

export type CategorySelectorProps = {
  selectedCategoryId: string | null;
  onSelect: (id: string) => void;
};

const CategorySelector: React.FC<CategorySelectorProps> = ({
  selectedCategoryId,
  onSelect,
}) => {
  return (
    <View style={styles.container}>
      <Text style={styles.label}>Category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        {SKILL_CATEGORIES.map((cat: SkillCategory) => {
          const isActive = cat.id === selectedCategoryId;
          return (
            <TouchableOpacity
              key={cat.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(cat.id)}
              activeOpacity={0.8}
            >
              <Text style={styles.chipEmoji}>{cat.icon}</Text>
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {cat.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

export default CategorySelector;

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#1d4ed8",
  },
  chipEmoji: {
    fontSize: 16,
    marginRight: 6,
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "500",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/index.tsx">
// app/manage-skills-to-learn/index.tsx
import React from "react";
import ManageSkillsToLearnScreen from "./ManageSkillsToLearnScreen";

export default function ManageSkillsToLearnRoute() {
  return <ManageSkillsToLearnScreen />;
}
</file>

<file path="app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx">
// app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import AddSkillToLearnForm from "./AddSkillToLearnForm";
import CategorySelector from "./CategorySelector";
import { SkillSubCategory } from "./skillData";
import { SkillsToLearnList } from "./SkillsToLearnList";
import { SubCategorySelector } from "./SubCategorySelector";
import SuggestedSkillsGrid from "./SuggestedSkillsGrid";
import { LEARN_LEVELS, LearnLevel, SkillToLearn } from "./types";
import { useManageSkillsToLearn } from "./useManageSkillsToLearn";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Public speaking",
  "Time management",
  "English conversation",
  "Excel / Google Sheets",
  "Problem solving",
  "Presentation design",
];

type FilterMode = "all" | "favorites" | "recent";

// Quick Start (shown once)
const QUICK_START_KEY = "skillsToLearn_quickStartSeen_v1";

// Toast
type ToastType = "success" | "error" | "info";
type ToastState = {
  visible: boolean;
  message: string;
  type: ToastType;
};

// Bottom Sheet modes
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToLearnScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,

    hasPendingSync, // (22)

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart, // (12)
    updateSkillLevel, // (11)
    trySyncPending, // (22)

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToLearn();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  // Quick Start
  const [showQuickStart, setShowQuickStart] = useState(false);

  // Toast
  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Bottom sheet (modal)
  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  // (12) when duplicate happens, we store the existing skill
  const [duplicateExisting, setDuplicateExisting] =
    useState<SkillToLearn | null>(null);

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name} ‚Üí ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  // Global search placeholder
  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Python, Algorithms...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Academic writing...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing basics...";
    return "Search or add: React Native, Guitar, Public speaking...";
  }, [selectedCategory]);

  // Visible skills (filters)
  const visibleSkills = useMemo(() => {
    let base: SkillToLearn[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  // Step state
  const isStep1Active = !selectedCategoryId;
  const isStep2Active = !!selectedCategoryId && !selectedSubCategoryId;
  const isStep3Active =
    (!!selectedCategoryId && !!selectedSubCategoryId) || skills.length > 0;

  // Progressive disclosure rules (2)
  const showRecommended = !selectedCategoryId;
  const showDiscoverSection = true;
  const showYourListSection = skills.length > 0 || !!selectedCategoryId;

  // Quick Start load (3)
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const seen = await AsyncStorage.getItem(QUICK_START_KEY);
        if (!mounted) return;
        if (!seen && skills.length === 0) setShowQuickStart(true);
      } catch {
        // ignore
      }
    })();
    return () => {
      mounted = false;
    };
  }, [skills.length]);

  const dismissQuickStart = async () => {
    setShowQuickStart(false);
    try {
      await AsyncStorage.setItem(QUICK_START_KEY, "1");
    } catch {
      // ignore
    }
  };

  // Toast helper (4)
  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  // Sync pending when screen loads (22)
  useEffect(() => {
    // try once on mount (safe even if no pending)
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ----- Add handlers -----
  const handleAddSkillBase = async (name: string, level?: LearnLevel) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (
    name: string,
    level?: LearnLevel
  ) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) ‚òÖ`);
    setFilterMode("all");
    setSearchQuery("");
  };

  // Clear all confirm
  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your learning list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  // Category selection
  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
    showToast("Category selected", "info");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  // ---------- Bottom Sheet logic (9 + 10 + 11 + 12) ----------
  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  // (11) open edit level sheet
  const openEditLevelSheet = (skill: SkillToLearn) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    // ----- QUICK ADD -----
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      // (12) smart add
      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        // show duplicate UI: offer edit level
        setDuplicateExisting(res.existing);
        showToast("Skill already exists ‚Äî edit its level?", "info");
        // switch to edit mode but keep modal open
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- SUGGESTED ADD -----
    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list ‚Äî edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- ADD ALL SUGGESTED -----
    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;

      // add all; duplicates will be skipped silently using addSkill
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      setFilterMode("all");
      setSearchQuery("");
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      closeSheet();
      return;
    }

    // ----- EDIT LEVEL (11) -----
    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };
  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills) {
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;
    }
    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }

    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  // loading
  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  // (20) stats

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {/* Toast */}
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}>‚Üê Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you want to learn</Text>
        <Text style={styles.subtitle}>
          Choose a category then add skills with the right level for better
          matching.
        </Text>

        {/* Pending sync indicator (22) */}
        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
              ‚è≥ Saved locally ‚Äî syncing when online
            </Text>
          </View>
        )}

        {/* Global Search */}
        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}>üîé Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your learning list.
          </Text>
        </View>

        {/* Steps */}
        <View style={styles.stepsRow}>
          <View
            style={[styles.stepPill, isStep1Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>1</Text>
            <Text style={styles.stepPillText}>Category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep2Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>2</Text>
            <Text style={styles.stepPillText}>Sub-category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep3Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>3</Text>
            <Text style={styles.stepPillText}>Your list</Text>
          </View>
        </View>

        {/* Quick Start */}
        {showQuickStart && (
          <View style={styles.quickStartCard}>
            <View style={styles.quickStartHeader}>
              <Text style={styles.quickStartTitle}>üöÄ Quick start</Text>
              <TouchableOpacity onPress={dismissQuickStart} activeOpacity={0.8}>
                <Text style={styles.quickStartDismiss}>Got it</Text>
              </TouchableOpacity>
            </View>

            <Text style={styles.quickStartText}>
              1) Pick a category {"\n"}
              2) Tap a suggested skill {"\n"}
              3) Choose your level and add
            </Text>
          </View>
        )}

        {/* Error box */}
        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops‚Ä¶</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        {/* Category */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>üß≠ 1. Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>You‚Äôre exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        {/* Discover */}
        {showDiscoverSection && (
          <>
            <Text style={styles.mainSectionTitle}>
              üîç 2. Discover skills to add
            </Text>

            <SuggestedSkillsGrid
              title={
                selectedCategory
                  ? `Popular in ${selectedCategory.name}`
                  : "Suggested skills"
              }
              description="Tap a skill to choose its level and add it."
              skills={suggestedSkillsByCategory}
              onAdd={(name) => openSuggestedAddSheet(name)}
              onAddAll={
                suggestedSkillsByCategory.length ? openAddAllSheet : undefined
              }
              existingSkills={skills.map((s) => s.name)}
              favoriteSkills={favoriteSkills}
              disableAddAll={saving || !suggestedSkillsByCategory.length}
            />

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Recommended skills for most people"
                description="Useful across many careers."
                skills={recommendedSkills}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Popular among SkillSwap learners"
                description="Skills many people are currently focusing on."
                skills={GLOBAL_POPULAR_SKILLS}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}
          </>
        )}

        {/* Add form (still available) */}
        <AddSkillToLearnForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        {/* Your list */}
        {showYourListSection && (
          <>
            <Text style={styles.mainSectionTitle}>
              üìå 3. Your learning list
            </Text>

            {/* (20) Stats */}
            <View style={styles.statsCard}>
              <Text style={styles.statsText}>
                {stats.total} skills ‚Ä¢ {stats.fav} favorites
                {stats.topLevel ? ` ‚Ä¢ Top level: ${stats.topLevel}` : ""}
              </Text>
              <Text style={styles.statsHint}>
                Tip: to edit a level, open ‚ÄúAdd‚Äù and type the same skill name.
              </Text>
            </View>

            <Text style={styles.recentHint}>
              Recent = your last 6 added skills.
            </Text>

            {skills.length === 0 ? (
              <View style={styles.emptyStateCard}>
                <Text style={styles.emptyStateTitle}>No skills yet</Text>
                <Text style={styles.emptyStateText}>
                  Start by picking a category above, or tap + to add a custom
                  skill quickly.
                </Text>

                <View style={styles.emptyStateButtons}>
                  <TouchableOpacity
                    style={styles.emptyPrimaryBtn}
                    onPress={() =>
                      showToast("Pick a category above üëÜ", "info")
                    }
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptyPrimaryText}>Pick a category</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.emptySecondaryBtn}
                    onPress={openQuickAddSheet}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptySecondaryText}>
                      Add custom skill
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            ) : (
              <SkillsToLearnList
                skills={visibleSkills}
                totalCount={skills.length}
                searchQuery={searchQuery}
                onChangeSearchQuery={setSearchQuery}
                onRemove={removeSkill}
                favoriteSkills={favoriteSkills}
                onToggleFavorite={toggleFavorite}
                onClearAll={handleClearAllWithConfirm}
                filterMode={filterMode}
                onChangeFilter={setFilterMode}
              />
            )}
          </>
        )}

        {/* Undo bar */}
        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      {/* FAB */}
      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}>Ôºã</Text>
      </TouchableOpacity>

      {/* Bottom Sheet modal */}
      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {/* Duplicate helper card (12) */}
          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name} ¬∑ {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press ‚ÄúSave‚Äù.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. React Native"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {LEARN_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: You can also add from the main form below.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },

  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },

  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },

  title: { fontSize: 24, fontWeight: "700", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: {
    fontSize: 12,
    color: "#9a3412",
    fontWeight: "700",
  },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "600", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  stepsRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 12,
    gap: 8,
  },
  stepPill: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  stepPillActive: { backgroundColor: "#2563eb" },
  stepPillNumber: {
    fontSize: 12,
    fontWeight: "700",
    color: "#111827",
    marginRight: 4,
  },
  stepPillText: { fontSize: 12, color: "#111827", fontWeight: "500" },

  quickStartCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  quickStartHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  quickStartTitle: { fontSize: 14, fontWeight: "700", color: "#111827" },
  quickStartDismiss: { fontSize: 12, fontWeight: "600", color: "#2563eb" },
  quickStartText: { fontSize: 12, color: "#4b5563", lineHeight: 18 },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "600",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "800" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  recentHint: { fontSize: 11, color: "#6b7280", marginBottom: 8 },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "700", color: "#2563eb" },

  emptyStateCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  emptyStateTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },
  emptyStateText: { marginTop: 6, fontSize: 13, color: "#6b7280" },
  emptyStateButtons: {
    marginTop: 12,
    flexDirection: "row",
    gap: 8,
  },
  emptyPrimaryBtn: {
    flex: 1,
    backgroundColor: "#2563eb",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
  },
  emptyPrimaryText: { color: "#ffffff", fontWeight: "700", fontSize: 13 },
  emptySecondaryBtn: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    backgroundColor: "#f9fafb",
  },
  emptySecondaryText: { color: "#374151", fontWeight: "700", fontSize: 13 },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "600" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "700" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "800", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-learn/SkillChip.tsx">
// app/manage-skills-to-learn/SkillChip.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label: string;
  onPress: () => void;
  compact?: boolean;

  disabled?: boolean;
  added?: boolean;

  showPlusIcon?: boolean;
  isFavorite?: boolean;

  // (24) accessibility extras
  accessibilityHint?: string;
};

export function SkillChip({
  label,
  onPress,
  compact = false,
  disabled = false,
  added = false,
  showPlusIcon = false,
  isFavorite = false,
  accessibilityHint,
}: Props) {
  const showPlus = showPlusIcon && !added;
  const showCheck = added;

  const badgeText = showCheck ? "‚úì" : showPlus ? "Ôºã" : "";
  const badgeLabel = showCheck ? "Added" : showPlus ? "Add" : "";

  return (
    <TouchableOpacity
      onPress={disabled ? () => {} : onPress}
      activeOpacity={disabled ? 1 : 0.85}
      disabled={disabled}
      style={[
        styles.chip,
        compact && styles.chipCompact,
        disabled && styles.chipDisabled,
        added && styles.chipAdded,
      ]}
      accessibilityRole="button"
      accessibilityLabel={label}
      accessibilityHint={
        accessibilityHint ||
        (disabled ? "This item is disabled." : "Tap to select this skill.")
      }
      hitSlop={{ top: 6, bottom: 6, left: 6, right: 6 }}
    >
      <View style={styles.row}>
        {/* Left badge (Ôºã / ‚úì) */}
        {(showPlus || showCheck) && (
          <View
            style={[
              styles.badge,
              showCheck && styles.badgeCheck,
              showPlus && styles.badgePlus,
            ]}
            accessibilityLabel={badgeLabel}
          >
            <Text style={styles.badgeText}>{badgeText}</Text>
          </View>
        )}

        {/* Favorite star */}
        {isFavorite && (
          <Text style={styles.star} accessibilityLabel="Favorite">
            ‚òÖ
          </Text>
        )}

        <Text
          style={[styles.label, disabled && styles.labelDisabled]}
          numberOfLines={1}
        >
          {label}
        </Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  chip: {
    alignSelf: "flex-start",
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipCompact: {
    paddingHorizontal: 10,
    paddingVertical: 7,
  },
  chipDisabled: {
    opacity: 0.62,
  },
  chipAdded: {
    backgroundColor: "#dcfce7",
    borderColor: "#86efac",
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },

  badge: {
    width: 18,
    height: 18,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  badgeCheck: {
    backgroundColor: "#16a34a",
    borderColor: "#16a34a",
  },
  badgePlus: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  badgeText: {
    fontSize: 12,
    color: "#ffffff",
    fontWeight: "900",
    lineHeight: 14,
  },

  star: {
    fontSize: 14,
    color: "#f59e0b",
    fontWeight: "900",
    marginRight: 2,
  },

  label: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "600",
    maxWidth: 240,
  },
  labelDisabled: {
    color: "#6b7280",
  },
});
</file>

<file path="app/manage-skills-to-learn/skillData.ts">
// app/manage-skills-to-learn/skillData.ts

export type SkillSubCategory = {
  id: string;
  name: string;
  skills: string[];
};

export type SkillCategory = {
  id: string;
  name: string;
  icon: string; // ‚úÖ FIX
  subCategories: SkillSubCategory[];
};

export const SKILL_CATEGORIES: SkillCategory[] = [
  {
    id: "programming",
    name: "Programming",
    icon: "üíª",
    subCategories: [
      {
        id: "frontend",
        name: "Frontend",
        skills: ["HTML", "CSS", "JavaScript", "React", "TypeScript"],
      },
      {
        id: "backend",
        name: "Backend",
        skills: ["Node.js", "Express", "MongoDB", "SQL"],
      },
    ],
  },
  {
    id: "languages",
    name: "Languages",
    icon: "üó£Ô∏è",
    subCategories: [
      {
        id: "spoken",
        name: "Spoken",
        skills: ["English", "Hebrew", "Arabic", "Spanish"],
      },
    ],
  },
];

export const RECOMMENDED_SKILLS = ["Public speaking", "Time management", "Problem solving"];

export const ALL_KNOWN_SKILLS = Array.from(
  new Set(SKILL_CATEGORIES.flatMap((c) => c.subCategories.flatMap((s) => s.skills)))
);
</file>

<file path="app/manage-skills-to-learn/SkillsToLearnList.tsx">
// app/manage-skills-to-learn/SkillsToLearnList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { SkillToLearn } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillToLearn[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  // ‚úÖ FIX: now matches the hook perfectly
  onRemove: (skill: SkillToLearn) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;
  onClearAll: () => void;
  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;
  onLayoutCard?: (y: number) => void;
};

export const SkillsToLearnList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "‚úî";
    if (mode === "favorites") return "‚òÖ";
    return "‚è±";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your learning list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your learning skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You don‚Äôt have any learning skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <SkillChip
                  label={`${skill.name} ¬∑ ${skill.level}`}
                  onPress={() => {}}
                />

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                  >
                    <Text style={styles.favoriteText}>{fav ? "‚òÖ" : "‚òÜ"}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)} // ‚úÖ FIX: remove by object
                    style={styles.removeButton}
                  >
                    <Text style={styles.removeIcon}>üóë</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity style={styles.clearAllButton} onPress={onClearAll}>
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: {
    flexDirection: "row",
    gap: 6,
    marginBottom: 8,
  },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  filterChipText: {
    fontSize: 12,
    color: "#374151",
  },
  filterChipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: {
    fontSize: 13,
    color: "#6b7280",
  },
  skillsWrap: {
    gap: 8,
  },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: {
    paddingHorizontal: 6,
    paddingVertical: 4,
  },
  favoriteText: {
    fontSize: 16,
    color: "#f59e0b",
  },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: {
    fontSize: 13,
  },
  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: {
    fontSize: 12,
    color: "#374151",
  },
});
</file>

<file path="app/manage-skills-to-learn/styles.ts">

</file>

<file path="app/manage-skills-to-learn/SubCategorySelector.tsx">
// app/manage-skills-to-learn/SubCategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillSubCategory } from "./skillData";

type Props = {
  subCategories: SkillSubCategory[];
  selectedSubCategoryId: string | null;
  onSelect: (id: string | null) => void;
};

export const SubCategorySelector: React.FC<Props> = ({
  subCategories,
  selectedSubCategoryId,
  onSelect,
}) => {
  if (!subCategories.length) return null;

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Sub-category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        <TouchableOpacity
          style={[
            styles.chip,
            selectedSubCategoryId === null && styles.chipActive,
          ]}
          onPress={() => onSelect(null)}
        >
          <Text
            style={[
              styles.chipText,
              selectedSubCategoryId === null && styles.chipTextActive,
            ]}
          >
            All
          </Text>
        </TouchableOpacity>

        {subCategories.map((sub) => {
          const isActive = sub.id === selectedSubCategoryId;
          return (
            <TouchableOpacity
              key={sub.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(sub.id)}
              activeOpacity={0.8}
            >
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {sub.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#1d4ed8",
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/SuggestedSkillsGrid.tsx">
// app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { SkillChip } from "./SkillChip";

type Props = {
  title: string;
  description?: string;
  skills: string[];
  onAdd: (name: string) => void;
  onAddAll?: () => void;
  existingSkills: string[]; // names only
  favoriteSkills: string[]; // names only
  disableAddAll?: boolean;
};

export default function SuggestedSkillsGrid({
  title,
  description,
  skills,
  onAdd,
  onAddAll,
  existingSkills,
  favoriteSkills,
  disableAddAll = false,
}: Props) {
  const existingLower = new Set(existingSkills.map((s) => s.toLowerCase()));
  const favLower = new Set(favoriteSkills.map((s) => s.toLowerCase()));

  if (!skills?.length) return null;

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>{title}</Text>
          {!!description && <Text style={styles.desc}>{description}</Text>}
        </View>

        {!!onAddAll && (
          <TouchableOpacity
            onPress={disableAddAll ? () => {} : onAddAll}
            activeOpacity={disableAddAll ? 1 : 0.8}
            style={[styles.addAllBtn, disableAddAll && { opacity: 0.5 }]}
            disabled={disableAddAll}
          >
            <Text style={styles.addAllText}>Add all</Text>
          </TouchableOpacity>
        )}
      </View>

      <View style={styles.wrap}>
        {skills.map((name) => {
          const added = existingLower.has(name.toLowerCase());
          const isFav = favLower.has(name.toLowerCase());

          // ‚úÖ ŸÖŸáŸÖ: SkillChip ŸÑÿßÿ≤ŸÖ onPress ÿØÿßŸäŸÖŸãÿß
          const handlePress = added ? () => {} : () => onAdd(name);

          return (
            <SkillChip
              key={name}
              label={name}
              onPress={handlePress}
              compact
              disabled={added}
              added={added}
              showPlusIcon={!added}
              isFavorite={isFav}
            />
          );
        })}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 10,
  },
  title: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
  },
  desc: {
    marginTop: 4,
    fontSize: 12,
    color: "#6b7280",
  },
  addAllBtn: {
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 6,
    backgroundColor: "#f9fafb",
  },
  addAllText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "600",
  },
  wrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/types.ts">
// app/manage-skills-to-learn/types.ts

export const LEARN_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type LearnLevel = (typeof LEARN_LEVELS)[number];

export type SkillToLearn = {
  name: string;
  level: LearnLevel;
};

export type UndoState = {
  skill: SkillToLearn;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-learn/useManageSkillsToLearn.ts">
// app/manage-skills-to-learn/useManageSkillsToLearn.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "./skillData";
import { LEARN_LEVELS, LearnLevel, SkillToLearn, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToLearnFavorites";

// (22) offline pending sync
const PENDING_SKILLS_KEY = "skillsToLearn_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillToLearn }
  | { ok: false; existed: true; existing: SkillToLearn }
  | { ok: false; existed: false; error: string };

// normalize level
function normalizeLearnLevel(raw?: string | null): LearnLevel {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = LEARN_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToLearn() {
  const [skills, setSkills] = useState<SkillToLearn[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  // (22) indicates we have unsynced local changes
  const [hasPendingSync, setHasPendingSync] = useState(false);

  // category / subcategory
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  // ---------- helpers ----------
  function findExistingSkill(name: string): SkillToLearn | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  // (22) store pending local changes when backend update fails
  async function savePendingSkills(next: SkillToLearn[]) {
    try {
      await AsyncStorage.setItem(PENDING_SKILLS_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePendingSkills error:", e);
    }
  }

  async function clearPendingSkills() {
    try {
      await AsyncStorage.removeItem(PENDING_SKILLS_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPendingSkills error:", e);
    }
  }

  async function loadPendingSkills(): Promise<SkillToLearn[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillToLearn[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return {
            name,
            level: normalizeLearnLevel(item.level),
          } as SkillToLearn;
        })
        .filter(Boolean) as SkillToLearn[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPendingSkills error:", e);
      return null;
    }
  }

  // (22) try to sync pending changes to backend
  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPendingSkills();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      // if there are pending changes, push them
      await updateProfile(token, { skillsToLearn: pending });
      await clearPendingSkills();

      // make sure local state matches pending
      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e: any) {
      // stay pending
      console.log("trySyncPending error:", e);
      setHasPendingSync(true);
    }
  }

  // ---- load from backend + favorites local ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        // (22) attempt sync pending first
        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        // NOTE: backend old format could be string[] OR new format object[]
        const raw = Array.isArray(userFromApi?.skillsToLearn)
          ? userFromApi.skillsToLearn
          : [];

        const cleanSkills: SkillToLearn[] = raw
          .map((item: any) => {
            // string -> object
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as LearnLevel };
            }

            // object -> normalize
            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLearnLevel(item.level),
              } as SkillToLearn;
            }

            return null;
          })
          .filter(Boolean) as SkillToLearn[];

        // sort by name
        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        // favorites local
        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        // pending indicator
        const pending = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToLearn load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load learning skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  // ---- persist skills to backend ----
  async function persistSkills(next: SkillToLearn[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, {
        skillsToLearn: next,
      });

      // if this succeeds, clear pending
      await clearPendingSkills();
    } catch (e: any) {
      console.log("updateProfile(skillsToLearn) error:", e);

      // (22) store pending changes locally
      await savePendingSkills(next);

      setError(
        e?.message ||
          "Failed to save learning skills. Your changes are saved locally and will sync when you're back online."
      );
    } finally {
      setSaving(false);
    }
  }

  // ---- persist favorites local ----
  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites learn error:", e);
    }
  }

  // ---- add skill (kept the same signature: boolean) ----
  async function addSkill(name: string, level?: LearnLevel): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  // ---- (12) add skill smart: tells you if it exists and returns existing skill ----
  async function addSkillSmart(
    name: string,
    level?: LearnLevel
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      // don't set as a hard error; this is a "smart" signal
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  // ---- (11) update level for an existing skill ----
  async function updateSkillLevel(
    name: string,
    newLevel: LearnLevel
  ): Promise<boolean> {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalizedLevel = normalizeLearnLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalizedLevel) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalizedLevel };

    // keep alphabetical order stable
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  // ---- remove skill (accept SkillToLearn object) ----
  async function removeSkill(skill: SkillToLearn) {
    const skillName = skill.name;

    const index = skills.findIndex((s) => sameName(s.name, skillName));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    // remove from favorites if needed
    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  // ---- clear all ----
  async function clearAllSkills() {
    const next: SkillToLearn[] = [];
    setSkills(next);
    setLastRemoved(null);

    await persistFavorites([]);
    await persistSkills(next);
  }

  // ---- undo remove ----
  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);

    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  // ---- toggle favorite ----
  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));

    let next: string[];
    if (exists) {
      next = favoriteSkills.filter((f) => !sameName(f, name));
    } else {
      next = [...favoriteSkills, name];
    }

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---- category helpers ----
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  // ---- filtered + sorted (favorites first) ----
  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();

    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync, // (22)

    // category stuff
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill, // keep old
    addSkillSmart, // (12) new
    updateSkillLevel, // (11) new
    trySyncPending, // (22) new

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/manage-skills-to-teach/AddSkillToTeachForm.tsx">
// app/manage-skills-to-teach/AddSkillToTeachForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { Level, TEACH_LEVELS } from "./types";

type Props = {
  onAdd: (name: string, level?: Level) => Promise<void> | void;
  onAddFavorite: (name: string, level?: Level) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

export default function AddSkillToTeachForm({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}: Props) {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] = useState<Level>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. Math tutoring, React, Guitar";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) await onAddFavorite(normalizedValue, selectedLevel);
      else await onAdd(normalizedValue, selectedLevel);

      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      console.log("AddSkillToTeachForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom teaching skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Add what you can teach and choose your level.
      </Text>

      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {TEACH_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>
        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: { fontSize: 15, fontWeight: "800", color: "#111827" },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },
  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },
  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },
  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "800" },
  levelPillTextActive: { color: "#ffffff" },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: { fontSize: 12, fontWeight: "800", color: "#2563eb" },
  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: { borderColor: "#fca5a5", backgroundColor: "#fff1f2" },
  errorText: { fontSize: 12, color: "#b91c1c", marginTop: 6 },

  buttonsRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: { backgroundColor: "#2563eb" },
  primaryButtonText: { color: "#f9fafb", fontSize: 13, fontWeight: "900" },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: { color: "#374151", fontSize: 13, fontWeight: "800" },

  suggestionsSection: { marginTop: 12 },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: { fontSize: 12, color: "#6b7280", fontWeight: "800" },
  suggestionsHint: { fontSize: 11, color: "#9ca3af", fontWeight: "700" },
  suggestionsRow: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
});
</file>

<file path="app/manage-skills-to-teach/index.tsx">
// app/manage-skills-to-teach/index.tsx
import React from "react";
import ManageSkillsToTeachScreen from "./ManageSkillsToTeachScreen";

export default function ManageSkillsToTeachRoute() {
  return <ManageSkillsToTeachScreen />;
}
</file>

<file path="app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx">
// app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

// ‚úÖ reuse learn components
import CategorySelector from "../manage-skills-to-learn/CategorySelector";
import { SubCategorySelector } from "../manage-skills-to-learn/SubCategorySelector";
import SuggestedSkillsGrid from "../manage-skills-to-learn/SuggestedSkillsGrid";
import { SkillSubCategory } from "../manage-skills-to-learn/skillData";

import AddSkillToTeachForm from "./AddSkillToTeachForm";
import { SkillsToTeachList } from "./SkillsToTeachList";
import { Level, SkillTeach, TEACH_LEVELS } from "./types";
import { useManageSkillsToTeach } from "./useManageSkillsToTeach";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Math tutoring",
  "English conversation",
  "React",
  "Node.js",
  "UI/UX basics",
  "Public speaking",
];

type FilterMode = "all" | "favorites" | "recent";
type ToastType = "success" | "error" | "info";
type ToastState = { visible: boolean; message: string; type: ToastType };
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToTeachScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToTeach();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<Level>("Intermediate");

  const [duplicateExisting, setDuplicateExisting] = useState<SkillTeach | null>(
    null
  );

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name} ‚Üí ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Node.js, Data structures...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Hebrew, Arabic...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing...";
    return "Search or add: Math tutoring, Guitar, Public speaking...";
  }, [selectedCategory]);

  const visibleSkills = useMemo(() => {
    let base: SkillTeach[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills)
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;

    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }
    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  useEffect(() => {
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleAddSkillBase = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) ‚òÖ`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your teaching list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openEditLevelSheet = (skill: SkillTeach) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Skill already exists ‚Äî edit its level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list ‚Äî edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      setFilterMode("all");
      setSearchQuery("");
      closeSheet();
      return;
    }

    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };

  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  const showRecommended = !selectedCategoryId;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}>‚Üê Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you can teach</Text>
        <Text style={styles.subtitle}>
          Add what you can teach with the right level for better matching.
        </Text>

        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
              ‚è≥ Saved locally ‚Äî syncing when online
            </Text>
          </View>
        )}

        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}>üîé Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your teaching list.
          </Text>
        </View>

        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops‚Ä¶</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        <View style={styles.card}>
          <Text style={styles.sectionTitle}>üß≠ Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>You‚Äôre exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        <Text style={styles.mainSectionTitle}>üîç Discover skills to add</Text>

        <SuggestedSkillsGrid
          title={
            selectedCategory
              ? `Popular in ${selectedCategory.name}`
              : "Suggested skills"
          }
          description="Tap a skill to choose its level and add it."
          skills={suggestedSkillsByCategory}
          onAdd={(name) => openSuggestedAddSheet(name)}
          onAddAll={
            suggestedSkillsByCategory.length ? openAddAllSheet : undefined
          }
          existingSkills={skills.map((s) => s.name)}
          favoriteSkills={favoriteSkills}
          disableAddAll={saving || !suggestedSkillsByCategory.length}
        />

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Recommended skills for most people"
            description="Useful across many careers."
            skills={recommendedSkills}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Popular among SkillSwap mentors"
            description="Skills many mentors are currently teaching."
            skills={GLOBAL_POPULAR_SKILLS}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        <AddSkillToTeachForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        <Text style={styles.mainSectionTitle}>üìå Your teaching list</Text>

        <View style={styles.statsCard}>
          <Text style={styles.statsText}>
            {stats.total} skills ‚Ä¢ {stats.fav} favorites
            {stats.topLevel ? ` ‚Ä¢ Top level: ${stats.topLevel}` : ""}
          </Text>
          <Text style={styles.statsHint}>Tap a skill to edit its level.</Text>
        </View>

        <SkillsToTeachList
          skills={visibleSkills}
          totalCount={skills.length}
          searchQuery={searchQuery}
          onChangeSearchQuery={setSearchQuery}
          onRemove={removeSkill}
          favoriteSkills={favoriteSkills}
          onToggleFavorite={toggleFavorite}
          onClearAll={handleClearAllWithConfirm}
          filterMode={filterMode}
          onChangeFilter={setFilterMode}
          onEditLevel={openEditLevelSheet}
        />

        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}>Ôºã</Text>
      </TouchableOpacity>

      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name} ¬∑ {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press ‚ÄúSave‚Äù.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. Math tutoring"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {TEACH_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: Tap a skill in the list to edit level.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },
  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },
  title: { fontSize: 24, fontWeight: "800", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: { fontSize: 12, color: "#9a3412", fontWeight: "800" },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "700", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "700",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "900" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "900", color: "#2563eb" },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "700" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "900", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "800",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "900" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "900", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-teach/SkillsToTeachList.tsx">
// app/manage-skills-to-teach/SkillsToTeachList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { SkillTeach } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillTeach[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  onRemove: (skill: SkillTeach) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;

  onClearAll: () => void;

  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;

  // ‚úÖ optional: for edit level from list (we'll use it)
  onEditLevel?: (skill: SkillTeach) => void;

  onLayoutCard?: (y: number) => void;
};

export const SkillsToTeachList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onEditLevel,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "‚úî";
    if (mode === "favorites") return "‚òÖ";
    return "‚è±";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
        activeOpacity={0.85}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your teaching list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your teaching skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You don‚Äôt have any teaching skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <TouchableOpacity
                  activeOpacity={0.85}
                  onPress={() => onEditLevel?.(skill)}
                  disabled={!onEditLevel}
                >
                  <SkillChip
                    label={`${skill.name} ¬∑ ${skill.level}`}
                    onPress={() => onEditLevel?.(skill)}
                    disabled={!onEditLevel}
                  />
                </TouchableOpacity>

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.favoriteText}>{fav ? "‚òÖ" : "‚òÜ"}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)}
                    style={styles.removeButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.removeIcon}>üóë</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity
          style={styles.clearAllButton}
          onPress={onClearAll}
          activeOpacity={0.85}
        >
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: { flexDirection: "row", gap: 6, marginBottom: 8 },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  filterChipText: { fontSize: 12, color: "#374151" },
  filterChipTextActive: { color: "#ffffff", fontWeight: "700" },

  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: { fontSize: 13, color: "#6b7280" },

  skillsWrap: { gap: 8 },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: { paddingHorizontal: 6, paddingVertical: 4 },
  favoriteText: { fontSize: 16, color: "#f59e0b" },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: { fontSize: 13 },

  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: { fontSize: 12, color: "#374151", fontWeight: "700" },
});
</file>

<file path="app/manage-skills-to-teach/types.ts">
// app/manage-skills-to-teach/types.ts

export const TEACH_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type Level = (typeof TEACH_LEVELS)[number];

export type SkillTeach = {
  name: string;
  level: Level;
};

export type UndoState = {
  skill: SkillTeach;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-teach/useManageSkillsToTeach.ts">
// app/manage-skills-to-teach/useManageSkillsToTeach.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";

// ‚úÖ reuse learn data + categories
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "../manage-skills-to-learn/skillData";

import { Level, SkillTeach, TEACH_LEVELS, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToTeachFavorites";
const PENDING_KEY = "skillsToTeach_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillTeach }
  | { ok: false; existed: true; existing: SkillTeach }
  | { ok: false; existed: false; error: string };

function normalizeLevel(raw?: string | null): Level {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = TEACH_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToTeach() {
  const [skills, setSkills] = useState<SkillTeach[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  const [hasPendingSync, setHasPendingSync] = useState(false);

  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  function findExistingSkill(name: string): SkillTeach | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  async function savePending(next: SkillTeach[]) {
    try {
      await AsyncStorage.setItem(PENDING_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePending teach error:", e);
    }
  }

  async function clearPending() {
    try {
      await AsyncStorage.removeItem(PENDING_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPending teach error:", e);
    }
  }

  async function loadPending(): Promise<SkillTeach[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_KEY);
      if (!raw) return null;

      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillTeach[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return { name, level: normalizeLevel(item.level) } as SkillTeach;
        })
        .filter(Boolean) as SkillTeach[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPending teach error:", e);
      return null;
    }
  }

  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPending();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      await updateProfile(token, { skillsToTeach: pending });
      await clearPending();

      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e) {
      console.log("trySyncPending teach error:", e);
      setHasPendingSync(true);
    }
  }

  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        const raw = Array.isArray(userFromApi?.skillsToTeach)
          ? userFromApi.skillsToTeach
          : [];

        const cleanSkills: SkillTeach[] = raw
          .map((item: any) => {
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as Level };
            }

            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLevel(item.level),
              } as SkillTeach;
            }

            return null;
          })
          .filter(Boolean) as SkillTeach[];

        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        const pending = await AsyncStorage.getItem(PENDING_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToTeach load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load teaching skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  async function persistSkills(next: SkillTeach[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, { skillsToTeach: next });
      await clearPending();
    } catch (e: any) {
      console.log("updateProfile(skillsToTeach) error:", e);
      await savePending(next);
      setError(
        e?.message ||
          "Failed to save teaching skills. Saved locally and will sync when online."
      );
    } finally {
      setSaving(false);
    }
  }

  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites teach error:", e);
    }
  }

  async function addSkill(name: string, level?: Level): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  async function addSkillSmart(
    name: string,
    level?: Level
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  async function updateSkillLevel(name: string, newLevel: Level) {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalized = normalizeLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalized) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalized };
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  async function removeSkill(skill: SkillTeach) {
    const index = skills.findIndex((s) => sameName(s.name, skill.name));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  async function clearAllSkills() {
    const next: SkillTeach[] = [];
    setSkills(next);
    setLastRemoved(null);
    await persistFavorites([]);
    await persistSkills(next);
  }

  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));
    const next = exists
      ? favoriteSkills.filter((f) => !sameName(f, name))
      : [...favoriteSkills, name];

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---------- category helpers (reuse learn data) ----------
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();
    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    // category
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/mentor/[id].tsx">
// app/mentor/[id].tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import { getOrCreateConversation } from "../../lib/chat/api";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import {
  AvailabilitySlot,
  PublicUserProfile,
  SkillTeach,
  getPublicUserProfile,
} from "../../lib/api";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = String(name).trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function ratingText(avg?: number, count?: number) {
  const a = typeof avg === "number" ? avg : 0;
  const c = typeof count === "number" ? count : 0;
  if (c <= 0) return "No ratings yet";
  return `${a.toFixed(1)}/5 ¬∑ ${c} rating${c === 1 ? "" : "s"}`;
}

function safeArrayStrings(v: any): string[] {
  if (!Array.isArray(v)) return [];
  return v.map((x) => String(x || "").trim()).filter(Boolean);
}

type MentorVM = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

function toMentorVM(p: PublicUserProfile): MentorVM {
  return {
    id: String(p.id),
    fullName: p.fullName || "Unknown",
    points: Number(p.points || 0),
    xp: Number(p.xp || 0),
    streak: Number(p.streak || 0),
    avgRating: Number(p.avgRating || 0),
    ratingCount: Number(p.ratingCount || 0),
    skillsToTeach: Array.isArray(p.skillsToTeach)
      ? p.skillsToTeach
          .filter((s) => s && s.name)
          .map((s) => ({
            name: String(s.name).trim(),
            level: String(s.level || "Not specified").trim() || "Not specified",
          }))
      : [],
    availabilitySlots: Array.isArray(p.availabilitySlots)
      ? p.availabilitySlots
          .filter(
            (a) =>
              a &&
              typeof a.dayOfWeek === "number" &&
              a.dayOfWeek >= 0 &&
              a.dayOfWeek <= 6 &&
              a.from &&
              a.to
          )
          .map((a) => ({
            dayOfWeek: Number(a.dayOfWeek),
            from: String(a.from),
            to: String(a.to),
          }))
      : [],
    preferences: p.preferences,
  };
}

export default function MentorProfileScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();

  const mentorIdRaw = params?.id;
  const mentorId =
    typeof mentorIdRaw === "string"
      ? mentorIdRaw
      : Array.isArray(mentorIdRaw)
      ? mentorIdRaw[0]
      : "";

  const [mentor, setMentor] = useState<MentorVM | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorText, setErrorText] = useState<string | null>(null);
  const [reloadKey, setReloadKey] = useState(0);

  const loadMentor = useCallback(async () => {
    try {
      setErrorText(null);
      setLoading(true);

      if (!mentorId) {
        setErrorText("Invalid mentor id.");
        return;
      }

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const profile = await getPublicUserProfile(token, mentorId);
      setMentor(toMentorVM(profile));
    } catch (e: any) {
      setErrorText(e?.message || "Failed to load mentor profile.");
    } finally {
      setLoading(false);
    }
  }, [mentorId, router]);

  useEffect(() => {
    loadMentor();
  }, [loadMentor, reloadKey]);

  const skills = useMemo(
    () => mentor?.skillsToTeach ?? [],
    [mentor?.skillsToTeach]
  );

  const slots = useMemo(
    () =>
      (mentor?.availabilitySlots ?? [])
        .slice()
        .sort((a, b) => a.dayOfWeek - b.dayOfWeek),
    [mentor?.availabilitySlots]
  );

  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);

  const bestDay = useMemo(() => {
    if (!slots.length) return null;
    const minutesByDay = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;
      minutesByDay[d] += Math.max(
        0,
        timeToMinutes(s.to) - timeToMinutes(s.from)
      );
    }

    let bestIdx = -1;
    let bestMin = 0;
    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }
    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]} ¬∑ ${minutesToHuman(bestMin)}`;
  }, [slots]);

  const languages = safeArrayStrings(mentor?.preferences?.languages);
  const commModes = safeArrayStrings(mentor?.preferences?.communicationModes);

  const goBack = () => router.back();

  const handleRequestSession = () => {
    if (!mentor) return;

    router.push({
      pathname: "/sessions/request",
      params: {
        mentorId: mentor.id,
        mentorName: mentor.fullName,
      },
    } as any);
  };

  const handleMessage = async () => {
    try {
      if (!mentor?.id) return;

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const conversationId = await getOrCreateConversation(token, mentor.id);

      // ‚úÖ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ± ŸáŸà ÿßŸÑÿ≠ŸÑ
      if (!conversationId || typeof conversationId !== "string") {
        console.warn("Invalid conversationId, aborting chat open");
        return;
      }

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: { conversationId },
      });
    } catch (e: any) {
      console.warn("Open chat failed:", e?.message || e);
    }
  };

  if (loading && !mentor && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading mentor profile‚Ä¶</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView style={{ flex: 1 }} contentContainerStyle={styles.container}>
        <View style={styles.topRow}>
          <TouchableOpacity onPress={goBack} activeOpacity={0.85}>
            <Text style={styles.backText}>‚Üê Back</Text>
          </TouchableOpacity>

          <View style={styles.idBadge}>
            <Text style={styles.idBadgeText}>Mentor</Text>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldn‚Äôt load profile</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryBtn}
              onPress={() => setReloadKey((k) => k + 1)}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={styles.heroCard}>
          <View style={styles.heroRow}>
            <View style={styles.avatar}>
              <Text style={styles.avatarText}>
                {getInitials(mentor?.fullName)}
              </Text>
            </View>

            <View style={{ flex: 1 }}>
              <Text style={styles.heroName}>
                {mentor?.fullName || "Unknown mentor"}
              </Text>
              <Text style={styles.heroMeta}>
                ‚≠ê {ratingText(mentor?.avgRating, mentor?.ratingCount)}
              </Text>

              <View style={styles.badgesRow}>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>XP</Text>
                  <Text style={styles.badgeValue}>{mentor?.xp ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Points</Text>
                  <Text style={styles.badgeValue}>{mentor?.points ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Streak</Text>
                  <Text style={styles.badgeValue}>{mentor?.streak ?? 0}</Text>
                </View>
              </View>
            </View>
          </View>

          <View style={styles.ctaRow}>
            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaPrimary]}
              onPress={handleRequestSession}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaPrimaryText}>Request session</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaSecondary]}
              onPress={handleMessage}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaSecondaryText}>Message</Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.ctaNote}>
            (Next step: we‚Äôll connect these buttons to Sessions + Chat)
          </Text>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>What this mentor teaches</Text>
          <Text style={styles.sectionSub}>
            Skills list (clean & fast) ‚Äî ready for future filters.
          </Text>

          {skills.length ? (
            <View style={styles.skillsWrap}>
              {skills.map((s, idx) => (
                <View key={`${s.name}-${idx}`} style={styles.skillChip}>
                  <Text style={styles.skillChipText}>
                    {s.name}
                    {s.level && s.level !== "Not specified"
                      ? ` ¬∑ ${s.level}`
                      : ""}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No teaching skills listed</Text>
              <Text style={styles.emptyText}>
                This mentor hasn‚Äôt added teaching skills yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Availability</Text>
          <Text style={styles.sectionSub}>
            Total:{" "}
            <Text style={styles.sectionSubStrong}>
              {minutesToHuman(totalMin)}
            </Text>
            {bestDay ? (
              <>
                {"  "}¬∑ Best:{" "}
                <Text style={styles.sectionSubStrong}>{bestDay}</Text>
              </>
            ) : null}
          </Text>

          {slots.length ? (
            <View style={styles.availCard}>
              {slots.map((a, idx) => (
                <View
                  key={`${a.dayOfWeek}-${a.from}-${a.to}-${idx}`}
                  style={[
                    styles.availRow,
                    idx !== slots.length - 1 && styles.availRowBorder,
                  ]}
                >
                  <Text style={styles.availDay}>
                    {dayNames[a.dayOfWeek] ?? `Day ${a.dayOfWeek}`}
                  </Text>
                  <Text style={styles.availTime}>
                    {a.from} ‚Äì {a.to}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No availability set</Text>
              <Text style={styles.emptyText}>
                This mentor didn‚Äôt add weekly availability yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Preferences</Text>

          <View style={styles.prefGrid}>
            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Languages</Text>
              <Text style={styles.prefValue}>
                {languages.length ? languages.join(", ") : "Not specified"}
              </Text>
            </View>

            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Communication</Text>
              <Text style={styles.prefValue}>
                {commModes.length ? commModes.join(", ") : "Not specified"}
              </Text>
            </View>
          </View>
        </View>

        <View style={styles.footer}>
          <Text style={styles.footerHint}>
            You‚Äôre viewing a mentor profile (not yours) ‚úÖ
          </Text>
          <TouchableOpacity
            onPress={goBack}
            style={styles.footerBtn}
            activeOpacity={0.85}
          >
            <Text style={styles.footerBtnText}>Back to results</Text>
          </TouchableOpacity>
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  container: { paddingHorizontal: 16, paddingTop: 16, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 10, color: "#9CA3AF", fontSize: 14 },

  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  backText: { fontSize: 14, color: "#60A5FA" },
  idBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0B1120",
  },
  idBadgeText: { color: "#CBD5F5", fontSize: 12, fontWeight: "600" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 12,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 10 },
  retryBtn: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "600" },

  heroCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  heroRow: { flexDirection: "row", alignItems: "center" },

  avatar: {
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 12,
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "800" },

  heroName: { color: "#F9FAFB", fontSize: 20, fontWeight: "800" },
  heroMeta: { color: "#9CA3AF", fontSize: 12, marginTop: 4 },

  badgesRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  badge: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    paddingVertical: 10,
    paddingHorizontal: 10,
    borderWidth: 1,
    borderColor: "#111827",
  },
  badgeLabel: { color: "#94A3B8", fontSize: 11 },
  badgeValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "800",
    marginTop: 4,
  },

  ctaRow: { flexDirection: "row", gap: 10, marginTop: 12 },
  ctaBtn: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
  },
  ctaPrimary: { backgroundColor: "#F97316" },
  ctaPrimaryText: { color: "#ffffff", fontWeight: "800", fontSize: 13 },
  ctaSecondary: {
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  ctaSecondaryText: { color: "#E5E7EB", fontWeight: "700", fontSize: 13 },
  ctaNote: { marginTop: 10, color: "#64748B", fontSize: 11 },

  section: { marginBottom: 18 },
  sectionTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "700",
    marginBottom: 4,
  },
  sectionSub: { color: "#94A3B8", fontSize: 12, marginBottom: 10 },
  sectionSubStrong: { color: "#E5E7EB", fontWeight: "800" },

  skillsWrap: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  skillChipText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  availCard: {
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    overflow: "hidden",
  },
  availRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  availRowBorder: { borderBottomWidth: 1, borderBottomColor: "#0B1120" },
  availDay: { color: "#E5E7EB", fontSize: 13, fontWeight: "700" },
  availTime: { color: "#9CA3AF", fontSize: 13, fontWeight: "600" },

  prefGrid: { flexDirection: "row", gap: 10 },
  prefBox: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  prefLabel: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "700",
    marginBottom: 4,
  },
  prefValue: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "800",
    marginBottom: 4,
  },
  emptyText: { color: "#64748B", fontSize: 12 },

  footer: { marginTop: 6 },
  footerHint: { color: "#64748B", fontSize: 11, marginBottom: 10 },
  footerBtn: {
    borderRadius: 999,
    paddingVertical: 11,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  footerBtnText: { color: "#E5E7EB", fontSize: 12, fontWeight: "700" },
});
</file>

<file path="app/modal.tsx">
import { Link } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';

export default function ModalScreen() {
  return (
    <ThemedView style={styles.container}>
      <ThemedText type="title">This is a modal</ThemedText>
      <Link href="/" dismissTo style={styles.link}>
        <ThemedText type="link">Go to home screen</ThemedText>
      </Link>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});
</file>

<file path="app/profile.tsx">
// app/profile.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../lib/api";
import { getMe } from "../lib/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export default function ProfileScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const mountedRef = useRef(true);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);
    } catch (err: any) {
      console.log("Profile / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(err?.message || "Couldn‚Äôt load your profile.");
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );

  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading profile‚Ä¶</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView
        style={styles.scroll}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
            colors={["#F97316"]}
          />
        }
      >
        <View style={styles.headerCard}>
          <Text style={styles.title}>Profile</Text>
          <Text style={styles.name}>{user?.fullName || "SkillSwap user"}</Text>
          <Text style={styles.email}>{user?.email || "‚Äî"}</Text>

          <View style={styles.headerStatsRow}>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>XP</Text>
              <Text style={styles.statValue}>{user?.xp ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Points</Text>
              <Text style={styles.statValue}>{user?.points ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Streak</Text>
              <Text style={styles.statValue}>{user?.streak ?? 0}</Text>
            </View>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldn‚Äôt refresh</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        {/* ‚úÖ One place to manage everything (no bouncing) */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Manage</Text>
          <Text style={styles.sectionSubtitle}>
            Update what matters without jumping around too much.
          </Text>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-learn" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to learn</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToLearn?.length ?? 0) > 0
                  ? `${user?.skillsToLearn?.length} goal(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>‚Ä∫</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-teach" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to teach</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToTeach?.length ?? 0) > 0
                  ? `${user?.skillsToTeach?.length} skill(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>‚Ä∫</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/weekly-availability" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Weekly availability</Text>
              <Text style={styles.rowSub}>
                {slots.length
                  ? `${daysSet} day(s) ¬∑ ${minutesToHuman(totalMin)} total`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>‚Ä∫</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/find-mentor" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Find mentor</Text>
              <Text style={styles.rowSub}>Get matched instantly</Text>
            </View>
            <Text style={styles.rowArrow}>‚Ä∫</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.footerRow}>
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  headerCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  title: { color: "#9CA3AF", fontSize: 13 },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "700", marginTop: 6 },
  email: { color: "#64748B", fontSize: 12, marginTop: 4 },

  headerStatsRow: { flexDirection: "row", gap: 8, marginTop: 12 },
  headerStat: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 10,
  },
  statLabel: { color: "#94A3B8", fontSize: 11, marginBottom: 4 },
  statValue: { color: "#F9FAFB", fontSize: 18, fontWeight: "700" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryButton: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "500" },

  section: { marginTop: 8, marginBottom: 20 },
  sectionTitle: { color: "#F9FAFB", fontSize: 16, fontWeight: "600" },
  sectionSubtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  rowBtn: {
    marginTop: 10,
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  rowTitle: { color: "#F9FAFB", fontSize: 14, fontWeight: "600" },
  rowSub: { color: "#94A3B8", fontSize: 12, marginTop: 2 },
  rowArrow: { color: "#60A5FA", fontSize: 22, marginLeft: 10 },

  footerRow: { marginTop: 8, alignItems: "flex-start" },
  logoutButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },
});
</file>

<file path="app/screens/components/MatchReadinessStrip.tsx">
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import {
  getMatchingStatus,
  type MatchingMode,
  type MatchingStatus,
} from "../../../lib/api";

type Props = {
  currentMode?: MatchingMode; // ÿßÿÆÿ™Ÿäÿßÿ±Ÿä (ŸÑŸà ÿπŸÜÿØŸÉ ŸÖŸàÿØ ŸÖÿ≠ŸÅŸàÿ∏ ÿ®ÿßŸÑŸÄ AsyncStorage)
  onApplyRecommended?: (recommended: MatchingMode) => void; // ŸÑŸÖÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸäŸÉÿ®ÿ≥ "Use recommended"
  onOpenSettings?: () => void; // ÿßÿÆÿ™Ÿäÿßÿ±Ÿä (ŸÑŸà ÿ®ÿØŸÉ ÿ™ŸÅÿ™ÿ≠ ÿ¥ÿßÿ¥ÿ© ÿ•ÿπÿØÿßÿØÿßÿ™ ŸÑÿßÿ≠ŸÇŸãÿß)
  compact?: boolean; // ŸÑŸà ÿ®ÿØŸÉ ÿ¥ŸÉŸÑ ÿ£ÿµÿ∫ÿ±
};

function getHumanMessage(s: MatchingStatus): string {
  if (!s.openaiAvailable) {
    if (s.reason === "NO_KEY")
      return "AI matching is off (no API key). Using local matching.";
    return "AI matching is unavailable right now. Using local matching.";
  }
  return "AI matching is ready. For best results, use Hybrid mode.";
}

export default function MatchReadinessStrip({
  currentMode,
  onApplyRecommended,
  onOpenSettings,
  compact = false,
}: Props) {
  const [status, setStatus] = useState<MatchingStatus | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        setLoading(true);
        const s = await getMatchingStatus();
        if (!alive) return;
        setStatus(s);
      } catch {
        if (!alive) return;
        setStatus({
          openaiAvailable: false,
          reason: "ERROR",
          recommendedMode: "local",
        });
      } finally {
        if (!alive) return;
        setLoading(false);
      }
    })();

    return () => {
      alive = false;
    };
  }, []);

  const recommendedMode: MatchingMode = useMemo(() => {
    // server returns "local" | "hybrid"
    const r = status?.recommendedMode;
    return r === "hybrid" ? "hybrid" : "local";
  }, [status]);

  const showApplyButton = useMemo(() => {
    if (!status) return false;
    if (!onApplyRecommended) return false;
    if (currentMode && currentMode === recommendedMode) return false;
    return true;
  }, [status, onApplyRecommended, currentMode, recommendedMode]);

  const tone = useMemo(() => {
    if (!status) return "neutral";
    return status.openaiAvailable ? "good" : "warn";
  }, [status]);

  return (
    <View
      style={[
        styles.wrap,
        compact && styles.wrapCompact,
        tone === "good" && styles.goodWrap,
        tone === "warn" && styles.warnWrap,
      ]}
    >
      <View style={styles.left}>
        <Text style={styles.title}>Matching status</Text>

        {loading ? (
          <View style={styles.row}>
            <ActivityIndicator />
            <Text style={styles.subtitle}>Checking availability‚Ä¶</Text>
          </View>
        ) : (
          <Text style={styles.subtitle}>
            {status ? getHumanMessage(status) : "Status unknown."}
          </Text>
        )}
      </View>

      <View style={styles.right}>
        {!loading && status && (
          <>
            <View style={styles.pill}>
              <Text style={styles.pillText}>
                Recommended: {recommendedMode.toUpperCase()}
              </Text>
            </View>

            {showApplyButton ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={styles.btn}
                onPress={() => onApplyRecommended?.(recommendedMode)}
              >
                <Text style={styles.btnText}>Use recommended</Text>
              </TouchableOpacity>
            ) : onOpenSettings ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={[styles.btn, styles.btnGhost]}
                onPress={onOpenSettings}
              >
                <Text style={styles.btnText}>Settings</Text>
              </TouchableOpacity>
            ) : null}
          </>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
    borderRadius: 16,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(15, 23, 42, 0.45)",
    padding: 14,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  wrapCompact: {
    paddingVertical: 10,
    paddingHorizontal: 12,
  },
  goodWrap: {
    borderColor: "rgba(34, 197, 94, 0.35)",
    backgroundColor: "rgba(20, 83, 45, 0.18)",
  },
  warnWrap: {
    borderColor: "rgba(251, 191, 36, 0.35)",
    backgroundColor: "rgba(120, 53, 15, 0.18)",
  },
  left: { flex: 1 },
  right: {
    alignItems: "flex-end",
    justifyContent: "center",
    gap: 8,
  },
  title: {
    color: "#e5e7eb",
    fontSize: 14,
    fontWeight: "700",
    marginBottom: 4,
  },
  subtitle: {
    color: "#cbd5e1",
    fontSize: 12.5,
    lineHeight: 18,
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  pill: {
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  pillText: {
    color: "#e5e7eb",
    fontSize: 11.5,
    fontWeight: "700",
    letterSpacing: 0.3,
  },
  btn: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  btnGhost: {
    backgroundColor: "transparent",
  },
  btnText: {
    color: "#e5e7eb",
    fontSize: 12,
    fontWeight: "700",
  },
});
</file>

<file path="app/screens/components/PillButton.tsx">
import React from "react";
import {
  ActivityIndicator,
  GestureResponderEvent,
  StyleProp,
  StyleSheet,
  Text,
  TouchableOpacity,
  ViewStyle,
} from "react-native";

type PillButtonProps = {
  title: string;
  onPress?: (event: GestureResponderEvent) => void;
  disabled?: boolean;
  loading?: boolean;
  style?: StyleProp<ViewStyle>;
  testID?: string;
};

export default function PillButton({
  title,
  onPress,
  disabled = false,
  loading = false,
  style,
  testID,
}: PillButtonProps) {
  const isDisabled = disabled || loading;

  return (
    <TouchableOpacity
      testID={testID}
      activeOpacity={0.85}
      onPress={onPress}
      disabled={isDisabled}
      style={[styles.pill, isDisabled && styles.pillDisabled, style]}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: loading }}
    >
      {loading ? (
        <ActivityIndicator />
      ) : (
        <Text style={[styles.text, isDisabled && styles.textDisabled]}>
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  pill: {
    width: "100%",
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.35)", // slate-400-ish
    backgroundColor: "rgba(15, 23, 42, 0.55)", // slate-900-ish
    alignItems: "center",
    justifyContent: "center",
  },
  pillDisabled: {
    opacity: 0.7,
  },
  text: {
    fontSize: 14.5,
    fontWeight: "600",
    color: "#e5e7eb",
    letterSpacing: 0.2,
  },
  textDisabled: {
    color: "rgba(229, 231, 235, 0.85)",
  },
});
</file>

<file path="app/screens/components/ProfileStatusCard.tsx">
// app/screens/components/ProfileStatusCard.tsx
import { useRouter } from "expo-router";
import React, { useMemo } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import type { ProfileCompletionStatus } from "../../../lib/profileCompletion";

type Props = {
  status: ProfileCompletionStatus;
};

function pickNextSection(status: ProfileCompletionStatus) {
  // ÿ£ŸàŸÑ ŸÇÿ≥ŸÖ ŸÜÿßŸÇÿµ
  return status.sections.find((s) => !s.done) || status.sections[0];
}

export default function ProfileStatusCard({ status }: Props) {
  const router = useRouter();

  const next = useMemo(() => pickNextSection(status), [status]);

  const progressText = status.isComplete
    ? "Complete"
    : `${status.doneCount}/${status.totalCount} done`;

  const subtitle = status.isComplete
    ? "Your profile is ready. You‚Äôll get better matches."
    : "Finish these steps to unlock better mentor matches.";

  const onPrimary = () => {
    if (!next?.href) return;
    router.push(next.href as any);
  };

  return (
    <View style={styles.card}>
      <View style={styles.topRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>Profile completion</Text>
          <Text style={styles.subtitle}>{subtitle}</Text>
        </View>

        <View style={styles.percentPill}>
          <Text style={styles.percentText}>{status.percent}%</Text>
        </View>
      </View>

      <View style={styles.progressRow}>
        <View style={styles.progressBg}>
          <View
            style={[styles.progressFill, { width: `${status.percent}%` }]}
          />
        </View>
        <Text style={styles.progressMeta}>{progressText}</Text>
      </View>

      {!status.isComplete && (
        <View style={styles.nextBox}>
          <View style={{ flex: 1 }}>
            <Text style={styles.nextTitle}>Next step</Text>
            <Text style={styles.nextHint}>{next.hint}</Text>
          </View>

          <TouchableOpacity
            style={styles.primaryBtn}
            onPress={onPrimary}
            activeOpacity={0.85}
          >
            <Text style={styles.primaryBtnText}>{next.ctaLabel}</Text>
          </TouchableOpacity>
        </View>
      )}

      <View style={styles.stepsWrap}>
        {status.sections.map((s) => (
          <View
            key={s.key}
            style={[
              styles.stepChip,
              s.done ? styles.stepChipDone : styles.stepChipTodo,
            ]}
          >
            <Text
              style={[
                styles.stepText,
                s.done ? styles.stepTextDone : styles.stepTextTodo,
              ]}
            >
              {s.done ? "‚úÖ" : "‚¨ú"} {s.title}
            </Text>
          </View>
        ))}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  topRow: { flexDirection: "row", alignItems: "flex-start", gap: 10 },
  title: { color: "#F9FAFB", fontSize: 15, fontWeight: "700" },
  subtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  percentPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#334155",
  },
  percentText: { color: "#F97316", fontSize: 12, fontWeight: "800" },

  progressRow: { marginTop: 10 },
  progressBg: {
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#111827",
  },
  progressFill: { height: "100%", backgroundColor: "#F97316" },
  progressMeta: { color: "#94A3B8", fontSize: 11, marginTop: 6 },

  nextBox: {
    marginTop: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#0B1120",
    padding: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  nextTitle: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },
  nextHint: { color: "#94A3B8", fontSize: 11, marginTop: 4 },

  primaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#F97316",
  },
  primaryBtnText: { color: "#ffffff", fontSize: 12, fontWeight: "800" },

  stepsWrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 12,
  },
  stepChip: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderWidth: 1,
  },
  stepChipDone: { backgroundColor: "#052e16", borderColor: "#14532d" },
  stepChipTodo: { backgroundColor: "#0F172A", borderColor: "#1E293B" },

  stepText: { fontSize: 11, fontWeight: "700" },
  stepTextDone: { color: "#BBF7D0" },
  stepTextTodo: { color: "#E5E7EB" },
});
</file>

<file path="app/screens/components/QuickEditBar.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  onAvailability: () => void;
  onLearn: () => void;
  onTeach: () => void;
  onMatch: () => void;
};

function Pill({
  title,
  emoji,
  onPress,
  variant = "neutral",
}: {
  title: string;
  emoji: string;
  onPress: () => void;
  variant?: "neutral" | "primary";
}) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.85}
      style={[
        styles.pill,
        variant === "primary" ? styles.pillPrimary : styles.pillNeutral,
      ]}
    >
      <Text style={styles.pillEmoji}>{emoji}</Text>
      <Text
        style={[
          styles.pillText,
          variant === "primary"
            ? styles.pillTextPrimary
            : styles.pillTextNeutral,
        ]}
      >
        {title}
      </Text>
    </TouchableOpacity>
  );
}

export default function QuickEditBar({
  onAvailability,
  onLearn,
  onTeach,
  onMatch,
}: Props) {
  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Quick edit</Text>
        <Text style={styles.hint}>Avoid page hopping</Text>
      </View>

      <View style={styles.row}>
        <Pill title="Match" emoji="üß†" onPress={onMatch} variant="primary" />
        <Pill title="Availability" emoji="üìÖ" onPress={onAvailability} />
      </View>

      <View style={styles.row}>
        <Pill title="Learn" emoji="üìö" onPress={onLearn} />
        <Pill title="Teach" emoji="üßë‚Äçüè´" onPress={onTeach} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
  },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  hint: { color: "#64748B", fontSize: 11 },

  row: { flexDirection: "row", gap: 10, marginTop: 10 },
  pill: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
  },
  pillNeutral: { backgroundColor: "#0B1120", borderColor: "#334155" },
  pillPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },

  pillEmoji: { fontSize: 14 },
  pillText: { fontSize: 12, fontWeight: "700" },
  pillTextNeutral: { color: "#E5E7EB" },
  pillTextPrimary: { color: "#DBEAFE" },
});
</file>

<file path="app/screens/components/SkeletonCard.tsx">
import React, { useMemo } from "react";
import { StyleSheet, View, type DimensionValue } from "react-native";

type Props = {
  /**
   * width can be:
   * - number (e.g. 120)
   * - percentage string (e.g. "80%")
   */
  width?: number | `${number}%`;
  height?: number;
  radius?: number;
  style?: any;
};

export default function SkeletonCard({
  width = "100%",
  height = 14,
  radius = 10,
  style,
}: Props) {
  // ‚úÖ ensure correct type for RN style
  const safeWidth = useMemo(() => width as DimensionValue, [width]);

  return (
    <View
      style={[
        styles.skeleton,
        {
          width: safeWidth,
          height,
          borderRadius: radius,
        },
        style,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  skeleton: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    overflow: "hidden",
  },
});
</file>

<file path="app/screens/components/ViewProfileCTA.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label?: string;
  onPress: () => void;
};

export default function ViewProfileCTA({
  label = "View profile",
  onPress,
}: Props) {
  return (
    <TouchableOpacity
      style={styles.wrap}
      onPress={onPress}
      activeOpacity={0.85}
    >
      <View style={styles.left}>
        <Text style={styles.title}>{label}</Text>
        <Text style={styles.sub}>See and update your profile in one place</Text>
      </View>

      <View style={styles.right}>
        <Text style={styles.arrow}>‚Üí</Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 12,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 14,
  },
  left: { flex: 1, paddingRight: 10 },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  sub: { color: "#94A3B8", fontSize: 12, marginTop: 4 },
  right: {
    width: 36,
    height: 36,
    borderRadius: 999,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#334155",
    alignItems: "center",
    justifyContent: "center",
  },
  arrow: { color: "#60A5FA", fontSize: 18, fontWeight: "800" },
});
</file>

<file path="app/screens/homescreen.styles.ts">
// app/screens/homescreen.styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: { flex: 1, alignItems: "center", justifyContent: "center" },

  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 16,
  },

  avatar: {
    width: 44,
    height: 44,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
  },

  avatarText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },

  nameWrap: { marginLeft: 12 },
  nameText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },
  metaText: { color: "#94A3B8", fontSize: 12, fontWeight: "700", marginTop: 2 },

  logoutBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1220",
  },

  card: {
    backgroundColor: "#0B1220",
    borderWidth: 1,
    borderColor: "#1F2937",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
  },

  cardTitle: { color: "#E5E7EB", fontSize: 14, fontWeight: "900", marginBottom: 8 },

  row: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  rowLeft: { flexDirection: "row", alignItems: "center" },

  pill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  pillText: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },

  small: { color: "#94A3B8", fontSize: 12, fontWeight: "700" },
  divider: { height: 1, backgroundColor: "#111827", marginVertical: 12 },

  actionBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  actionText: { color: "#E5E7EB", fontSize: 13, fontWeight: "900" },

  badge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },

  logoutText: { color: "#E5E7EB", fontSize: 12 },
});
</file>

<file path="app/sessions.tsx">

</file>

<file path="app/sessions/api/sessionsApi.ts">
// app/sessions/api/sessionsApi.ts
import { API_URL } from "../../../lib/api";

export type SessionStatus =
  | "requested"
  | "accepted"
  | "rejected"
  | "cancelled"
  | "completed";

export type SessionDTO = {
  _id: string;

  mentorId: string;
  learnerId: string;

  skill: string;
  level: string;

  scheduledAt: string; // ISO
  status: SessionStatus;

  note?: string;

  rating?: number | null;
  feedback?: string;

  createdAt?: string;
  updatedAt?: string;
};

async function handle(res: Response) {
  const text = await res.text();
  let data: any = null;

  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    const msg =
      (data && (data.error || data.message)) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;
    throw new Error(msg);
  }

  return data;
}

export async function listMySessions(
  token: string,
  params?: {
    role?: "mentor" | "learner" | "any";
    scope?: "upcoming" | "past" | "all";
    statuses?: SessionStatus[];
  }
): Promise<SessionDTO[]> {
  const q = new URLSearchParams();
  if (params?.role) q.set("role", params.role);
  if (params?.scope) q.set("scope", params.scope);
  if (params?.statuses?.length) q.set("statuses", params.statuses.join(","));

  const url = `${API_URL}/api/sessions/mine${
    q.toString() ? `?${q.toString()}` : ""
  }`;

  const res = await fetch(url, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });

  const data = await handle(res);
  return Array.isArray(data?.sessions) ? (data.sessions as SessionDTO[]) : [];
}

export async function requestSession(
  token: string,
  body: {
    mentorId: string;
    skill: string;
    level?: string;
    scheduledAt: string;
    note?: string;
  }
): Promise<SessionDTO> {
  const res = await fetch(`${API_URL}/api/sessions`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(body),
  });

  const data = await handle(res);
  return (data?.session ?? data) as SessionDTO;
}

export async function updateSessionStatus(
  token: string,
  sessionId: string,
  status: SessionStatus
): Promise<SessionDTO> {
  const res = await fetch(`${API_URL}/api/sessions/${sessionId}/status`, {
    method: "PATCH",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ status }),
  });

  const data = await handle(res);
  return (data?.session ?? data) as SessionDTO;
}

// ‚úÖ NEW: rate session
export async function rateSession(
  token: string,
  sessionId: string,
  body: { rating: number; feedback?: string }
): Promise<SessionDTO> {
  const res = await fetch(`${API_URL}/api/sessions/${sessionId}/rate`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(body),
  });

  const data = await handle(res);
  return (data?.session ?? data) as SessionDTO;
}
</file>

<file path="app/sessions/index.tsx">
// app/sessions/index.tsx
import SessionsScreen from "./screens/SessionsScreen";

export default SessionsScreen;
</file>

<file path="app/sessions/request.tsx">
// app/sessions/request.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  ScrollView,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { requestSession } from "./api/sessionsApi";

function pad2(n: number) {
  return String(n).padStart(2, "0");
}

/**
 * Accepts:
 * - date: "YYYY-MM-DD"
 * - time: "HH:MM"
 * Produces ISO string in local time.
 */
function buildISO(dateStr: string, timeStr: string): string | null {
  const d = String(dateStr || "").trim();
  const t = String(timeStr || "").trim();

  if (!/^\d{4}-\d{2}-\d{2}$/.test(d)) return null;
  if (!/^\d{2}:\d{2}$/.test(t)) return null;

  const [yy, mm, dd] = d.split("-").map((x) => Number(x));
  const [hh, mi] = t.split(":").map((x) => Number(x));

  if (![yy, mm, dd, hh, mi].every(Number.isFinite)) return null;
  if (mm < 1 || mm > 12) return null;
  if (dd < 1 || dd > 31) return null;
  if (hh < 0 || hh > 23) return null;
  if (mi < 0 || mi > 59) return null;

  const dt = new Date(yy, mm - 1, dd, hh, mi, 0, 0);
  if (Number.isNaN(dt.getTime())) return null;

  return dt.toISOString();
}

export default function RequestSessionScreen() {
  const router = useRouter();
  const params = useLocalSearchParams<{
    mentorId?: string;
    mentorName?: string;
    skill?: string;
    level?: string;
  }>();

  // Prefill from params if provided
  const mentorId = String(params.mentorId || "").trim();
  const mentorName = String(params.mentorName || "").trim();
  const defaultSkill = String(params.skill || "").trim();
  const defaultLevel = String(params.level || "").trim();

  const now = useMemo(() => new Date(), []);
  const defaultDate = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(
    now.getDate()
  )}`;
  const defaultTime = `${pad2(Math.min(23, now.getHours() + 1))}:${pad2(
    now.getMinutes()
  )}`;

  const [skill, setSkill] = useState(defaultSkill);
  const [level, setLevel] = useState(defaultLevel || "Not specified");
  const [dateStr, setDateStr] = useState(defaultDate);
  const [timeStr, setTimeStr] = useState(defaultTime);
  const [note, setNote] = useState("");

  const [busy, setBusy] = useState(false);

  const canSubmit = useMemo(() => {
    if (!mentorId) return false;
    if (!skill.trim()) return false;
    return buildISO(dateStr, timeStr) !== null;
  }, [mentorId, skill, dateStr, timeStr]);

  const submit = async () => {
    if (!mentorId) {
      Alert.alert("Missing mentor", "Open this screen from a mentor profile.");
      return;
    }

    const iso = buildISO(dateStr, timeStr);
    if (!iso) {
      Alert.alert("Invalid date/time", "Use Date: YYYY-MM-DD and Time: HH:MM");
      return;
    }

    const trimmedSkill = skill.trim();
    if (!trimmedSkill) {
      Alert.alert("Missing skill", "Please enter a skill for the session.");
      return;
    }

    try {
      setBusy(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      await requestSession(token, {
        mentorId,
        skill: trimmedSkill,
        level: String(level || "Not specified"),
        scheduledAt: iso,
        note: String(note || "").trim(),
      });

      Alert.alert("Requested ‚úÖ", "Your session request was sent.", [
        {
          text: "Go to sessions",
          onPress: () => router.replace("/sessions" as any),
        },
      ]);
    } catch (e: any) {
      Alert.alert("Request failed", e?.message || "Please try again.");
    } finally {
      setBusy(false);
    }
  };

  return (
    <View style={{ flex: 1, backgroundColor: "#020617" }}>
      <ScrollView contentContainerStyle={{ padding: 16, paddingBottom: 28 }}>
        {/* Header */}
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
            <Text style={{ color: "#60A5FA", fontWeight: "900" }}>‚Üê Back</Text>
          </TouchableOpacity>

          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
            Request session
          </Text>

          <View style={{ width: 54 }} />
        </View>

        <Text style={{ color: "#94A3B8", marginTop: 8, fontSize: 12 }}>
          {mentorName
            ? `Requesting with: ${mentorName}`
            : mentorId
            ? `Mentor selected`
            : `Open from a mentor profile to auto-fill mentorId.`}
        </Text>

        {/* Card */}
        <View
          style={{
            marginTop: 14,
            borderRadius: 14,
            borderWidth: 1,
            borderColor: "#1E293B",
            backgroundColor: "#0B1120",
            padding: 12,
            gap: 10,
          }}
        >
          <Field
            label="Skill"
            value={skill}
            onChangeText={setSkill}
            placeholder="e.g. React, Unity, AWS..."
          />

          <Field
            label="Level"
            value={level}
            onChangeText={setLevel}
            placeholder="Beginner / Intermediate / Advanced"
          />

          <View style={{ flexDirection: "row", gap: 10 }}>
            <View style={{ flex: 1 }}>
              <Field
                label="Date (YYYY-MM-DD)"
                value={dateStr}
                onChangeText={setDateStr}
                placeholder="2025-12-31"
              />
            </View>

            <View style={{ flex: 1 }}>
              <Field
                label="Time (HH:MM)"
                value={timeStr}
                onChangeText={setTimeStr}
                placeholder="18:30"
              />
            </View>
          </View>

          <Field
            label="Note (optional)"
            value={note}
            onChangeText={setNote}
            placeholder="Anything the mentor should know..."
            multiline
            minHeight={76}
          />
        </View>

        {/* Submit */}
        <TouchableOpacity
          onPress={submit}
          activeOpacity={0.85}
          disabled={!canSubmit || busy}
          style={{
            marginTop: 14,
            borderRadius: 999,
            paddingVertical: 12,
            alignItems: "center",
            backgroundColor: !canSubmit || busy ? "#334155" : "#F97316",
            borderWidth: 1,
            borderColor: !canSubmit || busy ? "#475569" : "#FB923C",
          }}
        >
          {busy ? (
            <View
              style={{ flexDirection: "row", alignItems: "center", gap: 10 }}
            >
              <ActivityIndicator />
              <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                Sending‚Ä¶
              </Text>
            </View>
          ) : (
            <Text style={{ color: "#111827", fontWeight: "900" }}>
              Send request
            </Text>
          )}
        </TouchableOpacity>

        {/* Hint */}
        <Text style={{ color: "#64748B", marginTop: 10, fontSize: 11 }}>
          Tip: the screen works best when opened with mentorId + skill
          prefilled.
        </Text>
      </ScrollView>
    </View>
  );
}

function Field(props: {
  label: string;
  value: string;
  onChangeText: (v: string) => void;
  placeholder?: string;
  multiline?: boolean;
  minHeight?: number;
}) {
  const { label, value, onChangeText, placeholder, multiline, minHeight } =
    props;

  return (
    <View style={{ gap: 6 }}>
      <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900" }}>
        {label}
      </Text>
      <TextInput
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor="#64748B"
        multiline={multiline}
        style={{
          borderWidth: 1,
          borderColor: "#1F2937",
          backgroundColor: "#020617",
          color: "#E5E7EB",
          paddingHorizontal: 12,
          paddingVertical: 10,
          borderRadius: 12,
          fontSize: 14,
          fontWeight: "700",
          minHeight: minHeight ?? 44,
          textAlignVertical: multiline ? "top" : "center",
        }}
      />
    </View>
  );
}
</file>

<file path="app/sessions/screens/SessionsScreen.tsx">
// app/sessions/screens/SessionsScreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useCallback, useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import { getMe } from "../../../lib/api";
import { listMySessions, SessionDTO } from "../api/sessionsApi";
import SessionCard from "../components/SessionCard";

type Scope = "upcoming" | "past" | "all";

export default function SessionsScreen() {
  const router = useRouter();

  const [scope, setScope] = useState<Scope>("upcoming");
  const [token, setToken] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  const [sessions, setSessions] = useState<SessionDTO[]>([]);
  const [loading, setLoading] = useState(true); // initial load
  const [loadingList, setLoadingList] = useState(false); // chip switching
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const scopeLabel = useMemo(() => {
    if (scope === "upcoming") return "Upcoming sessions";
    if (scope === "past") return "Past sessions";
    return "All sessions";
  }, [scope]);

  const load = useCallback(
    async (opts?: { silent?: boolean; listOnly?: boolean }) => {
      const silent = !!opts?.silent;
      const listOnly = !!opts?.listOnly;

      try {
        setErrorText(null);

        if (!silent && !listOnly) setLoading(true);
        if (listOnly) setLoadingList(true);

        const t = token ?? (await AsyncStorage.getItem("token"));
        if (!token) setToken(t);

        if (!t) {
          router.replace("/(auth)/login" as any);
          return;
        }

        // only fetch me once (unless missing)
        if (!currentUserId) {
          const me: any = await getMe(t);
          setCurrentUserId(me?.user?._id ?? me?._id ?? null);
        }

        const data = await listMySessions(t, { scope });
        setSessions(data);
      } catch (e: any) {
        setErrorText(e?.message || "Failed to load sessions.");
      } finally {
        if (!silent && !listOnly) setLoading(false);
        if (listOnly) setLoadingList(false);
        setRefreshing(false);
      }
    },
    [router, scope, token, currentUserId]
  );

  useEffect(() => {
    load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // when scope changes => load list only (no full-screen loader)
  useEffect(() => {
    if (!token) return; // wait initial token
    load({ listOnly: true, silent: true });
  }, [scope, token, load]);

  const onRefresh = () => {
    setRefreshing(true);
    load({ silent: true });
  };

  const ScopeChip = ({ v }: { v: Scope }) => {
    const active = v === scope;
    return (
      <TouchableOpacity
        onPress={() => setScope(v)}
        activeOpacity={0.85}
        style={{
          paddingHorizontal: 12,
          paddingVertical: 8,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: active ? "#F97316" : "#1E293B",
          backgroundColor: active ? "#0B1120" : "#020617",
        }}
      >
        <Text
          style={{
            color: active ? "#FED7AA" : "#E5E7EB",
            fontWeight: "900",
            fontSize: 12,
            textTransform: "capitalize",
          }}
        >
          {v}
        </Text>
      </TouchableOpacity>
    );
  };

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>
          Loading sessions‚Ä¶
        </Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, backgroundColor: "#020617" }}>
      <ScrollView
        contentContainerStyle={{ padding: 16, paddingBottom: 28 }}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
          />
        }
      >
        {/* Header */}
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
            <Text style={{ color: "#60A5FA", fontWeight: "900" }}>‚Üê Back</Text>
          </TouchableOpacity>

          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
            Sessions
          </Text>

          <View style={{ width: 54 }} />
        </View>

        {/* Subtitle */}
        <Text style={{ color: "#94A3B8", marginTop: 8, fontWeight: "700" }}>
          {scopeLabel}
        </Text>

        {/* Scope chips */}
        <View
          style={{
            flexDirection: "row",
            gap: 8,
            marginTop: 14,
            flexWrap: "wrap",
          }}
        >
          <ScopeChip v="upcoming" />
          <ScopeChip v="past" />
          <ScopeChip v="all" />
        </View>

        {/* Error */}
        {errorText ? (
          <View
            style={{
              marginTop: 14,
              backgroundColor: "#451A1A",
              borderRadius: 12,
              padding: 12,
              borderWidth: 1,
              borderColor: "#FCA5A5",
            }}
          >
            <Text style={{ color: "#FECACA", fontWeight: "900" }}>
              Couldn‚Äôt load sessions
            </Text>
            <Text style={{ color: "#FECACA", marginTop: 6 }}>{errorText}</Text>

            <TouchableOpacity
              onPress={() => load({ silent: true })}
              activeOpacity={0.85}
              style={{
                marginTop: 10,
                alignSelf: "flex-start",
                paddingHorizontal: 12,
                paddingVertical: 8,
                borderRadius: 999,
                backgroundColor: "#B91C1C",
              }}
            >
              <Text style={{ color: "#FEE2E2", fontWeight: "900" }}>
                Try again
              </Text>
            </TouchableOpacity>
          </View>
        ) : null}

        {/* List header row */}
        <View
          style={{
            marginTop: 16,
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "space-between",
          }}
        >
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 14 }}>
            Results
          </Text>

          {loadingList ? (
            <View
              style={{ flexDirection: "row", alignItems: "center", gap: 8 }}
            >
              <ActivityIndicator />
              <Text style={{ color: "#94A3B8", fontWeight: "900" }}>
                Updating‚Ä¶
              </Text>
            </View>
          ) : null}
        </View>

        {/* Sessions */}
        <View style={{ marginTop: 12, gap: 10 }}>
          {sessions.length === 0 ? (
            <View
              style={{
                backgroundColor: "#0B1120",
                borderWidth: 1,
                borderColor: "#1E293B",
                borderRadius: 14,
                padding: 14,
              }}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                No sessions yet
              </Text>
              <Text style={{ color: "#94A3B8", marginTop: 6 }}>
                When you request a session from a mentor, it‚Äôll show up here.
              </Text>

              <TouchableOpacity
                onPress={() => router.push("/find-mentor" as any)}
                activeOpacity={0.85}
                style={{
                  marginTop: 12,
                  borderRadius: 999,
                  paddingVertical: 10,
                  alignItems: "center",
                  backgroundColor: "#F97316",
                  borderWidth: 1,
                  borderColor: "#FB923C",
                }}
              >
                <Text style={{ color: "#111827", fontWeight: "900" }}>
                  Find a mentor
                </Text>
              </TouchableOpacity>
            </View>
          ) : (
            sessions.map((s) => (
              <SessionCard
                key={s._id}
                session={s}
                token={token}
                currentUserId={currentUserId}
                onChanged={() => load({ silent: true })}
              />
            ))
          )}
        </View>
      </ScrollView>
    </View>
  );
}
</file>

<file path="app/sessions/utils/formatSession.ts">
// app/sessions/utils/formatSession.ts
// I AM THE REAL formatSession.ts

import type { SessionStatus } from "../api/sessionsApi";

export function formatSessionDateTime(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "Invalid date";
  return d.toLocaleString();
}

export function statusBadge(
  status: SessionStatus
): { label: string; bg: string; border: string; text: string } {
  switch (status) {
    case "requested":
      return { label: "Requested", bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
    case "accepted":
      return { label: "Accepted", bg: "#052E16", border: "#16A34A", text: "#D1FAE5" };
    case "rejected":
      return { label: "Rejected", bg: "#450A0A", border: "#EF4444", text: "#FEE2E2" };
    case "cancelled":
      return { label: "Cancelled", bg: "#111827", border: "#6B7280", text: "#E5E7EB" };
    case "completed":
      return { label: "Completed", bg: "#0B1120", border: "#F97316", text: "#FED7AA" };
    default:
      return { label: String(status), bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
  }
}
</file>

<file path="app/shared/levels.ts">
// app/shared/levels.ts

export const LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
] as const;

export type Level = (typeof LEVELS)[number];

/**
 * ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÑŸÑŸÖŸÇÿßÿ±ŸÜÿ©
 * ŸÉŸÑ ŸÖÿß ÿßŸÑÿ±ŸÇŸÖ ÿ£ŸÉÿ®ÿ± ‚Üí ŸÖÿ≥ÿ™ŸàŸâ ÿ£ÿπŸÑŸâ
 */
export const LEVEL_RANK: Record<Level, number> = {
  Beginner: 1,
  Intermediate: 2,
  Advanced: 3,
};
</file>

<file path="app/shared/profileCompletion.ts">
// app/shared/profileCompletion.ts
// ‚úÖ Single-source-of-truth: re-export from /lib to avoid duplicated logic.
// This keeps old imports working if any screen still imports from app/shared.

export { getProfileCompletionStatus } from "../../lib/profileCompletion";
export type { ProfileCompletionStatus } from "../../lib/profileCompletion";
</file>

<file path="app/weekly-availability/SaveBar.tsx">
// app/weekly-availability/SaveBar.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";

type Props = {
  visible: boolean;
  saving?: boolean;
  onSave: () => void;
  onDiscard: () => void;
  lastSavedText?: string;
};

export default function SaveBar({
  visible,
  saving,
  onSave,
  onDiscard,
  lastSavedText,
}: Props) {
  if (!visible) return null;

  const disabled = !!saving;

  return (
    <View
      style={{
        position: "absolute",
        left: 14,
        right: 14,
        bottom: 14,
        borderRadius: 16,
        borderWidth: 1,
        borderColor: "#1E293B",
        backgroundColor: "#0B1120",
        padding: 12,
      }}
    >
      <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
        <View style={{ flex: 1 }}>
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
            Unsaved changes
          </Text>
          <Text
            style={{
              color: "#94A3B8",
              fontSize: 11,
              marginTop: 3,
              lineHeight: 14,
            }}
          >
            {lastSavedText ? `Last saved: ${lastSavedText}` : "Not saved yet"}
          </Text>
        </View>

        <Pressable
          onPress={onDiscard}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 12,
              paddingVertical: 10,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: "#334155",
              backgroundColor: "#020617",
              opacity: disabled ? 0.6 : 1,
            },
            pressed && !disabled ? { opacity: 0.85 } : null,
          ]}
        >
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
            Discard
          </Text>
        </Pressable>

        <Pressable
          onPress={onSave}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 14,
              paddingVertical: 10,
              borderRadius: 999,
              backgroundColor: "#22C55E",
              opacity: disabled ? 0.65 : 1,
              flexDirection: "row",
              alignItems: "center",
              gap: 8,
            },
            pressed && !disabled ? { opacity: 0.9 } : null,
          ]}
        >
          {saving ? <ActivityIndicator /> : null}
          <Text style={{ color: "#022C22", fontWeight: "900", fontSize: 12 }}>
            {saving ? "Saving‚Ä¶" : "Save"}
          </Text>
        </Pressable>
      </View>
    </View>
  );
}
</file>

<file path="app/weekly-availability/styles.ts">
// app/weekly-availability/styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: {
    flex: 1,
    backgroundColor: "#020617",
  },
  scroll: {
    flex: 1,
  },
  content: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 120, // extra space for save bar + toast
  },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    color: "#9CA3AF",
    marginTop: 8,
    fontSize: 14,
  },

  title: {
    color: "#F9FAFB",
    fontSize: 22,
    fontWeight: "800",
    marginBottom: 4,
  },
  subtitle: {
    color: "#64748B",
    fontSize: 13,
    marginBottom: 12,
    lineHeight: 18,
  },

  // Section headers (step-by-step)
  sectionTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "900",
    marginTop: 10,
    marginBottom: 4,
  },
  sectionHint: {
    color: "#64748B",
    fontSize: 12,
    marginBottom: 8,
    lineHeight: 16,
  },

  // Error box
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
    marginBottom: 8,
  },

  // Summary card
  summaryCard: {
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  summaryTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "900",
    marginBottom: 4,
  },
  summaryText: {
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },
  summaryRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
    gap: 8,
    flexWrap: "wrap",
  },
  summaryBadge: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
  },
  summaryBadgeText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  // Day selector row
  daySelectorRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  dayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  dayChipToday: {
    borderColor: "#60A5FA",
  },
  dayChipSelected: {
    backgroundColor: "#F97316",
    borderColor: "#F97316",
  },
  dayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },
  dayChipTextToday: {
    color: "#BFDBFE",
    fontWeight: "800",
  },
  dayChipTextSelected: {
    color: "#0F172A",
    fontWeight: "900",
  },

  // Time input card
  timeCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  // subtle state borders (edit vs normal) - safe additions
  timeCardNormal: {
    borderColor: "#1E293B",
  },
  timeCardEditing: {
    borderColor: "#60A5FA",
  },

  timeLabelRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 8,
    marginBottom: 8,
  },
  timeLabel: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "900",
  },
  timeSelectedDayText: {
    color: "#94A3B8",
    fontSize: 12,
  },

  editBanner: {
    marginTop: 8,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#334155",
  },
  editBannerTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
    marginBottom: 2,
  },
  editBannerSub: {
    color: "#94A3B8",
    fontSize: 11,
    lineHeight: 15,
  },
  editBannerRow: {
    marginTop: 8,
    flexDirection: "row",
    gap: 8,
    flexWrap: "wrap",
  },
  bannerBtn: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  bannerBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  bannerDanger: {
    borderColor: "#7F1D1D",
    backgroundColor: "#451A1A",
  },
  bannerDangerText: {
    color: "#FECACA",
  },
  bannerPrimary: {
    borderColor: "#60A5FA",
    backgroundColor: "#60A5FA",
  },
  bannerPrimaryText: {
    color: "#0F172A",
  },

  timeRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 6,
  },
  timeDash: {
    color: "#9CA3AF",
    marginHorizontal: 8,
    fontSize: 16,
    fontWeight: "900",
  },
  timeHint: {
    color: "#64748B",
    fontSize: 12,
    marginTop: 6,
    lineHeight: 16,
  },
  timeErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    marginTop: 8,
    lineHeight: 16,
  },

  // Quick presets
  quickRow: {
    flexDirection: "row",
    marginTop: 10,
    gap: 8,
    flexWrap: "wrap",
  },
  quickChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  quickChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  quickChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },
  quickChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "900",
  },

  // Multi-day add
  multiRow: {
    marginTop: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    backgroundColor: "#0B1120",
  },
  multiTopRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    flexWrap: "wrap",
  },
  multiTopActions: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
  },
  miniActionBtn: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  miniActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  multiTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  multiCountText: {
    color: "#94A3B8",
    fontSize: 11,
    marginTop: 6,
    marginBottom: 8,
    lineHeight: 15,
  },
  multiDaysRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  multiDayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  multiDayChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  multiDayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  primaryButton: {
    marginTop: 12,
    backgroundColor: "#22C55E",
    paddingVertical: 11,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryButtonDisabled: {
    opacity: 0.6,
  },
  primaryText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
  },

  secondaryActionsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
    flexWrap: "wrap",
  },
  secondaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  secondaryBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  // Day cards list
  dayCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
    marginBottom: 10,
  },
  dayHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 6,
  },
  dayHeaderActions: {
    flexDirection: "row",
    gap: 10,
    alignItems: "center",
    flexWrap: "wrap",
  },
  dayName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "900",
  },
  daySubText: {
    marginTop: 2,
    color: "#94A3B8",
    fontSize: 11,
  },
  clearDayText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },
  copyDayText: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
  daySlotsEmptyText: {
    color: "#6B7280",
    fontSize: 12,
  },

  slotChipRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  slotChip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    gap: 10,
  },
  slotChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  slotRemoveText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },

  // Save bar (sticky)
  saveBarSticky: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(2,6,23,0.95)",
    borderTopWidth: 1,
    borderTopColor: "#1E293B",
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  saveRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  saveHint: {
    color: "#94A3B8",
    fontSize: 12,
    flex: 1,
  },
  discardButton: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  discardText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },
  saveButton: {
    backgroundColor: "#22C55E",
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 999,
    alignItems: "center",
    minWidth: 110,
  },
  saveButtonDisabled: {
    opacity: 0.6,
  },
  saveText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
    textAlign: "center",
  },

  // Time picker field
  timeFieldBox: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0F172A",
  },
  timeFieldLabel: {
    color: "#64748B",
    fontSize: 11,
    fontWeight: "800",
  },
  timeFieldValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "900",
    marginTop: 4,
  },

  // Modal
  modalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "flex-end",
  },
  modalCard: {
    backgroundColor: "#0B1120",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingVertical: 18,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  modalTitle: {
    fontSize: 16,
    fontWeight: "900",
    textAlign: "center",
    marginBottom: 10,
    color: "#F9FAFB",
  },
  modalButtonsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
  },
  modalCancel: {
    fontSize: 14,
    color: "#94A3B8",
    fontWeight: "800",
  },
  modalDone: {
    fontSize: 14,
    fontWeight: "900",
    color: "#F9FAFB",
  },

  // Copy modal list
  copyList: {
    marginTop: 10,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    justifyContent: "center",
  },
  copyChip: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  copyChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  copyChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  copyHint: {
    marginTop: 10,
    textAlign: "center",
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },

  // Toast
  toastWrap: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 84, // above save bar
    alignItems: "center",
    justifyContent: "center",
  },
  toastCard: {
    backgroundColor: "rgba(11,17,32,0.96)",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 999,
  },
  toastText: {
    color: "#F9FAFB",
    fontSize: 12,
    fontWeight: "800",
  },
});
</file>

<file path="components/external-link.tsx">
import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}
</file>

<file path="components/haptic-tab.tsx">
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}
</file>

<file path="components/hello-wave.tsx">
import Animated from 'react-native-reanimated';

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          '50%': { transform: [{ rotate: '25deg' }] },
        },
        animationIterationCount: 4,
        animationDuration: '300ms',
      }}>
      üëã
    </Animated.Text>
  );
}
</file>

<file path="components/parallax-scroll-view.tsx">
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/themed-view';
import { useColorScheme } from '@/hooks/use-color-scheme';
import { useThemeColor } from '@/hooks/use-theme-color';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const backgroundColor = useThemeColor({}, 'background');
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <Animated.ScrollView
      ref={scrollRef}
      style={{ backgroundColor, flex: 1 }}
      scrollEventThrottle={16}>
      <Animated.View
        style={[
          styles.header,
          { backgroundColor: headerBackgroundColor[colorScheme] },
          headerAnimatedStyle,
        ]}>
        {headerImage}
      </Animated.View>
      <ThemedView style={styles.content}>{children}</ThemedView>
    </Animated.ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});
</file>

<file path="components/themed-text.tsx">
import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});
</file>

<file path="components/themed-view.tsx">
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}
</file>

<file path="components/ui/collapsible.tsx">
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { IconSymbol } from '@/components/ui/icon-symbol';
import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});
</file>

<file path="components/ui/icon-symbol.ios.tsx">
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}
</file>

<file path="components/ui/icon-symbol.tsx">
// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight, SymbolViewProps } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}
</file>

<file path="hooks/use-color-scheme.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="hooks/use-color-scheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
</file>

<file path="hooks/use-theme-color.ts">
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
</file>

<file path="lib/availabilityStorage.ts">
// lib/availabilityStorage.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import type { AvailabilitySlot } from "./api";
import { patchSectionStatus } from "./sectionStatus"; // ‚úÖ update Home status too

// ‚úÖ Keys (versioned to avoid future breaking)
const KEY_LAST_SAVED_AT = "weeklyAvailability_lastSavedAt_v1";
const KEY_PENDING = "weeklyAvailability_pending_v1";

/**
 * The pending payload stored locally when user edits availability
 * but hasn't synced to server yet.
 */
export type PendingAvailabilityPayload = {
  slots: AvailabilitySlot[];
  updatedAtISO: string; // when user changed locally
  source: "user-edit" | "auto-restore";
};

function safeParseJSON<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export async function getWeeklyLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_LAST_SAVED_AT);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

/**
 * ‚úÖ IMPORTANT:
 * - write local timestamp
 * - also patch sectionStatus so HomeScreen reflects it immediately
 */
export async function setWeeklyLastSavedAt(
  ts: number = Date.now()
): Promise<void> {
  try {
    await AsyncStorage.setItem(KEY_LAST_SAVED_AT, String(ts));
  } catch {
    // swallow - we don't want UI crash
  }

  // keep Home in sync (ignore errors safely)
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: ts });
  } catch {
    // ignore
  }
}

export async function clearWeeklyLastSavedAt(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_LAST_SAVED_AT);
  } catch {
    // ignore
  }

  // keep Home in sync
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: null });
  } catch {
    // ignore
  }
}

export async function getPendingWeeklyAvailability(): Promise<PendingAvailabilityPayload | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_PENDING);
    const parsed = safeParseJSON<PendingAvailabilityPayload>(raw);
    if (
      !parsed ||
      !Array.isArray(parsed.slots) ||
      typeof parsed.updatedAtISO !== "string"
    ) {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}

export async function setPendingWeeklyAvailability(
  slots: AvailabilitySlot[],
  source: PendingAvailabilityPayload["source"] = "user-edit"
): Promise<void> {
  try {
    const payload: PendingAvailabilityPayload = {
      slots,
      updatedAtISO: new Date().toISOString(),
      source,
    };
    await AsyncStorage.setItem(KEY_PENDING, JSON.stringify(payload));
  } catch {
    // ignore
  }
}

export async function clearPendingWeeklyAvailability(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_PENDING);
  } catch {
    // ignore
  }
}

/**
 * Convenience: mark "saved successfully" (server sync succeeded)
 * - clear pending
 * - bump lastSavedAt (and Home status)
 */
export async function markWeeklyAvailabilitySynced(): Promise<void> {
  await Promise.all([
    clearPendingWeeklyAvailability(),
    setWeeklyLastSavedAt(Date.now()), // ‚úÖ this also patches sectionStatus
  ]);
}

/**
 * Use this when entering weekly availability screen:
 * If there is a pending payload, you can offer restore.
 */
export async function hasPendingWeeklyAvailability(): Promise<boolean> {
  const p = await getPendingWeeklyAvailability();
  return !!p?.slots?.length;
}
</file>

<file path="lib/profileCompletion.ts">
// lib/profileCompletion.ts
import type { AvailabilitySlot, SkillLearn, SkillTeach } from "./api";

export type ProfileCompletionSection = {
  key: "basics" | "learn" | "teach" | "availability";
  title: string;
  done: boolean;
  hint: string;
  ctaLabel: string;
  href: string; // expo-router route
};

export type ProfileCompletionStatus = {
  percent: number; // 0..100
  isComplete: boolean;
  doneCount: number;
  totalCount: number;
  sections: ProfileCompletionSection[];
};

type UserLike = {
  fullName?: string;
  email?: string;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

function bool(v: any) {
  return !!v;
}

export function getProfileCompletionStatus(user: UserLike | null | undefined): ProfileCompletionStatus {
  const fullName = (user?.fullName || "").trim();
  const email = (user?.email || "").trim();

  const hasBasics = bool(fullName) && bool(email);

  const learnCount = user?.skillsToLearn?.length ?? 0;
  const teachCount = user?.skillsToTeach?.length ?? 0;
  const availabilityCount = user?.availabilitySlots?.length ?? 0;

  const hasLearn = learnCount > 0;
  const hasTeach = teachCount > 0;
  const hasAvailability = availabilityCount > 0;

  const sections: ProfileCompletionSection[] = [
    {
      key: "basics",
      title: "Profile basics",
      done: hasBasics,
      hint: hasBasics ? "Looks good." : "Add your name + email to finish the basics.",
      ctaLabel: hasBasics ? "View" : "Fix basics",
      // ŸÑŸà ÿπŸÜÿØŸÉ ÿ¥ÿßÿ¥ÿ© ÿ®ÿ±ŸàŸÅÿßŸäŸÑ ŸÑÿßÿ≠ŸÇÿßŸã ÿ∫ŸäŸëÿ± ÿßŸÑÿ±ÿßÿ®ÿ∑
      href: "/settings",
    },
    {
      key: "learn",
      title: "Skills to learn",
      done: hasLearn,
      hint: hasLearn
        ? `You have ${learnCount} learning goal${learnCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you want to learn (improves matching).",
      ctaLabel: hasLearn ? "Manage" : "Add skills",
      href: "/manage-skills-to-learn",
    },
    {
      key: "teach",
      title: "Skills to teach",
      done: hasTeach,
      hint: hasTeach
        ? `You can teach ${teachCount} skill${teachCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you can teach (unlocks more matches).",
      ctaLabel: hasTeach ? "Manage" : "Add skills",
      href: "/manage-skills-to-teach",
    },
    {
      key: "availability",
      title: "Weekly availability",
      done: hasAvailability,
      hint: hasAvailability
        ? `You have ${availabilityCount} time slot${availabilityCount === 1 ? "" : "s"} set.`
        : "Set 1‚Äì2 time slots so mentors can align with you.",
      ctaLabel: hasAvailability ? "Edit" : "Set now",
      href: "/weekly-availability",
    },
  ];

  const totalCount = sections.length;
  const doneCount = sections.filter((s) => s.done).length;

  // ‚úÖ Ÿàÿ≤ŸÜ ŸÖÿ™ÿ≥ÿßŸàŸä Ÿàÿ®ÿ≥Ÿäÿ∑
  const percent = clamp(Math.round((doneCount / totalCount) * 100), 0, 100);
  const isComplete = doneCount === totalCount;

  return { percent, isComplete, doneCount, totalCount, sections };
}
</file>

<file path="lib/sectionStatus.ts">
// lib/sectionStatus.ts
import AsyncStorage from "@react-native-async-storage/async-storage";

const STORAGE_KEY = "sectionStatus_v1";

export type SectionStatus = {
  weeklyAvailabilityLastSavedAt: number | null;
  learnHasPendingSync: boolean;
  teachHasPendingSync: boolean;
  updatedAt: number;
};

function safeJsonParse<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export function makeDefaultSectionStatus(
  overrides: Partial<SectionStatus> = {}
): SectionStatus {
  const now = Date.now();
  const next: SectionStatus = {
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: now,
    ...overrides,
  };

  if (!(typeof next.updatedAt === "number" && Number.isFinite(next.updatedAt))) {
    next.updatedAt = now;
  }
  return next;
}

export function normalizeSectionStatus(input: unknown): SectionStatus {
  const obj = (input ?? {}) as Partial<SectionStatus>;

  const weeklyAvailabilityLastSavedAt =
    typeof obj.weeklyAvailabilityLastSavedAt === "number" &&
    Number.isFinite(obj.weeklyAvailabilityLastSavedAt)
      ? obj.weeklyAvailabilityLastSavedAt
      : null;

  const learnHasPendingSync = obj.learnHasPendingSync === true;
  const teachHasPendingSync = obj.teachHasPendingSync === true;

  const updatedAt =
    typeof obj.updatedAt === "number" && Number.isFinite(obj.updatedAt)
      ? obj.updatedAt
      : Date.now();

  return {
    weeklyAvailabilityLastSavedAt,
    learnHasPendingSync,
    teachHasPendingSync,
    updatedAt,
  };
}

export async function readSectionStatus(): Promise<SectionStatus> {
  const raw = await AsyncStorage.getItem(STORAGE_KEY);
  const parsed = safeJsonParse<SectionStatus>(raw);
  if (!parsed) return makeDefaultSectionStatus();
  return normalizeSectionStatus(parsed);
}

export async function writeSectionStatus(next: SectionStatus): Promise<void> {
  const normalized = normalizeSectionStatus(next);
  await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
}

export async function patchSectionStatus(
  patch: Partial<Omit<SectionStatus, "updatedAt">>
): Promise<SectionStatus> {
  const current = await readSectionStatus();
  const next: SectionStatus = { ...current, ...patch, updatedAt: Date.now() };
  await writeSectionStatus(next);
  return next;
}

export function formatTimeAgo(
  timestampMs: number,
  nowMs: number = Date.now()
): string {
  const diffMs = Math.max(0, nowMs - timestampMs);
  const min = Math.floor(diffMs / 60000);

  if (min < 1) return "Just now";
  if (min < 60) return `${min}m ago`;

  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}h ago`;

  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}d ago`;

  const week = Math.floor(day / 7);
  if (week < 5) return `${week}w ago`;

  const month = Math.floor(day / 30);
  if (month < 12) return `${month}mo ago`;

  const year = Math.floor(day / 365);
  return `${year}y ago`;
}
</file>

<file path="app/(tabs)/_layout.tsx">
import { Tabs } from "expo-router";
import { Text } from "react-native";

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarStyle: {
          backgroundColor: "#020617",
          borderTopColor: "#0B1120",
        },
        tabBarActiveTintColor: "#F97316",
        tabBarInactiveTintColor: "#94A3B8",
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}>üè†</Text>
          ),
        }}
      />

      <Tabs.Screen
        name="explore"
        options={{
          title: "Explore",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}>üß≠</Text>
          ),
        }}
      />

      <Tabs.Screen
        name="chats"
        options={{
          title: "Chats",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}>üí¨</Text>
          ),
        }}
      />
    </Tabs>
  );
}
</file>

<file path="app/(tabs)/explore.tsx">
import React from "react";
import { StyleSheet, Text, View } from "react-native";

export default function ExploreScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Explore</Text>
      <Text style={styles.subtitle}>Coming soon...</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#0f172a",
  },
  title: {
    fontSize: 28,
    fontWeight: "bold",
    color: "#e5e7eb",
  },
  subtitle: {
    marginTop: 8,
    fontSize: 16,
    color: "#9ca3af",
  },
});
</file>

<file path="app/find-mentor.tsx">
// app/find-mentor.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import type { MatchingMode } from "../lib/api";
import {
  AvailabilitySlot,
  MentorMatch,
  SkillLearn,
  getMe,
  getMentorMatches,
} from "../lib/api";

// ‚úÖ chat: open conversation directly from results
import { getOrCreateConversation } from "../lib/chat/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points: number;
  xp: number;
  streak: number;
  skillsToLearn?: SkillLearn[];
  availabilitySlots?: AvailabilitySlot[];
};

type LevelOption = "Beginner" | "Intermediate" | "Advanced";

const LEVELS: { value: LevelOption; label: string }[] = [
  { value: "Beginner", label: "Beginner" },
  { value: "Intermediate", label: "Intermediate" },
  { value: "Advanced", label: "Advanced" },
];

const MODES: { value: MatchingMode; label: string; hint: string }[] = [
  { value: "local", label: "Local", hint: "Fast, no API key needed" },
  { value: "openai", label: "OpenAI", hint: "Semantic embeddings (needs key)" },
  { value: "hybrid", label: "Hybrid", hint: "OpenAI ‚Üí fallback to Local" },
];

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

export default function FindMentorScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loadingUser, setLoadingUser] = useState(true);
  const [loadingMatches, setLoadingMatches] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [selectedSkill, setSelectedSkill] = useState<string>("");
  const [customSkill, setCustomSkill] = useState<string>("");
  const [selectedLevel, setSelectedLevel] = useState<LevelOption>("Beginner");
  const [useMyAvailability, setUseMyAvailability] = useState<boolean>(true);
  const [mode, setMode] = useState<MatchingMode>("local");

  const [matches, setMatches] = useState<MentorMatch[]>([]);
  const [hasSearched, setHasSearched] = useState(false);

  // ---- Load current user ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      try {
        setErrorText(null);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const data = (await getMe(token)) as any;
        const userFromApi: User = (data?.user ?? data) as User;

        if (!isMounted) return;

        setUser(userFromApi);

        const skills = userFromApi.skillsToLearn ?? [];
        if (skills.length > 0 && skills[0]?.name) {
          setSelectedSkill(skills[0].name);
        }
      } catch (err: any) {
        console.log("FindMentor / getMe error:", err);
        if (isMounted) {
          setErrorText(
            err?.message ||
              "We couldn‚Äôt load your profile. Please go back and try again."
          );
        }
      } finally {
        if (isMounted) setLoadingUser(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, [router]);

  const learningSkills = useMemo(() => {
    const arr = user?.skillsToLearn ?? [];
    return arr
      .map((s) => ({
        name: String(s?.name || "").trim(),
        level: String((s as any)?.level || "Not specified").trim(),
      }))
      .filter((s) => !!s.name);
  }, [user?.skillsToLearn]);

  const availabilitySlots = useMemo(
    () => user?.availabilitySlots ?? [],
    [user?.availabilitySlots]
  );

  const effectiveSkill = useMemo(() => {
    if (customSkill.trim()) return customSkill.trim();
    return selectedSkill.trim();
  }, [customSkill, selectedSkill]);

  const canSearch = !!effectiveSkill && !loadingMatches && !loadingUser;

  const handleSearch = async () => {
    if (!canSearch) return;

    try {
      setErrorText(null);
      setLoadingMatches(true);
      setHasSearched(true);
      setMatches([]);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const payload = {
        skill: effectiveSkill,
        level: selectedLevel,
        availabilitySlots: useMyAvailability ? availabilitySlots : [],
        mode,
      };

      const res = await getMentorMatches(token, payload);
      setMatches(res.results ?? []);
    } catch (err: any) {
      console.log("getMentorMatches error:", err);
      setErrorText(
        err?.message ||
          "Something went wrong while searching for mentors. Please try again."
      );
    } finally {
      setLoadingMatches(false);
    }
  };

  const handleBack = () => router.back();

  // ‚úÖ NEW: open mentor profile
  const openMentorProfile = (mentorId: string) => {
    router.push({ pathname: "/mentor/[id]", params: { id: mentorId } } as any);
  };

  // ‚úÖ NEW: open chat directly
  const openMentorChat = async (mentorId: string) => {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return;
    }

    const conversationId = await getOrCreateConversation(token, mentorId);

    // ‚úÖ Ÿáÿ∞ÿß ŸáŸà ÿßŸÑÿ≠ŸÑ
    if (!conversationId || typeof conversationId !== "string") {
      console.warn("Invalid conversationId, aborting navigation");
      return;
    }

    router.push({
      pathname: "/(tabs)/chats/[conversationId]",
      params: { conversationId },
    });
  };

  const requestSession = (m: MentorMatch) => {
    router.push({
      pathname: "/sessions/request",
      params: {
        mentorId: m.mentorId,
        mentorName: m.fullName,
        skill: m.mainMatchedSkill?.name,
        level: m.mainMatchedSkill?.level,
      },
    } as any);
  };

  if (loadingUser && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your profile‚Ä¶</Text>
      </View>
    );
  }

  const noLearningSkills = learningSkills.length === 0;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={handleBack} activeOpacity={0.85}>
            <Text style={styles.backText}>‚Üê Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Find a mentor</Text>
        <Text style={styles.subtitle}>
          Pick a skill you want help with and we‚Äôll look for people who can
          teach you.
        </Text>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Something went wrong</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
          </View>
        )}

        {/* 0. Matching mode */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>0. Matching mode</Text>
          <Text style={styles.sectionDescription}>
            Switch matching method with one tap (no code changes).
          </Text>

          <View style={styles.levelRow}>
            {MODES.map((opt) => {
              const active = mode === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setMode(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>

          <Text style={styles.modeHint}>
            Current: <Text style={styles.modeHintStrong}>{mode}</Text> ‚Äî{" "}
            {MODES.find((m) => m.value === mode)?.hint}
          </Text>
        </View>

        {/* 1. Skill selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>1. Choose a skill</Text>
          <Text style={styles.sectionDescription}>
            Start with one of your learning goals, or type a custom skill.
          </Text>

          {noLearningSkills ? (
            <View style={styles.infoBox}>
              <Text style={styles.infoTitle}>No learning skills found</Text>
              <Text style={styles.infoBody}>
                You don‚Äôt have any learning goals yet. Go back to your dashboard
                and add some skills you want to learn.
              </Text>
            </View>
          ) : (
            <>
              <Text style={styles.label}>From your learning list</Text>
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.chipsRow}
              >
                {learningSkills.map((skillObj) => {
                  const active = selectedSkill === skillObj.name;
                  return (
                    <TouchableOpacity
                      key={skillObj.name}
                      onPress={() => setSelectedSkill(skillObj.name)}
                      style={[
                        styles.skillChip,
                        active && styles.skillChipActive,
                      ]}
                      activeOpacity={0.85}
                    >
                      <Text
                        style={[
                          styles.skillChipText,
                          active && styles.skillChipTextActive,
                        ]}
                      >
                        {skillObj.name}
                        {skillObj.level && skillObj.level !== "Not specified"
                          ? ` ¬∑ ${skillObj.level}`
                          : ""}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </ScrollView>
            </>
          )}

          <Text style={[styles.label, { marginTop: 10 }]}>
            Or type a custom skill
          </Text>
          <TextInput
            style={styles.input}
            placeholder="e.g. React Native, Public speaking"
            placeholderTextColor="#6b7280"
            value={customSkill}
            onChangeText={setCustomSkill}
          />

          <View style={styles.currentSkillBox}>
            <Text style={styles.currentSkillLabel}>Current search skill:</Text>
            <Text style={styles.currentSkillValue}>
              {effectiveSkill || "Not selected yet"}
            </Text>
          </View>
        </View>

        {/* 2. Level selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>2. Your level</Text>
          <Text style={styles.sectionDescription}>
            This helps us prioritize mentors who match your current experience.
          </Text>

          <View style={styles.levelRow}>
            {LEVELS.map((opt) => {
              const active = selectedLevel === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setSelectedLevel(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>

        {/* 3. Availability usage */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>3. Availability</Text>
          <Text style={styles.sectionDescription}>
            We can use your weekly availability to prioritize mentors who are
            free at similar times.
          </Text>

          <TouchableOpacity
            style={styles.toggleRow}
            onPress={() => setUseMyAvailability((prev) => !prev)}
            activeOpacity={0.85}
          >
            <View
              style={[
                styles.toggleOuter,
                useMyAvailability && styles.toggleOuterOn,
              ]}
            >
              <View
                style={[
                  styles.toggleInner,
                  useMyAvailability && styles.toggleInnerOn,
                ]}
              />
            </View>
            <Text style={styles.toggleLabel}>
              Use my weekly availability from dashboard
            </Text>
          </TouchableOpacity>

          {useMyAvailability && availabilitySlots.length > 0 && (
            <View style={styles.availabilityPreview}>
              {availabilitySlots.slice(0, 3).map((slot, idx) => (
                <Text key={idx} style={styles.availabilityLine}>
                  {dayNames[slot.dayOfWeek] ?? `Day ${slot.dayOfWeek}`}:{" "}
                  {slot.from} ‚Äì {slot.to}
                </Text>
              ))}
              {availabilitySlots.length > 3 && (
                <Text style={styles.availabilityMore}>
                  + {availabilitySlots.length - 3} more‚Ä¶
                </Text>
              )}
            </View>
          )}

          {useMyAvailability && availabilitySlots.length === 0 && (
            <Text style={styles.noAvailabilityText}>
              You don‚Äôt have any availability set yet. You can still search for
              mentors, but results won‚Äôt be filtered by time.
            </Text>
          )}
        </View>

        {/* Search button */}
        <TouchableOpacity
          style={[
            styles.searchButton,
            (!canSearch || loadingMatches) && styles.searchButtonDisabled,
          ]}
          onPress={handleSearch}
          disabled={!canSearch}
          activeOpacity={0.85}
        >
          {loadingMatches ? (
            <ActivityIndicator color="#ffffff" />
          ) : (
            <Text style={styles.searchButtonText}>Search for mentors</Text>
          )}
        </TouchableOpacity>

        {/* Results */}
        <View style={styles.resultsSection}>
          <Text style={styles.resultsTitle}>Results</Text>

          {!hasSearched && (
            <Text style={styles.resultsHint}>
              Start by selecting a skill and tapping ‚ÄúSearch for mentors‚Äù.
            </Text>
          )}

          {hasSearched && !loadingMatches && matches.length === 0 && (
            <Text style={styles.resultsHint}>
              No mentors found yet for this skill. Try another skill or relax
              your filters.
            </Text>
          )}

          {matches.map((m) => (
            <TouchableOpacity
              key={m.mentorId}
              activeOpacity={0.92}
              onPress={() => openMentorProfile(m.mentorId)}
              style={styles.matchCardClickable}
            >
              <View style={styles.matchHeaderRow}>
                <Text style={styles.matchName}>{m.fullName}</Text>
                <Text style={styles.matchScore}>
                  {Math.round(m.matchScore * 100)}%
                </Text>
              </View>

              {m.mainMatchedSkill && (
                <Text style={styles.matchSkillLine}>
                  Best match:{" "}
                  <Text style={styles.matchSkillHighlight}>
                    {m.mainMatchedSkill.name} ({m.mainMatchedSkill.level})
                  </Text>{" "}
                  ¬∑ similarity{" "}
                  {Math.round(m.mainMatchedSkill.similarityScore * 100)}%
                </Text>
              )}

              {m.skillsToTeach && m.skillsToTeach.length > 0 && (
                <View style={styles.matchSkillsList}>
                  <Text style={styles.matchSkillsLabel}>Teaches:</Text>
                  <Text style={styles.matchSkillsValue}>
                    {m.skillsToTeach
                      .slice(0, 3)
                      .map((s) => s.name)
                      .join(", ")}
                    {m.skillsToTeach.length > 3
                      ? ` +${m.skillsToTeach.length - 3} more`
                      : ""}
                  </Text>
                </View>
              )}

              {m.availabilitySlots && m.availabilitySlots.length > 0 && (
                <Text style={styles.matchAvailability}>
                  Example availability:{" "}
                  {dayNames[m.availabilitySlots[0].dayOfWeek] ??
                    `Day ${m.availabilitySlots[0].dayOfWeek}`}{" "}
                  ¬∑ {m.availabilitySlots[0].from} ‚Äì {m.availabilitySlots[0].to}
                </Text>
              )}

              {/* actions */}
              <View style={styles.actionsRow}>
                <TouchableOpacity
                  style={[styles.actionBtn, styles.actionSecondary]}
                  activeOpacity={0.85}
                  onPress={() => openMentorProfile(m.mentorId)}
                >
                  <Text style={styles.actionSecondaryText}>View profile</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.actionBtn, styles.actionPrimary]}
                  activeOpacity={0.85}
                  onPress={() => openMentorChat(m.mentorId)}
                >
                  <Text style={styles.actionPrimaryText}>Message</Text>
                </TouchableOpacity>
              </View>

              <TouchableOpacity
                style={styles.matchActionButton}
                activeOpacity={0.85}
                onPress={() => requestSession(m)}
              >
                <Text style={styles.matchActionText}>Request session</Text>
              </TouchableOpacity>

              <Text style={styles.tapHint}>
                Tip: tap anywhere on this card to open profile
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 14,
  },
  container: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 32,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  backText: {
    fontSize: 14,
    color: "#60A5FA",
  },
  title: {
    fontSize: 22,
    fontWeight: "700",
    color: "#F9FAFB",
    marginTop: 4,
  },
  subtitle: {
    fontSize: 13,
    color: "#9CA3AF",
    marginTop: 4,
    marginBottom: 14,
  },
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
  },
  card: {
    backgroundColor: "#020617",
    borderRadius: 16,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 14,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#F9FAFB",
    marginBottom: 4,
  },
  sectionDescription: {
    fontSize: 12,
    color: "#94A3B8",
    marginBottom: 10,
  },
  label: {
    fontSize: 12,
    color: "#CBD5F5",
    marginBottom: 4,
  },
  chipsRow: {
    flexDirection: "row",
    gap: 8,
    paddingVertical: 4,
  },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  skillChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  skillChipText: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  skillChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "600",
  },
  input: {
    marginTop: 2,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b5563",
    backgroundColor: "#020617",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#f9fafb",
  },
  currentSkillBox: {
    marginTop: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  currentSkillLabel: {
    color: "#94A3B8",
    fontSize: 11,
    marginBottom: 2,
  },
  currentSkillValue: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "500",
  },
  infoBox: {
    marginTop: 4,
    marginBottom: 8,
    padding: 10,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  infoTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 2,
  },
  infoBody: {
    color: "#9CA3AF",
    fontSize: 12,
  },
  levelRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 6,
  },
  levelChip: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
    alignItems: "center",
  },
  levelChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  levelChipText: {
    color: "#E5E7EB",
    fontSize: 13,
  },
  levelChipTextActive: {
    fontWeight: "600",
  },
  toggleRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
  },
  toggleOuter: {
    width: 38,
    height: 22,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#6B7280",
    padding: 2,
    justifyContent: "center",
  },
  toggleOuterOn: {
    borderColor: "#22C55E",
    backgroundColor: "#022C22",
  },
  toggleInner: {
    width: 16,
    height: 16,
    borderRadius: 999,
    backgroundColor: "#6B7280",
    alignSelf: "flex-start",
  },
  toggleInnerOn: {
    backgroundColor: "#22C55E",
    alignSelf: "flex-end",
  },
  toggleLabel: {
    marginLeft: 8,
    color: "#CBD5F5",
    fontSize: 12,
    flex: 1,
  },
  availabilityPreview: {
    marginTop: 8,
    padding: 8,
    borderRadius: 8,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#111827",
  },
  availabilityLine: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  availabilityMore: {
    color: "#9CA3AF",
    fontSize: 11,
    marginTop: 4,
  },
  noAvailabilityText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 12,
  },
  searchButton: {
    marginTop: 4,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  searchButtonDisabled: {
    opacity: 0.7,
  },
  searchButtonText: {
    color: "#ffffff",
    fontWeight: "600",
    fontSize: 15,
  },
  resultsSection: {
    marginTop: 18,
  },
  resultsTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "600",
    marginBottom: 4,
  },
  resultsHint: {
    color: "#9CA3AF",
    fontSize: 12,
  },

  // ‚úÖ clickable card
  matchCardClickable: {
    marginTop: 10,
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },

  matchHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 4,
  },
  matchName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "600",
  },
  matchScore: {
    color: "#F97316",
    fontSize: 14,
    fontWeight: "700",
  },
  matchSkillLine: {
    color: "#CBD5F5",
    fontSize: 12,
    marginTop: 4,
  },
  matchSkillHighlight: {
    color: "#FDE68A",
    fontWeight: "600",
  },
  matchSkillsList: {
    marginTop: 6,
  },
  matchSkillsLabel: {
    color: "#94A3B8",
    fontSize: 11,
  },
  matchSkillsValue: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  matchAvailability: {
    marginTop: 6,
    color: "#9CA3AF",
    fontSize: 11,
  },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 9,
    alignItems: "center",
  },
  actionPrimary: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
  },
  actionPrimaryText: {
    color: "#111827",
    fontSize: 12,
    fontWeight: "800",
  },
  actionSecondary: {
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  actionSecondaryText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  matchActionButton: {
    marginTop: 10,
    borderRadius: 999,
    paddingVertical: 9,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  matchActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  tapHint: {
    marginTop: 8,
    color: "#64748B",
    fontSize: 11,
  },

  modeHint: {
    marginTop: 10,
    color: "#9CA3AF",
    fontSize: 12,
  },
  modeHintStrong: {
    color: "#F9FAFB",
    fontWeight: "700",
  },
});
</file>

<file path="app/index.tsx">
import { Redirect } from "expo-router";

export default function Page() {
  return <Redirect href="/(tabs)" />;
}
</file>

<file path="app/sessions/components/SessionCard.tsx">
// app/sessions/components/SessionCard.tsx
import { useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  Modal,
  Pressable,
  Text,
  TextInput,
  View,
} from "react-native";

import type { SessionDTO, SessionStatus } from "../api/sessionsApi";
import { rateSession, updateSessionStatus } from "../api/sessionsApi";
import { formatSessionDateTime, statusBadge } from "../utils/formatSession";

// ‚úÖ Chat (get/create conversation)
import { getOrCreateConversation } from "../../../lib/chat/api";

type Props = {
  session: SessionDTO;
  token: string | null;
  currentUserId: string | null;
  onChanged: () => Promise<void>;
};

function clampInt(v: number, min: number, max: number) {
  const n = Math.floor(v);
  if (!Number.isFinite(n)) return min;
  return Math.max(min, Math.min(max, n));
}

export default function SessionCard({
  session,
  token,
  currentUserId,
  onChanged,
}: Props) {
  const router = useRouter();

  const [busy, setBusy] = useState(false);

  const [rateOpen, setRateOpen] = useState(false);
  const [rating, setRating] = useState<number>(5);
  const [feedback, setFeedback] = useState<string>("");

  const badge = useMemo(() => statusBadge(session.status), [session.status]);
  const when = useMemo(
    () => formatSessionDateTime(session.scheduledAt),
    [session.scheduledAt]
  );

  const isMentor = !!currentUserId && currentUserId === session.mentorId;
  const isLearner = !!currentUserId && currentUserId === session.learnerId;

  // ‚úÖ Rules (ŸÖÿ≠ÿ™ÿ±ŸÖÿ© ŸàŸàÿßŸÇÿπŸäÿ©)
  const canAcceptReject = isMentor && session.status === "requested";
  const canCancel =
    (isMentor || isLearner) &&
    (session.status === "requested" || session.status === "accepted");
  const canComplete = isMentor && session.status === "accepted";

  // ‚úÖ Rating Ÿäÿ∏Ÿáÿ± ÿ®ÿπÿØ completion + ÿ∫Ÿäÿ± ŸÖŸÉÿ±ÿ±
  const canRate =
    (isMentor || isLearner) &&
    session.status === "completed" &&
    !session.rating;

  // ‚úÖ Chat button: available for mentor/learner (any status)
  const canMessage = (isMentor || isLearner) && !!token && !!currentUserId;

  const handleMessage = async () => {
    try {
      if (!token || !currentUserId) {
        Alert.alert("Not logged in", "Please login again.");
        return;
      }

      const peerId = isMentor ? session.learnerId : session.mentorId;
      if (!peerId) {
        Alert.alert("Chat unavailable", "Could not find the other user.");
        return;
      }

      const conversationId = await getOrCreateConversation(token, peerId);

      if (!conversationId) {
        Alert.alert("Chat failed", "Could not create a conversation.");
        return;
      }

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: { conversationId },
      } as any);
    } catch (e: any) {
      Alert.alert("Chat failed", e?.message || "Please try again.");
    }
  };

  const setStatus = async (next: SessionStatus) => {
    if (!token) {
      Alert.alert("Not logged in", "Please login again.");
      return;
    }

    const pretty = next.charAt(0).toUpperCase() + next.slice(1).toLowerCase();

    Alert.alert(
      `${pretty}?`,
      `Are you sure you want to set this session to "${next}"?`,
      [
        { text: "No", style: "cancel" },
        {
          text: "Yes",
          style: "default",
          onPress: async () => {
            try {
              setBusy(true);
              await updateSessionStatus(token, session._id, next);
              await onChanged();
            } catch (e: any) {
              Alert.alert("Update failed", e?.message || "Please try again.");
            } finally {
              setBusy(false);
            }
          },
        },
      ]
    );
  };

  const submitRating = async () => {
    if (!token) {
      Alert.alert("Not logged in", "Please login again.");
      return;
    }

    try {
      setBusy(true);
      await rateSession(token, session._id, {
        rating: clampInt(rating, 1, 5),
        feedback: feedback.trim(),
      });
      setRateOpen(false);
      setFeedback("");
      setRating(5);
      await onChanged();
      Alert.alert("Thanks ‚úÖ", "Your rating was submitted.");
    } catch (e: any) {
      Alert.alert("Rating failed", e?.message || "Please try again.");
    } finally {
      setBusy(false);
    }
  };

  return (
    <View
      style={{
        backgroundColor: "#0B1120",
        borderWidth: 1,
        borderColor: "#1E293B",
        borderRadius: 14,
        padding: 12,
      }}
    >
      {/* Header */}
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
          gap: 10,
        }}
      >
        <Text style={{ color: "#F9FAFB", fontWeight: "900", fontSize: 14 }}>
          {session.skill} {session.level ? `¬∑ ${session.level}` : ""}
        </Text>

        <View
          style={{
            paddingHorizontal: 10,
            paddingVertical: 6,
            borderRadius: 999,
            backgroundColor: badge.bg,
            borderWidth: 1,
            borderColor: badge.border,
          }}
        >
          <Text style={{ color: badge.text, fontWeight: "900", fontSize: 12 }}>
            {badge.label}
          </Text>
        </View>
      </View>

      <Text style={{ color: "#94A3B8", marginTop: 8, fontSize: 12 }}>
        Scheduled: {when}
      </Text>

      {!!session.note && (
        <Text style={{ color: "#CBD5E1", marginTop: 6, fontSize: 12 }}>
          Note: {session.note}
        </Text>
      )}

      {/* Rating summary (if already rated) */}
      {session.status === "completed" && session.rating ? (
        <View style={{ marginTop: 10 }}>
          <Text style={{ color: "#FDE68A", fontWeight: "900", fontSize: 12 }}>
            Rated: {"‚≠ê".repeat(Math.max(1, Math.min(5, session.rating)))} (
            {session.rating}/5)
          </Text>
          {!!session.feedback && (
            <Text style={{ color: "#94A3B8", marginTop: 4, fontSize: 12 }}>
              Feedback: {session.feedback}
            </Text>
          )}
        </View>
      ) : null}

      {/* Actions */}
      <View
        style={{
          flexDirection: "row",
          flexWrap: "wrap",
          gap: 8,
          marginTop: 12,
        }}
      >
        {busy ? (
          <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
            <ActivityIndicator />
            <Text style={{ color: "#94A3B8", fontWeight: "900" }}>
              Working‚Ä¶
            </Text>
          </View>
        ) : (
          <>
            {/* ‚úÖ Message (available for mentor/learner from anywhere) */}
            {canMessage && (
              <ActionBtn
                label="Message"
                kind="neutral"
                onPress={handleMessage}
              />
            )}

            {canAcceptReject && (
              <>
                <ActionBtn
                  label="Accept"
                  kind="good"
                  onPress={() => setStatus("accepted")}
                />
                <ActionBtn
                  label="Reject"
                  kind="bad"
                  onPress={() => setStatus("rejected")}
                />
              </>
            )}

            {canCancel && (
              <ActionBtn
                label="Cancel"
                kind="neutral"
                onPress={() => setStatus("cancelled")}
              />
            )}

            {canComplete && (
              <ActionBtn
                label="Complete"
                kind="primary"
                onPress={() => setStatus("completed")}
              />
            )}

            {canRate && (
              <ActionBtn
                label="Rate session"
                kind="primary"
                onPress={() => setRateOpen(true)}
              />
            )}
          </>
        )}
      </View>

      {/* Rate Modal */}
      <Modal visible={rateOpen} transparent animationType="fade">
        <View
          style={{
            flex: 1,
            backgroundColor: "rgba(0,0,0,0.55)",
            justifyContent: "center",
            padding: 16,
          }}
        >
          <View
            style={{
              backgroundColor: "#0B1120",
              borderRadius: 16,
              borderWidth: 1,
              borderColor: "#1E293B",
              padding: 14,
            }}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
              Rate this session
            </Text>

            <Text style={{ color: "#94A3B8", marginTop: 6, fontSize: 12 }}>
              Give a quick rating and optional feedback.
            </Text>

            {/* Stars row */}
            <View style={{ flexDirection: "row", gap: 8, marginTop: 12 }}>
              {[1, 2, 3, 4, 5].map((n) => {
                const active = n <= rating;
                return (
                  <Pressable
                    key={n}
                    onPress={() => setRating(n)}
                    style={{
                      paddingHorizontal: 10,
                      paddingVertical: 10,
                      borderRadius: 12,
                      borderWidth: 1,
                      borderColor: active ? "#F97316" : "#334155",
                      backgroundColor: active ? "#111827" : "#020617",
                    }}
                  >
                    <Text
                      style={{
                        color: active ? "#FED7AA" : "#94A3B8",
                        fontWeight: "900",
                      }}
                    >
                      ‚≠ê {n}
                    </Text>
                  </Pressable>
                );
              })}
            </View>

            <TextInput
              value={feedback}
              onChangeText={setFeedback}
              placeholder="Optional feedback‚Ä¶"
              placeholderTextColor="#64748B"
              multiline
              style={{
                marginTop: 12,
                minHeight: 90,
                borderRadius: 12,
                borderWidth: 1,
                borderColor: "#1F2937",
                backgroundColor: "#020617",
                color: "#E5E7EB",
                paddingHorizontal: 12,
                paddingVertical: 10,
                textAlignVertical: "top",
                fontWeight: "700",
              }}
            />

            <View style={{ flexDirection: "row", gap: 10, marginTop: 12 }}>
              <Pressable
                onPress={() => setRateOpen(false)}
                style={{
                  flex: 1,
                  borderRadius: 999,
                  paddingVertical: 12,
                  alignItems: "center",
                  borderWidth: 1,
                  borderColor: "#334155",
                  backgroundColor: "#020617",
                }}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                  Cancel
                </Text>
              </Pressable>

              <Pressable
                onPress={submitRating}
                style={{
                  flex: 1,
                  borderRadius: 999,
                  paddingVertical: 12,
                  alignItems: "center",
                  borderWidth: 1,
                  borderColor: "#FB923C",
                  backgroundColor: "#F97316",
                }}
              >
                <Text style={{ color: "#111827", fontWeight: "900" }}>
                  Submit
                </Text>
              </Pressable>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

function ActionBtn({
  label,
  onPress,
  kind,
}: {
  label: string;
  onPress: () => void;
  kind: "primary" | "good" | "bad" | "neutral";
}) {
  const styleByKind =
    kind === "good"
      ? { bg: "#22C55E", text: "#022C22", border: "#16A34A" }
      : kind === "bad"
      ? { bg: "#B91C1C", text: "#FEE2E2", border: "#EF4444" }
      : kind === "primary"
      ? { bg: "#F97316", text: "#111827", border: "#FB923C" }
      : { bg: "#020617", text: "#E5E7EB", border: "#334155" };

  return (
    <Pressable
      onPress={onPress}
      style={({ pressed }) => [
        {
          paddingHorizontal: 12,
          paddingVertical: 10,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: styleByKind.border,
          backgroundColor: styleByKind.bg,
        },
        pressed ? { opacity: 0.9 } : null,
      ]}
    >
      <Text
        style={{ color: styleByKind.text, fontWeight: "900", fontSize: 12 }}
      >
        {label}
      </Text>
    </Pressable>
  );
}
</file>

<file path="app/weekly-availability/components.tsx">
// app/weekly-availability/components.tsx
import React, { useMemo } from "react";
import { Text, TouchableOpacity, View } from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { styles } from "./styles";

type DaySelectorProps = {
  selectedDay: number;
  onSelect: (dayIndex: number) => void;
  onLongPressDay?: (dayIndex: number) => void;
  dayNames: string[]; // ["Sun".."Sat"]
  todayIndex: number;
};

export const DaySelector: React.FC<DaySelectorProps> = ({
  selectedDay,
  onSelect,
  onLongPressDay,
  dayNames,
  todayIndex,
}) => {
  return (
    <View style={styles.daySelectorRow}>
      {dayNames.map((d, idx) => {
        const isSelected = idx === selectedDay;
        const isToday = idx === todayIndex;

        return (
          <TouchableOpacity
            key={`${d}-${idx}`}
            style={[
              styles.dayChip,
              isToday && styles.dayChipToday,
              isSelected && styles.dayChipSelected,
            ]}
            onPress={() => onSelect(idx)}
            onLongPress={() => onLongPressDay?.(idx)}
            delayLongPress={250}
            activeOpacity={0.85}
            accessibilityRole="button"
            accessibilityLabel={`Select ${d}`}
          >
            <Text
              style={[
                styles.dayChipText,
                isToday && styles.dayChipTextToday,
                isSelected && styles.dayChipTextSelected,
              ]}
            >
              {d}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

// ====================== Day Card ======================

type DayAvailabilityCardProps = {
  dayIndex: number;
  dayLabel: string;
  slots: AvailabilitySlot[];
  totalMinutesForDay: number;

  collapsed: boolean;
  onToggleCollapsed: (dayIndex: number) => void;

  onRemoveSlot: (slot: AvailabilitySlot) => void;
  onEditSlot: (slot: AvailabilitySlot) => void;
  onClearDay: (dayIndex: number) => void;

  onCopyDay: (dayIndex: number) => void;

  onQuickAdd?: (dayIndex: number, from: string, to: string) => void;

  highlightSlotKey?: string | null; // `${from}-${to}`
};

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export const DayAvailabilityCard: React.FC<DayAvailabilityCardProps> = ({
  dayIndex,
  dayLabel,
  slots,
  totalMinutesForDay,
  collapsed,
  onToggleCollapsed,
  onRemoveSlot,
  onEditSlot,
  onClearDay,
  onCopyDay,
  onQuickAdd,
  highlightSlotKey,
}) => {
  const dayHasSlots = slots.length > 0;

  const daySub = useMemo(() => {
    if (!dayHasSlots) return "No slots yet";
    return `${slots.length} slot${
      slots.length === 1 ? "" : "s"
    } ¬∑ ${minutesToHuman(totalMinutesForDay)}`;
  }, [dayHasSlots, slots.length, totalMinutesForDay]);

  const showQuickForEmpty = !dayHasSlots;

  return (
    <View style={styles.dayCard}>
      {/* Header */}
      <View style={styles.dayHeaderRow}>
        <TouchableOpacity
          onPress={() => onToggleCollapsed(dayIndex)}
          activeOpacity={0.85}
          style={{ flex: 1 }}
          accessibilityRole="button"
          accessibilityLabel={`Toggle ${dayLabel}`}
        >
          <Text style={styles.dayName}>
            {dayLabel}{" "}
            <Text style={{ color: "#64748B", fontSize: 12, fontWeight: "900" }}>
              {collapsed ? "‚ñ∏" : "‚ñæ"}
            </Text>
          </Text>
          <Text style={styles.daySubText}>{daySub}</Text>
        </TouchableOpacity>

        <View style={styles.dayHeaderActions}>
          {dayHasSlots ? (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          ) : (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          )}
        </View>
      </View>

      {/* Body */}
      {collapsed ? (
        <Text style={styles.daySlotsEmptyText}>
          {dayHasSlots ? "Collapsed" : "Collapsed (empty)"}
        </Text>
      ) : (
        <>
          {/* Empty state quick actions */}
          {showQuickForEmpty && onQuickAdd && (
            <View style={{ marginTop: 6 }}>
              <Text style={styles.daySlotsEmptyText}>
                Add something quick to get started:
              </Text>

              <View style={styles.quickRow}>
                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "18:00", "20:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>18:00‚Äì20:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "20:00", "22:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>20:00‚Äì22:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "10:00", "14:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>10:00‚Äì14:00</Text>
                </TouchableOpacity>
              </View>
            </View>
          )}

          {/* Slots */}
          {dayHasSlots ? (
            <View style={[styles.slotChipRow, { marginTop: 10 }]}>
              {slots.map((slot, idx) => {
                const key = `${slot.from}-${slot.to}`;
                const isHighlight = highlightSlotKey === key;

                return (
                  <TouchableOpacity
                    key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                    style={[
                      styles.slotChip,
                      isHighlight && {
                        borderColor: "#60A5FA",
                        backgroundColor: "#0B1120",
                      },
                    ]}
                    onPress={() => onEditSlot(slot)}
                    activeOpacity={0.85}
                    accessibilityRole="button"
                    accessibilityLabel={`Edit ${slot.from} to ${slot.to}`}
                  >
                    <Text style={styles.slotChipText}>
                      {slot.from} ‚Äì {slot.to}
                    </Text>

                    <TouchableOpacity
                      onPress={() => onRemoveSlot(slot)}
                      activeOpacity={0.85}
                      accessibilityRole="button"
                      accessibilityLabel={`Remove ${slot.from} to ${slot.to}`}
                    >
                      <Text style={styles.slotRemoveText}>Remove</Text>
                    </TouchableOpacity>
                  </TouchableOpacity>
                );
              })}
            </View>
          ) : (
            !onQuickAdd && (
              <Text style={[styles.daySlotsEmptyText, { marginTop: 6 }]}>
                No slots.
              </Text>
            )
          )}
        </>
      )}
    </View>
  );
};

// ====================== SaveBar ======================

type SaveBarProps = {
  hasChanges: boolean;
  saving: boolean;
  onSave: () => void;
  onDiscard: () => void;
};

export const SaveBar: React.FC<SaveBarProps> = ({
  hasChanges,
  saving,
  onSave,
  onDiscard,
}) => {
  if (!hasChanges) return null;

  return (
    <View style={styles.saveBarSticky}>
      <View style={styles.saveRow}>
        <Text style={styles.saveHint}>
          You have unsaved changes. Save to update your profile.
        </Text>

        <TouchableOpacity
          style={styles.discardButton}
          onPress={onDiscard}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.discardText}>Discard</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.saveButton, saving && styles.saveButtonDisabled]}
          onPress={onSave}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.saveText}>{saving ? "Saving‚Ä¶" : "Save"}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};
</file>

<file path="app/weekly-availability/index.tsx">
// app/weekly-availability/index.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  ScrollView,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { getMe, updateProfile } from "../../lib/api";
import {
  getPendingWeeklyAvailability,
  getWeeklyLastSavedAt,
  markWeeklyAvailabilitySynced,
  setPendingWeeklyAvailability,
  clearPendingWeeklyAvailability,
} from "../../lib/availabilityStorage";
import SaveBar from "./SaveBar";
import TimeField from "./TimeField";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function isValidSlot(s: AvailabilitySlot) {
  return timeToMinutes(s.to) > timeToMinutes(s.from);
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  const diff = Date.now() - ts;
  if (diff < 60_000) return "Just now";
  if (diff < 60 * 60_000) return `${Math.floor(diff / 60_000)}m ago`;
  if (diff < 24 * 60 * 60_000) return `${Math.floor(diff / (60 * 60_000))}h ago`;
  return new Date(ts).toLocaleDateString();
}

function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  // clean + sort for stable comparisons
  const clean = (Array.isArray(slots) ? slots : [])
    .map((s) => ({
      dayOfWeek: Number((s as any)?.dayOfWeek ?? 0),
      from: String((s as any)?.from ?? "18:00"),
      to: String((s as any)?.to ?? "19:00"),
    }))
    .filter((s) => s.dayOfWeek >= 0 && s.dayOfWeek <= 6);

  clean.sort((a, b) => a.dayOfWeek - b.dayOfWeek || timeToMinutes(a.from) - timeToMinutes(b.from));
  return clean;
}

function slotsEqual(a: AvailabilitySlot[], b: AvailabilitySlot[]) {
  const A = normalizeSlots(a);
  const B = normalizeSlots(b);
  if (A.length !== B.length) return false;
  for (let i = 0; i < A.length; i++) {
    if (A[i].dayOfWeek !== B[i].dayOfWeek) return false;
    if (A[i].from !== B[i].from) return false;
    if (A[i].to !== B[i].to) return false;
  }
  return true;
}

export default function WeeklyAvailabilityScreen() {
  const router = useRouter();
  const mountedRef = useRef(true);

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  const [selectedDay, setSelectedDay] = useState<number>(0);

  const [serverSlots, setServerSlots] = useState<AvailabilitySlot[]>([]);
  const [draftSlots, setDraftSlots] = useState<AvailabilitySlot[]>([]);

  const [restorePrompt, setRestorePrompt] = useState<null | {
    updatedAtISO: string;
    slots: AvailabilitySlot[];
  }>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  const lastSavedText = useMemo(() => formatLastUpdated(lastSavedAt), [lastSavedAt]);

  const dirty = useMemo(() => !slotsEqual(serverSlots, draftSlots), [serverSlots, draftSlots]);

  const daySlots = useMemo(
    () => draftSlots.filter((s) => Number(s.dayOfWeek) === Number(selectedDay)),
    [draftSlots, selectedDay]
  );

  useEffect(() => {
    mountedRef.current = true;

    (async () => {
      try {
        setLoading(true);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const [me, pending, ts] = await Promise.all([
          getMe(token),
          getPendingWeeklyAvailability(),
          getWeeklyLastSavedAt(),
        ]);

        const userFromApi: any = (me as any)?.user ?? me;
        const slotsFromApi = normalizeSlots(userFromApi?.availabilitySlots ?? []);

        if (!mountedRef.current) return;

        setServerSlots(slotsFromApi);
        setDraftSlots(slotsFromApi);
        setLastSavedAt(ts);

        if (pending?.slots?.length) {
          const pendingSlots = normalizeSlots(pending.slots);
          // show restore only if it differs from server
          if (!slotsEqual(pendingSlots, slotsFromApi)) {
            setRestorePrompt({
              updatedAtISO: pending.updatedAtISO,
              slots: pendingSlots,
            });
          } else {
            // pending same as server -> cleanup
            await clearPendingWeeklyAvailability();
          }
        }
      } catch (e: any) {
        console.log("weekly availability load error:", e);
        Alert.alert(
          "Couldn‚Äôt load availability",
          e?.message || "Please try again."
        );
      } finally {
        if (mountedRef.current) setLoading(false);
      }
    })();

    return () => {
      mountedRef.current = false;
    };
  }, [router]);

  // Auto store pending draft when user changes (simple, safe)
  useEffect(() => {
    if (loading) return;
    if (!dirty) return;
    setPendingWeeklyAvailability(draftSlots, "user-edit");
  }, [draftSlots, dirty, loading]);

  const addSlot = () => {
    setDraftSlots((prev) =>
      normalizeSlots([
        ...prev,
        { dayOfWeek: selectedDay, from: "18:00", to: "19:00" },
      ])
    );
  };

  const updateSlot = (idxInDay: number, patch: Partial<AvailabilitySlot>) => {
    // map daySlots index to actual index in draftSlots
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.map((s) => {
        if (
          Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
          s.from === target.from &&
          s.to === target.to
        ) {
          return { ...s, ...patch };
        }
        return s;
      });
      return normalizeSlots(next);
    });
  };

  const removeSlot = (idxInDay: number) => {
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.filter(
        (s) =>
          !(
            Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
            s.from === target.from &&
            s.to === target.to
          )
      );
      return normalizeSlots(next);
    });
  };

  const restorePending = async () => {
    if (!restorePrompt) return;
    setDraftSlots(restorePrompt.slots);
    setRestorePrompt(null);
  };

  const discardPending = async () => {
    setRestorePrompt(null);
    await clearPendingWeeklyAvailability();
  };

  const discardChanges = () => {
    setDraftSlots(serverSlots);
  };

  const save = async () => {
    const invalid = draftSlots.some((s) => !isValidSlot(s));
    if (invalid) {
      Alert.alert(
        "Fix time slots",
        "Make sure every slot has From earlier than To."
      );
      return;
    }

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      await updateProfile(token, {
        availabilitySlots: normalizeSlots(draftSlots),
      } as any);

      if (!mountedRef.current) return;

      const normalized = normalizeSlots(draftSlots);
      setServerSlots(normalized);
      setDraftSlots(normalized);

      await markWeeklyAvailabilitySynced();
      const ts = await getWeeklyLastSavedAt();
      setLastSavedAt(ts);

      Alert.alert("Saved ‚úÖ", "Your weekly availability has been updated.");
    } catch (e: any) {
      console.log("weekly availability save error:", e);
      Alert.alert(
        "Save failed",
        e?.message || "Couldn‚Äôt save. Please try again."
      );
    } finally {
      if (mountedRef.current) setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={{ flex: 1, backgroundColor: "#020617", alignItems: "center", justifyContent: "center" }}>
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>Loading availability‚Ä¶</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <View style={{ flex: 1 }}>
        <ScrollView
          contentContainerStyle={{ padding: 16, paddingBottom: 110 }}
          keyboardShouldPersistTaps="handled"
        >
          {/* Header */}
          <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
            <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
              <Text style={{ color: "#60A5FA", fontWeight: "900" }}>‚Üê Back</Text>
            </TouchableOpacity>

            <Text style={{ color: "#94A3B8", fontSize: 12, fontWeight: "800" }}>
              Last saved: {lastSavedText}
            </Text>
          </View>

          <Text style={{ color: "#F9FAFB", fontSize: 22, fontWeight: "900", marginTop: 10 }}>
            Weekly availability
          </Text>
          <Text style={{ color: "#94A3B8", marginTop: 6, lineHeight: 18, fontSize: 12 }}>
            Add 1‚Äì2 time slots (evenings/weekend). Better mentor matches when your schedule is clear.
          </Text>

          {/* Restore pending banner */}
          {restorePrompt && (
            <View
              style={{
                marginTop: 12,
                backgroundColor: "#0B1120",
                borderWidth: 1,
                borderColor: "#1E293B",
                borderRadius: 14,
                padding: 12,
              }}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
                Restore unsaved changes?
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 12, marginTop: 4, lineHeight: 16 }}>
                Found a previous edit from {new Date(restorePrompt.updatedAtISO).toLocaleString()}.
              </Text>

              <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                <Pressable
                  onPress={restorePending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#22C55E",
                      borderRadius: 999,
                      paddingVertical: 10,
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#022C22", fontWeight: "900" }}>Restore</Text>
                </Pressable>

                <Pressable
                  onPress={discardPending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#020617",
                      borderRadius: 999,
                      paddingVertical: 10,
                      borderWidth: 1,
                      borderColor: "#334155",
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>Discard</Text>
                </Pressable>
              </View>
            </View>
          )}

          {/* Day selector */}
          <View style={{ flexDirection: "row", gap: 8, flexWrap: "wrap", marginTop: 14 }}>
            {dayNames.map((d, idx) => {
              const active = idx === selectedDay;
              return (
                <Pressable
                  key={d}
                  onPress={() => setSelectedDay(idx)}
                  style={({ pressed }) => [
                    {
                      paddingHorizontal: 12,
                      paddingVertical: 8,
                      borderRadius: 999,
                      borderWidth: 1,
                      borderColor: active ? "#F97316" : "#1E293B",
                      backgroundColor: active ? "#0B1120" : "#020617",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: active ? "#FED7AA" : "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                    {d}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          {/* Slots for selected day */}
          <View style={{ marginTop: 14 }}>
            <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
              <Text style={{ color: "#F9FAFB", fontWeight: "900", fontSize: 14 }}>
                {dayNames[selectedDay]} slots
              </Text>

              <TouchableOpacity onPress={addSlot} activeOpacity={0.85}>
                <Text style={{ color: "#60A5FA", fontWeight: "900" }}>+ Add</Text>
              </TouchableOpacity>
            </View>

            {daySlots.length === 0 ? (
              <View
                style={{
                  marginTop: 10,
                  backgroundColor: "#020617",
                  borderWidth: 1,
                  borderColor: "#111827",
                  borderRadius: 14,
                  padding: 12,
                }}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "800" }}>No slots yet</Text>
                <Text style={{ color: "#64748B", marginTop: 4, fontSize: 12, lineHeight: 16 }}>
                  Tap ‚ÄúAdd‚Äù to create your first slot for this day.
                </Text>
              </View>
            ) : (
              <View style={{ marginTop: 10, gap: 10 }}>
                {daySlots.map((slot, idx) => {
                  const ok = isValidSlot(slot);
                  return (
                    <View
                      key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                      style={{
                        backgroundColor: "#0B1120",
                        borderWidth: 1,
                        borderColor: ok ? "#1E293B" : "#FCA5A5",
                        borderRadius: 14,
                        padding: 12,
                      }}
                    >
                      <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
                        <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                          Slot #{idx + 1} {ok ? "" : " (Fix time)"}
                        </Text>

                        <Pressable
                          onPress={() => removeSlot(idx)}
                          style={({ pressed }) => [
                            {
                              paddingHorizontal: 10,
                              paddingVertical: 6,
                              borderRadius: 999,
                              borderWidth: 1,
                              borderColor: "#334155",
                              backgroundColor: "#020617",
                            },
                            pressed ? { opacity: 0.85 } : null,
                          ]}
                        >
                          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>Remove</Text>
                        </Pressable>
                      </View>

                      <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            From
                          </Text>
                          <TimeField
                            value={slot.from}
                            onChange={(v: string) => updateSlot(idx, { from: v })}
                          />
                        </View>

                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            To
                          </Text>
                          <TimeField
                            value={slot.to}
                            onChange={(v: string) => updateSlot(idx, { to: v })}
                          />
                        </View>
                      </View>

                      {!ok && (
                        <Text style={{ color: "#FCA5A5", marginTop: 10, fontWeight: "900", fontSize: 12 }}>
                          ‚ÄúTo‚Äù must be later than ‚ÄúFrom‚Äù.
                        </Text>
                      )}
                    </View>
                  );
                })}
              </View>
            )}
          </View>

          {/* Small reset button (non-intrusive) */}
          {dirty && (
            <Pressable
              onPress={discardChanges}
              style={({ pressed }) => [
                {
                  marginTop: 16,
                  alignSelf: "flex-start",
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  borderRadius: 999,
                  borderWidth: 1,
                  borderColor: "#334155",
                  backgroundColor: "#020617",
                },
                pressed ? { opacity: 0.9 } : null,
              ]}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                Reset to last saved
              </Text>
            </Pressable>
          )}
        </ScrollView>

        <SaveBar
          visible={dirty}
          saving={saving}
          onSave={save}
          onDiscard={discardChanges}
          lastSavedText={lastSavedText}
        />
      </View>
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/weekly-availability/TimeField.tsx">
// app/weekly-availability/TimeField.tsx
import React, { useEffect, useState } from "react";
import { Platform, StyleSheet, Text, TextInput, View } from "react-native";

type Props = {
  label?: string;
  value: string;
  onChange: (v: string) => void;
  placeholder?: string;
  disabled?: boolean;
};

function normalizeTimeInput(raw: string): string {
  let s = raw.replace(/[^\d:]/g, "");

  const digitsOnly = s.replace(/:/g, "");
  if (!s.includes(":") && digitsOnly.length >= 3) {
    const hh = digitsOnly.slice(0, 2);
    const mm = digitsOnly.slice(2, 4);
    s = `${hh}:${mm}`;
  }

  if (s.length > 5) s = s.slice(0, 5);

  if (s.includes(":")) {
    const [hhRaw = "", mmRaw = ""] = s.split(":");
    const hh = hhRaw.slice(0, 2);
    const mm = mmRaw.slice(0, 2);
    s = `${hh}:${mm}`;
  }

  return s;
}

function isValidPartialTime(v: string): boolean {
  if (v === "") return true;
  if (!/^\d{0,2}(:\d{0,2})?$/.test(v)) return false;

  const [hhStr, mmStr] = v.split(":");
  if (hhStr.length > 0) {
    const hh = Number(hhStr);
    if (!Number.isFinite(hh) || hh > 23) return false;
  }
  if (mmStr !== undefined && mmStr.length > 0) {
    const mm = Number(mmStr);
    if (!Number.isFinite(mm) || mm > 59) return false;
  }
  return true;
}

export default function TimeField({
  label,
  value,
  onChange,
  placeholder = "HH:MM",
  disabled = false,
}: Props) {
  const [local, setLocal] = useState<string>(value ?? "");

  // ‚úÖ ÿßŸÑÿµÿ≠Ÿäÿ≠: side-effect -> useEffect
  useEffect(() => {
    setLocal(value ?? "");
  }, [value]);

  const onTextChange = (txt: string) => {
    const normalized = normalizeTimeInput(txt);
    if (!isValidPartialTime(normalized)) return;

    setLocal(normalized);
    onChange(normalized);
  };

  return (
    <View style={styles.wrap}>
      {label ? <Text style={styles.label}>{label}</Text> : null}

      <TextInput
        value={local}
        onChangeText={onTextChange}
        placeholder={placeholder}
        editable={!disabled}
        keyboardType={Platform.select({
          ios: "numbers-and-punctuation",
          android: "numeric",
          default: "numeric",
        })}
        style={[styles.input, disabled && styles.inputDisabled]}
        placeholderTextColor="#64748B"
        maxLength={5}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
  },
  label: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "900",
    marginBottom: 6,
  },
  input: {
    borderWidth: 1,
    borderColor: "#1F2937",
    backgroundColor: "#0B1220",
    color: "#E5E7EB",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    fontSize: 14,
    fontWeight: "700",
  },
  inputDisabled: {
    opacity: 0.6,
  },
});
</file>

<file path="app/weekly-availability/useWeeklyAvailability.ts">
// app/weekly-availability/useWeeklyAvailability.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  AvailabilitySlot,
  getMe,
  updateWeeklyAvailability,
} from "../../lib/api";

/**
 * Local key for "last saved" timestamp (used by Home + Weekly Availability)
 */
const WEEKLY_AVAIL_LAST_SAVED_KEY = "weeklyAvailability_lastSavedAt_v1";

/**
 * Sort slots by day, then time
 */
export function sortAvailability(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return [...slots].sort((a, b) => {
    if (a.dayOfWeek !== b.dayOfWeek) return a.dayOfWeek - b.dayOfWeek;
    return a.from.localeCompare(b.from);
  });
}

/**
 * Normalize + validate slots coming from API or UI
 */
function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return sortAvailability(
    (Array.isArray(slots) ? slots : [])
      .filter(
        (s) =>
          typeof s?.dayOfWeek === "number" &&
          s.dayOfWeek >= 0 &&
          s.dayOfWeek <= 6 &&
          typeof s?.from === "string" &&
          typeof s?.to === "string" &&
          s.from.trim() &&
          s.to.trim()
      )
      .map((s) => ({
        dayOfWeek: s.dayOfWeek,
        from: s.from.trim(),
        to: s.to.trim(),
      }))
  );
}

/**
 * Stable deep-equality key
 */
function slotsKey(slots: AvailabilitySlot[]): string {
  return normalizeSlots(slots)
    .map((s) => `${s.dayOfWeek}|${s.from}|${s.to}`)
    .join(";");
}

async function readLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(WEEKLY_AVAIL_LAST_SAVED_KEY);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

async function writeLastSavedAt(ts: number): Promise<void> {
  try {
    await AsyncStorage.setItem(WEEKLY_AVAIL_LAST_SAVED_KEY, String(ts));
  } catch {
    // ignore
  }
}

export type UserProfile = {
  _id: string;
  fullName: string;
  email: string;
  availabilitySlots?: AvailabilitySlot[];
  skillsToLearn?: any[];
  skillsToTeach?: any[];
};

type UseWeeklyAvailabilityResult = {
  user: UserProfile | null;
  availability: AvailabilitySlot[];
  loading: boolean;
  saving: boolean;
  errorText: string | null;
  hasChanges: boolean;
  lastSavedAt: number | null;

  reload: () => Promise<void>;
  save: () => Promise<boolean>;

  updateAvailability: (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => void;

  setErrorText: (t: string | null) => void;
};

export function useWeeklyAvailability(): UseWeeklyAvailabilityResult {
  const router = useRouter();

  const [user, setUser] = useState<UserProfile | null>(null);
  const [availability, setAvailability] = useState<AvailabilitySlot[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  /**
   * Baseline snapshot to detect unsaved changes
   */
  const baselineKeyRef = useRef<string>("");

  const hasChanges = useMemo(() => {
    return slotsKey(availability) !== baselineKeyRef.current;
  }, [availability]);

  /**
   * Load profile + availability
   */
  const reload = useCallback(async () => {
    try {
      setLoading(true);
      setErrorText(null);

      // load lastSavedAt (fast + local)
      const savedTs = await readLastSavedAt();
      setLastSavedAt(savedTs);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        // ‚úÖ keep consistent with your auth group routes
        router.replace("/(auth)/login" as any);
        return;
      }

      const data = (await getMe(token)) as UserProfile;
      const normalized = normalizeSlots(data.availabilitySlots || []);

      setUser(data);
      setAvailability(normalized);
      baselineKeyRef.current = slotsKey(normalized);

      // If user already has availability from backend but no local timestamp yet,
      // set a helpful baseline timestamp once (not critical, but improves UX).
      if (!savedTs && normalized.length > 0) {
        const now = Date.now();
        setLastSavedAt(now);
        await writeLastSavedAt(now);
      }
    } catch (err: any) {
      console.log("weekly-availability / load error:", err);
      setErrorText(
        err?.message || "We couldn‚Äôt load your availability. Please try again."
      );
    } finally {
      setLoading(false);
    }
  }, [router]);

  useEffect(() => {
    reload();
  }, [reload]);

  /**
   * Safe updater wrapper (always normalizes)
   */
  const updateAvailability = (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => {
    setAvailability((prev) => normalizeSlots(updater(prev)));
  };

  /**
   * Save changes to backend
   */
  const save = useCallback(async () => {
    // ‚úÖ prevents double taps + saves only when needed
    if (saving || !hasChanges) return false;

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return false;
      }

      const normalized = normalizeSlots(availability);

      const updated = (await updateWeeklyAvailability(
        token,
        normalized
      )) as UserProfile;

      const updatedNormalized = normalizeSlots(updated.availabilitySlots || []);

      setUser(updated);
      setAvailability(updatedNormalized);
      baselineKeyRef.current = slotsKey(updatedNormalized);

      // ‚úÖ write "last saved" timestamp for Home + other screens
      const now = Date.now();
      setLastSavedAt(now);
      await writeLastSavedAt(now);

      return true;
    } catch (err: any) {
      console.log("weekly-availability / save error:", err);
      setErrorText(
        err?.message || "Something went wrong while saving your availability."
      );
      return false;
    } finally {
      setSaving(false);
    }
  }, [availability, hasChanges, router, saving]);

  return {
    user,
    availability,
    loading,
    saving,
    errorText,
    hasChanges,
    lastSavedAt,

    reload,
    save,
    updateAvailability,
    setErrorText,
  };
}
</file>

<file path="app/(tabs)/index.tsx">
import HomeScreen from "../screens/homescreen";

export default function TabHome() {
  return <HomeScreen />;
}
</file>

<file path="app/login.tsx">
export { default } from "./(auth)/login";
</file>

<file path="app/signup.tsx">

</file>

<file path="lib/api.ts">
// lib/api.ts
import Constants from "expo-constants";
import { Platform } from "react-native";

function getDevHostFromExpo(): string | null {
  // Expo dev host (often available in dev mode)
  const anyConst = Constants as any;

  // common places across SDKs
  const debuggerHost: string | undefined = anyConst?.debuggerHost;
  const hostUri: string | undefined = anyConst?.expoConfig?.hostUri;

  const raw = debuggerHost || hostUri || "";
  if (!raw) return null;

  // examples:
  // "192.168.1.50:8081"
  // "exp://192.168.1.50:8081"
  // "http://192.168.1.50:8081"
  const cleaned = raw
    .replace("exp://", "")
    .replace("http://", "")
    .replace("https://", "");
  const host = cleaned.split(":")[0]?.trim();
  return host || null;
}

function resolveApiUrl(): string {
  const envUrlRaw = (process.env.EXPO_PUBLIC_API_URL || "").trim();

  // In Web we can safely use localhost if server is on same machine
  if (Platform.OS === "web") {
    // Prefer explicit env if provided
    if (envUrlRaw) return envUrlRaw;

    const host =
      (typeof window !== "undefined" && window.location?.hostname) || "localhost";
    return `http://${host}:4000`;
  }

  // Native (Android/iOS)
  // If user mistakenly set localhost in env, it breaks real devices.
  // We'll ignore localhost env on native and auto-resolve correctly.
  const envIsLocalhost =
    envUrlRaw.includes("localhost") || envUrlRaw.includes("127.0.0.1");

  if (envUrlRaw && !envIsLocalhost) {
    return envUrlRaw;
  }

  const hostFromExpo = getDevHostFromExpo();

  // Android emulator special-case
  if (Platform.OS === "android") {
    if (!hostFromExpo) return "http://10.0.2.2:4000";
    if (hostFromExpo === "localhost" || hostFromExpo === "127.0.0.1") {
      return "http://10.0.2.2:4000";
    }
    return `http://${hostFromExpo}:4000`;
  }

  // iOS simulator / real device
  if (hostFromExpo) return `http://${hostFromExpo}:4000`;

  // Last fallback
  return "http://localhost:4000";
}

export const API_URL = resolveApiUrl();
console.log("üîó API_URL resolved to:", API_URL);

async function handleResponse(res: Response) {
  const text = await res.text();

  let data: any = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    console.log("API ERROR =>", {
      url: res.url,
      status: res.status,
      rawBody: text,
      parsed: data,
    });

    const message =
      (data && (data as any).error) ||
      (data && (data as any).message) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;

    throw new Error(message);
  }

  return data;
}

// ---------- AUTH ----------
export async function signup(params: {
  fullName: string;
  email: string;
  password: string;
}) {
  const res = await fetch(`${API_URL}/auth/signup`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

export async function login(params: { email: string; password: string }) {
  const res = await fetch(`${API_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

// ---------- TYPES ----------
export type AvailabilitySlot = { dayOfWeek: number; from: string; to: string };
export type SkillTeach = { name: string; level: string };
export type SkillLearn = { name: string; level: string };

export type MentorMatch = {
  mentorId: string;
  fullName: string;
  matchScore: number;
  mainMatchedSkill?: { name: string; level: string; similarityScore: number };
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

export type MatchingMode = "local" | "openai" | "hybrid";

export type MatchingStatus = {
  openaiAvailable: boolean;
  reason: "OK" | "NO_KEY" | "ERROR" | string;
  recommendedMode: "local" | "hybrid";
};

export type MatchingMeta = {
  requestedMode: MatchingMode | null;
  modeUsed: MatchingMode | null;
  fallbackUsed: boolean;
  message?: string;
};

// ---------- USER ----------
export async function getMe(token: string) {
  const res = await fetch(`${API_URL}/api/me`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}

// ---------- PROFILE UPDATE ----------
export async function updateProfile(
  token: string,
  partial: {
    skillsToLearn?: SkillLearn[];
    skillsToTeach?: SkillTeach[];
    availabilitySlots?: AvailabilitySlot[];
  }
) {
  const res = await fetch(`${API_URL}/api/me/profile`, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(partial),
  });

  return handleResponse(res);
}

export async function updateWeeklyAvailability(
  token: string,
  availabilitySlots: AvailabilitySlot[]
) {
  return updateProfile(token, { availabilitySlots });
}

export async function updateSkillsToTeach(token: string, skillsToTeach: SkillTeach[]) {
  return updateProfile(token, { skillsToTeach });
}

export async function updateSkillsToLearn(token: string, skillsToLearn: SkillLearn[]) {
  return updateProfile(token, { skillsToLearn });
}

// ---------- MATCHING STATUS ----------
export async function getMatchingStatus(): Promise<MatchingStatus> {
  const res = await fetch(`${API_URL}/api/matching/status`, { method: "GET" });
  return handleResponse(res);
}

// ---------- MATCHING ----------
export async function getMentorMatches(
  token: string,
  params: {
    skill: string;
    level: "Beginner" | "Intermediate" | "Advanced";
    availabilitySlots?: AvailabilitySlot[];
    mode?: MatchingMode;
  }
): Promise<{ results: MentorMatch[]; meta?: MatchingMeta }> {
  const res = await fetch(`${API_URL}/api/matches/mentors`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      skill: params.skill,
      level: params.level,
      availabilitySlots: params.availabilitySlots ?? [],
      mode: params.mode,
    }),
  });

  return handleResponse(res);
}

// ---------- PUBLIC USER PROFILE (Mentor) ----------
export type PublicUserProfile = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

export async function getPublicUserProfile(token: string, userId: string): Promise<PublicUserProfile> {
  const res = await fetch(`${API_URL}/api/users/${userId}`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}
</file>

</files>

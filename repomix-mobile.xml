This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/**, lib/**, components/**, context/**, hooks/**, types/**
- Files matching these patterns are excluded: node_modules/**, **/*.log, **/*.map, **/*.env, **/*.json, package-lock.json, yarn.lock, pnpm-lock.yaml, README.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/_layout.tsx
app/(auth)/_layout.tsx
app/(auth)/login/index.tsx
app/(auth)/shared/AuthButton.tsx
app/(auth)/shared/AuthHeader.tsx
app/(auth)/shared/AuthTextField.tsx
app/(auth)/shared/InlineError.tsx
app/(auth)/shared/mapApiError.ts
app/(auth)/shared/PasswordField.tsx
app/(auth)/shared/styles.ts
app/(auth)/shared/useAuthFieldFocus.ts
app/(auth)/shared/useAuthRedirect.ts
app/(auth)/shared/validators.ts
app/(auth)/signup/index.tsx
app/(tabs)/_layout.tsx
app/(tabs)/chats/(components)/ChatHeader.tsx
app/(tabs)/chats/(components)/ChatInput.tsx
app/(tabs)/chats/(components)/MessageBubble.tsx
app/(tabs)/chats/(components)/MessagesList.tsx
app/(tabs)/chats/(components)/TopLoadingHint.tsx
app/(tabs)/chats/[conversationId].tsx
app/(tabs)/chats/index.tsx
app/(tabs)/explore.tsx
app/(tabs)/index.tsx
app/find-mentor.tsx
app/index.tsx
app/login.tsx
app/manage-skills-to-learn/AddSkillToLearnForm.tsx
app/manage-skills-to-learn/CategorySelector.tsx
app/manage-skills-to-learn/index.tsx
app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
app/manage-skills-to-learn/SkillChip.tsx
app/manage-skills-to-learn/skillData.ts
app/manage-skills-to-learn/SkillsToLearnList.tsx
app/manage-skills-to-learn/SubCategorySelector.tsx
app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
app/manage-skills-to-learn/types.ts
app/manage-skills-to-learn/useManageSkillsToLearn.ts
app/manage-skills-to-teach/AddSkillToTeachForm.tsx
app/manage-skills-to-teach/index.tsx
app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
app/manage-skills-to-teach/SkillsToTeachList.tsx
app/manage-skills-to-teach/types.ts
app/manage-skills-to-teach/useManageSkillsToTeach.ts
app/mentor/[id].tsx
app/modal.tsx
app/profile.tsx
app/screens/components/MatchReadinessStrip.tsx
app/screens/components/PillButton.tsx
app/screens/components/ProfileStatusCard.tsx
app/screens/components/QuickEditBar.tsx
app/screens/components/SkeletonCard.tsx
app/screens/components/ViewProfileCTA.tsx
app/screens/homescreen.styles.ts
app/screens/HomeScreen.tsx
app/sessions/api/sessionsApi.ts
app/sessions/components/SessionCard.tsx
app/sessions/index.tsx
app/sessions/request.tsx
app/sessions/screens/(components)/SessionsEmptyState.tsx
app/sessions/screens/(components)/SessionsHeader.tsx
app/sessions/screens/(components)/SessionsRowRenderer.tsx
app/sessions/screens/(components)/SessionsRows.tsx
app/sessions/screens/(components)/SessionsSummaryBar.tsx
app/sessions/screens/(hooks)/useSessionsData.ts
app/sessions/screens/request/(hooks)/useRequestSessionForm.ts
app/sessions/screens/request/components/MentorCard.tsx
app/sessions/screens/request/components/RequestTopBar.tsx
app/sessions/screens/request/components/StepNote.tsx
app/sessions/screens/request/components/StepPills.tsx
app/sessions/screens/request/components/StepSchedule.tsx
app/sessions/screens/request/components/StepSkillLevel.tsx
app/sessions/screens/request/components/StickyFooter.tsx
app/sessions/screens/request/components/UI.tsx
app/sessions/screens/request/RequestSessionScreen.tsx
app/sessions/screens/request/styles.ts
app/sessions/screens/SessionsScreen.tsx
app/sessions/utils/formatSession.ts
app/shared/levels.ts
app/shared/profileCompletion.ts
app/signup.tsx
app/weekly-availability/components.tsx
app/weekly-availability/index.tsx
app/weekly-availability/SaveBar.tsx
app/weekly-availability/styles.ts
app/weekly-availability/TimeField.tsx
app/weekly-availability/useWeeklyAvailability.ts
components/external-link.tsx
components/haptic-tab.tsx
components/hello-wave.tsx
components/parallax-scroll-view.tsx
components/themed-text.tsx
components/themed-view.tsx
components/ui/collapsible.tsx
components/ui/icon-symbol.ios.tsx
components/ui/icon-symbol.tsx
hooks/use-color-scheme.ts
hooks/use-color-scheme.web.ts
hooks/use-theme-color.ts
lib/api.ts
lib/availabilityStorage.ts
lib/chat/api.ts
lib/chat/socket.ts
lib/profileCompletion.ts
lib/sectionStatus.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/_layout.tsx">
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/use-color-scheme';

export const unstable_settings = {
  anchor: '(tabs)',
};

export default function RootLayout() {
  const colorScheme = useColorScheme();

  return (
    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="modal" options={{ presentation: 'modal', title: 'Modal' }} />
      </Stack>
      <StatusBar style="auto" />
    </ThemeProvider>
  );
}
</file>

<file path="app/(auth)/_layout.tsx">
// app/(auth)/_layout.tsx
import { Stack } from "expo-router";
import React from "react";

export default function AuthLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: "fade",
      }}
    />
  );
}
</file>

<file path="app/(auth)/login/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  Text,
  View,
} from "react-native";
import { getMe, login } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import { validateEmail, validatePassword } from "../shared/validators";

type FieldErrors = {
  email?: string;
  password?: string;
};

export default function LoginScreen() {
  const router = useRouter();

  const { register, focusNext } = useAuthFieldFocus([
    "email",
    "password",
  ] as const);

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [checkingSession, setCheckingSession] = useState(true);
  const [loading, setLoading] = useState(false);

  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const [forgotOpen, setForgotOpen] = useState(false);

  // ✅ Session check (prevents flicker)
  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!token) {
          if (mounted) setCheckingSession(false);
          return;
        }

        await getMe(token);
        if (!mounted) return;
        router.replace("/(tabs)" as any);
      } catch {
        await AsyncStorage.removeItem("token");
        if (mounted) setCheckingSession(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  const canSubmit = useMemo(() => {
    if (checkingSession || loading) return false;
    const e = validateEmail(email);
    const p = validatePassword(password);
    return e.ok && p.ok;
  }, [checkingSession, loading, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await login({
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Login failed: missing token from server.");
        setPassword("");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
      setPassword("");
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <KeyboardAvoidingView
        style={authStyles.root}
        behavior={Platform.OS === "ios" ? "padding" : undefined}
      >
        <ScrollView
          contentContainerStyle={authStyles.content}
          keyboardShouldPersistTaps="handled"
        >
          <AuthHeader
            title="Sign in"
            subtitle="Welcome back — continue learning where you left off."
          />

          {checkingSession ? (
            <View
              style={{ paddingVertical: 24, alignItems: "center", gap: 10 }}
            >
              <ActivityIndicator />
              <Text style={authStyles.subtitle}>Checking your session…</Text>
            </View>
          ) : (
            <>
              {bannerError ? (
                <View style={authStyles.bannerError}>
                  <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
                </View>
              ) : null}

              <AuthTextField
                ref={register("email")}
                label="Email"
                value={email}
                onChangeText={(t) => {
                  setEmail(t);
                  clearBannerAndField("email");
                }}
                placeholder="you@example.com"
                keyboardType="email-address"
                returnKeyType="next"
                onSubmitEditing={() => focusNext("email")}
                editable={!loading}
                errorText={fieldErrors.email}
              />

              <PasswordField
                ref={register("password")}
                value={password}
                onChangeText={(t) => {
                  setPassword(t);
                  clearBannerAndField("password");
                }}
                errorText={fieldErrors.password}
                returnKeyType="done"
                onSubmitEditing={onSubmit}
                editable={!loading}
              />

              <Pressable
                onPress={() => setForgotOpen(true)}
                disabled={loading}
                style={({ pressed }) => [
                  { alignSelf: "flex-end", marginTop: 6 },
                  pressed ? { opacity: 0.85 } : null,
                ]}
              >
                <Text style={authStyles.linkBtn}>Forgot password?</Text>
              </Pressable>

              <AuthButton
                title={loading ? "Signing in…" : "Sign in"}
                loading={loading}
                disabled={!canSubmit}
                onPress={onSubmit}
              />

              <View style={authStyles.linkRow}>
                <Text style={authStyles.linkText}>Don’t have an account?</Text>
                <Link href="/(auth)/signup" style={authStyles.linkBtn}>
                  Create one
                </Link>
              </View>
            </>
          )}
        </ScrollView>

        {/* ✅ Forgot password modal */}
        <Modal
          transparent
          visible={forgotOpen}
          animationType="fade"
          onRequestClose={() => setForgotOpen(false)}
        >
          <Pressable
            onPress={() => setForgotOpen(false)}
            style={{
              flex: 1,
              backgroundColor: "rgba(0,0,0,0.6)",
              justifyContent: "center",
              padding: 18,
            }}
          >
            <Pressable
              onPress={() => {}}
              style={{
                backgroundColor: "#0B1120",
                borderRadius: 16,
                borderWidth: 1,
                borderColor: "#1E293B",
                padding: 16,
              }}
            >
              <Text
                style={{
                  color: "#F9FAFB",
                  fontSize: 16,
                  fontWeight: "900",
                  marginBottom: 6,
                }}
              >
                Password reset
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 13, lineHeight: 18 }}>
                Coming soon. For now, create a new account or contact support if
                you’re locked out.
              </Text>

              <Pressable
                onPress={() => setForgotOpen(false)}
                style={({ pressed }) => [
                  {
                    marginTop: 14,
                    backgroundColor: "#22C55E",
                    borderRadius: 999,
                    paddingVertical: 12,
                    alignItems: "center",
                  },
                  pressed ? { opacity: 0.9 } : null,
                ]}
              >
                <Text style={{ color: "#022C22", fontWeight: "900" }}>OK</Text>
              </Pressable>
            </Pressable>
          </Pressable>
        </Modal>
      </KeyboardAvoidingView>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthButton.tsx">
import React from "react";
import { ActivityIndicator, Text, TouchableOpacity, View } from "react-native";
import { authStyles } from "./styles";

type Props = {
  title: string;
  onPress: () => void;
  loading?: boolean;
  disabled?: boolean;
};

export default function AuthButton({
  title,
  onPress,
  loading,
  disabled,
}: Props) {
  const isDisabled = !!disabled || !!loading;

  return (
    <TouchableOpacity
      style={[
        authStyles.primaryBtn,
        isDisabled && authStyles.primaryBtnDisabled,
      ]}
      onPress={onPress}
      disabled={isDisabled}
      activeOpacity={0.85}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: !!loading }}
    >
      {loading ? (
        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <ActivityIndicator />
          <Text style={authStyles.primaryBtnText}>{title}</Text>
        </View>
      ) : (
        <Text style={authStyles.primaryBtnText}>{title}</Text>
      )}
    </TouchableOpacity>
  );
}
</file>

<file path="app/(auth)/shared/AuthHeader.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { title: string; subtitle: string };

export default function AuthHeader({ title, subtitle }: Props) {
  return (
    <View style={authStyles.header}>
      <Text style={authStyles.title}>{title}</Text>
      <Text style={authStyles.subtitle}>{subtitle}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/AuthTextField.tsx">
import React from "react";
import { Text, TextInput, TextInputProps, View } from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  label: string;
  value: string;
  onChangeText: (t: string) => void;
  placeholder?: string;
  errorText?: string | null;
} & Omit<TextInputProps, "value" | "onChangeText">;

const AuthTextField = React.forwardRef<TextInput, Props>(function AuthTextField(
  { label, value, onChangeText, placeholder, errorText, style, ...rest },
  ref
) {
  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>
      <TextInput
        ref={ref}
        style={[authStyles.input, !!errorText && authStyles.inputError, style]}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor="#64748B"
        autoCapitalize="none"
        autoCorrect={false}
        {...rest}
      />
      <InlineError text={errorText} />
    </View>
  );
});

export default AuthTextField;
</file>

<file path="app/(auth)/shared/InlineError.tsx">
import React from "react";
import { Text, View } from "react-native";
import { authStyles } from "./styles";

type Props = { text?: string | null };

export default function InlineError({ text }: Props) {
  if (!text) return null;
  return (
    <View style={authStyles.inlineErrorBox}>
      <Text style={authStyles.inlineErrorText}>{text}</Text>
    </View>
  );
}
</file>

<file path="app/(auth)/shared/mapApiError.ts">
export function mapApiError(err: any): string {
  // Try to pick the most useful message without leaking raw server dumps.
  const raw =
    String(err?.message || "").trim() ||
    String(err?.response?.data?.message || "").trim() ||
    String(err?.response?.data?.error || "").trim();

  const msg = raw.toLowerCase();

  if (!raw) return "Something went wrong. Please try again.";

  // Network-ish
  if (
    msg.includes("network request failed") ||
    msg.includes("failed to fetch") ||
    msg.includes("network") ||
    msg.includes("socket") ||
    msg.includes("ecconn") ||
    msg.includes("timeout")
  ) {
    return "Can’t reach the server. Check your internet (or API URL) and try again.";
  }

  // Auth / credentials
  if (
    msg.includes("invalid credentials") ||
    msg.includes("invalid") && msg.includes("password") ||
    msg.includes("incorrect") ||
    msg.includes("unauthorized") ||
    msg.includes("401")
  ) {
    return "Email or password is incorrect.";
  }

  // Signup collisions
  if (msg.includes("already") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }
  if (msg.includes("exists") && msg.includes("email")) {
    return "This email is already registered. Try logging in.";
  }

  // User not found (login)
  if (msg.includes("not found") || msg.includes("no user")) {
    return "This email is not registered yet.";
  }

  // Token missing from backend
  if (msg.includes("missing") && msg.includes("token")) {
    return "Login succeeded but server didn’t return a token. Please contact support.";
  }

  // Generic fallback: avoid very long raw messages
  if (raw.length > 140) return "Something went wrong. Please try again.";
  return raw;
}
</file>

<file path="app/(auth)/shared/PasswordField.tsx">
import React, { useState } from "react";
import {
  Text,
  TextInput,
  TextInputProps,
  TouchableOpacity,
  View,
} from "react-native";
import InlineError from "./InlineError";
import { authStyles } from "./styles";

type Props = {
  value: string;
  onChangeText: (t: string) => void;
  errorText?: string | null;
  label?: string;
} & Omit<TextInputProps, "value" | "onChangeText" | "secureTextEntry">;

const PasswordField = React.forwardRef<TextInput, Props>(function PasswordField(
  { value, onChangeText, errorText, label = "Password", style, ...rest },
  ref
) {
  const [show, setShow] = useState(false);

  return (
    <View style={authStyles.fieldWrap}>
      <Text style={authStyles.fieldLabel}>{label}</Text>

      <View style={authStyles.passwordRow}>
        <TextInput
          ref={ref}
          style={[
            authStyles.input,
            { flex: 1 },
            !!errorText && authStyles.inputError,
            style,
          ]}
          value={value}
          onChangeText={onChangeText}
          placeholder="••••••••"
          placeholderTextColor="#64748B"
          secureTextEntry={!show}
          autoCapitalize="none"
          autoCorrect={false}
          {...rest}
        />

        <TouchableOpacity
          onPress={() => setShow((v) => !v)}
          style={authStyles.eyeBtn}
          accessibilityRole="button"
          accessibilityLabel={show ? "Hide password" : "Show password"}
          activeOpacity={0.85}
        >
          <Text style={authStyles.eyeText}>{show ? "Hide" : "Show"}</Text>
        </TouchableOpacity>
      </View>

      <InlineError text={errorText} />
    </View>
  );
});

export default PasswordField;
</file>

<file path="app/(auth)/shared/styles.ts">
import { StyleSheet } from "react-native";

export const authStyles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },

  content: {
    paddingHorizontal: 16,
    paddingTop: 28,
    paddingBottom: 28,
  },

  /* ===== Header ===== */
  header: { marginBottom: 18 },
  title: {
    color: "#F9FAFB",
    fontSize: 26,
    fontWeight: "900",
    letterSpacing: 0.2,
  },
  subtitle: {
    color: "#94A3B8",
    fontSize: 13,
    marginTop: 6,
    lineHeight: 18,
  },

  /* ===== Errors ===== */
  bannerError: {
    backgroundColor: "#451A1A",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  bannerErrorText: {
    color: "#FECACA",
    fontSize: 12,
    fontWeight: "800",
    lineHeight: 16,
  },

  inlineErrorBox: { marginTop: 6 },
  inlineErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "800",
  },

  /* ===== Fields ===== */
  fieldWrap: { marginBottom: 14 },
  fieldLabel: {
    color: "#CBD5E1",
    fontSize: 12,
    fontWeight: "800",
    marginBottom: 6,
  },

  input: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 14,
    paddingVertical: 12,
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "700",
  },

  inputError: {
    borderColor: "#FCA5A5",
  },

  passwordRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },

  eyeBtn: {
    paddingHorizontal: 12,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  eyeText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },

  /* ===== Buttons ===== */
  primaryBtn: {
    marginTop: 10,
    backgroundColor: "#22C55E",
    paddingVertical: 13,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryBtnDisabled: {
    opacity: 0.55,
  },
  primaryBtnText: {
    color: "#022C22",
    fontSize: 13,
    fontWeight: "900",
    letterSpacing: 0.3,
  },

  /* ===== Links ===== */
  linkRow: {
    marginTop: 16,
    flexDirection: "row",
    justifyContent: "center",
    gap: 6,
  },
  linkText: {
    color: "#94A3B8",
    fontSize: 12,
    fontWeight: "700",
  },
  linkBtn: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
});
</file>

<file path="app/(auth)/shared/useAuthFieldFocus.ts">
import { useRef } from "react";
import { TextInput } from "react-native";

export function useAuthFieldFocus<T extends string>(keys: readonly T[]) {
  const refs = useRef<Record<T, TextInput | null>>({} as any);

  const register = (key: T) => (ref: TextInput | null) => {
    refs.current[key] = ref;
  };

  const focusNext = (key: T) => {
    const idx = keys.indexOf(key);
    const nextKey = keys[idx + 1];
    if (nextKey && refs.current[nextKey]) {
      refs.current[nextKey]?.focus();
    }
  };

  return { register, focusNext };
}
</file>

<file path="app/(auth)/shared/useAuthRedirect.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useEffect, useState } from "react";

/**
 * If token exists -> redirect to "/"
 * Returns ready=false while checking storage (to avoid flicker)
 */
export function useAuthRedirect() {
  const router = useRouter();
  const [ready, setReady] = useState(false);

  useEffect(() => {
    let mounted = true;

    (async () => {
      try {
        const token = await AsyncStorage.getItem("token");
        if (!mounted) return;

        if (token) {
          router.replace("/"); // go to tabs/home
          return;
        }
      } finally {
        if (mounted) setReady(true);
      }
    })();

    return () => {
      mounted = false;
    };
  }, [router]);

  return { ready };
}
</file>

<file path="app/(auth)/shared/validators.ts">
export function validateEmail(email: string) {
  const v = email.trim();
  const ok = /^\S+@\S+\.\S+$/.test(v);
  return { ok, value: v, error: ok ? null : "Please enter a valid email." };
}

export function validatePassword(password: string) {
  const v = password;
  const ok = v.length >= 6;
  return { ok, value: v, error: ok ? null : "Password must be at least 6 characters." };
}

export function validateFullName(fullName: string) {
  const v = fullName.trim();
  const ok = v.length >= 2;
  return { ok, value: v, error: ok ? null : "Please enter your full name." };
}
</file>

<file path="app/(auth)/signup/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Link, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import { ScrollView, Text, View } from "react-native";
import { signup } from "../../../lib/api";
import AuthButton from "../shared/AuthButton";
import AuthHeader from "../shared/AuthHeader";
import AuthTextField from "../shared/AuthTextField";
import PasswordField from "../shared/PasswordField";
import { mapApiError } from "../shared/mapApiError";
import { authStyles } from "../shared/styles";
import { useAuthFieldFocus } from "../shared/useAuthFieldFocus";
import {
  validateEmail,
  validateFullName,
  validatePassword,
} from "../shared/validators";

type FieldErrors = {
  fullName?: string;
  email?: string;
  password?: string;
};

export default function SignupScreen() {
  const router = useRouter();
  const { register, focusNext } = useAuthFieldFocus([
    "fullName",
    "email",
    "password",
  ] as const);

  const [fullName, setFullName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [loading, setLoading] = useState(false);
  const [bannerError, setBannerError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<FieldErrors>({});

  const canSubmit = useMemo(() => {
    if (loading) return false;
    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);
    return n.ok && e.ok && p.ok;
  }, [loading, fullName, email, password]);

  const clearBannerAndField = (k: keyof FieldErrors) => {
    setBannerError(null);
    setFieldErrors((prev) => {
      if (!prev[k]) return prev;
      return { ...prev, [k]: undefined };
    });
  };

  const onSubmit = async () => {
    setBannerError(null);
    setFieldErrors({});

    const n = validateFullName(fullName);
    const e = validateEmail(email);
    const p = validatePassword(password);

    const nextErrors: FieldErrors = {};
    if (!n.ok) nextErrors.fullName = n.error || "Please enter your full name.";
    if (!e.ok) nextErrors.email = e.error || "Please enter a valid email.";
    if (!p.ok)
      nextErrors.password =
        p.error || "Password must be at least 6 characters.";

    if (Object.keys(nextErrors).length) {
      setFieldErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);

      const res: any = await signup({
        fullName: n.value,
        email: e.value.toLowerCase(),
        password: p.value,
      });

      const token = res?.token;
      if (!token) {
        setBannerError("Signup failed: missing token from server.");
        return;
      }

      await AsyncStorage.setItem("token", token);
      router.replace("/(tabs)" as any);
    } catch (err: any) {
      setBannerError(mapApiError(err));
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={authStyles.root}>
      <ScrollView
        contentContainerStyle={authStyles.content}
        keyboardShouldPersistTaps="handled"
      >
        <AuthHeader
          title="Create account"
          subtitle="Join SkillSwap and start learning & teaching."
        />

        {bannerError ? (
          <View style={authStyles.bannerError}>
            <Text style={authStyles.bannerErrorText}>{bannerError}</Text>
          </View>
        ) : null}

        <AuthTextField
          ref={register("fullName")}
          label="Full name"
          value={fullName}
          onChangeText={(t) => {
            setFullName(t);
            clearBannerAndField("fullName");
          }}
          placeholder="Your name"
          errorText={fieldErrors.fullName}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("fullName")}
        />

        <AuthTextField
          ref={register("email")}
          label="Email"
          value={email}
          onChangeText={(t) => {
            setEmail(t);
            clearBannerAndField("email");
          }}
          placeholder="name@example.com"
          keyboardType="email-address"
          errorText={fieldErrors.email}
          editable={!loading}
          returnKeyType="next"
          onSubmitEditing={() => focusNext("email")}
        />

        <PasswordField
          ref={register("password")}
          value={password}
          onChangeText={(t) => {
            setPassword(t);
            clearBannerAndField("password");
          }}
          errorText={fieldErrors.password}
          editable={!loading}
          returnKeyType="done"
          onSubmitEditing={onSubmit}
        />

        <AuthButton
          title={loading ? "Creating…" : "Create account"}
          loading={loading}
          disabled={!canSubmit}
          onPress={onSubmit}
        />

        <View style={authStyles.linkRow}>
          <Text style={authStyles.linkText}>Already have an account?</Text>
          <Link href="/(auth)/login" style={authStyles.linkBtn}>
            Sign in
          </Link>
        </View>
      </ScrollView>
    </View>
  );
}
</file>

<file path="app/(tabs)/chats/(components)/ChatHeader.tsx">
import React, { useMemo } from "react";
import { I18nManager, Pressable, StyleSheet, Text, View } from "react-native";

export type ConnStatus = "connected" | "reconnecting" | "disconnected";

type Props = {
  title: string; // peerName
  onBack: () => void;

  // realtime UI
  conn: ConnStatus;
  peerTyping: boolean;
  peerOnline: boolean;
  peerLastSeenIso: string | null;
};

function initials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return (parts[0][0] || "?").toUpperCase();
  return `${parts[0][0] || ""}${
    parts[parts.length - 1][0] || ""
  }`.toUpperCase();
}

function formatLastSeen(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleString(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export default function ChatHeader({
  title,
  onBack,
  conn,
  peerTyping,
  peerOnline,
  peerLastSeenIso,
}: Props) {
  const isRTL = I18nManager.isRTL;

  const subtitle = useMemo(() => {
    if (peerTyping) return isRTL ? "يكتب…" : "typing…";

    if (conn === "reconnecting")
      return isRTL ? "جاري إعادة الاتصال…" : "reconnecting…";
    if (conn !== "connected") return isRTL ? "غير متصل" : "offline";

    if (peerOnline) return isRTL ? "متصل الآن" : "online";
    if (peerLastSeenIso) {
      const seen = formatLastSeen(peerLastSeenIso);
      return isRTL ? `آخر ظهور ${seen}` : `last seen ${seen}`;
    }
    return isRTL ? "غير متصل" : "offline";
  }, [conn, peerLastSeenIso, peerOnline, peerTyping, isRTL]);

  const avatar = useMemo(() => initials(title), [title]);

  const dot = useMemo(() => {
    if (peerTyping) return "#FBBF24"; // yellow
    if (conn !== "connected") return "#64748B"; // gray
    if (peerOnline) return "#22C55E"; // green
    return "#64748B";
  }, [conn, peerOnline, peerTyping]);

  return (
    <View style={styles.header}>
      <Pressable
        onPress={onBack}
        accessibilityRole="button"
        accessibilityLabel="Back"
        style={({ pressed }) => [
          styles.backBtn,
          pressed ? { opacity: 0.9 } : null,
        ]}
        hitSlop={12}
      >
        <Text style={styles.backText}>{isRTL ? "→" : "←"}</Text>
      </Pressable>

      <View style={styles.center}>
        <View style={styles.avatar}>
          <Text style={styles.avatarText}>{avatar}</Text>
        </View>

        <View style={{ flex: 1 }}>
          <Text
            style={styles.title}
            numberOfLines={1}
            accessibilityRole="header"
          >
            {title || "Chat"}
          </Text>

          <View style={styles.subRow}>
            <View style={[styles.dot, { backgroundColor: dot }]} />
            <Text style={styles.sub} numberOfLines={1}>
              {subtitle}
            </Text>
          </View>
        </View>
      </View>

      {/* right spacer (future actions: call/info) */}
      <View style={{ width: 44 }} />
    </View>
  );
}

const styles = StyleSheet.create({
  header: {
    paddingHorizontal: 12,
    paddingTop: 14,
    paddingBottom: 10,
    flexDirection: "row",
    alignItems: "center",
    borderBottomWidth: 1,
    borderBottomColor: "#0B1120",
    backgroundColor: "#020617",
  },

  backBtn: {
    width: 44,
    height: 40,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  backText: {
    color: "#60A5FA",
    fontWeight: "900",
    fontSize: 18,
    lineHeight: 18,
  },

  center: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    paddingHorizontal: 6,
  },

  avatar: {
    width: 40,
    height: 40,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: {
    color: "#F97316",
    fontWeight: "900",
    fontSize: 14,
  },

  title: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 15,
    maxWidth: 260,
  },

  subRow: {
    marginTop: 3,
    flexDirection: "row",
    alignItems: "center",
    gap: 7,
  },
  dot: {
    width: 8,
    height: 8,
    borderRadius: 999,
  },

  sub: {
    color: "#94A3B8",
    fontWeight: "800",
    fontSize: 11,
  },
});
</file>

<file path="app/(tabs)/chats/(components)/ChatInput.tsx">
import React, { useCallback, useMemo } from "react";
import {
  NativeSyntheticEvent,
  Platform,
  Pressable,
  StyleSheet,
  Text,
  TextInput,
  TextInputKeyPressEventData,
  View,
} from "react-native";

type Props = {
  value: string;
  sending: boolean;
  onChange: (v: string) => void;
  onSend: () => void;
};

export default function ChatInput({ value, sending, onChange, onSend }: Props) {
  const canSend = useMemo(
    () => value.trim().length > 0 && !sending,
    [value, sending]
  );

  const onKeyPress = useCallback(
    (e: NativeSyntheticEvent<TextInputKeyPressEventData>) => {
      // Web behavior: Enter sends, Shift+Enter newline
      if (Platform.OS !== "web") return;

      const key = e?.nativeEvent?.key;
      // RN web: shiftKey exists on nativeEvent in many builds but not typed
      const shift = !!(e as any)?.nativeEvent?.shiftKey;

      if (key === "Enter" && !shift) {
        (e as any)?.preventDefault?.();
        if (canSend) onSend();
      }
    },
    [canSend, onSend]
  );

  return (
    <View style={styles.bar}>
      <View style={styles.inputWrap}>
        <TextInput
          value={value}
          onChangeText={onChange}
          placeholder="Type a message…"
          placeholderTextColor="#64748B"
          style={styles.input}
          multiline
          maxLength={4000}
          accessibilityLabel="Message input"
          returnKeyType={Platform.OS === "ios" ? "default" : "send"}
          blurOnSubmit={false}
          onKeyPress={onKeyPress}
        />
      </View>

      <Pressable
        onPress={onSend}
        disabled={!canSend}
        accessibilityRole="button"
        accessibilityLabel="Send message"
        style={({ pressed }) => [
          styles.sendBtn,
          canSend ? styles.sendOn : styles.sendOff,
          pressed && canSend ? { opacity: 0.92 } : null,
        ]}
        hitSlop={10}
      >
        <Text style={[styles.sendText, !canSend ? { opacity: 0.85 } : null]}>
          {sending ? "…" : "Send"}
        </Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  bar: {
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: "#0B1120",
    backgroundColor: "#020617",
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 10,
  },

  inputWrap: {
    flex: 1,
    borderRadius: 18,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0B1120",
    paddingHorizontal: 14,
    paddingVertical: 10,
  },

  input: {
    color: "#E5E7EB",
    fontWeight: "700",
    minHeight: 42,
    maxHeight: 140,
  },

  sendBtn: {
    minHeight: 44,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 999,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },

  sendOn: { backgroundColor: "#F97316", borderColor: "#FB923C" },
  sendOff: { backgroundColor: "#334155", borderColor: "#475569" },

  sendText: { color: "#111827", fontWeight: "900" },
});
</file>

<file path="app/(tabs)/chats/(components)/MessageBubble.tsx">
import React, { useMemo } from "react";
import { Pressable, StyleSheet, Text, View } from "react-native";
import type { ChatMessage } from "../../../../lib/chat/api";

type Props = {
  item: ChatMessage;
  mine: boolean;
};

function formatTime(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleTimeString(undefined, {
    hour: "2-digit",
    minute: "2-digit",
  });
}

export default function MessageBubble({ item, mine }: Props) {
  const time = useMemo(
    () => formatTime(String((item as any)?.createdAt || "")),
    [item]
  );

  return (
    <View style={[styles.row, mine ? styles.rowMine : styles.rowTheirs]}>
      <Pressable
        style={[styles.bubble, mine ? styles.mine : styles.theirs]}
        accessibilityRole="text"
      >
        <Text style={[styles.text, mine ? styles.textMine : styles.textTheirs]}>
          {item.text}
        </Text>

        <View style={styles.metaRow}>
          <Text
            style={[styles.time, mine ? styles.timeMine : styles.timeTheirs]}
          >
            {time}
          </Text>
          {mine ? <Text style={styles.tick}>✓</Text> : null}
        </View>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  row: { width: "100%", marginVertical: 6, flexDirection: "row" },
  rowMine: { justifyContent: "flex-end" },
  rowTheirs: { justifyContent: "flex-start" },

  bubble: {
    maxWidth: "82%",
    borderRadius: 18,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderWidth: 1,
  },

  mine: { backgroundColor: "#F97316", borderColor: "#FB923C" },
  theirs: { backgroundColor: "#0B1120", borderColor: "#111827" },

  text: { fontWeight: "800", fontSize: 14, lineHeight: 20 },
  textMine: { color: "#111827" },
  textTheirs: { color: "#E5E7EB" },

  metaRow: {
    marginTop: 6,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    gap: 6,
  },
  time: { color: "rgba(17,24,39,0.75)", fontSize: 11, fontWeight: "900" },
  tick: { color: "rgba(17,24,39,0.75)", fontSize: 12, fontWeight: "900" },
  timeMine: {
    color: "rgba(17,24,39,0.75)",
  },
  timeTheirs: {
    color: "#94A3B8",
  },
});
</file>

<file path="app/(tabs)/chats/(components)/MessagesList.tsx">
import React, { useCallback, useMemo, useRef } from "react";
import {
  FlatList,
  NativeScrollEvent,
  NativeSyntheticEvent,
  StyleSheet,
  View,
} from "react-native";
import type { ChatMessage } from "../../../../lib/chat/api";
import MessageBubble from "./MessageBubble";
import TopLoadingHint from "./TopLoadingHint";

type UiMessage = ChatMessage & { createdAt: string };

type Props = {
  items: ChatMessage[];
  meId: string;
  paging: boolean;
  hasMore: boolean;
  onLoadOlder: () => Promise<void>;
};

function toTime(iso: string) {
  const d = new Date(iso);
  const t = d.getTime();
  return Number.isNaN(t) ? 0 : t;
}

export default function MessagesList({
  items,
  meId,
  paging,
  hasMore,
  onLoadOlder,
}: Props) {
  const listRef = useRef<FlatList<UiMessage>>(null);
  const loadingOlderRef = useRef(false);

  // For inverted FlatList we want newest first
  const data = useMemo(() => {
    const arr = (Array.isArray(items) ? items : []).map((m) => ({
      ...m,
      createdAt:
        typeof (m as any).createdAt === "string"
          ? (m as any).createdAt
          : new Date().toISOString(),
    }));
    arr.sort((a, b) => toTime(b.createdAt) - toTime(a.createdAt));
    return arr;
  }, [items]);

  const keyExtractor = useCallback((m: UiMessage) => m.id, []);

  const renderItem = useCallback(
    ({ item }: { item: UiMessage }) => {
      const mine = String(item.senderId) === String(meId);
      return <MessageBubble item={item} mine={mine} />;
    },
    [meId]
  );

  // When list is inverted: onEndReached means user reached the TOP (older messages)
  const onEndReached = useCallback(async () => {
    if (!hasMore) return;
    if (paging) return;
    if (loadingOlderRef.current) return;

    loadingOlderRef.current = true;
    try {
      await onLoadOlder();
    } finally {
      loadingOlderRef.current = false;
    }
  }, [hasMore, onLoadOlder, paging]);

  // Optional: detect if user is not at bottom (newest side)
  const onScroll = useCallback((e: NativeSyntheticEvent<NativeScrollEvent>) => {
    // keep for future (scroll-to-bottom button)
    void e;
  }, []);

  return (
    <View style={styles.wrap}>
      <TopLoadingHint visible={paging} />

      <FlatList
        ref={listRef}
        data={data}
        keyExtractor={keyExtractor}
        renderItem={renderItem}
        inverted
        onEndReached={onEndReached}
        onEndReachedThreshold={0.2}
        onScroll={onScroll}
        scrollEventThrottle={16}
        contentContainerStyle={styles.content}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: { flex: 1, backgroundColor: "#020617" },
  content: { paddingHorizontal: 14, paddingTop: 12, paddingBottom: 12 },
});
</file>

<file path="app/(tabs)/chats/(components)/TopLoadingHint.tsx">
import React from "react";
import { ActivityIndicator, StyleSheet, Text, View } from "react-native";

type Props = { visible: boolean };

export default function TopLoadingHint({ visible }: Props) {
  if (!visible) return null;

  return (
    <View style={styles.wrap} pointerEvents="none">
      <View style={styles.pill}>
        <ActivityIndicator />
        <Text style={styles.txt}>Loading older…</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: { paddingTop: 10, alignItems: "center" },
  pill: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  txt: { color: "#94A3B8", fontWeight: "800", fontSize: 12 },
});
</file>

<file path="app/(tabs)/chats/[conversationId].tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  Text,
  View,
} from "react-native";

import { getMe } from "../../../lib/api";
import {
  getConversationMessages,
  sendMessageRest,
  type ChatMessage,
} from "../../../lib/chat/api";

import {
  connectChatSocket,
  disconnectChatSocket,
  joinConversationRoom,
  markConversationRead,
  onConnectionStatus,
  onNewMessage,
  onPeerTyping,
  onPresenceUpdate,
  sendRealtimeMessage,
  type RealtimeMessage,
} from "../../../lib/chat/socket";

import ChatHeader from "./(components)/ChatHeader";
import ChatInput from "./(components)/ChatInput";
import MessagesList from "./(components)/MessagesList";

function toChatMessage(m: RealtimeMessage): ChatMessage {
  return {
    id: m.id,
    conversationId: m.conversationId,
    senderId: m.senderId,
    text: m.text,
    createdAt:
      typeof m.createdAt === "string" ? m.createdAt : new Date().toISOString(),
  };
}

function toTime(s: string) {
  const d = new Date(s);
  const t = d.getTime();
  return Number.isNaN(t) ? 0 : t;
}

export default function ConversationScreen() {
  const router = useRouter();
  const params = useLocalSearchParams<{
    conversationId?: string;
    peerName?: string;
    peerId?: string;
  }>();

  const convId = String(params.conversationId || "").trim();
  const peerName = String(params.peerName || params.peerId || "Chat");
  const peerId = String(params.peerId || "").trim();

  const mountedRef = useRef(true);

  const [meId, setMeId] = useState("");
  const [loading, setLoading] = useState(true);

  const [items, setItems] = useState<ChatMessage[]>([]);
  const [text, setText] = useState("");
  const [sending, setSending] = useState(false);

  const [conn, setConn] = useState<
    "connected" | "reconnecting" | "disconnected"
  >("disconnected");

  const [peerTyping, setPeerTyping] = useState(false);
  const typingTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [peerOnline, setPeerOnline] = useState(false);
  const [peerLastSeenIso, setPeerLastSeenIso] = useState<string | null>(null);

  const [paging, setPaging] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const sorted = useMemo(() => {
    return items
      .slice()
      .sort((a, b) => toTime(a.createdAt) - toTime(b.createdAt));
  }, [items]);

  const oldestIso = useMemo(() => {
    if (!sorted.length) return null;
    return sorted[0]?.createdAt || null;
  }, [sorted]);

  const boot = useCallback(async () => {
    if (!convId) {
      router.back();
      return () => {};
    }

    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return () => {};
    }

    setLoading(true);

    const cleanupFns: ((() => void) | undefined)[] = [];

    try {
      const me = await getMe(token);
      if (!mountedRef.current) return () => {};

      const myId = String(me?.user?._id || "");
      setMeId(myId);

      // ✅ API returns { items: ChatMessage[] }
      const first = await getConversationMessages(token, convId, { limit: 50 });
      if (!mountedRef.current) return () => {};

      const firstArr = Array.isArray(first?.items) ? first.items : [];
      setItems(firstArr);
      setHasMore(firstArr.length >= 50);

      // ✅ connect socket (socket.ts handles re-join on reconnect)
      connectChatSocket(token);

      // ✅ join once now (and will re-join on reconnect from socket.ts)
      joinConversationRoom(convId, peerId);

      cleanupFns.push(onConnectionStatus(setConn));

      cleanupFns.push(
        onNewMessage((m) => {
          if (String(m.conversationId) !== convId) return;

          const cm = toChatMessage(m);
          setItems((prev) => {
            if (prev.some((x) => x.id === cm.id)) return prev;
            return [...prev, cm];
          });

          void markConversationRead(convId);
        })
      );

      cleanupFns.push(
        onPeerTyping((p) => {
          if (String(p.conversationId) !== convId) return;
          if (String(p.userId) === myId) return;

          setPeerTyping(!!p.isTyping);

          if (typingTimerRef.current) clearTimeout(typingTimerRef.current);
          if (p.isTyping) {
            typingTimerRef.current = setTimeout(() => {
              setPeerTyping(false);
            }, 1400);
          }
        })
      );

      cleanupFns.push(
        onPresenceUpdate((p) => {
          if (!peerId) return;
          if (String(p.userId) !== String(peerId)) return;

          setPeerOnline(!!p.online);
          setPeerLastSeenIso(p.lastSeen ? String(p.lastSeen) : null);
        })
      );

      void markConversationRead(convId);

      return () => {
        cleanupFns.forEach((fn) => {
          try {
            fn?.();
          } catch {}
        });
      };
    } finally {
      if (mountedRef.current) setLoading(false);
    }
  }, [convId, peerId, router]);

  useEffect(() => {
    mountedRef.current = true;

    let cleanup: (() => void) | null = null;
    (async () => {
      cleanup = await boot();
    })();

    return () => {
      mountedRef.current = false;

      try {
        cleanup?.();
      } catch {}

      try {
        if (typingTimerRef.current) clearTimeout(typingTimerRef.current);
      } catch {}

      // ✅ disconnect ONCE (no double disconnect / no looping)
      disconnectChatSocket();
    };
  }, [boot]);

  const loadOlder = useCallback(async () => {
    if (paging || !hasMore || !oldestIso) return;

    const token = await AsyncStorage.getItem("token");
    if (!token) return;

    setPaging(true);
    try {
      // ✅ API returns { items: ChatMessage[] }
      const older = await getConversationMessages(token, convId, {
        limit: 50,
        before: oldestIso,
      });

      const arr = Array.isArray(older?.items) ? older.items : [];
      setHasMore(arr.length >= 50);

      setItems((prev) => {
        const existing = new Set(prev.map((x) => x.id));
        const merged = [...arr.filter((x) => !existing.has(x.id)), ...prev];
        return merged;
      });
    } finally {
      if (mountedRef.current) setPaging(false);
    }
  }, [convId, hasMore, oldestIso, paging]);

  const send = useCallback(async () => {
    const clean = String(text || "").trim();
    if (!clean || !convId || sending) return;

    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return;
    }

    setSending(true);
    try {
      const rt = await sendRealtimeMessage(convId, clean);

      if (rt.ok && rt.message) {
        const cm = toChatMessage(rt.message);
        setItems((prev) => {
          if (prev.some((x) => x.id === cm.id)) return prev;
          return [...prev, cm];
        });
        setText("");
        return;
      }

      const m = await sendMessageRest(token, convId, clean);
      setItems((prev) => [...prev, m]);
      setText("");
    } catch {
      // silent
    } finally {
      setSending(false);
    }
  }, [convId, router, sending, text]);

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator />
        <Text style={{ marginTop: 10, color: "#94A3B8", fontWeight: "800" }}>
          Loading chat…
        </Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
      keyboardVerticalOffset={Platform.OS === "ios" ? 90 : 0}
    >
      <ChatHeader
        title={peerName}
        onBack={() => router.back()}
        conn={conn}
        peerTyping={peerTyping}
        peerOnline={peerOnline}
        peerLastSeenIso={peerLastSeenIso}
      />

      <MessagesList
        items={items}
        meId={meId}
        paging={paging}
        hasMore={hasMore}
        onLoadOlder={loadOlder}
      />

      <ChatInput
        value={text}
        sending={sending}
        onChange={setText}
        onSend={send}
      />
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/(tabs)/chats/index.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  FlatList,
  Pressable,
  RefreshControl,
  StyleSheet,
  Text,
  TextInput,
  View,
} from "react-native";
import {
  getChatInbox,
  getInboxCache,
  setInboxCache,
  type ChatInboxItem,
} from "../../../lib/chat/api";
import {
  connectChatSocket,
  disconnectChatSocket,
  onNewMessage,
} from "../../../lib/chat/socket";

function initials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return `${parts[0][0] ?? ""}${
    parts[parts.length - 1][0] ?? ""
  }`.toUpperCase();
}

function timeAgo(iso: string) {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  const diff = Date.now() - d.getTime();
  const sec = Math.floor(diff / 1000);
  if (sec < 60) return "Now";
  const min = Math.floor(sec / 60);
  if (min < 60) return `${min}m`;
  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}h`;
  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}d`;
  return d.toLocaleDateString(undefined, { month: "short", day: "2-digit" });
}

type LoadMode = "load" | "refresh";

export default function ChatsInboxScreen() {
  const router = useRouter();

  const [items, setItems] = useState<ChatInboxItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [query, setQuery] = useState("");
  const [pendingOpenId, setPendingOpenId] = useState<string | null>(null);

  const mountedRef = useRef(true);

  const load = useCallback(
    async (mode: LoadMode) => {
      try {
        setErrorText(null);

        if (mode === "refresh") setRefreshing(true);
        else setLoading(true);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        // ✅ عرض الكاش بسرعة (بس عند load مش refresh)
        if (mode === "load") {
          const cached = await getInboxCache();
          if (mountedRef.current && cached?.length) {
            const sortedCached = cached.slice().sort((a, b) => {
              const ta = a.lastMessageAt
                ? new Date(a.lastMessageAt).getTime()
                : 0;
              const tb = b.lastMessageAt
                ? new Date(b.lastMessageAt).getTime()
                : 0;
              return tb - ta;
            });
            setItems(sortedCached);
            setLoading(false);
          }
        }

        const list = await getChatInbox(token);

        if (!mountedRef.current) return;

        const sorted = (Array.isArray(list) ? list : [])
          .slice()
          .sort((a, b) => {
            const ta = a.lastMessageAt
              ? new Date(a.lastMessageAt).getTime()
              : 0;
            const tb = b.lastMessageAt
              ? new Date(b.lastMessageAt).getTime()
              : 0;
            return tb - ta;
          });

        setItems(sorted);
        void setInboxCache(sorted);
      } catch (e: any) {
        if (!mountedRef.current) return;
        setErrorText(e?.message || "Failed to load chats.");
      } finally {
        if (!mountedRef.current) return;
        setLoading(false);
        setRefreshing(false);
      }
    },
    [router]
  );

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;

      // load from cache + fetch
      load("load");

      // realtime inbox updates
      let offMsg: (() => void) | null = null;

      (async () => {
        const token = await AsyncStorage.getItem("token");
        if (!token || !mountedRef.current) return;

        connectChatSocket(token);

        offMsg = onNewMessage((m) => {
          // Move conversation to top + update preview/unread fast
          setItems((prev) => {
            const list = Array.isArray(prev) ? prev.slice() : [];
            const idx = list.findIndex(
              (x) => String(x.id) === String(m.conversationId)
            );

            const nextItem: ChatInboxItem =
              idx >= 0
                ? {
                    ...list[idx],
                    lastMessageText: m.text || list[idx].lastMessageText,
                    lastMessageAt: m.createdAt || list[idx].lastMessageAt,
                    unreadCount: Number(list[idx].unreadCount || 0) + 1,
                  }
                : {
                    id: String(m.conversationId),
                    peer: null,
                    lastMessageText: String(m.text || ""),
                    lastMessageAt: String(
                      m.createdAt || new Date().toISOString()
                    ),
                    updatedAt: null,
                    createdAt: null,
                    unreadCount: 1,
                  };

            if (idx >= 0) list.splice(idx, 1);
            const merged = [nextItem, ...list];

            void setInboxCache(merged);
            return merged;
          });
        });
      })();

      return () => {
        mountedRef.current = false;
        try {
          offMsg?.();
        } catch {}
        try {
          disconnectChatSocket();
        } catch {}
      };
    }, [load])
  );

  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return items;

    return items.filter((x) => {
      const name = String(x.peer?.fullName || "").toLowerCase();
      const last = String(x.lastMessageText || "").toLowerCase();
      return name.includes(q) || last.includes(q);
    });
  }, [items, query]);

  const empty = useMemo(
    () => !loading && !errorText && filtered.length === 0,
    [loading, errorText, filtered.length]
  );

  const openConversation = useCallback(
    (item: ChatInboxItem) => {
      const id = String(item?.id || "").trim();
      if (!id) return;
      if (pendingOpenId === id) return;

      setPendingOpenId(id);

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: {
          conversationId: id,
          peerName: item.peer?.fullName || "Chat",
          peerId: item.peer?.id || "",
        },
      } as any);

      setTimeout(() => setPendingOpenId(null), 650);
    },
    [pendingOpenId, router]
  );

  const renderItem = useCallback(
    ({ item }: { item: ChatInboxItem }) => {
      const name = item.peer?.fullName || "Unknown user";
      const last = item.lastMessageText?.trim()
        ? item.lastMessageText
        : "Say hi 👋";
      const ts = item.lastMessageAt ? timeAgo(item.lastMessageAt) : "";
      const unread = Number((item as any)?.unreadCount || 0);
      const disabled = pendingOpenId === item.id;

      return (
        <Pressable
          onPress={() => openConversation(item)}
          disabled={disabled}
          accessibilityRole="button"
          accessibilityLabel={`Open chat with ${name}`}
          accessibilityHint="Opens the conversation"
          style={({ pressed }) => [
            styles.row,
            pressed ? { opacity: 0.92 } : null,
            disabled ? { opacity: 0.65 } : null,
          ]}
          hitSlop={10}
        >
          <View style={styles.avatar} accessibilityLabel={`Avatar: ${name}`}>
            <Text style={styles.avatarText}>{initials(name)}</Text>
          </View>

          <View style={{ flex: 1 }}>
            <View style={styles.topLine}>
              <Text style={styles.name} numberOfLines={1}>
                {name}
              </Text>

              <View style={styles.rightMeta}>
                {!!unread && (
                  <View
                    style={styles.badge}
                    accessibilityLabel={`${unread} unread messages`}
                  >
                    <Text style={styles.badgeText}>
                      {unread > 99 ? "99+" : String(unread)}
                    </Text>
                  </View>
                )}

                {!!ts && <Text style={styles.time}>{ts}</Text>}
              </View>
            </View>

            <Text
              style={[styles.last, unread ? styles.lastUnread : null]}
              numberOfLines={2}
            >
              {last}
            </Text>
          </View>
        </Pressable>
      );
    },
    [openConversation, pendingOpenId]
  );

  const keyExtractor = useCallback((x: ChatInboxItem) => x.id, []);

  return (
    <View style={styles.root}>
      <View style={styles.header}>
        <Text style={styles.title} accessibilityRole="header">
          Chats
        </Text>
        <Text style={styles.subtitle}>Your 1:1 conversations (text only).</Text>

        <View style={styles.searchWrap}>
          <Text style={styles.searchIcon}>🔎</Text>
          <TextInput
            value={query}
            onChangeText={setQuery}
            placeholder="Search by name or message…"
            placeholderTextColor="#64748B"
            style={styles.searchInput}
            accessibilityLabel="Search chats"
            accessibilityHint="Filters conversations by name or last message"
            returnKeyType="search"
          />
          {!!query.trim() && (
            <Pressable
              onPress={() => setQuery("")}
              accessibilityRole="button"
              accessibilityLabel="Clear search"
              style={({ pressed }) => [
                styles.clearBtn,
                pressed ? { opacity: 0.9 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.clearText}>×</Text>
            </Pressable>
          )}
        </View>
      </View>

      {loading ? (
        <View style={styles.center}>
          <ActivityIndicator />
          <Text style={styles.muted}>Loading…</Text>
        </View>
      ) : errorText ? (
        <View style={{ padding: 16 }}>
          <View style={styles.errCard}>
            <Text style={styles.errTitle}>Couldn’t load chats</Text>
            <Text style={styles.errBody}>{errorText}</Text>

            <Pressable
              onPress={() => load("load")}
              accessibilityRole="button"
              accessibilityLabel="Try again"
              style={({ pressed }) => [
                styles.tryBtn,
                pressed ? { opacity: 0.9 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.tryText}>Try again</Text>
            </Pressable>
          </View>
        </View>
      ) : empty ? (
        <View style={{ padding: 16 }}>
          <View style={styles.emptyCard}>
            <Text style={styles.emptyTitle}>
              {query.trim() ? "No results" : "No chats yet"}
            </Text>
            <Text style={styles.emptyBody}>
              {query.trim()
                ? "Try a different search."
                : "Open any mentor profile and press “Message”."}
            </Text>
          </View>
        </View>
      ) : (
        <FlatList
          data={filtered}
          keyExtractor={keyExtractor}
          renderItem={renderItem}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={() => load("refresh")}
              tintColor="#94A3B8"
            />
          }
          contentContainerStyle={{ padding: 16, paddingBottom: 26 }}
          ItemSeparatorComponent={() => <View style={{ height: 10 }} />}
          keyboardShouldPersistTaps="handled"
          accessibilityLabel="Chats list"
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },

  header: { padding: 16, paddingBottom: 10 },
  title: { color: "#E5E7EB", fontWeight: "900", fontSize: 18 },
  subtitle: { color: "#94A3B8", marginTop: 6, fontSize: 12 },

  searchWrap: {
    marginTop: 12,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  searchIcon: { color: "#64748B", fontWeight: "900" },
  searchInput: { flex: 1, color: "#E5E7EB", fontWeight: "700" },
  clearBtn: {
    width: 28,
    height: 28,
    borderRadius: 999,
    backgroundColor: "#111827",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  clearText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 16,
    lineHeight: 18,
  },

  center: { flex: 1, alignItems: "center", justifyContent: "center" },
  muted: { color: "#94A3B8", marginTop: 10, fontWeight: "800" },

  errCard: {
    backgroundColor: "#451A1A",
    borderColor: "#FCA5A5",
    borderWidth: 1,
    borderRadius: 14,
    padding: 12,
  },
  errTitle: { color: "#FECACA", fontWeight: "900" },
  errBody: { color: "#FECACA", marginTop: 6 },

  tryBtn: {
    alignSelf: "flex-start",
    marginTop: 10,
    backgroundColor: "#B91C1C",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  tryText: { color: "#FEE2E2", fontWeight: "900" },

  emptyCard: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 14,
  },
  emptyTitle: { color: "#E5E7EB", fontWeight: "900" },
  emptyBody: { color: "#94A3B8", marginTop: 6 },

  row: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    minHeight: 66,
  },

  avatar: {
    width: 44,
    height: 44,
    borderRadius: 999,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  avatarText: { color: "#F97316", fontWeight: "900", fontSize: 16 },

  topLine: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 10,
  },
  name: { color: "#E5E7EB", fontWeight: "900", maxWidth: 220 },

  rightMeta: { flexDirection: "row", alignItems: "center", gap: 8 },

  time: {
    color: "#64748B",
    fontSize: 11,
    fontWeight: "800",
    writingDirection: "ltr",
  },

  badge: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
    paddingHorizontal: 8,
    height: 20,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  badgeText: { color: "#111827", fontWeight: "900", fontSize: 11 },

  last: { color: "#94A3B8", marginTop: 6 },
  lastUnread: { color: "#E5E7EB", fontWeight: "900" },
});
</file>

<file path="app/manage-skills-to-learn/AddSkillToLearnForm.tsx">
// app/manage-skills-to-learn/AddSkillToLearnForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { LEARN_LEVELS, LearnLevel } from "./types";

type Props = {
  onAdd: (name: string, level?: LearnLevel) => Promise<void> | void;
  onAddFavorite: (name: string, level?: LearnLevel) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

const AddSkillToLearnForm: React.FC<Props> = ({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}) => {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. React Native, Guitar, Public speaking";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    // slightly smarter: startsWith first, then includes
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) {
        await onAddFavorite(normalizedValue, selectedLevel);
      } else {
        await onAdd(normalizedValue, selectedLevel);
      }
      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      // keep local errors minimal; backend errors already appear in screen error box
      console.log("AddSkillToLearnForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Type a skill you want to learn, choose the level, then add it to your
        list.
      </Text>

      {/* Level selection */}
      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {LEARN_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      {/* Input */}
      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>

        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      {/* Actions */}
      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {/* Suggestions */}
      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
                accessibilityHint="Fills the input with this suggestion"
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
};

export default AddSkillToLearnForm;

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },

  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
  },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },

  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },

  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },

  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  levelPillText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "800",
  },
  levelPillTextActive: {
    color: "#ffffff",
  },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: {
    fontSize: 12,
    fontWeight: "800",
    color: "#2563eb",
  },

  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: {
    borderColor: "#fca5a5",
    backgroundColor: "#fff1f2",
  },

  errorText: {
    fontSize: 12,
    color: "#b91c1c",
    marginTop: 6,
  },

  buttonsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
  },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: {
    backgroundColor: "#2563eb",
  },
  primaryButtonText: {
    color: "#f9fafb",
    fontSize: 13,
    fontWeight: "900",
  },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: {
    color: "#374151",
    fontSize: 13,
    fontWeight: "800",
  },

  suggestionsSection: {
    marginTop: 12,
  },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: {
    fontSize: 12,
    color: "#6b7280",
    fontWeight: "800",
  },
  suggestionsHint: {
    fontSize: 11,
    color: "#9ca3af",
    fontWeight: "700",
  },
  suggestionsRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/CategorySelector.tsx">
// app/manage-skills-to-learn/CategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SKILL_CATEGORIES, SkillCategory } from "./skillData";

export type CategorySelectorProps = {
  selectedCategoryId: string | null;
  onSelect: (id: string) => void;
};

const CategorySelector: React.FC<CategorySelectorProps> = ({
  selectedCategoryId,
  onSelect,
}) => {
  return (
    <View style={styles.container}>
      <Text style={styles.label}>Category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        {SKILL_CATEGORIES.map((cat: SkillCategory) => {
          const isActive = cat.id === selectedCategoryId;
          return (
            <TouchableOpacity
              key={cat.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(cat.id)}
              activeOpacity={0.8}
            >
              <Text style={styles.chipEmoji}>{cat.icon}</Text>
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {cat.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

export default CategorySelector;

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#1d4ed8",
  },
  chipEmoji: {
    fontSize: 16,
    marginRight: 6,
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "500",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/index.tsx">
// app/manage-skills-to-learn/index.tsx
import React from "react";
import ManageSkillsToLearnScreen from "./ManageSkillsToLearnScreen";

export default function ManageSkillsToLearnRoute() {
  return <ManageSkillsToLearnScreen />;
}
</file>

<file path="app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx">
// app/manage-skills-to-learn/ManageSkillsToLearnScreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import AddSkillToLearnForm from "./AddSkillToLearnForm";
import CategorySelector from "./CategorySelector";
import { SkillSubCategory } from "./skillData";
import { SkillsToLearnList } from "./SkillsToLearnList";
import { SubCategorySelector } from "./SubCategorySelector";
import SuggestedSkillsGrid from "./SuggestedSkillsGrid";
import { LEARN_LEVELS, LearnLevel, SkillToLearn } from "./types";
import { useManageSkillsToLearn } from "./useManageSkillsToLearn";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Public speaking",
  "Time management",
  "English conversation",
  "Excel / Google Sheets",
  "Problem solving",
  "Presentation design",
];

type FilterMode = "all" | "favorites" | "recent";

// Quick Start (shown once)
const QUICK_START_KEY = "skillsToLearn_quickStartSeen_v1";

// Toast
type ToastType = "success" | "error" | "info";
type ToastState = {
  visible: boolean;
  message: string;
  type: ToastType;
};

// Bottom Sheet modes
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToLearnScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,

    hasPendingSync, // (22)

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart, // (12)
    updateSkillLevel, // (11)
    trySyncPending, // (22)

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToLearn();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  // Quick Start
  const [showQuickStart, setShowQuickStart] = useState(false);

  // Toast
  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Bottom sheet (modal)
  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<LearnLevel>("Intermediate");

  // (12) when duplicate happens, we store the existing skill
  const [duplicateExisting, setDuplicateExisting] =
    useState<SkillToLearn | null>(null);

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name} → ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  // Global search placeholder
  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Python, Algorithms...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Academic writing...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing basics...";
    return "Search or add: React Native, Guitar, Public speaking...";
  }, [selectedCategory]);

  // Visible skills (filters)
  const visibleSkills = useMemo(() => {
    let base: SkillToLearn[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  // Step state
  const isStep1Active = !selectedCategoryId;
  const isStep2Active = !!selectedCategoryId && !selectedSubCategoryId;
  const isStep3Active =
    (!!selectedCategoryId && !!selectedSubCategoryId) || skills.length > 0;

  // Progressive disclosure rules (2)
  const showRecommended = !selectedCategoryId;
  const showDiscoverSection = true;
  const showYourListSection = skills.length > 0 || !!selectedCategoryId;

  // Quick Start load (3)
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const seen = await AsyncStorage.getItem(QUICK_START_KEY);
        if (!mounted) return;
        if (!seen && skills.length === 0) setShowQuickStart(true);
      } catch {
        // ignore
      }
    })();
    return () => {
      mounted = false;
    };
  }, [skills.length]);

  const dismissQuickStart = async () => {
    setShowQuickStart(false);
    try {
      await AsyncStorage.setItem(QUICK_START_KEY, "1");
    } catch {
      // ignore
    }
  };

  // Toast helper (4)
  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  // Sync pending when screen loads (22)
  useEffect(() => {
    // try once on mount (safe even if no pending)
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ----- Add handlers -----
  const handleAddSkillBase = async (name: string, level?: LearnLevel) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (
    name: string,
    level?: LearnLevel
  ) => {
    const safe: LearnLevel = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) ★`);
    setFilterMode("all");
    setSearchQuery("");
  };

  // Clear all confirm
  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your learning list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  // Category selection
  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
    showToast("Category selected", "info");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  // ---------- Bottom Sheet logic (9 + 10 + 11 + 12) ----------
  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  // (11) open edit level sheet
  const openEditLevelSheet = (skill: SkillToLearn) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    // ----- QUICK ADD -----
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      // (12) smart add
      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        // show duplicate UI: offer edit level
        setDuplicateExisting(res.existing);
        showToast("Skill already exists — edit its level?", "info");
        // switch to edit mode but keep modal open
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- SUGGESTED ADD -----
    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list — edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    // ----- ADD ALL SUGGESTED -----
    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;

      // add all; duplicates will be skipped silently using addSkill
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      setFilterMode("all");
      setSearchQuery("");
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      closeSheet();
      return;
    }

    // ----- EDIT LEVEL (11) -----
    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };
  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills) {
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;
    }
    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }

    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  // loading
  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  // (20) stats

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {/* Toast */}
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you want to learn</Text>
        <Text style={styles.subtitle}>
          Choose a category then add skills with the right level for better
          matching.
        </Text>

        {/* Pending sync indicator (22) */}
        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
              ⏳ Saved locally — syncing when online
            </Text>
          </View>
        )}

        {/* Global Search */}
        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}>🔎 Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your learning list.
          </Text>
        </View>

        {/* Steps */}
        <View style={styles.stepsRow}>
          <View
            style={[styles.stepPill, isStep1Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>1</Text>
            <Text style={styles.stepPillText}>Category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep2Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>2</Text>
            <Text style={styles.stepPillText}>Sub-category</Text>
          </View>
          <View
            style={[styles.stepPill, isStep3Active && styles.stepPillActive]}
          >
            <Text style={styles.stepPillNumber}>3</Text>
            <Text style={styles.stepPillText}>Your list</Text>
          </View>
        </View>

        {/* Quick Start */}
        {showQuickStart && (
          <View style={styles.quickStartCard}>
            <View style={styles.quickStartHeader}>
              <Text style={styles.quickStartTitle}>🚀 Quick start</Text>
              <TouchableOpacity onPress={dismissQuickStart} activeOpacity={0.8}>
                <Text style={styles.quickStartDismiss}>Got it</Text>
              </TouchableOpacity>
            </View>

            <Text style={styles.quickStartText}>
              1) Pick a category {"\n"}
              2) Tap a suggested skill {"\n"}
              3) Choose your level and add
            </Text>
          </View>
        )}

        {/* Error box */}
        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops…</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        {/* Category */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>🧭 1. Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>You’re exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        {/* Discover */}
        {showDiscoverSection && (
          <>
            <Text style={styles.mainSectionTitle}>
              🔍 2. Discover skills to add
            </Text>

            <SuggestedSkillsGrid
              title={
                selectedCategory
                  ? `Popular in ${selectedCategory.name}`
                  : "Suggested skills"
              }
              description="Tap a skill to choose its level and add it."
              skills={suggestedSkillsByCategory}
              onAdd={(name) => openSuggestedAddSheet(name)}
              onAddAll={
                suggestedSkillsByCategory.length ? openAddAllSheet : undefined
              }
              existingSkills={skills.map((s) => s.name)}
              favoriteSkills={favoriteSkills}
              disableAddAll={saving || !suggestedSkillsByCategory.length}
            />

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Recommended skills for most people"
                description="Useful across many careers."
                skills={recommendedSkills}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}

            {showRecommended && (
              <SuggestedSkillsGrid
                title="Popular among SkillSwap learners"
                description="Skills many people are currently focusing on."
                skills={GLOBAL_POPULAR_SKILLS}
                onAdd={(name) => openSuggestedAddSheet(name)}
                existingSkills={skills.map((s) => s.name)}
                favoriteSkills={favoriteSkills}
              />
            )}
          </>
        )}

        {/* Add form (still available) */}
        <AddSkillToLearnForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        {/* Your list */}
        {showYourListSection && (
          <>
            <Text style={styles.mainSectionTitle}>
              📌 3. Your learning list
            </Text>

            {/* (20) Stats */}
            <View style={styles.statsCard}>
              <Text style={styles.statsText}>
                {stats.total} skills • {stats.fav} favorites
                {stats.topLevel ? ` • Top level: ${stats.topLevel}` : ""}
              </Text>
              <Text style={styles.statsHint}>
                Tip: to edit a level, open “Add” and type the same skill name.
              </Text>
            </View>

            <Text style={styles.recentHint}>
              Recent = your last 6 added skills.
            </Text>

            {skills.length === 0 ? (
              <View style={styles.emptyStateCard}>
                <Text style={styles.emptyStateTitle}>No skills yet</Text>
                <Text style={styles.emptyStateText}>
                  Start by picking a category above, or tap + to add a custom
                  skill quickly.
                </Text>

                <View style={styles.emptyStateButtons}>
                  <TouchableOpacity
                    style={styles.emptyPrimaryBtn}
                    onPress={() =>
                      showToast("Pick a category above 👆", "info")
                    }
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptyPrimaryText}>Pick a category</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={styles.emptySecondaryBtn}
                    onPress={openQuickAddSheet}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.emptySecondaryText}>
                      Add custom skill
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            ) : (
              <SkillsToLearnList
                skills={visibleSkills}
                totalCount={skills.length}
                searchQuery={searchQuery}
                onChangeSearchQuery={setSearchQuery}
                onRemove={removeSkill}
                favoriteSkills={favoriteSkills}
                onToggleFavorite={toggleFavorite}
                onClearAll={handleClearAllWithConfirm}
                filterMode={filterMode}
                onChangeFilter={setFilterMode}
              />
            )}
          </>
        )}

        {/* Undo bar */}
        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      {/* FAB */}
      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}>＋</Text>
      </TouchableOpacity>

      {/* Bottom Sheet modal */}
      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {/* Duplicate helper card (12) */}
          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name} · {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press “Save”.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. React Native"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {LEARN_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: You can also add from the main form below.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },

  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },

  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },

  title: { fontSize: 24, fontWeight: "700", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: {
    fontSize: 12,
    color: "#9a3412",
    fontWeight: "700",
  },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "600", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  stepsRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 12,
    gap: 8,
  },
  stepPill: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  stepPillActive: { backgroundColor: "#2563eb" },
  stepPillNumber: {
    fontSize: 12,
    fontWeight: "700",
    color: "#111827",
    marginRight: 4,
  },
  stepPillText: { fontSize: 12, color: "#111827", fontWeight: "500" },

  quickStartCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  quickStartHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  quickStartTitle: { fontSize: 14, fontWeight: "700", color: "#111827" },
  quickStartDismiss: { fontSize: 12, fontWeight: "600", color: "#2563eb" },
  quickStartText: { fontSize: 12, color: "#4b5563", lineHeight: 18 },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "600",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "800" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  recentHint: { fontSize: 11, color: "#6b7280", marginBottom: 8 },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "700", color: "#2563eb" },

  emptyStateCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  emptyStateTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },
  emptyStateText: { marginTop: 6, fontSize: 13, color: "#6b7280" },
  emptyStateButtons: {
    marginTop: 12,
    flexDirection: "row",
    gap: 8,
  },
  emptyPrimaryBtn: {
    flex: 1,
    backgroundColor: "#2563eb",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
  },
  emptyPrimaryText: { color: "#ffffff", fontWeight: "700", fontSize: 13 },
  emptySecondaryBtn: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    backgroundColor: "#f9fafb",
  },
  emptySecondaryText: { color: "#374151", fontWeight: "700", fontSize: 13 },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "600" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "800", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "700" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "800", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-learn/SkillChip.tsx">
// app/manage-skills-to-learn/SkillChip.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label: string;
  onPress: () => void;
  compact?: boolean;

  disabled?: boolean;
  added?: boolean;

  showPlusIcon?: boolean;
  isFavorite?: boolean;

  // (24) accessibility extras
  accessibilityHint?: string;
};

export function SkillChip({
  label,
  onPress,
  compact = false,
  disabled = false,
  added = false,
  showPlusIcon = false,
  isFavorite = false,
  accessibilityHint,
}: Props) {
  const showPlus = showPlusIcon && !added;
  const showCheck = added;

  const badgeText = showCheck ? "✓" : showPlus ? "＋" : "";
  const badgeLabel = showCheck ? "Added" : showPlus ? "Add" : "";

  return (
    <TouchableOpacity
      onPress={disabled ? () => {} : onPress}
      activeOpacity={disabled ? 1 : 0.85}
      disabled={disabled}
      style={[
        styles.chip,
        compact && styles.chipCompact,
        disabled && styles.chipDisabled,
        added && styles.chipAdded,
      ]}
      accessibilityRole="button"
      accessibilityLabel={label}
      accessibilityHint={
        accessibilityHint ||
        (disabled ? "This item is disabled." : "Tap to select this skill.")
      }
      hitSlop={{ top: 6, bottom: 6, left: 6, right: 6 }}
    >
      <View style={styles.row}>
        {/* Left badge (＋ / ✓) */}
        {(showPlus || showCheck) && (
          <View
            style={[
              styles.badge,
              showCheck && styles.badgeCheck,
              showPlus && styles.badgePlus,
            ]}
            accessibilityLabel={badgeLabel}
          >
            <Text style={styles.badgeText}>{badgeText}</Text>
          </View>
        )}

        {/* Favorite star */}
        {isFavorite && (
          <Text style={styles.star} accessibilityLabel="Favorite">
            ★
          </Text>
        )}

        <Text
          style={[styles.label, disabled && styles.labelDisabled]}
          numberOfLines={1}
        >
          {label}
        </Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  chip: {
    alignSelf: "flex-start",
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  chipCompact: {
    paddingHorizontal: 10,
    paddingVertical: 7,
  },
  chipDisabled: {
    opacity: 0.62,
  },
  chipAdded: {
    backgroundColor: "#dcfce7",
    borderColor: "#86efac",
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },

  badge: {
    width: 18,
    height: 18,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  badgeCheck: {
    backgroundColor: "#16a34a",
    borderColor: "#16a34a",
  },
  badgePlus: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  badgeText: {
    fontSize: 12,
    color: "#ffffff",
    fontWeight: "900",
    lineHeight: 14,
  },

  star: {
    fontSize: 14,
    color: "#f59e0b",
    fontWeight: "900",
    marginRight: 2,
  },

  label: {
    fontSize: 13,
    color: "#111827",
    fontWeight: "600",
    maxWidth: 240,
  },
  labelDisabled: {
    color: "#6b7280",
  },
});
</file>

<file path="app/manage-skills-to-learn/skillData.ts">
// app/manage-skills-to-learn/skillData.ts

export type SkillSubCategory = {
  id: string;
  name: string;
  skills: string[];
};

export type SkillCategory = {
  id: string;
  name: string;
  icon: string; // ✅ FIX
  subCategories: SkillSubCategory[];
};

export const SKILL_CATEGORIES: SkillCategory[] = [
  {
    id: "programming",
    name: "Programming",
    icon: "💻",
    subCategories: [
      {
        id: "frontend",
        name: "Frontend",
        skills: ["HTML", "CSS", "JavaScript", "React", "TypeScript"],
      },
      {
        id: "backend",
        name: "Backend",
        skills: ["Node.js", "Express", "MongoDB", "SQL"],
      },
    ],
  },
  {
    id: "languages",
    name: "Languages",
    icon: "🗣️",
    subCategories: [
      {
        id: "spoken",
        name: "Spoken",
        skills: ["English", "Hebrew", "Arabic", "Spanish"],
      },
    ],
  },
];

export const RECOMMENDED_SKILLS = ["Public speaking", "Time management", "Problem solving"];

export const ALL_KNOWN_SKILLS = Array.from(
  new Set(SKILL_CATEGORIES.flatMap((c) => c.subCategories.flatMap((s) => s.skills)))
);
</file>

<file path="app/manage-skills-to-learn/SkillsToLearnList.tsx">
// app/manage-skills-to-learn/SkillsToLearnList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillChip } from "./SkillChip";
import { SkillToLearn } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillToLearn[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  // ✅ FIX: now matches the hook perfectly
  onRemove: (skill: SkillToLearn) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;
  onClearAll: () => void;
  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;
  onLayoutCard?: (y: number) => void;
};

export const SkillsToLearnList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "✔";
    if (mode === "favorites") return "★";
    return "⏱";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your learning list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your learning skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You don’t have any learning skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <SkillChip
                  label={`${skill.name} · ${skill.level}`}
                  onPress={() => {}}
                />

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                  >
                    <Text style={styles.favoriteText}>{fav ? "★" : "☆"}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)} // ✅ FIX: remove by object
                    style={styles.removeButton}
                  >
                    <Text style={styles.removeIcon}>🗑</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity style={styles.clearAllButton} onPress={onClearAll}>
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: {
    flexDirection: "row",
    gap: 6,
    marginBottom: 8,
  },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: {
    backgroundColor: "#2563eb",
    borderColor: "#2563eb",
  },
  filterChipText: {
    fontSize: 12,
    color: "#374151",
  },
  filterChipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: {
    fontSize: 13,
    color: "#6b7280",
  },
  skillsWrap: {
    gap: 8,
  },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: {
    paddingHorizontal: 6,
    paddingVertical: 4,
  },
  favoriteText: {
    fontSize: 16,
    color: "#f59e0b",
  },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: {
    fontSize: 13,
  },
  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: {
    fontSize: 12,
    color: "#374151",
  },
});
</file>

<file path="app/manage-skills-to-learn/SubCategorySelector.tsx">
// app/manage-skills-to-learn/SubCategorySelector.tsx
import React from "react";
import {
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SkillSubCategory } from "./skillData";

type Props = {
  subCategories: SkillSubCategory[];
  selectedSubCategoryId: string | null;
  onSelect: (id: string | null) => void;
};

export const SubCategorySelector: React.FC<Props> = ({
  subCategories,
  selectedSubCategoryId,
  onSelect,
}) => {
  if (!subCategories.length) return null;

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Sub-category</Text>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.row}
      >
        <TouchableOpacity
          style={[
            styles.chip,
            selectedSubCategoryId === null && styles.chipActive,
          ]}
          onPress={() => onSelect(null)}
        >
          <Text
            style={[
              styles.chipText,
              selectedSubCategoryId === null && styles.chipTextActive,
            ]}
          >
            All
          </Text>
        </TouchableOpacity>

        {subCategories.map((sub) => {
          const isActive = sub.id === selectedSubCategoryId;
          return (
            <TouchableOpacity
              key={sub.id}
              style={[styles.chip, isActive && styles.chipActive]}
              onPress={() => onSelect(sub.id)}
              activeOpacity={0.8}
            >
              <Text
                style={[styles.chipText, isActive && styles.chipTextActive]}
              >
                {sub.name}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
  label: {
    fontSize: 13,
    fontWeight: "600",
    color: "#4b5563",
    marginBottom: 6,
  },
  row: {
    flexDirection: "row",
    gap: 8,
  },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
  },
  chipActive: {
    backgroundColor: "#1d4ed8",
  },
  chipText: {
    fontSize: 13,
    color: "#111827",
  },
  chipTextActive: {
    color: "#ffffff",
    fontWeight: "600",
  },
});
</file>

<file path="app/manage-skills-to-learn/SuggestedSkillsGrid.tsx">
// app/manage-skills-to-learn/SuggestedSkillsGrid.tsx
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { SkillChip } from "./SkillChip";

type Props = {
  title: string;
  description?: string;
  skills: string[];
  onAdd: (name: string) => void;
  onAddAll?: () => void;
  existingSkills: string[]; // names only
  favoriteSkills: string[]; // names only
  disableAddAll?: boolean;
};

export default function SuggestedSkillsGrid({
  title,
  description,
  skills,
  onAdd,
  onAddAll,
  existingSkills,
  favoriteSkills,
  disableAddAll = false,
}: Props) {
  const existingLower = new Set(existingSkills.map((s) => s.toLowerCase()));
  const favLower = new Set(favoriteSkills.map((s) => s.toLowerCase()));

  if (!skills?.length) return null;

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>{title}</Text>
          {!!description && <Text style={styles.desc}>{description}</Text>}
        </View>

        {!!onAddAll && (
          <TouchableOpacity
            onPress={disableAddAll ? () => {} : onAddAll}
            activeOpacity={disableAddAll ? 1 : 0.8}
            style={[styles.addAllBtn, disableAddAll && { opacity: 0.5 }]}
            disabled={disableAddAll}
          >
            <Text style={styles.addAllText}>Add all</Text>
          </TouchableOpacity>
        )}
      </View>

      <View style={styles.wrap}>
        {skills.map((name) => {
          const added = existingLower.has(name.toLowerCase());
          const isFav = favLower.has(name.toLowerCase());

          // ✅ مهم: SkillChip لازم onPress دايمًا
          const handlePress = added ? () => {} : () => onAdd(name);

          return (
            <SkillChip
              key={name}
              label={name}
              onPress={handlePress}
              compact
              disabled={added}
              added={added}
              showPlusIcon={!added}
              isFavorite={isFav}
            />
          );
        })}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 10,
  },
  title: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
  },
  desc: {
    marginTop: 4,
    fontSize: 12,
    color: "#6b7280",
  },
  addAllBtn: {
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 6,
    backgroundColor: "#f9fafb",
  },
  addAllText: {
    fontSize: 12,
    color: "#374151",
    fontWeight: "600",
  },
  wrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
});
</file>

<file path="app/manage-skills-to-learn/types.ts">
// app/manage-skills-to-learn/types.ts

export const LEARN_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type LearnLevel = (typeof LEARN_LEVELS)[number];

export type SkillToLearn = {
  name: string;
  level: LearnLevel;
};

export type UndoState = {
  skill: SkillToLearn;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-learn/useManageSkillsToLearn.ts">
// app/manage-skills-to-learn/useManageSkillsToLearn.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "./skillData";
import { LEARN_LEVELS, LearnLevel, SkillToLearn, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToLearnFavorites";

// (22) offline pending sync
const PENDING_SKILLS_KEY = "skillsToLearn_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillToLearn }
  | { ok: false; existed: true; existing: SkillToLearn }
  | { ok: false; existed: false; error: string };

// normalize level
function normalizeLearnLevel(raw?: string | null): LearnLevel {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = LEARN_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToLearn() {
  const [skills, setSkills] = useState<SkillToLearn[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  // (22) indicates we have unsynced local changes
  const [hasPendingSync, setHasPendingSync] = useState(false);

  // category / subcategory
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  // ---------- helpers ----------
  function findExistingSkill(name: string): SkillToLearn | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  // (22) store pending local changes when backend update fails
  async function savePendingSkills(next: SkillToLearn[]) {
    try {
      await AsyncStorage.setItem(PENDING_SKILLS_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePendingSkills error:", e);
    }
  }

  async function clearPendingSkills() {
    try {
      await AsyncStorage.removeItem(PENDING_SKILLS_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPendingSkills error:", e);
    }
  }

  async function loadPendingSkills(): Promise<SkillToLearn[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillToLearn[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return {
            name,
            level: normalizeLearnLevel(item.level),
          } as SkillToLearn;
        })
        .filter(Boolean) as SkillToLearn[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPendingSkills error:", e);
      return null;
    }
  }

  // (22) try to sync pending changes to backend
  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPendingSkills();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      // if there are pending changes, push them
      await updateProfile(token, { skillsToLearn: pending });
      await clearPendingSkills();

      // make sure local state matches pending
      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e: any) {
      // stay pending
      console.log("trySyncPending error:", e);
      setHasPendingSync(true);
    }
  }

  // ---- load from backend + favorites local ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        // (22) attempt sync pending first
        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        // NOTE: backend old format could be string[] OR new format object[]
        const raw = Array.isArray(userFromApi?.skillsToLearn)
          ? userFromApi.skillsToLearn
          : [];

        const cleanSkills: SkillToLearn[] = raw
          .map((item: any) => {
            // string -> object
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as LearnLevel };
            }

            // object -> normalize
            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLearnLevel(item.level),
              } as SkillToLearn;
            }

            return null;
          })
          .filter(Boolean) as SkillToLearn[];

        // sort by name
        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        // favorites local
        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        // pending indicator
        const pending = await AsyncStorage.getItem(PENDING_SKILLS_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToLearn load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load learning skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  // ---- persist skills to backend ----
  async function persistSkills(next: SkillToLearn[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, {
        skillsToLearn: next,
      });

      // if this succeeds, clear pending
      await clearPendingSkills();
    } catch (e: any) {
      console.log("updateProfile(skillsToLearn) error:", e);

      // (22) store pending changes locally
      await savePendingSkills(next);

      setError(
        e?.message ||
          "Failed to save learning skills. Your changes are saved locally and will sync when you're back online."
      );
    } finally {
      setSaving(false);
    }
  }

  // ---- persist favorites local ----
  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites learn error:", e);
    }
  }

  // ---- add skill (kept the same signature: boolean) ----
  async function addSkill(name: string, level?: LearnLevel): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  // ---- (12) add skill smart: tells you if it exists and returns existing skill ----
  async function addSkillSmart(
    name: string,
    level?: LearnLevel
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      // don't set as a hard error; this is a "smart" signal
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillToLearn = {
      name: trimmed,
      level: normalizeLearnLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  // ---- (11) update level for an existing skill ----
  async function updateSkillLevel(
    name: string,
    newLevel: LearnLevel
  ): Promise<boolean> {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalizedLevel = normalizeLearnLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalizedLevel) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalizedLevel };

    // keep alphabetical order stable
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  // ---- remove skill (accept SkillToLearn object) ----
  async function removeSkill(skill: SkillToLearn) {
    const skillName = skill.name;

    const index = skills.findIndex((s) => sameName(s.name, skillName));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    // remove from favorites if needed
    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  // ---- clear all ----
  async function clearAllSkills() {
    const next: SkillToLearn[] = [];
    setSkills(next);
    setLastRemoved(null);

    await persistFavorites([]);
    await persistSkills(next);
  }

  // ---- undo remove ----
  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);

    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  // ---- toggle favorite ----
  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));

    let next: string[];
    if (exists) {
      next = favoriteSkills.filter((f) => !sameName(f, name));
    } else {
      next = [...favoriteSkills, name];
    }

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---- category helpers ----
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  // ---- filtered + sorted (favorites first) ----
  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();

    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync, // (22)

    // category stuff
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill, // keep old
    addSkillSmart, // (12) new
    updateSkillLevel, // (11) new
    trySyncPending, // (22) new

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/manage-skills-to-teach/AddSkillToTeachForm.tsx">
// app/manage-skills-to-teach/AddSkillToTeachForm.tsx
import React, { useMemo, useState } from "react";
import {
  Keyboard,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { Level, TEACH_LEVELS } from "./types";

type Props = {
  onAdd: (name: string, level?: Level) => Promise<void> | void;
  onAddFavorite: (name: string, level?: Level) => Promise<void> | void;
  isSaving: boolean;
  suggestionPool: string[];
  placeholderHint?: string;
};

const MAX_SUGGESTIONS = 10;

export default function AddSkillToTeachForm({
  onAdd,
  onAddFavorite,
  isSaving,
  suggestionPool,
  placeholderHint,
}: Props) {
  const [value, setValue] = useState("");
  const [localError, setLocalError] = useState<string | null>(null);
  const [selectedLevel, setSelectedLevel] = useState<Level>("Intermediate");

  const normalizedValue = value.trim();
  const showPlaceholder =
    placeholderHint || "e.g. Math tutoring, React, Guitar";

  const filteredSuggestions = useMemo(() => {
    const base = Array.isArray(suggestionPool) ? suggestionPool : [];
    if (!normalizedValue) return base.slice(0, MAX_SUGGESTIONS);

    const q = normalizedValue.toLowerCase();
    const starts = base.filter((s) => s.toLowerCase().startsWith(q));
    const contains = base.filter(
      (s) => !s.toLowerCase().startsWith(q) && s.toLowerCase().includes(q)
    );

    return [...starts, ...contains].slice(0, MAX_SUGGESTIONS);
  }, [normalizedValue, suggestionPool]);

  const validate = () => {
    if (!normalizedValue) return "Please type a skill name first.";
    if (normalizedValue.length < 2) return "Skill name is too short.";
    return null;
  };

  const handleSubmit = async (favorite = false) => {
    const err = validate();
    if (err) {
      setLocalError(err);
      return;
    }

    setLocalError(null);

    try {
      if (favorite) await onAddFavorite(normalizedValue, selectedLevel);
      else await onAdd(normalizedValue, selectedLevel);

      setValue("");
      Keyboard.dismiss();
    } catch (e) {
      console.log("AddSkillToTeachForm submit error:", e);
    }
  };

  const handleClear = () => {
    setLocalError(null);
    setValue("");
  };

  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Add a custom teaching skill</Text>
        <Text style={styles.badge}>Optional</Text>
      </View>

      <Text style={styles.subtitle}>
        Add what you can teach and choose your level.
      </Text>

      <Text style={styles.label}>Level</Text>
      <View style={styles.levelRow}>
        {TEACH_LEVELS.slice(0, 4).map((lvl) => {
          const active = selectedLevel === lvl;
          return (
            <TouchableOpacity
              key={lvl}
              style={[styles.levelPill, active && styles.levelPillActive]}
              onPress={() => setSelectedLevel(lvl)}
              activeOpacity={0.85}
              disabled={isSaving}
            >
              <Text
                style={[
                  styles.levelPillText,
                  active && styles.levelPillTextActive,
                ]}
              >
                {lvl}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>

      <View style={styles.inputHeader}>
        <Text style={styles.label}>Skill name</Text>
        {!!value && (
          <TouchableOpacity
            onPress={handleClear}
            activeOpacity={0.85}
            disabled={isSaving}
          >
            <Text style={styles.clearText}>Clear</Text>
          </TouchableOpacity>
        )}
      </View>

      <TextInput
        style={[styles.input, localError && styles.inputError]}
        placeholder={showPlaceholder}
        placeholderTextColor="#9ca3af"
        value={value}
        onChangeText={(t) => {
          setLocalError(null);
          setValue(t);
        }}
        autoCapitalize="sentences"
        returnKeyType="done"
        editable={!isSaving}
        onSubmitEditing={() => handleSubmit(false)}
      />

      {localError && <Text style={styles.errorText}>{localError}</Text>}

      <View style={styles.buttonsRow}>
        <TouchableOpacity
          style={[
            styles.button,
            styles.primaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(false)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.primaryButtonText}>
            {isSaving ? "Saving..." : "Add skill"}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.button,
            styles.secondaryButton,
            isSaving && { opacity: 0.7 },
          ]}
          onPress={() => handleSubmit(true)}
          disabled={isSaving}
          activeOpacity={0.85}
        >
          <Text style={styles.secondaryButtonText}>Add & favorite</Text>
        </TouchableOpacity>
      </View>

      {filteredSuggestions.length > 0 && (
        <View style={styles.suggestionsSection}>
          <View style={styles.suggestionsHeader}>
            <Text style={styles.suggestionsTitle}>Suggestions</Text>
            <Text style={styles.suggestionsHint}>Tap to fill the input</Text>
          </View>

          <View style={styles.suggestionsRow}>
            {filteredSuggestions.map((s) => (
              <SkillChip
                key={s}
                label={s}
                onPress={() => setValue(s)}
                compact
                disabled={isSaving}
              />
            ))}
          </View>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: { fontSize: 15, fontWeight: "800", color: "#111827" },
  badge: {
    fontSize: 11,
    fontWeight: "800",
    color: "#374151",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
  },
  subtitle: {
    fontSize: 13,
    color: "#6b7280",
    marginTop: 6,
    marginBottom: 10,
    lineHeight: 18,
  },
  label: {
    fontSize: 12,
    fontWeight: "700",
    color: "#4b5563",
    marginBottom: 6,
  },
  levelRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "800" },
  levelPillTextActive: { color: "#ffffff" },

  inputHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  clearText: { fontSize: 12, fontWeight: "800", color: "#2563eb" },
  input: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  inputError: { borderColor: "#fca5a5", backgroundColor: "#fff1f2" },
  errorText: { fontSize: 12, color: "#b91c1c", marginTop: 6 },

  buttonsRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  button: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  primaryButton: { backgroundColor: "#2563eb" },
  primaryButtonText: { color: "#f9fafb", fontSize: 13, fontWeight: "900" },
  secondaryButton: {
    borderWidth: 1,
    borderColor: "#9ca3af",
    backgroundColor: "#ffffff",
  },
  secondaryButtonText: { color: "#374151", fontSize: 13, fontWeight: "800" },

  suggestionsSection: { marginTop: 12 },
  suggestionsHeader: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  suggestionsTitle: { fontSize: 12, color: "#6b7280", fontWeight: "800" },
  suggestionsHint: { fontSize: 11, color: "#9ca3af", fontWeight: "700" },
  suggestionsRow: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
});
</file>

<file path="app/manage-skills-to-teach/index.tsx">
// app/manage-skills-to-teach/index.tsx
import React from "react";
import ManageSkillsToTeachScreen from "./ManageSkillsToTeachScreen";

export default function ManageSkillsToTeachRoute() {
  return <ManageSkillsToTeachScreen />;
}
</file>

<file path="app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx">
// app/manage-skills-to-teach/ManageSkillsToTeachScreen.tsx
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Modal,
  Platform,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

// ✅ reuse learn components
import CategorySelector from "../manage-skills-to-learn/CategorySelector";
import { SubCategorySelector } from "../manage-skills-to-learn/SubCategorySelector";
import SuggestedSkillsGrid from "../manage-skills-to-learn/SuggestedSkillsGrid";
import { SkillSubCategory } from "../manage-skills-to-learn/skillData";

import AddSkillToTeachForm from "./AddSkillToTeachForm";
import { SkillsToTeachList } from "./SkillsToTeachList";
import { Level, SkillTeach, TEACH_LEVELS } from "./types";
import { useManageSkillsToTeach } from "./useManageSkillsToTeach";

const GLOBAL_POPULAR_SKILLS: string[] = [
  "Math tutoring",
  "English conversation",
  "React",
  "Node.js",
  "UI/UX basics",
  "Public speaking",
];

type FilterMode = "all" | "favorites" | "recent";
type ToastType = "success" | "error" | "info";
type ToastState = { visible: boolean; message: string; type: ToastType };
type SheetMode = "quickAdd" | "suggestedAdd" | "addAllSuggested" | "editLevel";

export default function ManageSkillsToTeachScreen() {
  const router = useRouter();

  const {
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  } = useManageSkillsToTeach();

  const [filterMode, setFilterMode] = useState<FilterMode>("all");
  const [lastAdded, setLastAdded] = useState<string | null>(null);

  const [toast, setToast] = useState<ToastState>({
    visible: false,
    message: "",
    type: "info",
  });
  const toastTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [sheetOpen, setSheetOpen] = useState(false);
  const [sheetMode, setSheetMode] = useState<SheetMode>("quickAdd");
  const [sheetSkillName, setSheetSkillName] = useState("");
  const [sheetSelectedLevel, setSheetSelectedLevel] =
    useState<Level>("Intermediate");

  const [duplicateExisting, setDuplicateExisting] = useState<SkillTeach | null>(
    null
  );

  const currentSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const breadcrumbLabel = useMemo(() => {
    if (!selectedCategory && !currentSubCategory) {
      return "Browse all skills or pick a category to get focused suggestions.";
    }
    if (selectedCategory && !currentSubCategory) {
      return `Category: ${selectedCategory.name}`;
    }
    if (selectedCategory && currentSubCategory) {
      return `${selectedCategory.name} → ${currentSubCategory.name}`;
    }
    return "";
  }, [selectedCategory, currentSubCategory]);

  const dynamicPlaceholder = useMemo(() => {
    const name = selectedCategory?.name?.toLowerCase() || "";
    if (name.includes("program"))
      return "Search or add: React, Node.js, Data structures...";
    if (name.includes("lang"))
      return "Search or add: English speaking, Hebrew, Arabic...";
    if (name.includes("design"))
      return "Search or add: UI design, Figma, Logo design...";
    if (name.includes("business") || name.includes("product"))
      return "Search or add: Project management, Marketing...";
    return "Search or add: Math tutoring, Guitar, Public speaking...";
  }, [selectedCategory]);

  const visibleSkills = useMemo(() => {
    let base: SkillTeach[] = filteredSkills;

    if (filterMode === "favorites") {
      base = base.filter((s) =>
        favoriteSkills.some((f) => f.toLowerCase() === s.name.toLowerCase())
      );
    } else if (filterMode === "recent") {
      const recent = skills.slice(-6);
      base = recent.filter((s) =>
        filteredSkills.some((fs) => fs.name === s.name)
      );
    }

    return base;
  }, [filteredSkills, favoriteSkills, filterMode, skills]);

  const stats = useMemo(() => {
    const total = skills.length;
    const fav = favoriteSkills.length;

    const levelCounts: Record<string, number> = {};
    for (const s of skills)
      levelCounts[s.level] = (levelCounts[s.level] ?? 0) + 1;

    let topLevel: string | null = null;
    let topCount = 0;
    for (const k of Object.keys(levelCounts)) {
      const c = levelCounts[k];
      if (c > topCount) {
        topCount = c;
        topLevel = k;
      }
    }
    return { total, fav, topLevel };
  }, [skills, favoriteSkills]);

  const showToast = (message: string, type: ToastType = "info") => {
    if (toastTimer.current) clearTimeout(toastTimer.current);
    setToast({ visible: true, message, type });
    toastTimer.current = setTimeout(() => {
      setToast((t) => ({ ...t, visible: false }));
    }, 2400);
  };

  useEffect(() => {
    if (!lastAdded) return;
    showToast(`Added ${lastAdded}`, "success");
    const id = setTimeout(() => setLastAdded(null), 2500);
    return () => clearTimeout(id);
  }, [lastAdded]);

  useEffect(() => {
    trySyncPending();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleAddSkillBase = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    setLastAdded(`${name} (${safe})`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleAddSkillAndFavorite = async (name: string, level?: Level) => {
    const safe: Level = level ?? "Not specified";
    const ok = await addSkill(name, safe);
    if (!ok) return;
    await toggleFavorite(name);
    setLastAdded(`${name} (${safe}) ★`);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleClearAllWithConfirm = () => {
    if (!skills.length) return;

    Alert.alert("Remove all skills?", "This will clear your teaching list.", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Clear all",
        style: "destructive",
        onPress: () => clearAllSkills(),
      },
    ]);
  };

  const handleSelectCategory = (id: string) => {
    setSelectedCategoryId(id);
    setSelectedSubCategoryId(null);
    setFilterMode("all");
    setSearchQuery("");
  };

  const handleSelectSubCategory = (id: string | null) => {
    setSelectedSubCategoryId(id);
    setFilterMode("all");
    setSearchQuery("");
  };

  const openQuickAddSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("quickAdd");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openSuggestedAddSheet = (skillName: string) => {
    setDuplicateExisting(null);
    setSheetMode("suggestedAdd");
    setSheetSkillName(skillName);
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openAddAllSheet = () => {
    setDuplicateExisting(null);
    setSheetMode("addAllSuggested");
    setSheetSkillName("");
    setSheetSelectedLevel("Intermediate");
    setSheetOpen(true);
  };

  const openEditLevelSheet = (skill: SkillTeach) => {
    setDuplicateExisting(null);
    setSheetMode("editLevel");
    setSheetSkillName(skill.name);
    setSheetSelectedLevel(skill.level);
    setSheetOpen(true);
  };

  const closeSheet = () => setSheetOpen(false);

  const confirmSheetAction = async () => {
    if (sheetMode === "quickAdd") {
      const name = sheetSkillName.trim();
      if (!name) {
        showToast("Type a skill name first.", "error");
        return;
      }

      const res = await addSkillSmart(name, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }

      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Skill already exists — edit its level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }

      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "suggestedAdd") {
      const res = await addSkillSmart(sheetSkillName, sheetSelectedLevel);
      if (res.ok) {
        setLastAdded(`${res.skill.name} (${res.skill.level})`);
        setFilterMode("all");
        setSearchQuery("");
        closeSheet();
        return;
      }
      if (!res.ok && res.existed) {
        setDuplicateExisting(res.existing);
        showToast("Already in your list — edit level?", "info");
        setSheetMode("editLevel");
        setSheetSkillName(res.existing.name);
        setSheetSelectedLevel(res.existing.level);
        return;
      }
      showToast(res.error || "Could not add skill.", "error");
      return;
    }

    if (sheetMode === "addAllSuggested") {
      if (!suggestedSkillsByCategory.length) return;
      for (const skillName of suggestedSkillsByCategory) {
        await addSkill(skillName, sheetSelectedLevel);
      }
      showToast(
        `Added ${suggestedSkillsByCategory.length} skills (${sheetSelectedLevel})`,
        "success"
      );
      setFilterMode("all");
      setSearchQuery("");
      closeSheet();
      return;
    }

    if (sheetMode === "editLevel") {
      const ok = await updateSkillLevel(sheetSkillName, sheetSelectedLevel);
      if (ok) {
        showToast(`Updated level for ${sheetSkillName}`, "success");
        closeSheet();
      }
      return;
    }
  };

  if (loadingInitial) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your skills...</Text>
      </View>
    );
  }

  const showRecommended = !selectedCategoryId;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#f4f4f5" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      {toast.visible && (
        <View
          style={[styles.toast, toast.type === "error" && styles.toastError]}
        >
          <Text style={styles.toastText}>{toast.message}</Text>
        </View>
      )}

      <ScrollView
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={() => router.back()} activeOpacity={0.8}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Skills you can teach</Text>
        <Text style={styles.subtitle}>
          Add what you can teach with the right level for better matching.
        </Text>

        {hasPendingSync && (
          <View style={styles.pendingSyncBar}>
            <Text style={styles.pendingSyncText}>
              ⏳ Saved locally — syncing when online
            </Text>
          </View>
        )}

        <View style={styles.globalSearchWrap}>
          <Text style={styles.globalSearchLabel}>🔎 Search</Text>
          <TextInput
            style={styles.globalSearchInput}
            placeholder={dynamicPlaceholder}
            value={searchQuery}
            onChangeText={setSearchQuery}
            placeholderTextColor="#9ca3af"
          />
          <Text style={styles.globalSearchHint}>
            Search filters your teaching list.
          </Text>
        </View>

        {error && (
          <TouchableOpacity
            style={styles.errorBox}
            onPress={clearError}
            activeOpacity={0.85}
          >
            <Text style={styles.errorTitle}>Oops…</Text>
            <Text style={styles.errorText}>{error}</Text>
            <Text style={styles.errorHint}>Tap to dismiss</Text>
          </TouchableOpacity>
        )}

        <View style={styles.card}>
          <Text style={styles.sectionTitle}>🧭 Category & sub-category</Text>
          <Text style={styles.sectionDescription}>
            Pick a category to get focused suggestions.
          </Text>

          <View style={styles.breadcrumbBar}>
            <Text style={styles.breadcrumbLabel}>You’re exploring</Text>
            <Text style={styles.breadcrumbText}>{breadcrumbLabel}</Text>
          </View>

          <CategorySelector
            selectedCategoryId={selectedCategoryId}
            onSelect={handleSelectCategory}
          />

          <SubCategorySelector
            subCategories={subCategories}
            selectedSubCategoryId={selectedSubCategoryId}
            onSelect={handleSelectSubCategory}
          />
        </View>

        <Text style={styles.mainSectionTitle}>🔍 Discover skills to add</Text>

        <SuggestedSkillsGrid
          title={
            selectedCategory
              ? `Popular in ${selectedCategory.name}`
              : "Suggested skills"
          }
          description="Tap a skill to choose its level and add it."
          skills={suggestedSkillsByCategory}
          onAdd={(name) => openSuggestedAddSheet(name)}
          onAddAll={
            suggestedSkillsByCategory.length ? openAddAllSheet : undefined
          }
          existingSkills={skills.map((s) => s.name)}
          favoriteSkills={favoriteSkills}
          disableAddAll={saving || !suggestedSkillsByCategory.length}
        />

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Recommended skills for most people"
            description="Useful across many careers."
            skills={recommendedSkills}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        {showRecommended && (
          <SuggestedSkillsGrid
            title="Popular among SkillSwap mentors"
            description="Skills many mentors are currently teaching."
            skills={GLOBAL_POPULAR_SKILLS}
            onAdd={(name) => openSuggestedAddSheet(name)}
            existingSkills={skills.map((s) => s.name)}
            favoriteSkills={favoriteSkills}
          />
        )}

        <AddSkillToTeachForm
          onAdd={handleAddSkillBase}
          onAddFavorite={handleAddSkillAndFavorite}
          isSaving={saving}
          suggestionPool={suggestionPoolForInput}
          placeholderHint={dynamicPlaceholder}
        />

        <Text style={styles.mainSectionTitle}>📌 Your teaching list</Text>

        <View style={styles.statsCard}>
          <Text style={styles.statsText}>
            {stats.total} skills • {stats.fav} favorites
            {stats.topLevel ? ` • Top level: ${stats.topLevel}` : ""}
          </Text>
          <Text style={styles.statsHint}>Tap a skill to edit its level.</Text>
        </View>

        <SkillsToTeachList
          skills={visibleSkills}
          totalCount={skills.length}
          searchQuery={searchQuery}
          onChangeSearchQuery={setSearchQuery}
          onRemove={removeSkill}
          favoriteSkills={favoriteSkills}
          onToggleFavorite={toggleFavorite}
          onClearAll={handleClearAllWithConfirm}
          filterMode={filterMode}
          onChangeFilter={setFilterMode}
          onEditLevel={openEditLevelSheet}
        />

        {lastRemoved && (
          <View style={styles.undoBar}>
            <Text style={styles.undoText}>
              Removed {lastRemoved.skill.name}
            </Text>
            <TouchableOpacity onPress={undoRemove} activeOpacity={0.85}>
              <Text style={styles.undoButtonText}>Undo</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={{ height: 90 }} />
      </ScrollView>

      <TouchableOpacity
        style={[styles.fab, saving && { opacity: 0.6 }]}
        onPress={openQuickAddSheet}
        activeOpacity={0.85}
        disabled={saving}
      >
        <Text style={styles.fabText}>＋</Text>
      </TouchableOpacity>

      <Modal
        visible={sheetOpen}
        transparent
        animationType="fade"
        onRequestClose={closeSheet}
      >
        <Pressable style={styles.sheetBackdrop} onPress={closeSheet} />
        <View style={styles.sheetContainer}>
          <View style={styles.sheetHandle} />

          <Text style={styles.sheetTitle}>
            {sheetMode === "quickAdd" && "Add a skill"}
            {sheetMode === "suggestedAdd" && `Add "${sheetSkillName}"`}
            {sheetMode === "addAllSuggested" && "Add all suggested skills"}
            {sheetMode === "editLevel" && `Edit level: "${sheetSkillName}"`}
          </Text>

          {duplicateExisting && (
            <View style={styles.duplicateCard}>
              <Text style={styles.duplicateTitle}>Already in your list</Text>
              <Text style={styles.duplicateText}>
                Current: {duplicateExisting.name} · {duplicateExisting.level}
              </Text>
              <Text style={styles.duplicateHint}>
                Pick a new level below and press “Save”.
              </Text>
            </View>
          )}

          {sheetMode === "quickAdd" && (
            <View style={{ marginTop: 10 }}>
              <Text style={styles.sheetLabel}>Skill name</Text>
              <TextInput
                style={styles.sheetInput}
                placeholder="e.g. Math tutoring"
                placeholderTextColor="#9ca3af"
                value={sheetSkillName}
                onChangeText={(t) => {
                  setDuplicateExisting(null);
                  setSheetSkillName(t);
                }}
                autoCapitalize="sentences"
              />
            </View>
          )}

          <View style={{ marginTop: 14 }}>
            <Text style={styles.sheetLabel}>Choose level</Text>
            <View style={styles.levelRow}>
              {TEACH_LEVELS.slice(0, 4).map((lvl) => {
                const active = sheetSelectedLevel === lvl;
                return (
                  <TouchableOpacity
                    key={lvl}
                    style={[styles.levelPill, active && styles.levelPillActive]}
                    onPress={() => setSheetSelectedLevel(lvl)}
                    activeOpacity={0.85}
                  >
                    <Text
                      style={[
                        styles.levelPillText,
                        active && styles.levelPillTextActive,
                      ]}
                    >
                      {lvl}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <View style={styles.sheetButtonsRow}>
            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnSecondary]}
              onPress={closeSheet}
              activeOpacity={0.85}
            >
              <Text style={styles.sheetBtnSecondaryText}>Cancel</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.sheetBtn, styles.sheetBtnPrimary]}
              onPress={confirmSheetAction}
              activeOpacity={0.85}
              disabled={saving}
            >
              <Text style={styles.sheetBtnPrimaryText}>
                {saving
                  ? "Saving..."
                  : sheetMode === "editLevel"
                  ? "Save"
                  : "Add"}
              </Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.sheetHint}>
            Tip: Tap a skill in the list to edit level.
          </Text>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  centered: {
    flex: 1,
    backgroundColor: "#f4f4f5",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 8, fontSize: 14, color: "#4b5563" },
  container: { paddingHorizontal: 20, paddingTop: 16, paddingBottom: 32 },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  backText: { fontSize: 14, color: "#3b82f6" },
  title: { fontSize: 24, fontWeight: "800", color: "#111827", marginTop: 8 },
  subtitle: { fontSize: 14, color: "#6b7280", marginTop: 4 },

  pendingSyncBar: {
    marginTop: 10,
    backgroundColor: "#fff7ed",
    borderWidth: 1,
    borderColor: "#fed7aa",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 14,
  },
  pendingSyncText: { fontSize: 12, color: "#9a3412", fontWeight: "800" },

  globalSearchWrap: {
    marginTop: 12,
    marginBottom: 8,
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 14,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  globalSearchLabel: { fontSize: 12, fontWeight: "700", color: "#4b5563" },
  globalSearchInput: {
    marginTop: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },
  globalSearchHint: { marginTop: 6, fontSize: 11, color: "#6b7280" },

  errorBox: {
    backgroundColor: "#fee2e2",
    borderRadius: 12,
    padding: 12,
    marginBottom: 16,
  },
  errorTitle: {
    fontSize: 14,
    fontWeight: "700",
    color: "#b91c1c",
    marginBottom: 2,
  },
  errorText: { fontSize: 13, color: "#b91c1c" },
  errorHint: { fontSize: 11, color: "#7f1d1d", marginTop: 4 },

  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginBottom: 4,
  },
  sectionDescription: { fontSize: 13, color: "#6b7280", marginBottom: 8 },

  breadcrumbBar: {
    borderRadius: 10,
    backgroundColor: "#f3f4f6",
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginBottom: 10,
  },
  breadcrumbLabel: { fontSize: 11, color: "#6b7280", marginBottom: 2 },
  breadcrumbText: { fontSize: 12, color: "#111827" },

  mainSectionTitle: {
    fontSize: 15,
    fontWeight: "800",
    color: "#111827",
    marginTop: 12,
    marginBottom: 6,
  },

  statsCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    borderColor: "#e5e7eb",
    marginBottom: 8,
  },
  statsText: { fontSize: 13, color: "#111827", fontWeight: "900" },
  statsHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  undoBar: {
    marginTop: 10,
    marginHorizontal: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  undoText: { fontSize: 13, color: "#374151" },
  undoButtonText: { fontSize: 13, fontWeight: "900", color: "#2563eb" },

  toast: {
    position: "absolute",
    top: 14,
    left: 16,
    right: 16,
    zIndex: 50,
    backgroundColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  toastError: { backgroundColor: "#991b1b" },
  toastText: { color: "#ffffff", fontSize: 13, fontWeight: "700" },

  fab: {
    position: "absolute",
    right: 18,
    bottom: 22,
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#2563eb",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 8,
  },
  fabText: { color: "#ffffff", fontSize: 26, fontWeight: "900" },

  sheetBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)" },
  sheetContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "#ffffff",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 16,
  },
  sheetHandle: {
    alignSelf: "center",
    width: 46,
    height: 5,
    borderRadius: 999,
    backgroundColor: "#e5e7eb",
    marginBottom: 10,
  },
  sheetTitle: { fontSize: 16, fontWeight: "900", color: "#111827" },

  duplicateCard: {
    marginTop: 10,
    borderRadius: 14,
    padding: 12,
    backgroundColor: "#f3f4f6",
    borderWidth: 1,
    borderColor: "#e5e7eb",
  },
  duplicateTitle: { fontSize: 13, fontWeight: "900", color: "#111827" },
  duplicateText: { marginTop: 4, fontSize: 12, color: "#374151" },
  duplicateHint: { marginTop: 4, fontSize: 11, color: "#6b7280" },

  sheetLabel: {
    marginTop: 6,
    fontSize: 12,
    fontWeight: "800",
    color: "#4b5563",
  },
  sheetInput: {
    marginTop: 6,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 10,
    fontSize: 14,
    color: "#111827",
    backgroundColor: "#f9fafb",
  },

  levelRow: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginTop: 8 },
  levelPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  levelPillActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  levelPillText: { fontSize: 12, color: "#374151", fontWeight: "900" },
  levelPillTextActive: { color: "#ffffff" },

  sheetButtonsRow: { flexDirection: "row", gap: 10, marginTop: 14 },
  sheetBtn: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  sheetBtnSecondary: {
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  sheetBtnSecondaryText: { color: "#374151", fontWeight: "900", fontSize: 13 },
  sheetBtnPrimary: { backgroundColor: "#2563eb" },
  sheetBtnPrimaryText: { color: "#ffffff", fontWeight: "900", fontSize: 13 },

  sheetHint: { marginTop: 10, fontSize: 11, color: "#6b7280" },
});
</file>

<file path="app/manage-skills-to-teach/SkillsToTeachList.tsx">
// app/manage-skills-to-teach/SkillsToTeachList.tsx
import React from "react";
import {
  LayoutChangeEvent,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import { SkillChip } from "../manage-skills-to-learn/SkillChip";
import { SkillTeach } from "./types";

type FilterMode = "all" | "favorites" | "recent";

type Props = {
  skills: SkillTeach[];
  totalCount: number;
  searchQuery: string;
  onChangeSearchQuery: (text: string) => void;

  onRemove: (skill: SkillTeach) => Promise<void> | void;

  favoriteSkills: string[];
  onToggleFavorite: (skillName: string) => Promise<void> | void;

  onClearAll: () => void;

  filterMode: FilterMode;
  onChangeFilter: (mode: FilterMode) => void;

  // ✅ optional: for edit level from list (we'll use it)
  onEditLevel?: (skill: SkillTeach) => void;

  onLayoutCard?: (y: number) => void;
};

export const SkillsToTeachList: React.FC<Props> = ({
  skills,
  totalCount,
  searchQuery,
  onChangeSearchQuery,
  onRemove,
  favoriteSkills,
  onToggleFavorite,
  onClearAll,
  filterMode,
  onChangeFilter,
  onEditLevel,
  onLayoutCard,
}) => {
  const getFilterIcon = (mode: FilterMode) => {
    if (mode === "all") return "✔";
    if (mode === "favorites") return "★";
    return "⏱";
  };

  const renderFilterButton = (mode: FilterMode, label: string) => {
    const active = filterMode === mode;
    const icon = getFilterIcon(mode);
    return (
      <TouchableOpacity
        key={mode}
        style={[styles.filterChip, active && styles.filterChipActive]}
        onPress={() => onChangeFilter(mode)}
        activeOpacity={0.85}
      >
        <Text
          style={[styles.filterChipText, active && styles.filterChipTextActive]}
        >
          {icon} {label}
        </Text>
      </TouchableOpacity>
    );
  };

  const handleLayout = (e: LayoutChangeEvent) => {
    if (onLayoutCard) onLayoutCard(e.nativeEvent.layout.y);
  };

  const isFavorite = (name: string) =>
    favoriteSkills.some((f) => f.toLowerCase() === name.toLowerCase());

  return (
    <View style={styles.card} onLayout={handleLayout}>
      <View style={styles.headerRow}>
        <Text style={styles.sectionTitle}>Your teaching list</Text>
        <Text style={styles.countBadge}>{totalCount}</Text>
      </View>

      <View style={styles.filtersRow}>
        {renderFilterButton("all", "All")}
        {renderFilterButton("favorites", "Favorites")}
        {renderFilterButton("recent", "Recent")}
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Search in your teaching skills..."
        value={searchQuery}
        onChangeText={onChangeSearchQuery}
        placeholderTextColor="#9ca3af"
      />

      {skills.length === 0 ? (
        <Text style={styles.emptyText}>
          You don’t have any teaching skills in this view yet. Choose a category
          above, tap a suggested skill, or add your own.
        </Text>
      ) : (
        <View style={styles.skillsWrap}>
          {skills.map((skill) => {
            const fav = isFavorite(skill.name);
            return (
              <View
                style={styles.skillRow}
                key={`${skill.name}-${skill.level}`}
              >
                <TouchableOpacity
                  activeOpacity={0.85}
                  onPress={() => onEditLevel?.(skill)}
                  disabled={!onEditLevel}
                >
                  <SkillChip
                    label={`${skill.name} · ${skill.level}`}
                    onPress={() => onEditLevel?.(skill)}
                    disabled={!onEditLevel}
                  />
                </TouchableOpacity>

                <View style={styles.skillActions}>
                  <TouchableOpacity
                    onPress={() => onToggleFavorite(skill.name)}
                    style={styles.favoriteButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.favoriteText}>{fav ? "★" : "☆"}</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={() => onRemove(skill)}
                    style={styles.removeButton}
                    activeOpacity={0.85}
                  >
                    <Text style={styles.removeIcon}>🗑</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          })}
        </View>
      )}

      {totalCount > 0 && (
        <TouchableOpacity
          style={styles.clearAllButton}
          onPress={onClearAll}
          activeOpacity={0.85}
        >
          <Text style={styles.clearAllText}>Clear all</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 16,
    marginTop: 8,
    shadowColor: "#000",
    shadowOpacity: 0.03,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 1,
  },
  headerRow: { flexDirection: "row", alignItems: "center", marginBottom: 8 },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "700",
    color: "#111827",
    flex: 1,
  },
  countBadge: {
    fontSize: 12,
    color: "#111827",
    backgroundColor: "#e5e7eb",
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 999,
  },
  filtersRow: { flexDirection: "row", gap: 6, marginBottom: 8 },
  filterChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
    backgroundColor: "#f9fafb",
  },
  filterChipActive: { backgroundColor: "#2563eb", borderColor: "#2563eb" },
  filterChipText: { fontSize: 12, color: "#374151" },
  filterChipTextActive: { color: "#ffffff", fontWeight: "700" },

  searchInput: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#d1d5db",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#111827",
    backgroundColor: "#f9fafb",
    marginBottom: 10,
  },
  emptyText: { fontSize: 13, color: "#6b7280" },

  skillsWrap: { gap: 8 },
  skillRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  skillActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    marginLeft: 8,
  },
  favoriteButton: { paddingHorizontal: 6, paddingVertical: 4 },
  favoriteText: { fontSize: 16, color: "#f59e0b" },
  removeButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    backgroundColor: "#fee2e2",
    justifyContent: "center",
    alignItems: "center",
  },
  removeIcon: { fontSize: 13 },

  clearAllButton: {
    marginTop: 10,
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#d1d5db",
  },
  clearAllText: { fontSize: 12, color: "#374151", fontWeight: "700" },
});
</file>

<file path="app/manage-skills-to-teach/types.ts">
// app/manage-skills-to-teach/types.ts

export const TEACH_LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
  "Not specified",
] as const;

export type Level = (typeof TEACH_LEVELS)[number];

export type SkillTeach = {
  name: string;
  level: Level;
};

export type UndoState = {
  skill: SkillTeach;
  index: number;
} | null;
</file>

<file path="app/manage-skills-to-teach/useManageSkillsToTeach.ts">
// app/manage-skills-to-teach/useManageSkillsToTeach.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useEffect, useMemo, useState } from "react";
import { getMe, updateProfile } from "../../lib/api";

// ✅ reuse learn data + categories
import {
  ALL_KNOWN_SKILLS,
  RECOMMENDED_SKILLS,
  SKILL_CATEGORIES,
  SkillCategory,
  SkillSubCategory,
} from "../manage-skills-to-learn/skillData";

import { Level, SkillTeach, TEACH_LEVELS, UndoState } from "./types";

const FAVORITES_STORAGE_KEY = "skillsToTeachFavorites";
const PENDING_KEY = "skillsToTeach_pending_v1";

type AddSmartResult =
  | { ok: true; existed: false; skill: SkillTeach }
  | { ok: false; existed: true; existing: SkillTeach }
  | { ok: false; existed: false; error: string };

function normalizeLevel(raw?: string | null): Level {
  if (!raw) return "Not specified";
  const trimmed = String(raw).trim();
  const found = TEACH_LEVELS.find((lvl) => lvl === trimmed);
  return found ?? "Not specified";
}

function normalizeName(raw: string) {
  return String(raw || "").trim();
}

function sameName(a: string, b: string) {
  return a.trim().toLowerCase() === b.trim().toLowerCase();
}

export function useManageSkillsToTeach() {
  const [skills, setSkills] = useState<SkillTeach[]>([]);
  const [favoriteSkills, setFavoriteSkills] = useState<string[]>([]);
  const [loadingInitial, setLoadingInitial] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [lastRemoved, setLastRemoved] = useState<UndoState>(null);

  const [hasPendingSync, setHasPendingSync] = useState(false);

  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );
  const [selectedSubCategoryId, setSelectedSubCategoryId] = useState<
    string | null
  >(null);

  async function getTokenOrFail(): Promise<string | null> {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      setError("You are not logged in. Please log in again.");
      return null;
    }
    return token;
  }

  function findExistingSkill(name: string): SkillTeach | null {
    const trimmed = normalizeName(name);
    if (!trimmed) return null;
    const found = skills.find((s) => sameName(s.name, trimmed));
    return found ?? null;
  }

  async function savePending(next: SkillTeach[]) {
    try {
      await AsyncStorage.setItem(PENDING_KEY, JSON.stringify(next));
      setHasPendingSync(true);
    } catch (e) {
      console.log("savePending teach error:", e);
    }
  }

  async function clearPending() {
    try {
      await AsyncStorage.removeItem(PENDING_KEY);
      setHasPendingSync(false);
    } catch (e) {
      console.log("clearPending teach error:", e);
    }
  }

  async function loadPending(): Promise<SkillTeach[] | null> {
    try {
      const raw = await AsyncStorage.getItem(PENDING_KEY);
      if (!raw) return null;

      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return null;

      const clean: SkillTeach[] = parsed
        .map((item: any) => {
          if (!item || typeof item !== "object") return null;
          if (typeof item.name !== "string") return null;
          const name = normalizeName(item.name);
          if (!name) return null;
          return { name, level: normalizeLevel(item.level) } as SkillTeach;
        })
        .filter(Boolean) as SkillTeach[];

      return clean.length ? clean : [];
    } catch (e) {
      console.log("loadPending teach error:", e);
      return null;
    }
  }

  async function trySyncPending() {
    try {
      const token = await getTokenOrFail();
      if (!token) return;

      const pending = await loadPending();
      if (pending === null) {
        setHasPendingSync(false);
        return;
      }

      await updateProfile(token, { skillsToTeach: pending });
      await clearPending();

      setSkills([...pending].sort((a, b) => a.name.localeCompare(b.name)));
    } catch (e) {
      console.log("trySyncPending teach error:", e);
      setHasPendingSync(true);
    }
  }

  useEffect(() => {
    let isMounted = true;

    async function load() {
      setLoadingInitial(true);
      setError(null);

      try {
        const token = await getTokenOrFail();
        if (!token) return;

        await trySyncPending();

        const me: any = await getMe(token);
        const userFromApi = me?.user ?? me;

        const raw = Array.isArray(userFromApi?.skillsToTeach)
          ? userFromApi.skillsToTeach
          : [];

        const cleanSkills: SkillTeach[] = raw
          .map((item: any) => {
            if (typeof item === "string") {
              const name = normalizeName(item);
              if (!name) return null;
              return { name, level: "Not specified" as Level };
            }

            if (
              item &&
              typeof item === "object" &&
              typeof item.name === "string"
            ) {
              const name = normalizeName(item.name);
              if (!name) return null;
              return {
                name,
                level: normalizeLevel(item.level),
              } as SkillTeach;
            }

            return null;
          })
          .filter(Boolean) as SkillTeach[];

        cleanSkills.sort((a, b) => a.name.localeCompare(b.name));

        if (!isMounted) return;
        setSkills(cleanSkills);

        const favJson = await AsyncStorage.getItem(FAVORITES_STORAGE_KEY);
        if (favJson && isMounted) {
          const parsed = JSON.parse(favJson);
          if (Array.isArray(parsed)) {
            setFavoriteSkills(parsed.filter((x) => typeof x === "string"));
          }
        }

        const pending = await AsyncStorage.getItem(PENDING_KEY);
        if (isMounted) setHasPendingSync(!!pending);
      } catch (e: any) {
        console.log("useManageSkillsToTeach load error:", e);
        if (isMounted) {
          setError(e?.message || "Failed to load teaching skills");
        }
      } finally {
        if (isMounted) setLoadingInitial(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  async function persistSkills(next: SkillTeach[]) {
    setSaving(true);
    setError(null);

    try {
      const token = await getTokenOrFail();
      if (!token) return;

      await updateProfile(token, { skillsToTeach: next });
      await clearPending();
    } catch (e: any) {
      console.log("updateProfile(skillsToTeach) error:", e);
      await savePending(next);
      setError(
        e?.message ||
          "Failed to save teaching skills. Saved locally and will sync when online."
      );
    } finally {
      setSaving(false);
    }
  }

  async function persistFavorites(next: string[]) {
    setFavoriteSkills(next);
    try {
      await AsyncStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {
      console.log("persistFavorites teach error:", e);
    }
  }

  async function addSkill(name: string, level?: Level): Promise<boolean> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }
    if (trimmed.length < 2) {
      setError("Skill name is too short.");
      return false;
    }

    const exists = skills.some((s) => sameName(s.name, trimmed));
    if (exists) {
      setError("This skill is already in your list.");
      return false;
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
    return true;
  }

  async function addSkillSmart(
    name: string,
    level?: Level
  ): Promise<AddSmartResult> {
    const trimmed = normalizeName(name);

    if (!trimmed) {
      const msg = "Skill name cannot be empty.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }
    if (trimmed.length < 2) {
      const msg = "Skill name is too short.";
      setError(msg);
      return { ok: false, existed: false, error: msg };
    }

    const existing = findExistingSkill(trimmed);
    if (existing) {
      return { ok: false, existed: true, existing };
    }

    const newSkill: SkillTeach = {
      name: trimmed,
      level: normalizeLevel(level ?? "Not specified"),
    };

    const next = [...skills, newSkill].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);

    return { ok: true, existed: false, skill: newSkill };
  }

  async function updateSkillLevel(name: string, newLevel: Level) {
    const trimmed = normalizeName(name);
    if (!trimmed) {
      setError("Skill name cannot be empty.");
      return false;
    }

    const idx = skills.findIndex((s) => sameName(s.name, trimmed));
    if (idx === -1) {
      setError("Skill not found.");
      return false;
    }

    const normalized = normalizeLevel(newLevel);
    const current = skills[idx];
    if (current.level === normalized) return true;

    const next = [...skills];
    next[idx] = { ...current, level: normalized };
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    await persistSkills(next);
    return true;
  }

  async function removeSkill(skill: SkillTeach) {
    const index = skills.findIndex((s) => sameName(s.name, skill.name));
    if (index === -1) return;

    const removed = skills[index];
    const next = skills.filter((_, i) => i !== index);

    setSkills(next);
    setLastRemoved({ skill: removed, index });

    const favExists = favoriteSkills.some((f) => sameName(f, removed.name));
    if (favExists) {
      const nextFav = favoriteSkills.filter((f) => !sameName(f, removed.name));
      await persistFavorites(nextFav);
    }

    await persistSkills(next);
  }

  async function clearAllSkills() {
    const next: SkillTeach[] = [];
    setSkills(next);
    setLastRemoved(null);
    await persistFavorites([]);
    await persistSkills(next);
  }

  async function undoRemove() {
    if (!lastRemoved) return;

    const { skill, index } = lastRemoved;
    const next = [...skills];
    const safeIndex = index >= 0 && index <= next.length ? index : next.length;
    next.splice(safeIndex, 0, skill);
    next.sort((a, b) => a.name.localeCompare(b.name));

    setSkills(next);
    setLastRemoved(null);
    await persistSkills(next);
  }

  async function toggleFavorite(name: string) {
    const exists = favoriteSkills.some((f) => sameName(f, name));
    const next = exists
      ? favoriteSkills.filter((f) => !sameName(f, name))
      : [...favoriteSkills, name];

    await persistFavorites(next);
  }

  function clearError() {
    setError(null);
  }

  // ---------- category helpers (reuse learn data) ----------
  const selectedCategory: SkillCategory | undefined = useMemo(
    () => SKILL_CATEGORIES.find((c) => c.id === selectedCategoryId),
    [selectedCategoryId]
  );

  const subCategories: SkillSubCategory[] =
    selectedCategory?.subCategories ?? [];

  const selectedSubCategory: SkillSubCategory | undefined = useMemo(
    () => subCategories.find((s) => s.id === selectedSubCategoryId),
    [subCategories, selectedSubCategoryId]
  );

  const suggestedSkillsByCategory: string[] = useMemo(() => {
    if (selectedSubCategory) return selectedSubCategory.skills;
    if (selectedCategory)
      return selectedCategory.subCategories.flatMap((s) => s.skills);
    return [];
  }, [selectedCategory, selectedSubCategory]);

  const recommendedSkills = RECOMMENDED_SKILLS;

  const suggestionPoolForInput = useMemo(() => {
    return Array.from(
      new Set(
        [
          ...ALL_KNOWN_SKILLS,
          ...recommendedSkills,
          ...skills.map((s) => s.name),
        ].filter((s) => typeof s === "string")
      )
    );
  }, [skills, recommendedSkills]);

  const filteredSkills = useMemo(() => {
    const q = searchQuery.trim().toLowerCase();
    const base = !q
      ? skills
      : skills.filter((s) => s.name.toLowerCase().includes(q));

    return [...base].sort((a, b) => {
      const aFav = favoriteSkills.some((f) => sameName(f, a.name));
      const bFav = favoriteSkills.some((f) => sameName(f, b.name));
      if (aFav && !bFav) return -1;
      if (!aFav && bFav) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [skills, favoriteSkills, searchQuery]);

  return {
    // data
    skills,
    filteredSkills,
    favoriteSkills,
    loadingInitial,
    saving,
    error,
    searchQuery,
    lastRemoved,
    hasPendingSync,

    // category
    selectedCategoryId,
    selectedSubCategoryId,
    selectedCategory,
    subCategories,
    selectedSubCategory,
    suggestedSkillsByCategory,
    recommendedSkills,
    suggestionPoolForInput,

    // actions
    setSearchQuery,
    setSelectedCategoryId,
    setSelectedSubCategoryId,

    addSkill,
    addSkillSmart,
    updateSkillLevel,
    trySyncPending,

    removeSkill,
    undoRemove,
    clearAllSkills,
    toggleFavorite,
    clearError,
  };
}
</file>

<file path="app/modal.tsx">
import { Link } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';

export default function ModalScreen() {
  return (
    <ThemedView style={styles.container}>
      <ThemedText type="title">This is a modal</ThemedText>
      <Link href="/" dismissTo style={styles.link}>
        <ThemedText type="link">Go to home screen</ThemedText>
      </Link>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});
</file>

<file path="app/profile.tsx">
// app/profile.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../lib/api";
import { getMe } from "../lib/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export default function ProfileScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const mountedRef = useRef(true);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);
    } catch (err: any) {
      console.log("Profile / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(err?.message || "Couldn’t load your profile.");
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );

  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading profile…</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView
        style={styles.scroll}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
            colors={["#F97316"]}
          />
        }
      >
        <View style={styles.headerCard}>
          <Text style={styles.title}>Profile</Text>
          <Text style={styles.name}>{user?.fullName || "SkillSwap user"}</Text>
          <Text style={styles.email}>{user?.email || "—"}</Text>

          <View style={styles.headerStatsRow}>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>XP</Text>
              <Text style={styles.statValue}>{user?.xp ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Points</Text>
              <Text style={styles.statValue}>{user?.points ?? 0}</Text>
            </View>
            <View style={styles.headerStat}>
              <Text style={styles.statLabel}>Streak</Text>
              <Text style={styles.statValue}>{user?.streak ?? 0}</Text>
            </View>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldn’t refresh</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        {/* ✅ One place to manage everything (no bouncing) */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Manage</Text>
          <Text style={styles.sectionSubtitle}>
            Update what matters without jumping around too much.
          </Text>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-learn" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to learn</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToLearn?.length ?? 0) > 0
                  ? `${user?.skillsToLearn?.length} goal(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/manage-skills-to-teach" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Skills to teach</Text>
              <Text style={styles.rowSub}>
                {(user?.skillsToTeach?.length ?? 0) > 0
                  ? `${user?.skillsToTeach?.length} skill(s)`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/weekly-availability" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Weekly availability</Text>
              <Text style={styles.rowSub}>
                {slots.length
                  ? `${daysSet} day(s) · ${minutesToHuman(totalMin)} total`
                  : "Not set yet"}
              </Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.rowBtn}
            activeOpacity={0.85}
            onPress={() => router.push("/find-mentor" as any)}
          >
            <View style={{ flex: 1 }}>
              <Text style={styles.rowTitle}>Find mentor</Text>
              <Text style={styles.rowSub}>Get matched instantly</Text>
            </View>
            <Text style={styles.rowArrow}>›</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.footerRow}>
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  headerCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  title: { color: "#9CA3AF", fontSize: 13 },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "700", marginTop: 6 },
  email: { color: "#64748B", fontSize: 12, marginTop: 4 },

  headerStatsRow: { flexDirection: "row", gap: 8, marginTop: 12 },
  headerStat: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 10,
  },
  statLabel: { color: "#94A3B8", fontSize: 11, marginBottom: 4 },
  statValue: { color: "#F9FAFB", fontSize: 18, fontWeight: "700" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryButton: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "500" },

  section: { marginTop: 8, marginBottom: 20 },
  sectionTitle: { color: "#F9FAFB", fontSize: 16, fontWeight: "600" },
  sectionSubtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  rowBtn: {
    marginTop: 10,
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  rowTitle: { color: "#F9FAFB", fontSize: 14, fontWeight: "600" },
  rowSub: { color: "#94A3B8", fontSize: 12, marginTop: 2 },
  rowArrow: { color: "#60A5FA", fontSize: 22, marginLeft: 10 },

  footerRow: { marginTop: 8, alignItems: "flex-start" },
  logoutButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },
});
</file>

<file path="app/screens/components/MatchReadinessStrip.tsx">
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import {
  getMatchingStatus,
  type MatchingMode,
  type MatchingStatus,
} from "../../../lib/api";

type Props = {
  currentMode?: MatchingMode; // اختياري (لو عندك مود محفوظ بالـ AsyncStorage)
  onApplyRecommended?: (recommended: MatchingMode) => void; // لما المستخدم يكبس "Use recommended"
  onOpenSettings?: () => void; // اختياري (لو بدك تفتح شاشة إعدادات لاحقًا)
  compact?: boolean; // لو بدك شكل أصغر
};

function getHumanMessage(s: MatchingStatus): string {
  if (!s.openaiAvailable) {
    if (s.reason === "NO_KEY")
      return "AI matching is off (no API key). Using local matching.";
    return "AI matching is unavailable right now. Using local matching.";
  }
  return "AI matching is ready. For best results, use Hybrid mode.";
}

export default function MatchReadinessStrip({
  currentMode,
  onApplyRecommended,
  onOpenSettings,
  compact = false,
}: Props) {
  const [status, setStatus] = useState<MatchingStatus | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        setLoading(true);
        const s = await getMatchingStatus();
        if (!alive) return;
        setStatus(s);
      } catch {
        if (!alive) return;
        setStatus({
          openaiAvailable: false,
          reason: "ERROR",
          recommendedMode: "local",
        });
      } finally {
        if (!alive) return;
        setLoading(false);
      }
    })();

    return () => {
      alive = false;
    };
  }, []);

  const recommendedMode: MatchingMode = useMemo(() => {
    // server returns "local" | "hybrid"
    const r = status?.recommendedMode;
    return r === "hybrid" ? "hybrid" : "local";
  }, [status]);

  const showApplyButton = useMemo(() => {
    if (!status) return false;
    if (!onApplyRecommended) return false;
    if (currentMode && currentMode === recommendedMode) return false;
    return true;
  }, [status, onApplyRecommended, currentMode, recommendedMode]);

  const tone = useMemo(() => {
    if (!status) return "neutral";
    return status.openaiAvailable ? "good" : "warn";
  }, [status]);

  return (
    <View
      style={[
        styles.wrap,
        compact && styles.wrapCompact,
        tone === "good" && styles.goodWrap,
        tone === "warn" && styles.warnWrap,
      ]}
    >
      <View style={styles.left}>
        <Text style={styles.title}>Matching status</Text>

        {loading ? (
          <View style={styles.row}>
            <ActivityIndicator />
            <Text style={styles.subtitle}>Checking availability…</Text>
          </View>
        ) : (
          <Text style={styles.subtitle}>
            {status ? getHumanMessage(status) : "Status unknown."}
          </Text>
        )}
      </View>

      <View style={styles.right}>
        {!loading && status && (
          <>
            <View style={styles.pill}>
              <Text style={styles.pillText}>
                Recommended: {recommendedMode.toUpperCase()}
              </Text>
            </View>

            {showApplyButton ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={styles.btn}
                onPress={() => onApplyRecommended?.(recommendedMode)}
              >
                <Text style={styles.btnText}>Use recommended</Text>
              </TouchableOpacity>
            ) : onOpenSettings ? (
              <TouchableOpacity
                activeOpacity={0.85}
                style={[styles.btn, styles.btnGhost]}
                onPress={onOpenSettings}
              >
                <Text style={styles.btnText}>Settings</Text>
              </TouchableOpacity>
            ) : null}
          </>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
    borderRadius: 16,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(15, 23, 42, 0.45)",
    padding: 14,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  wrapCompact: {
    paddingVertical: 10,
    paddingHorizontal: 12,
  },
  goodWrap: {
    borderColor: "rgba(34, 197, 94, 0.35)",
    backgroundColor: "rgba(20, 83, 45, 0.18)",
  },
  warnWrap: {
    borderColor: "rgba(251, 191, 36, 0.35)",
    backgroundColor: "rgba(120, 53, 15, 0.18)",
  },
  left: { flex: 1 },
  right: {
    alignItems: "flex-end",
    justifyContent: "center",
    gap: 8,
  },
  title: {
    color: "#e5e7eb",
    fontSize: 14,
    fontWeight: "700",
    marginBottom: 4,
  },
  subtitle: {
    color: "#cbd5e1",
    fontSize: 12.5,
    lineHeight: 18,
  },
  row: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  pill: {
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  pillText: {
    color: "#e5e7eb",
    fontSize: 11.5,
    fontWeight: "700",
    letterSpacing: 0.3,
  },
  btn: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.25)",
    backgroundColor: "rgba(2, 6, 23, 0.35)",
  },
  btnGhost: {
    backgroundColor: "transparent",
  },
  btnText: {
    color: "#e5e7eb",
    fontSize: 12,
    fontWeight: "700",
  },
});
</file>

<file path="app/screens/components/PillButton.tsx">
import React from "react";
import {
  ActivityIndicator,
  GestureResponderEvent,
  StyleProp,
  StyleSheet,
  Text,
  TouchableOpacity,
  ViewStyle,
} from "react-native";

type PillButtonProps = {
  title: string;
  onPress?: (event: GestureResponderEvent) => void;
  disabled?: boolean;
  loading?: boolean;
  style?: StyleProp<ViewStyle>;
  testID?: string;
};

export default function PillButton({
  title,
  onPress,
  disabled = false,
  loading = false,
  style,
  testID,
}: PillButtonProps) {
  const isDisabled = disabled || loading;

  return (
    <TouchableOpacity
      testID={testID}
      activeOpacity={0.85}
      onPress={onPress}
      disabled={isDisabled}
      style={[styles.pill, isDisabled && styles.pillDisabled, style]}
      accessibilityRole="button"
      accessibilityState={{ disabled: isDisabled, busy: loading }}
    >
      {loading ? (
        <ActivityIndicator />
      ) : (
        <Text style={[styles.text, isDisabled && styles.textDisabled]}>
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  pill: {
    width: "100%",
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(148, 163, 184, 0.35)", // slate-400-ish
    backgroundColor: "rgba(15, 23, 42, 0.55)", // slate-900-ish
    alignItems: "center",
    justifyContent: "center",
  },
  pillDisabled: {
    opacity: 0.7,
  },
  text: {
    fontSize: 14.5,
    fontWeight: "600",
    color: "#e5e7eb",
    letterSpacing: 0.2,
  },
  textDisabled: {
    color: "rgba(229, 231, 235, 0.85)",
  },
});
</file>

<file path="app/screens/components/ProfileStatusCard.tsx">
// app/screens/components/ProfileStatusCard.tsx
import { useRouter } from "expo-router";
import React, { useMemo } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import type { ProfileCompletionStatus } from "../../../lib/profileCompletion";

type Props = {
  status: ProfileCompletionStatus;
};

function pickNextSection(status: ProfileCompletionStatus) {
  // أول قسم ناقص
  return status.sections.find((s) => !s.done) || status.sections[0];
}

export default function ProfileStatusCard({ status }: Props) {
  const router = useRouter();

  const next = useMemo(() => pickNextSection(status), [status]);

  const progressText = status.isComplete
    ? "Complete"
    : `${status.doneCount}/${status.totalCount} done`;

  const subtitle = status.isComplete
    ? "Your profile is ready. You’ll get better matches."
    : "Finish these steps to unlock better mentor matches.";

  const onPrimary = () => {
    if (!next?.href) return;
    router.push(next.href as any);
  };

  return (
    <View style={styles.card}>
      <View style={styles.topRow}>
        <View style={{ flex: 1 }}>
          <Text style={styles.title}>Profile completion</Text>
          <Text style={styles.subtitle}>{subtitle}</Text>
        </View>

        <View style={styles.percentPill}>
          <Text style={styles.percentText}>{status.percent}%</Text>
        </View>
      </View>

      <View style={styles.progressRow}>
        <View style={styles.progressBg}>
          <View
            style={[styles.progressFill, { width: `${status.percent}%` }]}
          />
        </View>
        <Text style={styles.progressMeta}>{progressText}</Text>
      </View>

      {!status.isComplete && (
        <View style={styles.nextBox}>
          <View style={{ flex: 1 }}>
            <Text style={styles.nextTitle}>Next step</Text>
            <Text style={styles.nextHint}>{next.hint}</Text>
          </View>

          <TouchableOpacity
            style={styles.primaryBtn}
            onPress={onPrimary}
            activeOpacity={0.85}
          >
            <Text style={styles.primaryBtnText}>{next.ctaLabel}</Text>
          </TouchableOpacity>
        </View>
      )}

      <View style={styles.stepsWrap}>
        {status.sections.map((s) => (
          <View
            key={s.key}
            style={[
              styles.stepChip,
              s.done ? styles.stepChipDone : styles.stepChipTodo,
            ]}
          >
            <Text
              style={[
                styles.stepText,
                s.done ? styles.stepTextDone : styles.stepTextTodo,
              ]}
            >
              {s.done ? "✅" : "⬜"} {s.title}
            </Text>
          </View>
        ))}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  topRow: { flexDirection: "row", alignItems: "flex-start", gap: 10 },
  title: { color: "#F9FAFB", fontSize: 15, fontWeight: "700" },
  subtitle: { color: "#64748B", fontSize: 12, marginTop: 4 },

  percentPill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#334155",
  },
  percentText: { color: "#F97316", fontSize: 12, fontWeight: "800" },

  progressRow: { marginTop: 10 },
  progressBg: {
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "#111827",
  },
  progressFill: { height: "100%", backgroundColor: "#F97316" },
  progressMeta: { color: "#94A3B8", fontSize: 11, marginTop: 6 },

  nextBox: {
    marginTop: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#0B1120",
    padding: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  nextTitle: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },
  nextHint: { color: "#94A3B8", fontSize: 11, marginTop: 4 },

  primaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    backgroundColor: "#F97316",
  },
  primaryBtnText: { color: "#ffffff", fontSize: 12, fontWeight: "800" },

  stepsWrap: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 12,
  },
  stepChip: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderWidth: 1,
  },
  stepChipDone: { backgroundColor: "#052e16", borderColor: "#14532d" },
  stepChipTodo: { backgroundColor: "#0F172A", borderColor: "#1E293B" },

  stepText: { fontSize: 11, fontWeight: "700" },
  stepTextDone: { color: "#BBF7D0" },
  stepTextTodo: { color: "#E5E7EB" },
});
</file>

<file path="app/screens/components/QuickEditBar.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  onAvailability: () => void;
  onLearn: () => void;
  onTeach: () => void;
  onMatch: () => void;
};

function Pill({
  title,
  emoji,
  onPress,
  variant = "neutral",
}: {
  title: string;
  emoji: string;
  onPress: () => void;
  variant?: "neutral" | "primary";
}) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.85}
      style={[
        styles.pill,
        variant === "primary" ? styles.pillPrimary : styles.pillNeutral,
      ]}
    >
      <Text style={styles.pillEmoji}>{emoji}</Text>
      <Text
        style={[
          styles.pillText,
          variant === "primary"
            ? styles.pillTextPrimary
            : styles.pillTextNeutral,
        ]}
      >
        {title}
      </Text>
    </TouchableOpacity>
  );
}

export default function QuickEditBar({
  onAvailability,
  onLearn,
  onTeach,
  onMatch,
}: Props) {
  return (
    <View style={styles.card}>
      <View style={styles.headerRow}>
        <Text style={styles.title}>Quick edit</Text>
        <Text style={styles.hint}>Avoid page hopping</Text>
      </View>

      <View style={styles.row}>
        <Pill title="Match" emoji="🧠" onPress={onMatch} variant="primary" />
        <Pill title="Availability" emoji="📅" onPress={onAvailability} />
      </View>

      <View style={styles.row}>
        <Pill title="Learn" emoji="📚" onPress={onLearn} />
        <Pill title="Teach" emoji="🧑‍🏫" onPress={onTeach} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
  },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  hint: { color: "#64748B", fontSize: 11 },

  row: { flexDirection: "row", gap: 10, marginTop: 10 },
  pill: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
  },
  pillNeutral: { backgroundColor: "#0B1120", borderColor: "#334155" },
  pillPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },

  pillEmoji: { fontSize: 14 },
  pillText: { fontSize: 12, fontWeight: "700" },
  pillTextNeutral: { color: "#E5E7EB" },
  pillTextPrimary: { color: "#DBEAFE" },
});
</file>

<file path="app/screens/components/SkeletonCard.tsx">
import React, { useMemo } from "react";
import { StyleSheet, View, type DimensionValue } from "react-native";

type Props = {
  /**
   * width can be:
   * - number (e.g. 120)
   * - percentage string (e.g. "80%")
   */
  width?: number | `${number}%`;
  height?: number;
  radius?: number;
  style?: any;
};

export default function SkeletonCard({
  width = "100%",
  height = 14,
  radius = 10,
  style,
}: Props) {
  // ✅ ensure correct type for RN style
  const safeWidth = useMemo(() => width as DimensionValue, [width]);

  return (
    <View
      style={[
        styles.skeleton,
        {
          width: safeWidth,
          height,
          borderRadius: radius,
        },
        style,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  skeleton: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    overflow: "hidden",
  },
});
</file>

<file path="app/screens/components/ViewProfileCTA.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";

type Props = {
  label?: string;
  onPress: () => void;
};

export default function ViewProfileCTA({
  label = "View profile",
  onPress,
}: Props) {
  return (
    <TouchableOpacity
      style={styles.wrap}
      onPress={onPress}
      activeOpacity={0.85}
    >
      <View style={styles.left}>
        <Text style={styles.title}>{label}</Text>
        <Text style={styles.sub}>See and update your profile in one place</Text>
      </View>

      <View style={styles.right}>
        <Text style={styles.arrow}>→</Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 12,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 14,
  },
  left: { flex: 1, paddingRight: 10 },
  title: { color: "#F9FAFB", fontSize: 14, fontWeight: "700" },
  sub: { color: "#94A3B8", fontSize: 12, marginTop: 4 },
  right: {
    width: 36,
    height: 36,
    borderRadius: 999,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#334155",
    alignItems: "center",
    justifyContent: "center",
  },
  arrow: { color: "#60A5FA", fontSize: 18, fontWeight: "800" },
});
</file>

<file path="app/screens/homescreen.styles.ts">
// app/screens/homescreen.styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: { flex: 1, alignItems: "center", justifyContent: "center" },

  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 16,
  },

  avatar: {
    width: 44,
    height: 44,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
  },

  avatarText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },

  nameWrap: { marginLeft: 12 },
  nameText: { color: "#E5E7EB", fontSize: 16, fontWeight: "900" },
  metaText: { color: "#94A3B8", fontSize: 12, fontWeight: "700", marginTop: 2 },

  logoutBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1220",
  },

  card: {
    backgroundColor: "#0B1220",
    borderWidth: 1,
    borderColor: "#1F2937",
    borderRadius: 16,
    padding: 14,
    marginBottom: 12,
  },

  cardTitle: { color: "#E5E7EB", fontSize: 14, fontWeight: "900", marginBottom: 8 },

  row: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  rowLeft: { flexDirection: "row", alignItems: "center" },

  pill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  pillText: { color: "#E5E7EB", fontSize: 12, fontWeight: "800" },

  small: { color: "#94A3B8", fontSize: 12, fontWeight: "700" },
  divider: { height: 1, backgroundColor: "#111827", marginVertical: 12 },

  actionBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0F172A",
  },

  actionText: { color: "#E5E7EB", fontSize: 13, fontWeight: "900" },

  badge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },

  logoutText: { color: "#E5E7EB", fontSize: 12 },
});
</file>

<file path="app/sessions/screens/(components)/SessionsEmptyState.tsx">
import React from "react";
import { Pressable, StyleSheet, Text, View } from "react-native";

type Variant = "noSessions" | "noResults" | "error";

type Props = {
  variant: Variant;
  title?: string;
  body?: string;
  primaryText?: string;
  onPrimary?: () => void;
  secondaryText?: string;
  onSecondary?: () => void;
};

export default function SessionsEmptyState({
  variant,
  title,
  body,
  primaryText,
  onPrimary,
  secondaryText,
  onSecondary,
}: Props) {
  const defaults = getDefaults(variant);

  const t = title || defaults.title;
  const b = body || defaults.body;

  const showPrimary = !!primaryText && !!onPrimary;
  const showSecondary = !!secondaryText && !!onSecondary;

  return (
    <View style={styles.wrap} accessibilityRole="summary">
      <Text style={styles.icon} accessibilityLabel="Empty state icon">
        {defaults.icon}
      </Text>

      <Text style={styles.title}>{t}</Text>
      <Text style={styles.body}>{b}</Text>

      {(showPrimary || showSecondary) && (
        <View style={styles.btnRow}>
          {showPrimary && (
            <Pressable
              onPress={onPrimary}
              accessibilityRole="button"
              accessibilityLabel={primaryText}
              style={({ pressed }) => [
                styles.primaryBtn,
                pressed ? { opacity: 0.92 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.primaryText}>{primaryText}</Text>
            </Pressable>
          )}

          {showSecondary && (
            <Pressable
              onPress={onSecondary}
              accessibilityRole="button"
              accessibilityLabel={secondaryText}
              style={({ pressed }) => [
                styles.secondaryBtn,
                pressed ? { opacity: 0.92 } : null,
              ]}
              hitSlop={10}
            >
              <Text style={styles.secondaryText}>{secondaryText}</Text>
            </Pressable>
          )}
        </View>
      )}
    </View>
  );
}

function getDefaults(v: Variant) {
  if (v === "noResults") {
    return {
      icon: "🔎",
      title: "No results",
      body: "Try changing filters or search keywords.",
    };
  }

  if (v === "error") {
    return {
      icon: "⚠️",
      title: "Something went wrong",
      body: "Couldn’t load sessions. Please try again.",
    };
  }

  return {
    icon: "🗓️",
    title: "No sessions yet",
    body: "When you request a session, it will appear here with full details.",
  };
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 16,
    alignItems: "center",
    gap: 8,
  },

  icon: {
    fontSize: 28,
  },

  title: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 16,
    textAlign: "center",
  },

  body: {
    color: "#94A3B8",
    fontWeight: "700",
    fontSize: 12,
    textAlign: "center",
    lineHeight: 18,
  },

  btnRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 10,
  },

  primaryBtn: {
    backgroundColor: "#F97316",
    borderColor: "#FB923C",
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 10,
  },

  primaryText: {
    color: "#111827",
    fontWeight: "900",
  },

  secondaryBtn: {
    backgroundColor: "#020617",
    borderColor: "#1E293B",
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 10,
  },

  secondaryText: {
    color: "#E5E7EB",
    fontWeight: "900",
  },
});
</file>

<file path="app/sessions/screens/(components)/SessionsHeader.tsx">
import { useRouter } from "expo-router";
import React, { useCallback, useMemo } from "react";
import {
  Pressable,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import type { Scope } from "../(hooks)/useSessionsData";
import type { SessionDTO } from "../../api/sessionsApi";
import { UpdatingMiniBadge } from "./SessionsRowRenderer";
import type { StatusFilter } from "./SessionsRows";
import { computeStatusCounts } from "./SessionsRows";

function scopeLabelOf(scope: Scope) {
  if (scope === "upcoming") return "Upcoming sessions";
  if (scope === "past") return "Past sessions";
  return "All sessions";
}

function statusLabel(v: StatusFilter) {
  if (v === "all") return "All";
  if (v === "requested") return "Requested";
  if (v === "accepted") return "Accepted";
  if (v === "rejected") return "Rejected";
  if (v === "cancelled") return "Cancelled";
  if (v === "completed") return "Completed";
  return "All";
}

function Chip({
  label,
  active,
  onPress,
  accent = "orange",
  rightBadge,
}: {
  label: string;
  active: boolean;
  onPress: () => void;
  accent?: "orange" | "blue";
  rightBadge?: string;
}) {
  const border =
    accent === "blue"
      ? active
        ? "#60A5FA"
        : "#1E293B"
      : active
      ? "#F97316"
      : "#1E293B";

  const text =
    accent === "blue"
      ? active
        ? "#BFDBFE"
        : "#E5E7EB"
      : active
      ? "#FED7AA"
      : "#E5E7EB";

  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.85}
      style={{
        paddingHorizontal: 12,
        paddingVertical: 8,
        borderRadius: 999,
        borderWidth: 1,
        borderColor: border,
        backgroundColor: active ? "#0B1120" : "#020617",
        flexDirection: "row",
        alignItems: "center",
        gap: 8,
      }}
    >
      <Text style={{ color: text, fontWeight: "900", fontSize: 12 }}>
        {label}
      </Text>

      {!!rightBadge && (
        <View
          style={{
            minWidth: 22,
            paddingHorizontal: 8,
            height: 18,
            borderRadius: 999,
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: active
              ? accent === "blue"
                ? "#60A5FA"
                : "#F97316"
              : "#111827",
            borderWidth: 1,
            borderColor: active
              ? accent === "blue"
                ? "#93C5FD"
                : "#FB923C"
              : "#1E293B",
          }}
        >
          <Text
            style={{
              color: active ? "#0B1120" : "#CBD5E1",
              fontWeight: "900",
              fontSize: 11,
            }}
          >
            {rightBadge}
          </Text>
        </View>
      )}
    </TouchableOpacity>
  );
}

export default function SessionsHeader({
  scope,
  setScope,
  statusFilter,
  setStatusFilter,
  sessions,
  filteredCount,
  loadingList,
  errorText,
  onRetry,

  // ✅ NEW (controlled search)
  query,
  setQuery,

  // ✅ NEW (safe actions)
  onFindMentor,
  onRequestSession,
}: {
  scope: Scope;
  setScope: (v: Scope) => void;
  statusFilter: StatusFilter;
  setStatusFilter: (v: StatusFilter) => void;
  sessions: SessionDTO[];
  filteredCount: number;
  loadingList: boolean;
  errorText: string | null;
  onRetry: () => void;

  query: string;
  setQuery: (v: string) => void;

  onFindMentor?: () => void;
  onRequestSession?: () => void; // optional (حتى ما نخرب routes)
}) {
  const router = useRouter();

  const scopeLabel = useMemo(() => scopeLabelOf(scope), [scope]);
  const countsAll = useMemo(() => computeStatusCounts(sessions), [sessions]);

  const badge = (n: number) => (n > 99 ? "99+" : String(n));

  const hasAnyFilter = useMemo(() => {
    return scope !== "upcoming" || statusFilter !== "all" || !!query.trim();
  }, [query, scope, statusFilter]);

  const onReset = useCallback(() => {
    setScope("upcoming");
    setStatusFilter("all");
    setQuery("");
  }, [setQuery, setScope, setStatusFilter]);

  const searchHint = useMemo(() => {
    return "Search: skill / level / status / note…";
  }, []);

  const handleFind = useCallback(() => {
    if (onFindMentor) return onFindMentor();
    router.push("/find-mentor" as any);
  }, [onFindMentor, router]);

  return (
    <View style={{ padding: 16, paddingBottom: 10 }}>
      {/* Top nav */}
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
          <Text style={{ color: "#60A5FA", fontWeight: "900" }}>← Back</Text>
        </TouchableOpacity>

        <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
          Sessions
        </Text>

        {/* right actions */}
        <View style={{ flexDirection: "row", gap: 8, alignItems: "center" }}>
          <Pressable
            onPress={handleFind}
            style={({ pressed }) => [
              {
                paddingHorizontal: 10,
                paddingVertical: 8,
                borderRadius: 999,
                borderWidth: 1,
                borderColor: "#1E293B",
                backgroundColor: "#0B1120",
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
              Find
            </Text>
          </Pressable>

          {/* ✅ optional: يظهر فقط لو مرّرته من SessionsScreen */}
          {onRequestSession ? (
            <Pressable
              onPress={onRequestSession}
              style={({ pressed }) => [
                {
                  paddingHorizontal: 10,
                  paddingVertical: 8,
                  borderRadius: 999,
                  borderWidth: 1,
                  borderColor: "#FB923C",
                  backgroundColor: "#F97316",
                },
                pressed ? { opacity: 0.92 } : null,
              ]}
            >
              <Text
                style={{ color: "#111827", fontWeight: "900", fontSize: 12 }}
              >
                Request
              </Text>
            </Pressable>
          ) : null}
        </View>
      </View>

      {/* Subtitle */}
      <Text style={{ color: "#94A3B8", marginTop: 8, fontWeight: "700" }}>
        {scopeLabel}{" "}
        <Text style={{ color: "#CBD5E1", fontWeight: "900" }}>
          ({filteredCount}/{sessions.length})
        </Text>
      </Text>

      {/* Search (now реально يفلتر ✅) */}
      <View
        style={{
          marginTop: 12,
          backgroundColor: "#0B1120",
          borderWidth: 1,
          borderColor: "#111827",
          borderRadius: 14,
          paddingHorizontal: 12,
          paddingVertical: 10,
          flexDirection: "row",
          alignItems: "center",
          gap: 10,
        }}
      >
        <Text style={{ color: "#64748B", fontWeight: "900" }}>🔎</Text>

        <TextInput
          value={query}
          onChangeText={setQuery}
          placeholder={searchHint}
          placeholderTextColor="#64748B"
          style={{ flex: 1, color: "#E5E7EB", fontWeight: "700" }}
          returnKeyType="search"
          accessibilityLabel="Search sessions"
        />

        {!!query.trim() && (
          <Pressable
            onPress={() => setQuery("")}
            style={({ pressed }) => [
              {
                width: 28,
                height: 28,
                borderRadius: 999,
                backgroundColor: "#111827",
                borderWidth: 1,
                borderColor: "#1E293B",
                alignItems: "center",
                justifyContent: "center",
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
            hitSlop={10}
          >
            <Text
              style={{
                color: "#E5E7EB",
                fontWeight: "900",
                fontSize: 16,
                lineHeight: 18,
              }}
            >
              ×
            </Text>
          </Pressable>
        )}
      </View>

      {/* Reset filters */}
      {hasAnyFilter ? (
        <View style={{ marginTop: 10, flexDirection: "row", gap: 10 }}>
          <Pressable
            onPress={onReset}
            style={({ pressed }) => [
              {
                paddingHorizontal: 12,
                paddingVertical: 8,
                borderRadius: 999,
                borderWidth: 1,
                borderColor: "#1E293B",
                backgroundColor: "#020617",
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
              Reset filters
            </Text>
          </Pressable>

          <Text
            style={{
              color: "#64748B",
              fontWeight: "800",
              fontSize: 12,
              alignSelf: "center",
            }}
          >
            Filters active
          </Text>
        </View>
      ) : null}

      {/* Scope chips */}
      <View
        style={{
          flexDirection: "row",
          gap: 8,
          marginTop: 14,
          flexWrap: "wrap",
        }}
      >
        <Chip
          label="upcoming"
          active={scope === "upcoming"}
          onPress={() => setScope("upcoming")}
        />
        <Chip
          label="past"
          active={scope === "past"}
          onPress={() => setScope("past")}
        />
        <Chip
          label="all"
          active={scope === "all"}
          onPress={() => setScope("all")}
        />
      </View>

      {/* Status chips */}
      <View
        style={{
          flexDirection: "row",
          gap: 8,
          marginTop: 10,
          flexWrap: "wrap",
        }}
      >
        <Chip
          accent="blue"
          label={statusLabel("all")}
          active={statusFilter === "all"}
          onPress={() => setStatusFilter("all")}
          rightBadge={badge(countsAll.total)}
        />
        <Chip
          accent="blue"
          label={statusLabel("requested")}
          active={statusFilter === "requested"}
          onPress={() => setStatusFilter("requested")}
          rightBadge={badge(countsAll.byStatus.requested)}
        />
        <Chip
          accent="blue"
          label={statusLabel("accepted")}
          active={statusFilter === "accepted"}
          onPress={() => setStatusFilter("accepted")}
          rightBadge={badge(countsAll.byStatus.accepted)}
        />
        <Chip
          accent="blue"
          label={statusLabel("completed")}
          active={statusFilter === "completed"}
          onPress={() => setStatusFilter("completed")}
          rightBadge={badge(countsAll.byStatus.completed)}
        />
        <Chip
          accent="blue"
          label={statusLabel("cancelled")}
          active={statusFilter === "cancelled"}
          onPress={() => setStatusFilter("cancelled")}
          rightBadge={badge(countsAll.byStatus.cancelled)}
        />
      </View>

      {/* Error */}
      {errorText ? (
        <View
          style={{
            marginTop: 14,
            backgroundColor: "#451A1A",
            borderRadius: 12,
            padding: 12,
            borderWidth: 1,
            borderColor: "#FCA5A5",
          }}
        >
          <Text style={{ color: "#FECACA", fontWeight: "900" }}>
            Couldn’t load sessions
          </Text>
          <Text style={{ color: "#FECACA", marginTop: 6 }}>{errorText}</Text>

          <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
            <TouchableOpacity
              onPress={onRetry}
              activeOpacity={0.85}
              style={{
                paddingHorizontal: 12,
                paddingVertical: 8,
                borderRadius: 999,
                backgroundColor: "#B91C1C",
              }}
            >
              <Text style={{ color: "#FEE2E2", fontWeight: "900" }}>
                Try again
              </Text>
            </TouchableOpacity>

            {hasAnyFilter ? (
              <TouchableOpacity
                onPress={onReset}
                activeOpacity={0.85}
                style={{
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  borderRadius: 999,
                  backgroundColor: "#0B1120",
                  borderWidth: 1,
                  borderColor: "#1E293B",
                }}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                  Reset
                </Text>
              </TouchableOpacity>
            ) : null}
          </View>
        </View>
      ) : null}

      {/* List meta */}
      <View
        style={{
          marginTop: 16,
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between",
        }}
      >
        <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 14 }}>
          Results
        </Text>

        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <Text style={{ color: "#64748B", fontWeight: "800", fontSize: 12 }}>
            Total: {badge(countsAll.total)}
          </Text>
          {loadingList ? <UpdatingMiniBadge /> : null}
        </View>
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/(components)/SessionsRowRenderer.tsx">
// app/sessions/screens/(components)/SessionsRowRenderer.tsx
import React, { useCallback, useRef } from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";

import type { SessionDTO } from "../../api/sessionsApi";
import SessionCard from "../../components/SessionCard";
import type { Row } from "./SessionsRows";

type Props = {
  token: string | null;
  currentUserId: string | null;
  onChanged: () => Promise<void> | void;
};

function pluralize(n: number, one: string, many: string) {
  return n === 1 ? one : many;
}

export function useRowRenderer({ token, currentUserId, onChanged }: Props) {
  const safeOnChanged = useCallback(async () => {
    try {
      await onChanged?.();
    } catch {
      /* ignore */
    }
  }, [onChanged]);

  // ✅ double-tap guard (خصوصاً على موبايل)
  const lastTapRef = useRef<{ id: string; at: number } | null>(null);
  const canTap = useCallback((id: string) => {
    const now = Date.now();
    const prev = lastTapRef.current;
    if (prev && prev.id === id && now - prev.at < 550) return false;
    lastTapRef.current = { id, at: now };
    return true;
  }, []);

  return useCallback(
    ({ item }: { item: Row }) => {
      if (item.type === "header") {
        const n = Number(item.count || 0);
        return (
          <View
            style={{ paddingHorizontal: 16, paddingTop: 6, paddingBottom: 8 }}
          >
            <View
              style={{
                flexDirection: "row",
                justifyContent: "space-between",
                alignItems: "center",
              }}
            >
              <Text style={{ color: "#CBD5E1", fontWeight: "900" }}>
                {item.title}
              </Text>

              <Text
                style={{ color: "#64748B", fontWeight: "900", fontSize: 12 }}
              >
                {n} {pluralize(n, "session", "sessions")}
              </Text>
            </View>
          </View>
        );
      }

      const s = item.session as SessionDTO;
      const sid = String(
        (s as any)?._id || (s as any)?.id || item.key || ""
      ).trim();

      return (
        <View style={{ paddingHorizontal: 16, paddingBottom: 10 }}>
          <Pressable
            onPress={() => {
              if (!sid) return;
              // ✅ gate only (SessionCard still handles actions)
              canTap(sid);
            }}
            style={({ pressed }) => [
              { borderRadius: 16 },
              pressed ? { opacity: 0.98 } : null,
            ]}
          >
            <SessionCard
              session={s}
              token={token}
              currentUserId={currentUserId}
              onChanged={safeOnChanged}
            />
          </Pressable>
        </View>
      );
    },
    [token, currentUserId, safeOnChanged, canTap]
  );
}

export function UpdatingMiniBadge() {
  return (
    <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
      <ActivityIndicator />
      <Text style={{ color: "#94A3B8", fontWeight: "900" }}>Updating…</Text>
    </View>
  );
}
</file>

<file path="app/sessions/screens/(components)/SessionsRows.tsx">
// app/sessions/screens/(components)/SessionsRows.ts
import type { SessionDTO } from "../../api/sessionsApi";

export type StatusFilter =
  | "all"
  | "requested"
  | "accepted"
  | "rejected"
  | "cancelled"
  | "completed";

export type Row =
  | { type: "header"; key: string; title: string; count: number }
  | { type: "session"; key: string; session: SessionDTO };

function toDate(v: any) {
  const d = new Date(String(v || ""));
  return Number.isNaN(d.getTime()) ? null : d;
}

function safeId(s: any) {
  return String(s?._id || s?.id || "").trim();
}

function normStatus(v: any) {
  const st = String(v || "")
    .trim()
    .toLowerCase();
  if (st === "canceled") return "cancelled";
  if (st === "done") return "completed";
  return st;
}

function getWhen(s: any): Date | null {
  // scheduledAt هو الأساس، وإذا مش موجود خليه fallback createdAt
  return toDate(s?.scheduledAt) || toDate(s?.createdAt) || null;
}

function startOfDay(d: Date) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function dayKey(d: Date) {
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(
    2,
    "0"
  )}-${String(d.getDate()).padStart(2, "0")}`;
}

function dayTitleSmart(d: Date) {
  const today = startOfDay(new Date());
  const that = startOfDay(d);

  const diffDays = Math.round(
    (that.getTime() - today.getTime()) / (24 * 60 * 60 * 1000)
  );

  if (diffDays === 0) return "Today";
  if (diffDays === 1) return "Tomorrow";
  if (diffDays === -1) return "Yesterday";

  const dow = d.toLocaleDateString(undefined, { weekday: "long" });
  const md = d.toLocaleDateString(undefined, {
    month: "short",
    day: "2-digit",
  });
  return `${dow} · ${md}`;
}

// ✅ status priority داخل اليوم (أهم شيء فوق)
function statusRank(st: string) {
  const s = normStatus(st);
  if (s === "requested") return 0;
  if (s === "accepted") return 1;
  if (s === "completed") return 2;
  if (s === "cancelled") return 3;
  if (s === "rejected") return 4;
  return 9;
}

export function filterSessionsByStatus(
  sessions: SessionDTO[],
  statusFilter: StatusFilter
) {
  if (statusFilter === "all") return sessions;
  const target = normStatus(statusFilter);

  return (Array.isArray(sessions) ? sessions : []).filter((s: any) => {
    const st = normStatus(s?.status);
    return st === target;
  });
}

export function computeStatusCounts(sessions: SessionDTO[]) {
  const list = Array.isArray(sessions) ? sessions : [];

  const byStatus = {
    requested: 0,
    accepted: 0,
    rejected: 0,
    cancelled: 0,
    completed: 0,
  };

  for (const x of list as any[]) {
    const st = normStatus(x?.status);
    if (st === "requested") byStatus.requested++;
    else if (st === "accepted") byStatus.accepted++;
    else if (st === "rejected") byStatus.rejected++;
    else if (st === "cancelled") byStatus.cancelled++;
    else if (st === "completed") byStatus.completed++;
  }

  return { total: list.length, byStatus };
}

export function buildGroupedRows(filteredSessions: SessionDTO[]): Row[] {
  const list = Array.isArray(filteredSessions) ? filteredSessions : [];

  // Groups by date + special "unknown"
  const map = new Map<string, { date: Date | null; list: SessionDTO[] }>();

  for (const s of list) {
    const d = getWhen(s);
    const k = d ? dayKey(d) : "unknown";

    const g = map.get(k);
    if (!g) map.set(k, { date: d, list: [s] });
    else g.list.push(s);
  }

  // Sort groups: unknown آخر شيء، والباقي حسب التاريخ (desc)
  const keys = Array.from(map.keys()).sort((a, b) => {
    if (a === "unknown" && b === "unknown") return 0;
    if (a === "unknown") return 1;
    if (b === "unknown") return -1;

    const da = map.get(a)!.date?.getTime() ?? 0;
    const db = map.get(b)!.date?.getTime() ?? 0;
    return db - da;
  });

  const out: Row[] = [];

  for (const k of keys) {
    const g = map.get(k)!;

    // Sort sessions داخل اليوم:
    // 1) status priority
    // 2) time (newer first)
    g.list.sort((a: any, b: any) => {
      const ra = statusRank(a?.status);
      const rb = statusRank(b?.status);
      if (ra !== rb) return ra - rb;

      const ta = getWhen(a)?.getTime() ?? 0;
      const tb = getWhen(b)?.getTime() ?? 0;
      return tb - ta;
    });

    out.push({
      type: "header",
      key: `h:${k}`,
      title: k === "unknown" ? "Unknown date" : dayTitleSmart(g.date as Date),
      count: g.list.length,
    });

    for (let i = 0; i < g.list.length; i++) {
      const s: any = g.list[i];
      const id = safeId(s);
      // ✅ key ثابت (بدون random)
      out.push({
        type: "session",
        key: `s:${id || `${k}:${i}`}`,
        session: s,
      });
    }
  }

  return out;
}
</file>

<file path="app/sessions/screens/(components)/SessionsSummaryBar.tsx">
import React, { useMemo } from "react";
import { StyleSheet, Text, View } from "react-native";

type Props = {
  total: number;
  upcoming: number;
  pending: number; // requested
  completed: number;
  nextSessionAtIso?: string | null; // optional
};

function formatWhen(iso?: string | null) {
  if (!iso) return null;
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return null;

  // مثال: Jan 01, 15:59
  return d.toLocaleString(undefined, {
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

function StatPill({ label, value }: { label: string; value: number | string }) {
  return (
    <View style={styles.pill}>
      <Text style={styles.pillLabel} numberOfLines={1}>
        {label}
      </Text>
      <Text style={styles.pillValue} numberOfLines={1}>
        {String(value)}
      </Text>
    </View>
  );
}

export default function SessionsSummaryBar({
  total,
  upcoming,
  pending,
  completed,
  nextSessionAtIso,
}: Props) {
  const next = useMemo(() => formatWhen(nextSessionAtIso), [nextSessionAtIso]);

  return (
    <View style={styles.wrap} accessibilityRole="summary">
      <View style={styles.topRow}>
        <Text style={styles.title}>Overview</Text>
        {next ? (
          <View
            style={styles.nextWrap}
            accessibilityLabel={`Next session ${next}`}
          >
            <Text style={styles.nextLabel}>Next</Text>
            <Text style={styles.nextValue}>{next}</Text>
          </View>
        ) : (
          <Text style={styles.nextMuted}>No upcoming scheduled</Text>
        )}
      </View>

      <View style={styles.row}>
        <StatPill label="Total" value={total} />
        <StatPill label="Upcoming" value={upcoming} />
        <StatPill label="Pending" value={pending} />
        <StatPill label="Done" value={completed} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    backgroundColor: "#0B1120",
    borderColor: "#111827",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    gap: 10,
  },

  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },

  title: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 14,
  },

  nextWrap: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },

  nextLabel: {
    color: "#94A3B8",
    fontWeight: "900",
    fontSize: 11,
  },

  nextValue: {
    color: "#F97316",
    fontWeight: "900",
    fontSize: 11,
  },

  nextMuted: {
    color: "#64748B",
    fontWeight: "800",
    fontSize: 12,
  },

  row: {
    flexDirection: "row",
    gap: 10,
  },

  pill: {
    flex: 1,
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    paddingHorizontal: 10,
    paddingVertical: 10,
    gap: 4,
    minHeight: 58,
  },

  pillLabel: {
    color: "#94A3B8",
    fontWeight: "900",
    fontSize: 11,
  },

  pillValue: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 16,
  },
});
</file>

<file path="app/sessions/screens/(hooks)/useSessionsData.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import { getMe } from "../../../../lib/api";
import { listMySessions, type SessionDTO } from "../../api/sessionsApi";

export type Scope = "upcoming" | "past" | "all";

type LoadOpts = {
  silent?: boolean; // لا تغيّر loading الرئيسي
  listOnly?: boolean; // استخدم loadingList بدل loading
  force?: boolean; // تجاهل الكاش واعمل fetch مباشر
};

function cacheKey(scope: Scope) {
  return `sessions_cache_v1:${scope}`;
}

function safeJsonParse<T>(txt: string | null): T | null {
  if (!txt) return null;
  try {
    return JSON.parse(txt) as T;
  } catch {
    return null;
  }
}

function sortSessions(list: SessionDTO[]) {
  // أحدث سيشن (حسب scheduledAt) بالأعلى
  return list
    .slice()
    .sort(
      (a, b) =>
        new Date(b.scheduledAt).getTime() - new Date(a.scheduledAt).getTime()
    );
}

export function useSessionsData(scope: Scope) {
  const router = useRouter();

  const mountedRef = useRef(true);
  const tokenRef = useRef<string | null>(null);
  const meIdRef = useRef<string | null>(null);
const didMountRef = useRef(false);

  // لمنع race conditions
  const reqSeqRef = useRef(0);

  const [token, setToken] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  const [sessions, setSessions] = useState<SessionDTO[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingList, setLoadingList] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  // نستخدمها لنعرف إذا عرضنا كاش بالفعل لهذا الـ scope
  const shownCacheForScopeRef = useRef<Record<string, boolean>>({});

  const ensureToken = useCallback(async () => {
    if (tokenRef.current) return tokenRef.current;

    const t = await AsyncStorage.getItem("token");
    console.log("[sessions] token =", t);

    tokenRef.current = t;

    if (mountedRef.current) setToken(t);
    return t;
  }, []);

  const ensureMeId = useCallback(async (t: string) => {
    if (meIdRef.current) return meIdRef.current;

    const me: any = await getMe(t);
    const id = String(me?.user?._id ?? me?._id ?? "").trim() || null;

    meIdRef.current = id;
    if (mountedRef.current) setCurrentUserId(id);

    return id;
  }, []);

  const showCacheIfAvailable = useCallback(async (scopeToUse: Scope) => {
    const key = cacheKey(scopeToUse);

    // لا نعيد عرض الكاش بنفس السكوب كل مرة
    if (shownCacheForScopeRef.current[key]) return;

    const cachedRaw = await AsyncStorage.getItem(key);
    const cached =
      safeJsonParse<{ ts: number; items: SessionDTO[] }>(cachedRaw);

    if (cached?.items?.length && mountedRef.current) {
      setSessions(sortSessions(cached.items));
      // إذا إحنا بأول تحميل، خلي الواجهة تطلع فوراً
      setLoading(false);
    }

    shownCacheForScopeRef.current[key] = true;
  }, []);

  const writeCache = useCallback(async (scopeToUse: Scope, list: SessionDTO[]) => {
    const key = cacheKey(scopeToUse);
    const payload = { ts: Date.now(), items: list };
    try {
      await AsyncStorage.setItem(key, JSON.stringify(payload));
    } catch {
      // ignore
    }
  }, []);

  const load = useCallback(
    async (opts?: LoadOpts) => {
      const silent = !!opts?.silent;
      const listOnly = !!opts?.listOnly;
      const force = !!opts?.force;

      const seq = ++reqSeqRef.current;

      try {
        setErrorText(null);

        // ✅ كاش سريع (SWR) إذا مش force
        if (!force) {
          await showCacheIfAvailable(scope);
        }

        if (!silent && !listOnly) setLoading(true);
        if (listOnly) setLoadingList(true);

       console.log("[sessions] load start scope=", scope);

const t = await ensureToken();
console.log("[sessions] got token?", !!t);

if (!t) {
  console.log("[sessions] no token -> redirect login");
  router.replace("/(auth)/login" as any);
  return;
}

if (!meIdRef.current) {
  console.log("[sessions] fetching me...");
  await ensureMeId(t);
  console.log("[sessions] me id =", meIdRef.current);
}

console.log("[sessions] calling listMySessions...");
const data = await listMySessions(t, { scope });
console.log("[sessions] listMySessions returned:", Array.isArray(data) ? data.length : data);


        // ✅ تجاهل نتائج قديمة لو كان في طلب أحدث
        if (!mountedRef.current) return;
        if (seq !== reqSeqRef.current) return;

        const next = sortSessions(Array.isArray(data) ? data : []);
        setSessions(next);
        void writeCache(scope, next);
      } catch (e: any) {
        if (!mountedRef.current) return;
        if (seq !== reqSeqRef.current) return;
        setErrorText(e?.message || "Failed to load sessions.");
      } finally {
        if (!mountedRef.current) return;
        if (seq !== reqSeqRef.current) return;

        if (!silent && !listOnly) setLoading(false);
        if (listOnly) setLoadingList(false);
        setRefreshing(false);
      }
    },
    [ensureMeId, ensureToken, router, scope, showCacheIfAvailable, writeCache]
  );

  // ✅ Initial boot (يعرض كاش + fetch)
  useEffect(() => {
  mountedRef.current = true;

  // أول مرة: خليها تعمل load عادي (يعرض كاش ثم يجدد)
  void load({ silent: false, listOnly: false });

  return () => {
    mountedRef.current = false;
  };
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);


  // ✅ When scope changes: show cache instantly + refresh list only
  useEffect(() => {
  if (!mountedRef.current) return;

  // ✅ skip first run (important) — prevents double-load on mount
  if (!didMountRef.current) {
    didMountRef.current = true;
    return;
  }

  // اعرض كاش للسكوب الجديد فوراً، وبعدين fetch خفيف
  void showCacheIfAvailable(scope);
  void load({ silent: true, listOnly: true });
}, [scope, load, showCacheIfAvailable]);


  const onRefresh = useCallback(() => {
    setRefreshing(true);
    void load({ silent: true, listOnly: true, force: true });
  }, [load]);

  return useMemo(
    () => ({
      token,
      currentUserId,
      sessions,
      loading,
      loadingList,
      refreshing,
      errorText,
      load,
      onRefresh,
    }),
    [
      token,
      currentUserId,
      sessions,
      loading,
      loadingList,
      refreshing,
      errorText,
      load,
      onRefresh,
    ]
  );
}
</file>

<file path="app/sessions/screens/request/(hooks)/useRequestSessionForm.ts">
// app/sessions/screens/request/(hooks)/useRequestSessionForm.ts
import { useCallback, useMemo, useState } from "react";
import { Alert } from "react-native";

import type { SessionDTO } from "../../../api/sessionsApi";
import { requestSession } from "../../../api/sessionsApi";

export type Step = "mentor" | "details" | "schedule" | "review";

export type RequestSessionFormInit = {
  token: string | null;

  mentorId?: string;
  mentorName?: string;

  skill?: string;
  level?: string;

  // optional: prefilled schedule/note
  scheduledAt?: string;
  note?: string;
};

type Errors = Partial<Record<keyof FormState, string>> & { general?: string };

type FormState = {
  mentorId: string;
  mentorName: string;
  skill: string;
  level: string;
  scheduledAt: string; // ISO string
  note: string;
};

function normalize(v: any) {
  return String(v ?? "").trim();
}

function isValidIso(iso: string) {
  const d = new Date(iso);
  return !Number.isNaN(d.getTime());
}

function isFutureOrNow(iso: string) {
  const t = new Date(iso).getTime();
  if (Number.isNaN(t)) return false;
  return t >= Date.now() - 60 * 1000; // allow 1 minute tolerance
}

export function useRequestSessionForm(init: RequestSessionFormInit) {
  const [step, setStep] = useState<Step>("mentor");

  const [state, setState] = useState<FormState>(() => ({
    mentorId: normalize(init.mentorId),
    mentorName: normalize(init.mentorName),
    skill: normalize(init.skill),
    level: normalize(init.level),
    scheduledAt: normalize(init.scheduledAt),
    note: normalize(init.note),
  }));

  const [errors, setErrors] = useState<Errors>({});
  const [submitting, setSubmitting] = useState(false);
  const [created, setCreated] = useState<SessionDTO | null>(null);

  const steps: Step[] = useMemo(
    () => ["mentor", "details", "schedule", "review"],
    []
  );

  const stepIndex = useMemo(
    () => steps.findIndex((s) => s === step),
    [steps, step]
  );

  const setField = useCallback(<K extends keyof FormState>(k: K, v: FormState[K]) => {
    setState((prev) => ({ ...prev, [k]: v }));
    setErrors((prev) => ({ ...prev, [k]: undefined, general: undefined }));
  }, []);

  const setMany = useCallback((patch: Partial<FormState>) => {
    setState((prev) => ({ ...prev, ...patch }));
    setErrors((prev) => ({ ...prev, general: undefined }));
  }, []);

  const validate = useCallback(
    (forStep: Step): boolean => {
      const next: Errors = {};

      const mentorId = normalize(state.mentorId);
      const skill = normalize(state.skill);
      const level = normalize(state.level);
      const scheduledAt = normalize(state.scheduledAt);

      if (forStep === "mentor") {
        if (!mentorId) next.mentorId = "Choose a mentor first.";
      }

      if (forStep === "details") {
        if (!mentorId) next.mentorId = "Choose a mentor first.";
        if (!skill) next.skill = "Choose a skill.";
        if (!level) next.level = "Choose a level.";
      }

      if (forStep === "schedule") {
        if (!mentorId) next.mentorId = "Choose a mentor first.";
        if (!skill) next.skill = "Choose a skill.";
        if (!scheduledAt) next.scheduledAt = "Pick date & time.";
        else if (!isValidIso(scheduledAt)) next.scheduledAt = "Invalid date.";
        else if (!isFutureOrNow(scheduledAt))
          next.scheduledAt = "Time must be in the future.";
      }

      if (forStep === "review") {
        if (!mentorId) next.mentorId = "Choose a mentor first.";
        if (!skill) next.skill = "Choose a skill.";
        if (!level) next.level = "Choose a level.";
        if (!scheduledAt) next.scheduledAt = "Pick date & time.";
        else if (!isValidIso(scheduledAt)) next.scheduledAt = "Invalid date.";
      }

      setErrors(next);
      return Object.keys(next).length === 0;
    },
    [state]
  );

  const canGoNext = useMemo(() => validate(step), [step, validate]);

  const nextStep = useCallback(() => {
    // validate current step before moving
    if (!validate(step)) return;

    const idx = steps.findIndex((s) => s === step);
    if (idx < 0) return;

    const next = steps[Math.min(steps.length - 1, idx + 1)];
    setStep(next);
  }, [step, steps, validate]);

  const prevStep = useCallback(() => {
    const idx = steps.findIndex((s) => s === step);
    if (idx <= 0) return;
    const prev = steps[idx - 1];
    setStep(prev);
  }, [step, steps]);

  const jumpTo = useCallback(
    (to: Step) => {
      // allow jumping only backward freely, forward requires validation through the chain
      const fromIdx = steps.indexOf(step);
      const toIdx = steps.indexOf(to);
      if (toIdx < 0) return;
      if (toIdx <= fromIdx) {
        setStep(to);
        return;
      }

      // forward jump: validate each intermediate step
      let ok = true;
      for (let i = fromIdx; i < toIdx; i++) {
        const s = steps[i];
        if (!validate(s)) {
          ok = false;
          break;
        }
      }
      if (ok) setStep(to);
    },
    [step, steps, validate]
  );

  const submit = useCallback(async () => {
    if (submitting) return;
    if (!init.token) {
      Alert.alert("Not logged in", "Please login again.");
      return;
    }

    // validate everything
    if (!validate("review")) return;

    const body = {
      mentorId: normalize(state.mentorId),
      skill: normalize(state.skill),
      level: normalize(state.level) || undefined,
      scheduledAt: normalize(state.scheduledAt),
      note: normalize(state.note) || undefined,
    };

    try {
      setSubmitting(true);
      setErrors({});
      const s = await requestSession(init.token, body);
      setCreated(s);
      return s;
    } catch (e: any) {
      const msg = e?.message || "Failed to request session.";
      setErrors((prev) => ({ ...prev, general: msg }));
      Alert.alert("Request failed", msg);
      return null;
    } finally {
      setSubmitting(false);
    }
  }, [init.token, state, submitting, validate]);

  const reset = useCallback(() => {
    setStep("mentor");
    setSubmitting(false);
    setErrors({});
    setCreated(null);
    setState({
      mentorId: normalize(init.mentorId),
      mentorName: normalize(init.mentorName),
      skill: normalize(init.skill),
      level: normalize(init.level),
      scheduledAt: normalize(init.scheduledAt),
      note: normalize(init.note),
    });
  }, [init.level, init.mentorId, init.mentorName, init.note, init.scheduledAt, init.skill]);

  return {
    // state
    step,
    steps,
    stepIndex,

    // values
    ...state,
    errors,
    submitting,
    created,

    // setters
    setField,
    setMany,
    setStep,
    jumpTo,

    // nav
    canGoNext,
    nextStep,
    prevStep,

    // actions
    validate,
    submit,
    reset,
  };
}
</file>

<file path="app/sessions/screens/request/components/MentorCard.tsx">
// app/sessions/screens/request/components/MentorCard.tsx
import React, { useMemo } from "react";
import { Pressable, Text, View } from "react-native";
import { COLORS } from "../styles";

function initialsFromName(name: string) {
  const clean = String(name || "").trim();
  if (!clean) return "M";
  const parts = clean.split(" ").filter(Boolean);
  const a = parts[0]?.[0] || "M";
  const b = parts.length > 1 ? parts[parts.length - 1]?.[0] : "";
  return (a + b).toUpperCase();
}

// UI-only helper: avoid showing "111111" as a name
function looksLikeIdOrNumber(name: string) {
  const n = name.trim();
  if (!n) return false;
  const digitsOnly = /^\d+$/.test(n);
  if (digitsOnly) return true;
  if (n.length <= 2) return true;
  return false;
}

export default function MentorCard({
  mentorName,
  mentorId,
  onChangeMentor,
  matchedSkill, // ✅ optional: pass skill if you have it (UI-only)
}: {
  mentorName?: string;
  mentorId?: string;
  onChangeMentor?: () => void;
  matchedSkill?: string;
}) {
  const rawName = String(mentorName || "").trim();
  const rawSkill = String(matchedSkill || "").trim();

  const title = useMemo(() => {
    if (!rawName) return "Selected mentor";
    if (looksLikeIdOrNumber(rawName)) return "Selected mentor";
    return rawName;
  }, [rawName]);

  const badge = useMemo(() => {
    if (!rawName || looksLikeIdOrNumber(rawName)) return "M";
    return initialsFromName(rawName);
  }, [rawName]);

  // ✅ short, useful, and contextual (no extra logic)
  const reason = useMemo(() => {
    const s = rawSkill.trim();
    if (!s) return "Recommended based on your request.";
    return `Recommended for learning ${s}.`;
  }, [rawSkill]);

  return (
    <View
      style={{
        backgroundColor: COLORS.card,
        borderWidth: 1,
        borderColor: COLORS.border,
        borderRadius: 16,
        padding: 14,
      }}
      accessibilityRole="summary"
      accessibilityLabel={`Selected mentor: ${title}`}
    >
      <View style={{ flexDirection: "row", alignItems: "center", gap: 12 }}>
        <View
          style={{
            width: 46,
            height: 46,
            borderRadius: 16,
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "#111827",
            borderWidth: 1,
            borderColor: COLORS.border,
          }}
        >
          <Text style={{ color: "#FED7AA", fontWeight: "900" }}>{badge}</Text>
        </View>

        <View style={{ flex: 1 }}>
          {/* ✅ keep small label, but the main focus is the name */}
          <Text
            style={{ color: COLORS.muted, fontWeight: "900", fontSize: 12 }}
          >
            Selected mentor
          </Text>

          {/* ✅ show name (not "Selected mentor" in the middle) */}
          <Text
            style={{
              color: COLORS.text,
              fontWeight: "900",
              fontSize: 16, // slightly stronger for clarity
              marginTop: 2,
            }}
            numberOfLines={1}
          >
            {looksLikeIdOrNumber(rawName) ? "Mentor" : title}
          </Text>

          {/* ✅ replace generic sentence with a short useful one */}
          <Text
            style={{
              color: COLORS.hint,
              marginTop: 6,
              fontSize: 12,
              fontWeight: "800",
            }}
            numberOfLines={2}
          >
            {reason}
          </Text>
        </View>

        {onChangeMentor ? (
          <Pressable
            onPress={onChangeMentor}
            hitSlop={10}
            accessibilityRole="button"
            accessibilityLabel="Change mentor"
            style={({ pressed }) => [
              {
                paddingHorizontal: 12,
                paddingVertical: 10,
                borderRadius: 999,
                borderWidth: 1,
                borderColor: COLORS.border,
                backgroundColor: COLORS.bg,
              },
              pressed ? { opacity: 0.9 } : null,
            ]}
          >
            <Text
              style={{ color: COLORS.text, fontWeight: "900", fontSize: 12 }}
            >
              Change
            </Text>
          </Pressable>
        ) : null}
      </View>

      <View style={{ marginTop: 10 }}>
        <Text style={{ color: COLORS.tip, fontWeight: "800", fontSize: 12 }}>
          You can edit the topic and time before sending.
        </Text>
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/RequestTopBar.tsx">
// app/sessions/screens/request/components/RequestTopBar.tsx
import React from "react";
import { Pressable, Text, View } from "react-native";
import { COLORS } from "../styles";
import { Title } from "./UI";

/**
 * RequestTopBar (UI/UX fix)
 * المشكلة: كلمة "Back" هون بتوهم المستخدم انها خطوة لورا، بس هي فعليًا بتطلع من الشاشة (router.back)
 * الحل: نخليها "Close" (أو "Cancel") بشكل واضح.
 *
 * ✅ ما غيّرنا ولا ذرة لوجيك — بس نصوص وشكل ووضوح.
 */
export default function RequestTopBar({
  onBack,
  title,
  leftLabel = "Close",
}: {
  onBack: () => void;
  title: string;
  leftLabel?: string; // optional, default "Close"
}) {
  return (
    <View
      style={{
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: 12,
      }}
    >
      <Pressable
        onPress={onBack}
        hitSlop={12}
        accessibilityRole="button"
        accessibilityLabel={leftLabel}
        style={({ pressed }) => [
          {
            paddingHorizontal: 10,
            paddingVertical: 8,
            borderRadius: 999,
            borderWidth: 1,
            borderColor: COLORS.border,
            backgroundColor: COLORS.bg,
          },
          pressed ? { opacity: 0.9 } : null,
        ]}
      >
        <Text style={{ color: COLORS.link, fontWeight: "900", fontSize: 12 }}>
          ✕ {leftLabel}
        </Text>
      </Pressable>

      <View style={{ flex: 1, paddingHorizontal: 10 }}>
        <Title>{title}</Title>
      </View>

      {/* spacer to keep title centered */}
      <View style={{ width: 74 }} />
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepNote.tsx">
// app/sessions/screens/request/components/StepNote.tsx
import React from "react";
import { Text, TextInput, View } from "react-native";
import { COLORS, fieldBase } from "../styles";
import { Hint, Label } from "./UI";

type Props = {
  note: string;
  onChangeNote: (v: string) => void;
};

export default function StepNote({ note, onChangeNote }: Props) {
  return (
    <View style={{ gap: 10 }}>
      <Label>Note (optional)</Label>

      <TextInput
        value={note}
        onChangeText={onChangeNote}
        placeholder="Anything the mentor should know before the session…"
        placeholderTextColor={COLORS.hint}
        multiline
        style={{
          ...fieldBase,
          minHeight: 120,
          textAlignVertical: "top",
        }}
        accessibilityLabel="Optional note for the mentor"
      />

      {/* Soft guidance instead of silence */}
      <Hint>
        Optional • Share goals, questions, or anything important to prepare.
      </Hint>

      {/* Character hint (UI-only, no limits enforced) */}
      <Text
        style={{
          alignSelf: "flex-end",
          color: COLORS.muted,
          fontSize: 11,
          fontWeight: "800",
        }}
      >
        {note.length} characters
      </Text>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepPills.tsx">
// app/sessions/screens/request/components/StepPills.tsx
import React, { useMemo } from "react";
import { Text, View } from "react-native";
import type { Step } from "../(hooks)/useRequestSessionForm";
import { COLORS } from "../styles";

export default function StepPills({ step }: { step: Step }) {
  const items = useMemo(
    () =>
      [
        { n: 1 as const, label: "Topic" },
        { n: 2 as const, label: "Time" },
        { n: 3 as const, label: "Note" },
      ] as const,
    []
  );

  return (
    <View style={{ flexDirection: "row", gap: 8, flexWrap: "wrap" }}>
      {items.map((it) => {
        const active = it.n === step;
        const done = it.n < step;

        return (
          <View
            key={it.n}
            style={{
              paddingHorizontal: 10,
              paddingVertical: 7,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: active ? COLORS.orange : COLORS.border,
              backgroundColor: active ? COLORS.card : COLORS.bg,
              opacity: done ? 0.92 : 1,
              flexDirection: "row",
              alignItems: "center",
              gap: 6,
            }}
            accessibilityRole="text"
            accessibilityLabel={`Step ${it.n}: ${it.label}${
              active ? " (current)" : done ? " (done)" : ""
            }`}
          >
            {/* number / check */}
            <Text
              style={{
                color: active ? "#FED7AA" : done ? "#86EFAC" : COLORS.muted,
                fontWeight: "900",
                fontSize: 12,
              }}
            >
              {done ? "✓" : it.n}
            </Text>

            {/* label */}
            <Text
              style={{
                color: active ? "#FED7AA" : COLORS.muted,
                fontWeight: "900",
                fontSize: 12,
              }}
            >
              {it.label}
            </Text>
          </View>
        );
      })}
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepSchedule.tsx">
// app/sessions/screens/request/components/StepSchedule.tsx
import React, { useMemo, useState } from "react";
import { Pressable, Text, TextInput, View } from "react-native";
import { COLORS, fieldBase } from "../styles";
import { Hint, Label } from "./UI";

type Props = {
  date: string; // YYYY-MM-DD
  time: string; // HH:MM
  onChangeDate: (v: string) => void;
  onChangeTime: (v: string) => void;
  errors?: { date?: string; time?: string };
  onQuickPick?: (preset: "today" | "tomorrow" | "plus30" | "plus60") => void;
};

export default function StepSchedule({
  date,
  time,
  onChangeDate,
  onChangeTime,
  errors,
  onQuickPick,
}: Props) {
  const quicks = useMemo(
    () => [
      { key: "today" as const, label: "Today" },
      { key: "tomorrow" as const, label: "Tomorrow" },
      { key: "plus30" as const, label: "+30 min" },
      { key: "plus60" as const, label: "+1 hour" },
    ],
    []
  );

  const hasQuick = !!onQuickPick;

  // ✅ UI-only: remember last clicked option so user "feels" selection
  const [lastPick, setLastPick] = useState<
    "today" | "tomorrow" | "plus30" | "plus60" | null
  >(null);

  const filled = !!date?.trim() && !!time?.trim();

  return (
    <View style={{ gap: 14 }}>
      {hasQuick ? (
        <View>
          <Label>Quick pick (recommended)</Label>

          <View
            style={{
              flexDirection: "row",
              gap: 8,
              flexWrap: "wrap",
              marginTop: 10,
            }}
          >
            {quicks.map((q) => {
              const active = q.key === lastPick;

              return (
                <Pressable
                  key={q.key}
                  onPress={() => {
                    setLastPick(q.key); // ✅ visual confirmation
                    onQuickPick?.(q.key); // ✅ existing behavior
                  }}
                  hitSlop={8}
                  accessibilityRole="button"
                  accessibilityLabel={`Pick ${q.label}`}
                  style={({ pressed }) => [
                    {
                      paddingHorizontal: 14,
                      paddingVertical: 10,
                      borderRadius: 999,
                      borderWidth: 1,
                      borderColor: active ? COLORS.orange : COLORS.border,
                      backgroundColor: active ? COLORS.card : COLORS.bg,
                      opacity: pressed ? 0.92 : 1,
                      transform: [{ scale: pressed ? 0.98 : 1 }],
                    },
                  ]}
                >
                  <Text
                    style={{
                      color: active ? "#FED7AA" : COLORS.text,
                      fontWeight: "900",
                      fontSize: 12,
                    }}
                  >
                    {q.label}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          {/* ✅ actually useful feedback */}
          <Hint>
            {filled
              ? `Filled: ${date} • ${time}`
              : "Tap one option to fill date & time."}
          </Hint>
        </View>
      ) : null}

      <View>
        <Label>Date</Label>
        <TextInput
          value={date}
          onChangeText={(v) => {
            setLastPick(null); // typing means not a preset
            onChangeDate(v);
          }}
          placeholder="YYYY-MM-DD"
          placeholderTextColor={COLORS.hint}
          style={{
            ...fieldBase,
            borderColor: date?.trim()
              ? COLORS.orangeBorder
              : fieldBase.borderColor,
          }}
          keyboardType="numbers-and-punctuation"
          autoCapitalize="none"
          autoCorrect={false}
          returnKeyType="next"
          accessibilityLabel="Date input YYYY-MM-DD"
        />
        {!!errors?.date && (
          <Text
            style={{ color: COLORS.danger, marginTop: 8, fontWeight: "900" }}
          >
            {errors.date}
          </Text>
        )}
      </View>

      <View>
        <Label>Time</Label>
        <TextInput
          value={time}
          onChangeText={(v) => {
            setLastPick(null);
            onChangeTime(v);
          }}
          placeholder="HH:MM (24h)"
          placeholderTextColor={COLORS.hint}
          style={{
            ...fieldBase,
            borderColor: time?.trim()
              ? COLORS.orangeBorder
              : fieldBase.borderColor,
          }}
          keyboardType="numbers-and-punctuation"
          autoCapitalize="none"
          autoCorrect={false}
          returnKeyType="done"
          accessibilityLabel="Time input HH:MM"
        />
        {!!errors?.time && (
          <Text
            style={{ color: COLORS.danger, marginTop: 8, fontWeight: "900" }}
          >
            {errors.time}
          </Text>
        )}
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StepSkillLevel.tsx">
// app/sessions/screens/request/components/StepSkillLevel.tsx
import React, { useMemo } from "react";
import { Pressable, Text, TextInput, View } from "react-native";
import { COLORS, fieldBase } from "../styles";
import { Hint, Label } from "./UI";

type Props = {
  skill: string;
  level: string;
  onChangeSkill: (v: string) => void;
  onChangeLevel: (v: string) => void;
};

function Chip({
  label,
  active,
  onPress,
  accessibilityLabel,
}: {
  label: string;
  active?: boolean;
  onPress: () => void;
  accessibilityLabel: string;
}) {
  return (
    <Pressable
      onPress={onPress}
      hitSlop={8}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      style={({ pressed }) => [
        {
          paddingHorizontal: 14,
          paddingVertical: 10,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: active ? COLORS.orange : COLORS.border,
          backgroundColor: active ? COLORS.card : COLORS.bg,
          // ✅ clearer "pressed" feedback
          opacity: pressed ? 0.92 : 1,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
    >
      <Text
        style={{
          color: active ? "#FED7AA" : COLORS.text,
          fontWeight: "900",
          fontSize: 12,
        }}
      >
        {label}
      </Text>
    </Pressable>
  );
}

export default function StepSkillLevel({
  skill,
  level,
  onChangeSkill,
  onChangeLevel,
}: Props) {
  const levelOptions = useMemo(
    () => ["Beginner", "Intermediate", "Advanced", "Not sure"],
    []
  );

  const skillPresets = useMemo(
    () => ["English", "React", "Math", "Interview prep"],
    []
  );

  return (
    <View style={{ gap: 14 }}>
      {/* Skill */}
      <View>
        <Label>Skill</Label>
        <TextInput
          value={skill}
          onChangeText={onChangeSkill}
          placeholder="e.g. React basics"
          placeholderTextColor={COLORS.hint}
          style={fieldBase}
          autoCapitalize="sentences"
          autoCorrect={false}
          accessibilityLabel="Skill input"
          returnKeyType="next"
        />

        <View
          style={{
            flexDirection: "row",
            flexWrap: "wrap",
            gap: 8,
            marginTop: 10,
          }}
        >
          {skillPresets.map((s) => {
            const active = skill.trim().toLowerCase() === s.toLowerCase();
            return (
              <Chip
                key={s}
                label={s}
                active={active}
                onPress={() => onChangeSkill(s)}
                accessibilityLabel={`Select skill ${s}`}
              />
            );
          })}
        </View>

        <Hint>Tap a preset to avoid typing mistakes.</Hint>
      </View>

      {/* Level */}
      <View>
        <Label>Level</Label>

        <View
          style={{
            flexDirection: "row",
            flexWrap: "wrap",
            gap: 8,
            marginTop: 10,
          }}
        >
          {levelOptions.map((opt) => {
            const active = level.trim().toLowerCase() === opt.toLowerCase();
            return (
              <Chip
                key={opt}
                label={opt}
                active={active}
                onPress={() => onChangeLevel(opt)}
                accessibilityLabel={`Select level ${opt}`}
              />
            );
          })}
        </View>

        {/* keep fallback input, but make it clearly secondary */}
        <TextInput
          value={level}
          onChangeText={onChangeLevel}
          placeholder="Or type a custom level (optional)"
          placeholderTextColor={COLORS.hint}
          style={{
            ...fieldBase,
            marginTop: 12,
            opacity: 0.85,
          }}
          accessibilityLabel="Custom level input"
        />
      </View>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/StickyFooter.tsx">
// app/sessions/screens/request/components/StickyFooter.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";
import { COLORS } from "../styles";

/**
 * StickyFooter
 * UI/UX improvements only:
 * - Clear primary action
 * - Stable button size (no layout jump on loading)
 * - Visual priority to Next / Send
 * - Back is secondary and calm
 */
export default function StickyFooter({
  showBack,
  backLabel,
  nextLabel,
  disableNext,
  loading,
  onBack,
  onNext,
}: {
  showBack: boolean;
  backLabel: string;
  nextLabel: string;
  disableNext?: boolean;
  loading?: boolean;
  onBack: () => void;
  onNext: () => void;
}) {
  return (
    <View
      style={{
        marginTop: 16,
        paddingTop: 12,
        borderTopWidth: 1,
        borderTopColor: COLORS.border,
        flexDirection: "row",
        alignItems: "center",
        gap: 12,
      }}
    >
      {/* Back (secondary) */}
      {showBack ? (
        <Pressable
          onPress={onBack}
          hitSlop={10}
          accessibilityRole="button"
          accessibilityLabel={backLabel}
          style={({ pressed }) => [
            {
              paddingHorizontal: 14,
              paddingVertical: 12,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: COLORS.border,
              backgroundColor: COLORS.bg,
            },
            pressed ? { opacity: 0.9 } : null,
          ]}
        >
          <Text
            style={{
              color: COLORS.text,
              fontWeight: "900",
              fontSize: 13,
            }}
          >
            {backLabel}
          </Text>
        </Pressable>
      ) : (
        <View />
      )}

      {/* Spacer */}
      <View style={{ flex: 1 }} />

      {/* Primary action */}
      <Pressable
        onPress={onNext}
        disabled={!!disableNext || !!loading}
        hitSlop={10}
        accessibilityRole="button"
        accessibilityLabel={nextLabel}
        style={({ pressed }) => [
          {
            minWidth: 180,
            paddingVertical: 14,
            paddingHorizontal: 18,
            borderRadius: 999,
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: COLORS.orange,
            borderWidth: 1,
            borderColor: COLORS.orangeBorder,
            opacity: disableNext || loading ? 0.55 : 1,
          },
          pressed ? { opacity: 0.92 } : null,
        ]}
      >
        {loading ? (
          <View style={{ flexDirection: "row", gap: 10, alignItems: "center" }}>
            <ActivityIndicator />
            <Text
              style={{
                color: "#111827",
                fontWeight: "900",
                fontSize: 14,
              }}
            >
              Sending…
            </Text>
          </View>
        ) : (
          <Text
            style={{
              color: "#111827",
              fontWeight: "900",
              fontSize: 14,
            }}
          >
            {nextLabel}
          </Text>
        )}
      </Pressable>
    </View>
  );
}
</file>

<file path="app/sessions/screens/request/components/UI.tsx">
// app/sessions/screens/request/components/UI.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";
import { COLORS, shadowCard } from "../styles";

/**
 * UI primitives – refined for clarity, speed, and consistency
 * No logic changes, visuals only.
 */

export function Title({ children }: { children: React.ReactNode }) {
  return (
    <Text
      style={{
        color: COLORS.text,
        fontWeight: "900",
        fontSize: 18,
        textAlign: "center",
      }}
      accessibilityRole="header"
    >
      {children}
    </Text>
  );
}

export function Label({ children }: { children: React.ReactNode }) {
  return (
    <Text
      style={{
        color: COLORS.muted,
        fontWeight: "900",
        fontSize: 12,
        marginBottom: 4,
      }}
    >
      {children}
    </Text>
  );
}

export function Hint({ children }: { children: React.ReactNode }) {
  return (
    <Text
      style={{
        color: COLORS.hint,
        fontWeight: "800",
        fontSize: 12,
        marginTop: 6,
      }}
    >
      {children}
    </Text>
  );
}

export function Card({ children }: { children: React.ReactNode }) {
  return (
    <View
      style={{
        ...shadowCard,
        gap: 14,
      }}
    >
      {children}
    </View>
  );
}

export function PrimaryBtn({
  label,
  onPress,
  disabled,
  loading,
}: {
  label: string;
  onPress: () => void;
  disabled?: boolean;
  loading?: boolean;
}) {
  return (
    <Pressable
      onPress={onPress}
      disabled={!!disabled || !!loading}
      accessibilityRole="button"
      accessibilityLabel={label}
      style={({ pressed }) => [
        {
          borderRadius: 999,
          paddingVertical: 14,
          paddingHorizontal: 18,
          alignItems: "center",
          justifyContent: "center",
          backgroundColor: COLORS.orange,
          borderWidth: 1,
          borderColor: COLORS.orangeBorder,
          opacity: disabled || loading ? 0.55 : 1,
          minHeight: 48,
        },
        pressed ? { opacity: 0.92 } : null,
      ]}
    >
      {loading ? (
        <View style={{ flexDirection: "row", gap: 10, alignItems: "center" }}>
          <ActivityIndicator />
          <Text style={{ color: "#111827", fontWeight: "900" }}>Working…</Text>
        </View>
      ) : (
        <Text style={{ color: "#111827", fontWeight: "900" }}>{label}</Text>
      )}
    </Pressable>
  );
}

export function GhostBtn({
  label,
  onPress,
}: {
  label: string;
  onPress: () => void;
}) {
  return (
    <Pressable
      onPress={onPress}
      hitSlop={10}
      accessibilityRole="button"
      accessibilityLabel={label}
      style={({ pressed }) => [
        {
          paddingHorizontal: 14,
          paddingVertical: 12,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: COLORS.border,
          backgroundColor: COLORS.bg,
          minHeight: 44,
          justifyContent: "center",
        },
        pressed ? { opacity: 0.9 } : null,
      ]}
    >
      <Text
        style={{
          color: COLORS.text,
          fontWeight: "900",
          fontSize: 13,
        }}
      >
        {label}
      </Text>
    </Pressable>
  );
}
</file>

<file path="app/sessions/screens/request/RequestSessionScreen.tsx">
// app/sessions/screens/request/RequestSessionScreen.tsx
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import {
  Alert,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Text,
  View,
} from "react-native";

import MentorCard from "./components/MentorCard";
import RequestTopBar from "./components/RequestTopBar";
import StepNote from "./components/StepNote";
import StepPills from "./components/StepPills";
import StepSchedule from "./components/StepSchedule";
import StepSkillLevel from "./components/StepSkillLevel";
import StickyFooter from "./components/StickyFooter";
import { Card, Hint } from "./components/UI";
import { COLORS, SPACING } from "./styles";

import { useRequestSessionForm } from "./(hooks)/useRequestSessionForm";

type Params = {
  mentorId?: string;
  mentorName?: string;
  skill?: string;
  level?: string;
};

function StepLabel({
  active,
  children,
}: {
  active: boolean;
  children: string;
}) {
  return (
    <Text
      style={{
        color: active ? "#FED7AA" : COLORS.muted,
        fontWeight: "900",
        fontSize: 12,
      }}
    >
      {children}
    </Text>
  );
}

function InlineError({ text }: { text?: string }) {
  if (!text) return null;
  return (
    <Text style={{ color: COLORS.danger, marginTop: 10, fontWeight: "900" }}>
      {text}
    </Text>
  );
}

export default function RequestSessionScreen() {
  const router = useRouter();
  const params = useLocalSearchParams<Params>();

  const mentorId = useMemo(
    () => String(params.mentorId || "").trim(),
    [params.mentorId]
  );
  const mentorName = useMemo(
    () => String(params.mentorName || "").trim(),
    [params.mentorName]
  );
  const preSkill = useMemo(
    () => String(params.skill || "").trim(),
    [params.skill]
  );
  const preLevel = useMemo(
    () => String(params.level || "").trim(),
    [params.level]
  );

  const form = useRequestSessionForm({
    mentorId,
    mentorName,
    prefillSkill: preSkill,
    prefillLevel: preLevel,
  });

  // UI-only state: show success hint (no logic changes)
  const [sentOk, setSentOk] = useState(false);

  const headerSub = useMemo(() => {
    const n = mentorName?.trim();
    return n ? `Requesting a session with ${n}` : "Requesting a session";
  }, [mentorName]);

  const microSub = "3 steps";

  const primaryLabel = useMemo(() => {
    if (form.step === 3) return "Send request";
    return "Continue";
  }, [form.step]);

  const onNext = () => {
    // ✅ no alerts: just reveal inline errors for this step
    if (!form.canGoNext) {
      form.touchStep(form.step);
      return;
    }
    form.next();
  };

  const onSubmit = async () => {
    // reveal all inline errors
    form.touchStep(1);
    form.touchStep(2);
    form.touchStep(3);

    const out = await form.submit();
    if (!out.ok) {
      // ✅ no alert — show inline submitError (hook already sets it)
      return;
    }

    setSentOk(true);

    // Success confirmation is OK (single clean confirmation)
    Alert.alert("Sent ✅", "Your request was sent.", [
      {
        text: "Go to sessions",
        onPress: () => router.replace("/sessions" as any),
      },
    ]);
  };

  if (!mentorId) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: COLORS.bg,
          alignItems: "center",
          justifyContent: "center",
          padding: 16,
        }}
      >
        <Text style={{ color: COLORS.danger, fontWeight: "900" }}>
          Missing mentorId.
        </Text>
        <Text
          style={{ color: COLORS.muted, marginTop: 8, textAlign: "center" }}
        >
          Open this screen from a mentor profile so it can prefill correctly.
        </Text>
      </View>
    );
  }

  const isLast = form.step === 3;

  const stepTitle =
    form.step === 1 ? "Topic" : form.step === 2 ? "Time" : "Note";

  // Inline error strings per step (no component changes required)
  const topicError =
    form.touched.topic && (form.errors.skill || form.errors.level)
      ? form.errors.skill || form.errors.level
      : undefined;

  const scheduleErrors = form.touched.schedule
    ? { date: form.errors.date, time: form.errors.time }
    : undefined;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: COLORS.bg }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
      keyboardVerticalOffset={Platform.OS === "ios" ? 90 : 0}
    >
      <ScrollView
        contentContainerStyle={{ padding: SPACING.pagePad, paddingBottom: 28 }}
      >
        <RequestTopBar onBack={() => router.back()} title="Request session" />

        {/* Context header */}
        <View style={{ marginBottom: 12 }}>
          <Text style={{ color: COLORS.text, fontWeight: "900", fontSize: 16 }}>
            {headerSub}
          </Text>
          <Text
            style={{
              color: COLORS.hint,
              fontWeight: "800",
              marginTop: 6,
              fontSize: 12,
            }}
          >
            Choose a topic, pick a time, and send.
          </Text>
        </View>

        {/* Mentor summary (fast reassurance) */}
        <View style={{ marginBottom: 12 }}>
          <MentorCard mentorName={mentorName} mentorId={mentorId} />
        </View>

        {/* Stepper */}
        <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
          <StepPills step={form.step} />
          <View style={{ flex: 1 }} />
          <Text
            style={{ color: COLORS.muted, fontWeight: "900", fontSize: 12 }}
          >
            Step {form.step}/3 · {stepTitle}
          </Text>
        </View>

        <View style={{ marginTop: 14 }}>
          <Card>
            {/* Step content */}
            {form.step === 1 ? (
              <>
                <StepSkillLevel
                  skill={form.skill}
                  level={form.level}
                  onChangeSkill={form.setSkill}
                  onChangeLevel={form.setLevel}
                />
                <InlineError text={topicError} />
                <Text
                  style={{
                    marginTop: 10,
                    color: COLORS.tip,
                    fontSize: 12,
                    fontWeight: "800",
                  }}
                >
                  Tip: keep it short (e.g. “React hooks”, “English speaking”).
                </Text>
              </>
            ) : form.step === 2 ? (
              <StepSchedule
                date={form.date}
                time={form.time}
                onChangeDate={form.setDate}
                onChangeTime={form.setTime}
                errors={scheduleErrors}
                // ✅ use hook helper (no duplicate logic)
                onQuickPick={(preset) => form.quickPick(preset)}
              />
            ) : (
              <>
                {/* Review summary (prevents mistakes before sending) */}
                <View
                  style={{
                    borderWidth: 1,
                    borderColor: COLORS.border,
                    backgroundColor: COLORS.bg,
                    borderRadius: 14,
                    padding: 12,
                    marginBottom: 12,
                  }}
                >
                  <Text
                    style={{
                      color: COLORS.muted,
                      fontWeight: "900",
                      fontSize: 12,
                    }}
                  >
                    Review
                  </Text>

                  <View style={{ marginTop: 8, gap: 6 }}>
                    <Text style={{ color: COLORS.text, fontWeight: "900" }}>
                      Skill:{" "}
                      <Text style={{ color: COLORS.text, fontWeight: "800" }}>
                        {form.skill?.trim() ? form.skill.trim() : "—"}
                      </Text>
                    </Text>

                    <Text style={{ color: COLORS.text, fontWeight: "900" }}>
                      Level:{" "}
                      <Text style={{ color: COLORS.text, fontWeight: "800" }}>
                        {form.level?.trim() ? form.level.trim() : "—"}
                      </Text>
                    </Text>

                    <Text style={{ color: COLORS.text, fontWeight: "900" }}>
                      When:{" "}
                      <Text style={{ color: COLORS.text, fontWeight: "800" }}>
                        {form.reviewScheduleText}
                      </Text>
                    </Text>
                  </View>
                </View>

                <StepNote note={form.note} onChangeNote={form.setNote} />

                {/* Submit error inline */}
                <InlineError text={form.submitError || undefined} />

                {sentOk ? (
                  <Text
                    style={{
                      marginTop: 10,
                      color: "#86EFAC",
                      fontWeight: "900",
                    }}
                  >
                    Sent successfully ✅
                  </Text>
                ) : null}
              </>
            )}

            {/* Footer */}
            <StickyFooter
              showBack={form.step !== 1}
              backLabel="Back"
              nextLabel={primaryLabel}
              disableNext={!form.canGoNext}
              loading={isLast ? form.submitting : false}
              onBack={form.back}
              onNext={isLast ? onSubmit : onNext}
            />
          </Card>

          {/* One-line help (short + clear) */}
          <View style={{ marginTop: 10 }}>
            <Hint>
              Can’t access this screen? Find Mentor → open a mentor profile →
              Request.
            </Hint>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/sessions/screens/request/styles.ts">
// app/sessions/screens/request/styles.ts

export const COLORS = {
  bg: "#020617",
  card: "#0B1120",

  border: "#1E293B",
  borderSoft: "#111827",
  fieldBorder: "#1F2937",

  text: "#E5E7EB",
  muted: "#94A3B8",
  hint: "#64748B",
  tip: "#334155",

  link: "#60A5FA",
  danger: "#FCA5A5",

  orange: "#F97316",
  orangeBorder: "#FB923C",
};

export const SPACING = {
  pagePad: 16,
  cardPad: 14,

  radius: 16,
  pillRadius: 999,

  // consistent hit targets (fast + accessible)
  tapMinH: 44,
  inputMinH: 48,
};

export const shadowCard = {
  borderWidth: 1,
  borderColor: COLORS.border,
  backgroundColor: COLORS.card,
  borderRadius: SPACING.radius,
  padding: SPACING.cardPad,

  // subtle depth (no performance heavy shadows)
  // RN Android: elevation is cheap
  elevation: 1,
};

export const fieldBase = {
  marginTop: 8,
  borderRadius: 14,
  borderWidth: 1,
  borderColor: COLORS.fieldBorder,
  backgroundColor: COLORS.bg,

  color: COLORS.text,
  paddingHorizontal: 12,
  paddingVertical: 12,

  fontWeight: "800" as const,

  minHeight: SPACING.inputMinH,
};
</file>

<file path="app/sessions/utils/formatSession.ts">
// app/sessions/utils/formatSession.ts
// I AM THE REAL formatSession.ts

import type { SessionStatus } from "../api/sessionsApi";

export function formatSessionDateTime(iso: string): string {
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "Invalid date";
  return d.toLocaleString();
}

export function statusBadge(
  status: SessionStatus
): { label: string; bg: string; border: string; text: string } {
  switch (status) {
    case "requested":
      return { label: "Requested", bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
    case "accepted":
      return { label: "Accepted", bg: "#052E16", border: "#16A34A", text: "#D1FAE5" };
    case "rejected":
      return { label: "Rejected", bg: "#450A0A", border: "#EF4444", text: "#FEE2E2" };
    case "cancelled":
      return { label: "Cancelled", bg: "#111827", border: "#6B7280", text: "#E5E7EB" };
    case "completed":
      return { label: "Completed", bg: "#0B1120", border: "#F97316", text: "#FED7AA" };
    default:
      return { label: String(status), bg: "#0B1120", border: "#1E293B", text: "#E5E7EB" };
  }
}
</file>

<file path="app/shared/levels.ts">
// app/shared/levels.ts

export const LEVELS = [
  "Beginner",
  "Intermediate",
  "Advanced",
] as const;

export type Level = (typeof LEVELS)[number];

/**
 * ترتيب المستويات للمقارنة
 * كل ما الرقم أكبر → مستوى أعلى
 */
export const LEVEL_RANK: Record<Level, number> = {
  Beginner: 1,
  Intermediate: 2,
  Advanced: 3,
};
</file>

<file path="app/shared/profileCompletion.ts">
// app/shared/profileCompletion.ts
// ✅ Single-source-of-truth: re-export from /lib to avoid duplicated logic.
// This keeps old imports working if any screen still imports from app/shared.

export { getProfileCompletionStatus } from "../../lib/profileCompletion";
export type { ProfileCompletionStatus } from "../../lib/profileCompletion";
</file>

<file path="app/weekly-availability/SaveBar.tsx">
// app/weekly-availability/SaveBar.tsx
import React from "react";
import { ActivityIndicator, Pressable, Text, View } from "react-native";

type Props = {
  visible: boolean;
  saving?: boolean;
  onSave: () => void;
  onDiscard: () => void;
  lastSavedText?: string;
};

export default function SaveBar({
  visible,
  saving,
  onSave,
  onDiscard,
  lastSavedText,
}: Props) {
  if (!visible) return null;

  const disabled = !!saving;

  return (
    <View
      style={{
        position: "absolute",
        left: 14,
        right: 14,
        bottom: 14,
        borderRadius: 16,
        borderWidth: 1,
        borderColor: "#1E293B",
        backgroundColor: "#0B1120",
        padding: 12,
      }}
    >
      <View style={{ flexDirection: "row", alignItems: "center", gap: 10 }}>
        <View style={{ flex: 1 }}>
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
            Unsaved changes
          </Text>
          <Text
            style={{
              color: "#94A3B8",
              fontSize: 11,
              marginTop: 3,
              lineHeight: 14,
            }}
          >
            {lastSavedText ? `Last saved: ${lastSavedText}` : "Not saved yet"}
          </Text>
        </View>

        <Pressable
          onPress={onDiscard}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 12,
              paddingVertical: 10,
              borderRadius: 999,
              borderWidth: 1,
              borderColor: "#334155",
              backgroundColor: "#020617",
              opacity: disabled ? 0.6 : 1,
            },
            pressed && !disabled ? { opacity: 0.85 } : null,
          ]}
        >
          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
            Discard
          </Text>
        </Pressable>

        <Pressable
          onPress={onSave}
          disabled={disabled}
          style={({ pressed }) => [
            {
              paddingHorizontal: 14,
              paddingVertical: 10,
              borderRadius: 999,
              backgroundColor: "#22C55E",
              opacity: disabled ? 0.65 : 1,
              flexDirection: "row",
              alignItems: "center",
              gap: 8,
            },
            pressed && !disabled ? { opacity: 0.9 } : null,
          ]}
        >
          {saving ? <ActivityIndicator /> : null}
          <Text style={{ color: "#022C22", fontWeight: "900", fontSize: 12 }}>
            {saving ? "Saving…" : "Save"}
          </Text>
        </Pressable>
      </View>
    </View>
  );
}
</file>

<file path="app/weekly-availability/styles.ts">
// app/weekly-availability/styles.ts
import { StyleSheet } from "react-native";

export const styles = StyleSheet.create({
  root: {
    flex: 1,
    backgroundColor: "#020617",
  },
  scroll: {
    flex: 1,
  },
  content: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 120, // extra space for save bar + toast
  },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    color: "#9CA3AF",
    marginTop: 8,
    fontSize: 14,
  },

  title: {
    color: "#F9FAFB",
    fontSize: 22,
    fontWeight: "800",
    marginBottom: 4,
  },
  subtitle: {
    color: "#64748B",
    fontSize: 13,
    marginBottom: 12,
    lineHeight: 18,
  },

  // Section headers (step-by-step)
  sectionTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "900",
    marginTop: 10,
    marginBottom: 4,
  },
  sectionHint: {
    color: "#64748B",
    fontSize: 12,
    marginBottom: 8,
    lineHeight: 16,
  },

  // Error box
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
    marginBottom: 8,
  },

  // Summary card
  summaryCard: {
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  summaryTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "900",
    marginBottom: 4,
  },
  summaryText: {
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },
  summaryRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
    gap: 8,
    flexWrap: "wrap",
  },
  summaryBadge: {
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
  },
  summaryBadgeText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  // Day selector row
  daySelectorRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 12,
  },
  dayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  dayChipToday: {
    borderColor: "#60A5FA",
  },
  dayChipSelected: {
    backgroundColor: "#F97316",
    borderColor: "#F97316",
  },
  dayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },
  dayChipTextToday: {
    color: "#BFDBFE",
    fontWeight: "800",
  },
  dayChipTextSelected: {
    color: "#0F172A",
    fontWeight: "900",
  },

  // Time input card
  timeCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  // subtle state borders (edit vs normal) - safe additions
  timeCardNormal: {
    borderColor: "#1E293B",
  },
  timeCardEditing: {
    borderColor: "#60A5FA",
  },

  timeLabelRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 8,
    marginBottom: 8,
  },
  timeLabel: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "900",
  },
  timeSelectedDayText: {
    color: "#94A3B8",
    fontSize: 12,
  },

  editBanner: {
    marginTop: 8,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#334155",
  },
  editBannerTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
    marginBottom: 2,
  },
  editBannerSub: {
    color: "#94A3B8",
    fontSize: 11,
    lineHeight: 15,
  },
  editBannerRow: {
    marginTop: 8,
    flexDirection: "row",
    gap: 8,
    flexWrap: "wrap",
  },
  bannerBtn: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  bannerBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  bannerDanger: {
    borderColor: "#7F1D1D",
    backgroundColor: "#451A1A",
  },
  bannerDangerText: {
    color: "#FECACA",
  },
  bannerPrimary: {
    borderColor: "#60A5FA",
    backgroundColor: "#60A5FA",
  },
  bannerPrimaryText: {
    color: "#0F172A",
  },

  timeRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 6,
  },
  timeDash: {
    color: "#9CA3AF",
    marginHorizontal: 8,
    fontSize: 16,
    fontWeight: "900",
  },
  timeHint: {
    color: "#64748B",
    fontSize: 12,
    marginTop: 6,
    lineHeight: 16,
  },
  timeErrorText: {
    color: "#FCA5A5",
    fontSize: 12,
    marginTop: 8,
    lineHeight: 16,
  },

  // Quick presets
  quickRow: {
    flexDirection: "row",
    marginTop: 10,
    gap: 8,
    flexWrap: "wrap",
  },
  quickChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  quickChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  quickChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },
  quickChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "900",
  },

  // Multi-day add
  multiRow: {
    marginTop: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    backgroundColor: "#0B1120",
  },
  multiTopRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    flexWrap: "wrap",
  },
  multiTopActions: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
  },
  miniActionBtn: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  miniActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  multiTitle: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  multiCountText: {
    color: "#94A3B8",
    fontSize: 11,
    marginTop: 6,
    marginBottom: 8,
    lineHeight: 15,
  },
  multiDaysRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  multiDayChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  multiDayChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  multiDayChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  primaryButton: {
    marginTop: 12,
    backgroundColor: "#22C55E",
    paddingVertical: 11,
    borderRadius: 999,
    alignItems: "center",
  },
  primaryButtonDisabled: {
    opacity: 0.6,
  },
  primaryText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
  },

  secondaryActionsRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 10,
    flexWrap: "wrap",
  },
  secondaryBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  secondaryBtnText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "800",
  },

  // Day cards list
  dayCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
    marginBottom: 10,
  },
  dayHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 10,
    marginBottom: 6,
  },
  dayHeaderActions: {
    flexDirection: "row",
    gap: 10,
    alignItems: "center",
    flexWrap: "wrap",
  },
  dayName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "900",
  },
  daySubText: {
    marginTop: 2,
    color: "#94A3B8",
    fontSize: 11,
  },
  clearDayText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },
  copyDayText: {
    color: "#60A5FA",
    fontSize: 12,
    fontWeight: "900",
  },
  daySlotsEmptyText: {
    color: "#6B7280",
    fontSize: 12,
  },

  slotChipRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  slotChip: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    gap: 10,
  },
  slotChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  slotRemoveText: {
    color: "#FCA5A5",
    fontSize: 12,
    fontWeight: "900",
  },

  // Save bar (sticky)
  saveBarSticky: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(2,6,23,0.95)",
    borderTopWidth: 1,
    borderTopColor: "#1E293B",
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  saveRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  saveHint: {
    color: "#94A3B8",
    fontSize: 12,
    flex: 1,
  },
  discardButton: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  discardText: {
    color: "#E5E7EB",
    fontWeight: "900",
    fontSize: 12,
  },
  saveButton: {
    backgroundColor: "#22C55E",
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 999,
    alignItems: "center",
    minWidth: 110,
  },
  saveButtonDisabled: {
    opacity: 0.6,
  },
  saveText: {
    color: "#022C22",
    fontWeight: "900",
    fontSize: 13,
    textAlign: "center",
  },

  // Time picker field
  timeFieldBox: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0F172A",
  },
  timeFieldLabel: {
    color: "#64748B",
    fontSize: 11,
    fontWeight: "800",
  },
  timeFieldValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "900",
    marginTop: 4,
  },

  // Modal
  modalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "flex-end",
  },
  modalCard: {
    backgroundColor: "#0B1120",
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingVertical: 18,
    paddingHorizontal: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  modalTitle: {
    fontSize: 16,
    fontWeight: "900",
    textAlign: "center",
    marginBottom: 10,
    color: "#F9FAFB",
  },
  modalButtonsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
  },
  modalCancel: {
    fontSize: 14,
    color: "#94A3B8",
    fontWeight: "800",
  },
  modalDone: {
    fontSize: 14,
    fontWeight: "900",
    color: "#F9FAFB",
  },

  // Copy modal list
  copyList: {
    marginTop: 10,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    justifyContent: "center",
  },
  copyChip: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#020617",
  },
  copyChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  copyChipText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "900",
  },
  copyHint: {
    marginTop: 10,
    textAlign: "center",
    color: "#94A3B8",
    fontSize: 12,
    lineHeight: 16,
  },

  // Toast
  toastWrap: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 84, // above save bar
    alignItems: "center",
    justifyContent: "center",
  },
  toastCard: {
    backgroundColor: "rgba(11,17,32,0.96)",
    borderWidth: 1,
    borderColor: "#1E293B",
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 999,
  },
  toastText: {
    color: "#F9FAFB",
    fontSize: 12,
    fontWeight: "800",
  },
});
</file>

<file path="components/external-link.tsx">
import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}
</file>

<file path="components/haptic-tab.tsx">
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}
</file>

<file path="components/hello-wave.tsx">
import Animated from 'react-native-reanimated';

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          '50%': { transform: [{ rotate: '25deg' }] },
        },
        animationIterationCount: 4,
        animationDuration: '300ms',
      }}>
      👋
    </Animated.Text>
  );
}
</file>

<file path="components/parallax-scroll-view.tsx">
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/themed-view';
import { useColorScheme } from '@/hooks/use-color-scheme';
import { useThemeColor } from '@/hooks/use-theme-color';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const backgroundColor = useThemeColor({}, 'background');
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <Animated.ScrollView
      ref={scrollRef}
      style={{ backgroundColor, flex: 1 }}
      scrollEventThrottle={16}>
      <Animated.View
        style={[
          styles.header,
          { backgroundColor: headerBackgroundColor[colorScheme] },
          headerAnimatedStyle,
        ]}>
        {headerImage}
      </Animated.View>
      <ThemedView style={styles.content}>{children}</ThemedView>
    </Animated.ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});
</file>

<file path="components/themed-text.tsx">
import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});
</file>

<file path="components/themed-view.tsx">
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}
</file>

<file path="components/ui/collapsible.tsx">
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { IconSymbol } from '@/components/ui/icon-symbol';
import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});
</file>

<file path="components/ui/icon-symbol.ios.tsx">
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}
</file>

<file path="components/ui/icon-symbol.tsx">
// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight, SymbolViewProps } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}
</file>

<file path="hooks/use-color-scheme.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="hooks/use-color-scheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
</file>

<file path="hooks/use-theme-color.ts">
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
</file>

<file path="lib/availabilityStorage.ts">
// lib/availabilityStorage.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import type { AvailabilitySlot } from "./api";
import { patchSectionStatus } from "./sectionStatus"; // ✅ update Home status too

// ✅ Keys (versioned to avoid future breaking)
const KEY_LAST_SAVED_AT = "weeklyAvailability_lastSavedAt_v1";
const KEY_PENDING = "weeklyAvailability_pending_v1";

/**
 * The pending payload stored locally when user edits availability
 * but hasn't synced to server yet.
 */
export type PendingAvailabilityPayload = {
  slots: AvailabilitySlot[];
  updatedAtISO: string; // when user changed locally
  source: "user-edit" | "auto-restore";
};

function safeParseJSON<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export async function getWeeklyLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_LAST_SAVED_AT);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

/**
 * ✅ IMPORTANT:
 * - write local timestamp
 * - also patch sectionStatus so HomeScreen reflects it immediately
 */
export async function setWeeklyLastSavedAt(
  ts: number = Date.now()
): Promise<void> {
  try {
    await AsyncStorage.setItem(KEY_LAST_SAVED_AT, String(ts));
  } catch {
    // swallow - we don't want UI crash
  }

  // keep Home in sync (ignore errors safely)
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: ts });
  } catch {
    // ignore
  }
}

export async function clearWeeklyLastSavedAt(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_LAST_SAVED_AT);
  } catch {
    // ignore
  }

  // keep Home in sync
  try {
    await patchSectionStatus({ weeklyAvailabilityLastSavedAt: null });
  } catch {
    // ignore
  }
}

export async function getPendingWeeklyAvailability(): Promise<PendingAvailabilityPayload | null> {
  try {
    const raw = await AsyncStorage.getItem(KEY_PENDING);
    const parsed = safeParseJSON<PendingAvailabilityPayload>(raw);
    if (
      !parsed ||
      !Array.isArray(parsed.slots) ||
      typeof parsed.updatedAtISO !== "string"
    ) {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}

export async function setPendingWeeklyAvailability(
  slots: AvailabilitySlot[],
  source: PendingAvailabilityPayload["source"] = "user-edit"
): Promise<void> {
  try {
    const payload: PendingAvailabilityPayload = {
      slots,
      updatedAtISO: new Date().toISOString(),
      source,
    };
    await AsyncStorage.setItem(KEY_PENDING, JSON.stringify(payload));
  } catch {
    // ignore
  }
}

export async function clearPendingWeeklyAvailability(): Promise<void> {
  try {
    await AsyncStorage.removeItem(KEY_PENDING);
  } catch {
    // ignore
  }
}

/**
 * Convenience: mark "saved successfully" (server sync succeeded)
 * - clear pending
 * - bump lastSavedAt (and Home status)
 */
export async function markWeeklyAvailabilitySynced(): Promise<void> {
  await Promise.all([
    clearPendingWeeklyAvailability(),
    setWeeklyLastSavedAt(Date.now()), // ✅ this also patches sectionStatus
  ]);
}

/**
 * Use this when entering weekly availability screen:
 * If there is a pending payload, you can offer restore.
 */
export async function hasPendingWeeklyAvailability(): Promise<boolean> {
  const p = await getPendingWeeklyAvailability();
  return !!p?.slots?.length;
}
</file>

<file path="lib/chat/api.ts">
// lib/chat/api.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { API_URL } from "../api";

export type ChatMessage = {
  id: string;
  conversationId: string;
  senderId: string;
  text: string;
  createdAt: string; // ISO
};

export type PeerPublic = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
};

export type ChatInboxItem = {
  id: string; // conversationId
  peer: PeerPublic | null;
  lastMessageText: string;
  lastMessageAt: string | null;
  updatedAt: string | null;
  createdAt: string | null;
  unreadCount: number;
};

async function handleResponse(res: Response) {
  const text = await res.text();

  let data: any = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    const message =
      (data && (data as any).error) ||
      (data && (data as any).message) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;

    throw new Error(message);
  }

  return data;
}

function authHeader(token: string) {
  return { Authorization: `Bearer ${token}` };
}

/**
 * GET /api/chat/inbox
 * returns: ChatInboxItem[]
 */
export async function getChatInbox(token: string): Promise<ChatInboxItem[]> {
  const res = await fetch(`${API_URL}/api/chat/inbox`, {
    method: "GET",
    headers: {
      ...authHeader(token),
    },
  });


  const data = await handleResponse(res);
  return Array.isArray(data?.items) ? (data.items as ChatInboxItem[]) : [];
}
// ---- inbox cache (fast boot) ----
const INBOX_CACHE_KEY = "chat_inbox_cache_v1";

export async function getInboxCache(): Promise<ChatInboxItem[] | null> {
  try {
    const raw = await AsyncStorage.getItem(INBOX_CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? (parsed as ChatInboxItem[]) : null;
  } catch {
    return null;
  }
}

export async function setInboxCache(items: ChatInboxItem[]): Promise<void> {
  try {
    await AsyncStorage.setItem(INBOX_CACHE_KEY, JSON.stringify(items));
  } catch {}
}

/**
 * POST /api/chat/conversation
 * body: { peerId }
 * returns: { conversationId: string }
 */
export async function getOrCreateConversation(
  token: string,
  peerId: string
): Promise<string> {
  const res = await fetch(`${API_URL}/api/chat/conversation`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...authHeader(token),
    },
    body: JSON.stringify({ peerId }),
  });

  const data = await handleResponse(res);

  const conversationId = String(data?.conversationId || "").trim();
  if (!conversationId) throw new Error("Invalid conversationId");
  return conversationId;
}

/**
 * GET /api/chat/:conversationId/messages?limit=50&before=ISO
 * returns: { items: ChatMessage[] }
 */
export async function getConversationMessages(
  token: string,
  conversationId: string,
  opts?: { limit?: number; before?: string }
): Promise<{ items: ChatMessage[] }> {
  const params = new URLSearchParams();
  if (opts?.limit != null) params.set("limit", String(opts.limit));
  if (opts?.before) params.set("before", String(opts.before));

  const q = params.toString();
  const url = `${API_URL}/api/chat/${encodeURIComponent(
    conversationId
  )}/messages${q ? `?${q}` : ""}`;

  const res = await fetch(url, {
    method: "GET",
    headers: {
      ...authHeader(token),
    },
  });

  const data = await handleResponse(res);

  return {
    items: Array.isArray(data?.items) ? (data.items as ChatMessage[]) : [],
  };
}

/**
 * POST /api/chat/:conversationId/messages
 * body: { text }
 * returns: { message: ChatMessage }
 */
export async function sendMessageRest(
  token: string,
  conversationId: string,
  text: string
): Promise<ChatMessage> {
  const res = await fetch(
    `${API_URL}/api/chat/${encodeURIComponent(conversationId)}/messages`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...authHeader(token),
      },
      body: JSON.stringify({ text }),
    }
  );

  const data = await handleResponse(res);

  const msgObj = data?.message;
  if (!msgObj?.id) throw new Error("Invalid message payload");
  return msgObj as ChatMessage;
}
</file>

<file path="lib/chat/socket.ts">
// lib/chat/socket.ts
import { io, Socket } from "socket.io-client";
import { API_URL } from "../api";

export type RealtimeMessage = {
  id: string;
  conversationId: string;
  senderId: string;
  text: string;
  createdAt: string;
};

type ConnStatus = "connected" | "reconnecting" | "disconnected";

let socket: Socket | null = null;
let currentToken: string | null = null;

// ✅ keep last joined room so we can re-join on reconnect safely
let lastJoin: { conversationId: string; peerId: string } | null = null;

// ✅ prevent duplicate global connection listeners
let connListenersBound = false;

function normalizeCreatedAt(v: any): string {
  if (!v) return new Date().toISOString();
  if (typeof v === "string") return v;
  if (v instanceof Date) return v.toISOString();
  const d = new Date(v);
  return Number.isNaN(d.getTime()) ? new Date().toISOString() : d.toISOString();
}

function ensureConnected(token: string) {
  currentToken = token;

  if (socket) {
    socket.auth = token ? { token } : {};
    if (!socket.connected) socket.connect();
    return socket;
  }

  socket = io(API_URL, {
    transports: ["websocket"],
    auth: token ? { token } : {},
    autoConnect: true,
    reconnection: true,
  });

  return socket;
}

export function connectChatSocket(token: string) {
  const s = ensureConnected(token);

  // ✅ bind only once per socket instance
  if (!connListenersBound) {
    connListenersBound = true;

    // if reconnect happens, rejoin last room automatically
    s.on("connect", () => {
      if (lastJoin?.conversationId) {
        s.emit("conversation:join", {
          conversationId: lastJoin.conversationId,
          peerId: lastJoin.peerId || "",
        });
      }
    });
  }

  return s;
}

export function disconnectChatSocket() {
  try {
    socket?.disconnect();
  } finally {
    socket = null;
    currentToken = null;
    lastJoin = null;
    connListenersBound = false;
  }
}

export function joinConversationRoom(conversationId: string, peerId?: string) {
  const s = socket;
  if (!s) return;

  const cid = String(conversationId || "").trim();
  const pid = String(peerId || "").trim();

  if (!cid) return;

  lastJoin = { conversationId: cid, peerId: pid };
  s.emit("conversation:join", { conversationId: cid, peerId: pid || "" });
}

export function markConversationRead(conversationId: string) {
  const s = socket;
  if (!s) return Promise.resolve();
  const cid = String(conversationId || "").trim();
  if (!cid) return Promise.resolve();

  return new Promise<void>((resolve) => {
    s.emit("conversation:read", { conversationId: cid });
    resolve();
  });
}

export function emitTyping(conversationId: string, isTyping: boolean) {
  const s = socket;
  if (!s) return;
  const cid = String(conversationId || "").trim();
  if (!cid) return;
  s.emit("typing", { conversationId: cid, isTyping: !!isTyping });
}

export function onNewMessage(handler: (m: RealtimeMessage) => void) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    const msg: RealtimeMessage = {
      id: String(payload?.id || payload?._id || ""),
      conversationId: String(payload?.conversationId || ""),
      senderId: String(payload?.senderId || ""),
      text: String(payload?.text || ""),
      createdAt: normalizeCreatedAt(payload?.createdAt),
    };
    if (!msg.id || !msg.conversationId) return;
    handler(msg);
  };

  s.on("message:new", wrapped);
  return () => s.off("message:new", wrapped);
}

export function onPeerTyping(
  handler: (p: { conversationId: string; userId: string; isTyping: boolean }) => void
) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      conversationId: String(payload?.conversationId || ""),
      userId: String(payload?.userId || ""),
      isTyping: !!payload?.isTyping,
    });
  };

  s.on("typing", wrapped);
  return () => s.off("typing", wrapped);
}

export function onPresenceUpdate(
  handler: (p: { userId: string; online: boolean; lastSeen: string | null }) => void
) {
  const s = socket;
  if (!s) return () => {};

  const wrapped = (payload: any) => {
    handler({
      userId: String(payload?.userId || ""),
      online: !!payload?.online,
      lastSeen: payload?.lastSeen ? String(payload.lastSeen) : null,
    });
  };

  s.on("presence:update", wrapped);
  return () => s.off("presence:update", wrapped);
}

export function onConnectionStatus(handler: (s: ConnStatus) => void) {
  const s = socket;
  if (!s) return () => {};

  const onConnect = () => handler("connected");
  const onDisconnect = () => handler("disconnected");
  const onReconnectAttempt = () => handler("reconnecting");
  const onConnectError = () => handler("reconnecting");

  s.on("connect", onConnect);
  s.on("disconnect", onDisconnect);
  s.io.on("reconnect_attempt", onReconnectAttempt);
  s.on("connect_error", onConnectError);

  // immediate
  handler(s.connected ? "connected" : "disconnected");

  return () => {
    s.off("connect", onConnect);
    s.off("disconnect", onDisconnect);
    s.off("connect_error", onConnectError);
    s.io.off("reconnect_attempt", onReconnectAttempt);
  };
}

export function sendRealtimeMessage(
  conversationId: string,
  text: string
): Promise<{ ok: boolean; message?: RealtimeMessage; error?: string }> {
  return new Promise((resolve) => {
    const s = socket;
    if (!s) return resolve({ ok: false, error: "Socket not connected" });

    const cid = String(conversationId || "").trim();
    const t = String(text || "").trim();
    if (!cid || !t) return resolve({ ok: false, error: "Missing data" });

    s.emit(
      "message:send",
      { conversationId: cid, text: t },
      (resp: any = { ok: false, error: "No response" }) => {
        if (!resp?.ok)
          return resolve({
            ok: false,
            error: String(resp?.error || "Failed"),
          });

        const payload = resp?.message || resp;
        const msg: RealtimeMessage = {
          id: String(payload?.id || payload?._id || ""),
          conversationId: String(payload?.conversationId || cid),
          senderId: String(payload?.senderId || ""),
          text: String(payload?.text || t),
          createdAt: normalizeCreatedAt(payload?.createdAt),
        };

        if (!msg.id) {
          // if server didn't return id, still allow optimistic success
          msg.id = `${Date.now()}`;
        }

        return resolve({ ok: true, message: msg });
      }
    );
  });
}
</file>

<file path="lib/profileCompletion.ts">
// lib/profileCompletion.ts
import type { AvailabilitySlot, SkillLearn, SkillTeach } from "./api";

export type ProfileCompletionSection = {
  key: "basics" | "learn" | "teach" | "availability";
  title: string;
  done: boolean;
  hint: string;
  ctaLabel: string;
  href: string; // expo-router route
};

export type ProfileCompletionStatus = {
  percent: number; // 0..100
  isComplete: boolean;
  doneCount: number;
  totalCount: number;
  sections: ProfileCompletionSection[];
};

type UserLike = {
  fullName?: string;
  email?: string;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

function bool(v: any) {
  return !!v;
}

export function getProfileCompletionStatus(user: UserLike | null | undefined): ProfileCompletionStatus {
  const fullName = (user?.fullName || "").trim();
  const email = (user?.email || "").trim();

  const hasBasics = bool(fullName) && bool(email);

  const learnCount = user?.skillsToLearn?.length ?? 0;
  const teachCount = user?.skillsToTeach?.length ?? 0;
  const availabilityCount = user?.availabilitySlots?.length ?? 0;

  const hasLearn = learnCount > 0;
  const hasTeach = teachCount > 0;
  const hasAvailability = availabilityCount > 0;

  const sections: ProfileCompletionSection[] = [
    {
      key: "basics",
      title: "Profile basics",
      done: hasBasics,
      hint: hasBasics ? "Looks good." : "Add your name + email to finish the basics.",
      ctaLabel: hasBasics ? "View" : "Fix basics",
      // لو عندك شاشة بروفايل لاحقاً غيّر الرابط
      href: "/settings",
    },
    {
      key: "learn",
      title: "Skills to learn",
      done: hasLearn,
      hint: hasLearn
        ? `You have ${learnCount} learning goal${learnCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you want to learn (improves matching).",
      ctaLabel: hasLearn ? "Manage" : "Add skills",
      href: "/manage-skills-to-learn",
    },
    {
      key: "teach",
      title: "Skills to teach",
      done: hasTeach,
      hint: hasTeach
        ? `You can teach ${teachCount} skill${teachCount === 1 ? "" : "s"}.`
        : "Add at least 1 skill you can teach (unlocks more matches).",
      ctaLabel: hasTeach ? "Manage" : "Add skills",
      href: "/manage-skills-to-teach",
    },
    {
      key: "availability",
      title: "Weekly availability",
      done: hasAvailability,
      hint: hasAvailability
        ? `You have ${availabilityCount} time slot${availabilityCount === 1 ? "" : "s"} set.`
        : "Set 1–2 time slots so mentors can align with you.",
      ctaLabel: hasAvailability ? "Edit" : "Set now",
      href: "/weekly-availability",
    },
  ];

  const totalCount = sections.length;
  const doneCount = sections.filter((s) => s.done).length;

  // ✅ وزن متساوي وبسيط
  const percent = clamp(Math.round((doneCount / totalCount) * 100), 0, 100);
  const isComplete = doneCount === totalCount;

  return { percent, isComplete, doneCount, totalCount, sections };
}
</file>

<file path="lib/sectionStatus.ts">
// lib/sectionStatus.ts
import AsyncStorage from "@react-native-async-storage/async-storage";

const STORAGE_KEY = "sectionStatus_v1";

export type SectionStatus = {
  weeklyAvailabilityLastSavedAt: number | null;
  learnHasPendingSync: boolean;
  teachHasPendingSync: boolean;
  updatedAt: number;
};

function safeJsonParse<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

export function makeDefaultSectionStatus(
  overrides: Partial<SectionStatus> = {}
): SectionStatus {
  const now = Date.now();
  const next: SectionStatus = {
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: now,
    ...overrides,
  };

  if (!(typeof next.updatedAt === "number" && Number.isFinite(next.updatedAt))) {
    next.updatedAt = now;
  }
  return next;
}

export function normalizeSectionStatus(input: unknown): SectionStatus {
  const obj = (input ?? {}) as Partial<SectionStatus>;

  const weeklyAvailabilityLastSavedAt =
    typeof obj.weeklyAvailabilityLastSavedAt === "number" &&
    Number.isFinite(obj.weeklyAvailabilityLastSavedAt)
      ? obj.weeklyAvailabilityLastSavedAt
      : null;

  const learnHasPendingSync = obj.learnHasPendingSync === true;
  const teachHasPendingSync = obj.teachHasPendingSync === true;

  const updatedAt =
    typeof obj.updatedAt === "number" && Number.isFinite(obj.updatedAt)
      ? obj.updatedAt
      : Date.now();

  return {
    weeklyAvailabilityLastSavedAt,
    learnHasPendingSync,
    teachHasPendingSync,
    updatedAt,
  };
}

export async function readSectionStatus(): Promise<SectionStatus> {
  const raw = await AsyncStorage.getItem(STORAGE_KEY);
  const parsed = safeJsonParse<SectionStatus>(raw);
  if (!parsed) return makeDefaultSectionStatus();
  return normalizeSectionStatus(parsed);
}

export async function writeSectionStatus(next: SectionStatus): Promise<void> {
  const normalized = normalizeSectionStatus(next);
  await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));
}

export async function patchSectionStatus(
  patch: Partial<Omit<SectionStatus, "updatedAt">>
): Promise<SectionStatus> {
  const current = await readSectionStatus();
  const next: SectionStatus = { ...current, ...patch, updatedAt: Date.now() };
  await writeSectionStatus(next);
  return next;
}

export function formatTimeAgo(
  timestampMs: number,
  nowMs: number = Date.now()
): string {
  const diffMs = Math.max(0, nowMs - timestampMs);
  const min = Math.floor(diffMs / 60000);

  if (min < 1) return "Just now";
  if (min < 60) return `${min}m ago`;

  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}h ago`;

  const day = Math.floor(hr / 24);
  if (day < 7) return `${day}d ago`;

  const week = Math.floor(day / 7);
  if (week < 5) return `${week}w ago`;

  const month = Math.floor(day / 30);
  if (month < 12) return `${month}mo ago`;

  const year = Math.floor(day / 365);
  return `${year}y ago`;
}
</file>

<file path="app/(tabs)/explore.tsx">
import React from "react";
import { StyleSheet, Text, View } from "react-native";

export default function ExploreScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Explore</Text>
      <Text style={styles.subtitle}>Coming soon...</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#0f172a",
  },
  title: {
    fontSize: 28,
    fontWeight: "bold",
    color: "#e5e7eb",
  },
  subtitle: {
    marginTop: 8,
    fontSize: 16,
    color: "#9ca3af",
  },
});
</file>

<file path="app/index.tsx">
import { Redirect } from "expo-router";

export default function Page() {
  return <Redirect href="/(tabs)" />;
}
</file>

<file path="app/mentor/[id].tsx">
// app/mentor/[id].tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useLocalSearchParams, useRouter } from "expo-router";
import { getOrCreateConversation } from "../../lib/chat/api";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import {
  AvailabilitySlot,
  PublicUserProfile,
  SkillTeach,
  getPublicUserProfile,
} from "../../lib/api";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = String(name).trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function ratingText(avg?: number, count?: number) {
  const a = typeof avg === "number" ? avg : 0;
  const c = typeof count === "number" ? count : 0;
  if (c <= 0) return "No ratings yet";
  return `${a.toFixed(1)}/5 · ${c} rating${c === 1 ? "" : "s"}`;
}

function safeArrayStrings(v: any): string[] {
  if (!Array.isArray(v)) return [];
  return v.map((x) => String(x || "").trim()).filter(Boolean);
}

type MentorVM = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

function toMentorVM(p: PublicUserProfile): MentorVM {
  return {
    id: String(p.id),
    fullName: p.fullName || "Unknown",
    points: Number(p.points || 0),
    xp: Number(p.xp || 0),
    streak: Number(p.streak || 0),
    avgRating: Number(p.avgRating || 0),
    ratingCount: Number(p.ratingCount || 0),
    skillsToTeach: Array.isArray(p.skillsToTeach)
      ? p.skillsToTeach
          .filter((s) => s && s.name)
          .map((s) => ({
            name: String(s.name).trim(),
            level: String(s.level || "Not specified").trim() || "Not specified",
          }))
      : [],
    availabilitySlots: Array.isArray(p.availabilitySlots)
      ? p.availabilitySlots
          .filter(
            (a) =>
              a &&
              typeof a.dayOfWeek === "number" &&
              a.dayOfWeek >= 0 &&
              a.dayOfWeek <= 6 &&
              a.from &&
              a.to
          )
          .map((a) => ({
            dayOfWeek: Number(a.dayOfWeek),
            from: String(a.from),
            to: String(a.to),
          }))
      : [],
    preferences: p.preferences,
  };
}

export default function MentorProfileScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();

  const mentorIdRaw = params?.id;
  const mentorId =
    typeof mentorIdRaw === "string"
      ? mentorIdRaw
      : Array.isArray(mentorIdRaw)
      ? mentorIdRaw[0]
      : "";

  const [mentor, setMentor] = useState<MentorVM | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorText, setErrorText] = useState<string | null>(null);
  const [reloadKey, setReloadKey] = useState(0);

  const loadMentor = useCallback(async () => {
    try {
      setErrorText(null);
      setLoading(true);

      if (!mentorId) {
        setErrorText("Invalid mentor id.");
        return;
      }

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const profile = await getPublicUserProfile(token, mentorId);
      setMentor(toMentorVM(profile));
    } catch (e: any) {
      setErrorText(e?.message || "Failed to load mentor profile.");
    } finally {
      setLoading(false);
    }
  }, [mentorId, router]);

  useEffect(() => {
    loadMentor();
  }, [loadMentor, reloadKey]);

  const skills = useMemo(
    () => mentor?.skillsToTeach ?? [],
    [mentor?.skillsToTeach]
  );

  const slots = useMemo(
    () =>
      (mentor?.availabilitySlots ?? [])
        .slice()
        .sort((a, b) => a.dayOfWeek - b.dayOfWeek),
    [mentor?.availabilitySlots]
  );

  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);

  const bestDay = useMemo(() => {
    if (!slots.length) return null;
    const minutesByDay = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;
      minutesByDay[d] += Math.max(
        0,
        timeToMinutes(s.to) - timeToMinutes(s.from)
      );
    }

    let bestIdx = -1;
    let bestMin = 0;
    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }
    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]} · ${minutesToHuman(bestMin)}`;
  }, [slots]);

  const languages = safeArrayStrings(mentor?.preferences?.languages);
  const commModes = safeArrayStrings(mentor?.preferences?.communicationModes);

  const goBack = () => router.back();

  const handleRequestSession = () => {
    if (!mentor) return;

    router.push({
      pathname: "/sessions/request",
      params: {
        mentorId: mentor.id,
        mentorName: mentor.fullName,
      },
    } as any);
  };

  const handleMessage = async () => {
    try {
      if (!mentor?.id) return;

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const conversationId = await getOrCreateConversation(token, mentor.id);

      // ✅ هذا السطر هو الحل
      if (!conversationId || typeof conversationId !== "string") {
        console.warn("Invalid conversationId, aborting chat open");
        return;
      }

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: { conversationId },
      });
    } catch (e: any) {
      console.warn("Open chat failed:", e?.message || e);
    }
  };

  if (loading && !mentor && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading mentor profile…</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <ScrollView style={{ flex: 1 }} contentContainerStyle={styles.container}>
        <View style={styles.topRow}>
          <TouchableOpacity onPress={goBack} activeOpacity={0.85}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>

          <View style={styles.idBadge}>
            <Text style={styles.idBadgeText}>Mentor</Text>
          </View>
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Couldn’t load profile</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryBtn}
              onPress={() => setReloadKey((k) => k + 1)}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={styles.heroCard}>
          <View style={styles.heroRow}>
            <View style={styles.avatar}>
              <Text style={styles.avatarText}>
                {getInitials(mentor?.fullName)}
              </Text>
            </View>

            <View style={{ flex: 1 }}>
              <Text style={styles.heroName}>
                {mentor?.fullName || "Unknown mentor"}
              </Text>
              <Text style={styles.heroMeta}>
                ⭐ {ratingText(mentor?.avgRating, mentor?.ratingCount)}
              </Text>

              <View style={styles.badgesRow}>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>XP</Text>
                  <Text style={styles.badgeValue}>{mentor?.xp ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Points</Text>
                  <Text style={styles.badgeValue}>{mentor?.points ?? 0}</Text>
                </View>
                <View style={styles.badge}>
                  <Text style={styles.badgeLabel}>Streak</Text>
                  <Text style={styles.badgeValue}>{mentor?.streak ?? 0}</Text>
                </View>
              </View>
            </View>
          </View>

          <View style={styles.ctaRow}>
            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaPrimary]}
              onPress={handleRequestSession}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaPrimaryText}>Request session</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.ctaBtn, styles.ctaSecondary]}
              onPress={handleMessage}
              activeOpacity={0.85}
            >
              <Text style={styles.ctaSecondaryText}>Message</Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.ctaNote}>
            (Next step: we’ll connect these buttons to Sessions + Chat)
          </Text>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>What this mentor teaches</Text>
          <Text style={styles.sectionSub}>
            Skills list (clean & fast) — ready for future filters.
          </Text>

          {skills.length ? (
            <View style={styles.skillsWrap}>
              {skills.map((s, idx) => (
                <View key={`${s.name}-${idx}`} style={styles.skillChip}>
                  <Text style={styles.skillChipText}>
                    {s.name}
                    {s.level && s.level !== "Not specified"
                      ? ` · ${s.level}`
                      : ""}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No teaching skills listed</Text>
              <Text style={styles.emptyText}>
                This mentor hasn’t added teaching skills yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Availability</Text>
          <Text style={styles.sectionSub}>
            Total:{" "}
            <Text style={styles.sectionSubStrong}>
              {minutesToHuman(totalMin)}
            </Text>
            {bestDay ? (
              <>
                {"  "}· Best:{" "}
                <Text style={styles.sectionSubStrong}>{bestDay}</Text>
              </>
            ) : null}
          </Text>

          {slots.length ? (
            <View style={styles.availCard}>
              {slots.map((a, idx) => (
                <View
                  key={`${a.dayOfWeek}-${a.from}-${a.to}-${idx}`}
                  style={[
                    styles.availRow,
                    idx !== slots.length - 1 && styles.availRowBorder,
                  ]}
                >
                  <Text style={styles.availDay}>
                    {dayNames[a.dayOfWeek] ?? `Day ${a.dayOfWeek}`}
                  </Text>
                  <Text style={styles.availTime}>
                    {a.from} – {a.to}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No availability set</Text>
              <Text style={styles.emptyText}>
                This mentor didn’t add weekly availability yet.
              </Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Preferences</Text>

          <View style={styles.prefGrid}>
            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Languages</Text>
              <Text style={styles.prefValue}>
                {languages.length ? languages.join(", ") : "Not specified"}
              </Text>
            </View>

            <View style={styles.prefBox}>
              <Text style={styles.prefLabel}>Communication</Text>
              <Text style={styles.prefValue}>
                {commModes.length ? commModes.join(", ") : "Not specified"}
              </Text>
            </View>
          </View>
        </View>

        <View style={styles.footer}>
          <Text style={styles.footerHint}>
            You’re viewing a mentor profile (not yours) ✅
          </Text>
          <TouchableOpacity
            onPress={goBack}
            style={styles.footerBtn}
            activeOpacity={0.85}
          >
            <Text style={styles.footerBtnText}>Back to results</Text>
          </TouchableOpacity>
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  container: { paddingHorizontal: 16, paddingTop: 16, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 10, color: "#9CA3AF", fontSize: 14 },

  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  backText: { fontSize: 14, color: "#60A5FA" },
  idBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#0B1120",
  },
  idBadgeText: { color: "#CBD5F5", fontSize: 12, fontWeight: "600" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 12,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "700",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 10 },
  retryBtn: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "600" },

  heroCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 16,
  },
  heroRow: { flexDirection: "row", alignItems: "center" },

  avatar: {
    width: 56,
    height: 56,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 12,
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "800" },

  heroName: { color: "#F9FAFB", fontSize: 20, fontWeight: "800" },
  heroMeta: { color: "#9CA3AF", fontSize: 12, marginTop: 4 },

  badgesRow: { flexDirection: "row", gap: 8, marginTop: 10 },
  badge: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 12,
    paddingVertical: 10,
    paddingHorizontal: 10,
    borderWidth: 1,
    borderColor: "#111827",
  },
  badgeLabel: { color: "#94A3B8", fontSize: 11 },
  badgeValue: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "800",
    marginTop: 4,
  },

  ctaRow: { flexDirection: "row", gap: 10, marginTop: 12 },
  ctaBtn: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
  },
  ctaPrimary: { backgroundColor: "#F97316" },
  ctaPrimaryText: { color: "#ffffff", fontWeight: "800", fontSize: 13 },
  ctaSecondary: {
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  ctaSecondaryText: { color: "#E5E7EB", fontWeight: "700", fontSize: 13 },
  ctaNote: { marginTop: 10, color: "#64748B", fontSize: 11 },

  section: { marginBottom: 18 },
  sectionTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "700",
    marginBottom: 4,
  },
  sectionSub: { color: "#94A3B8", fontSize: 12, marginBottom: 10 },
  sectionSubStrong: { color: "#E5E7EB", fontWeight: "800" },

  skillsWrap: { flexDirection: "row", flexWrap: "wrap", gap: 8 },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  skillChipText: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  availCard: {
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    overflow: "hidden",
  },
  availRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  availRowBorder: { borderBottomWidth: 1, borderBottomColor: "#0B1120" },
  availDay: { color: "#E5E7EB", fontSize: 13, fontWeight: "700" },
  availTime: { color: "#9CA3AF", fontSize: 13, fontWeight: "600" },

  prefGrid: { flexDirection: "row", gap: 10 },
  prefBox: {
    flex: 1,
    backgroundColor: "#0B1120",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  prefLabel: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "700",
    marginBottom: 4,
  },
  prefValue: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "800",
    marginBottom: 4,
  },
  emptyText: { color: "#64748B", fontSize: 12 },

  footer: { marginTop: 6 },
  footerHint: { color: "#64748B", fontSize: 11, marginBottom: 10 },
  footerBtn: {
    borderRadius: 999,
    paddingVertical: 11,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  footerBtnText: { color: "#E5E7EB", fontSize: 12, fontWeight: "700" },
});
</file>

<file path="app/sessions/api/sessionsApi.ts">
// app/sessions/api/sessionsApi.ts
import { API_URL } from "../../../lib/api";

export type SessionStatus =
  | "requested"
  | "accepted"
  | "rejected"
  | "cancelled" // UI/internal
  | "completed";

export type SessionDTO = {
  _id: string;
  mentorId: string;
  learnerId: string;
  skill: string;
  level: string;
  scheduledAt: string; // ISO
  status: SessionStatus;
  note?: string;
  rating?: number | null;
  feedback?: string;
  createdAt?: string;
  updatedAt?: string;
};

async function handle(res: Response) {
  const text = await res.text();
  let data: any = null;

  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    const msg =
      (data && (data.error || data.message)) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;
    throw new Error(msg);
  }

  return data;
}

async function fetchWithTimeout(url: string, options: RequestInit, ms = 12000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), ms);

  try {
    const res = await fetch(url, { ...options, signal: controller.signal });
    return res;
  } catch (e: any) {
    if (e?.name === "AbortError") {
      throw new Error("Request timed out. Check API_URL / server.");
    }
    throw e;
  } finally {
    clearTimeout(id);
  }
}

// ✅ UI -> API spelling (backend usually uses "canceled")
function statusForApi(status: SessionStatus) {
  return status === "cancelled" ? "canceled" : status;
}

// ✅ API -> UI spelling
function statusFromApi(status: any): SessionStatus {
  if (status === "canceled") return "cancelled";
  return status as SessionStatus;
}

function normalizeSessionFromApi(s: any): SessionDTO {
  return {
    ...s,
    status: statusFromApi(s?.status),
  } as SessionDTO;
}

export async function listMySessions(
  token: string,
  params?: {
    role?: "mentor" | "learner" | "any";
    scope?: "upcoming" | "past" | "all";
    statuses?: SessionStatus[];
  }
): Promise<SessionDTO[]> {
  const q = new URLSearchParams();
  if (params?.role) q.set("role", params.role);
  if (params?.scope) q.set("scope", params.scope);
  if (params?.statuses?.length) {
    q.set("statuses", params.statuses.map(statusForApi).join(","));
  }

  const url = `${API_URL}/api/sessions/mine${
    q.toString() ? `?${q.toString()}` : ""
  }`;

  const res = await fetchWithTimeout(
    url,
    {
      method: "GET",
      headers: { Authorization: `Bearer ${token}` },
    },
    12000
  );

  const data = await handle(res);
  const arr = Array.isArray(data?.sessions) ? data.sessions : Array.isArray(data) ? data : [];
  return arr.map(normalizeSessionFromApi);
}

export async function requestSession(
  token: string,
  body: {
    mentorId: string;
    skill: string;
    level?: string;
    scheduledAt: string;
    note?: string;
  }
): Promise<SessionDTO> {
  const res = await fetchWithTimeout(
    `${API_URL}/api/sessions`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(body),
    },
    12000
  );

  const data = await handle(res);
  const s = data?.session ?? data;
  return normalizeSessionFromApi(s);
}

export async function updateSessionStatus(
  token: string,
  sessionId: string,
  status: SessionStatus
): Promise<SessionDTO> {
  // ✅ log صح (جوا الفنكشن) لو بدك
  // console.log("[sessions] update status", sessionId, "=>", status);

  const res = await fetchWithTimeout(
    `${API_URL}/api/sessions/${sessionId}/status`,
    {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ status: statusForApi(status) }),
    },
    12000
  );

  const data = await handle(res);
  const s = data?.session ?? data;
  return normalizeSessionFromApi(s);
}

export async function rateSession(
  token: string,
  sessionId: string,
  body: { rating: number; feedback?: string }
): Promise<SessionDTO> {
  const res = await fetchWithTimeout(
    `${API_URL}/api/sessions/${sessionId}/rate`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(body),
    },
    12000
  );

  const data = await handle(res);
  const s = data?.session ?? data;
  return normalizeSessionFromApi(s);
}
</file>

<file path="app/sessions/index.tsx">
import SessionsScreen from "./screens/SessionsScreen";

export default SessionsScreen;
</file>

<file path="app/sessions/request.tsx">
// app/sessions/request.tsx
import RequestSessionScreen from "./screens/request/RequestSessionScreen";

export default function Request() {
  return <RequestSessionScreen />;
}
</file>

<file path="app/sessions/screens/SessionsScreen.tsx">
import { useRouter } from "expo-router";
import React, { useCallback, useMemo, useState } from "react";
import {
  ActivityIndicator,
  FlatList,
  RefreshControl,
  Text,
  View,
} from "react-native";

import type { SessionDTO } from "../api/sessionsApi";
import SessionsHeader from "./(components)/SessionsHeader";
import { useRowRenderer } from "./(components)/SessionsRowRenderer";
import {
  buildGroupedRows,
  filterSessionsByStatus,
  type Row,
  type StatusFilter,
} from "./(components)/SessionsRows";
import { useSessionsData, type Scope } from "./(hooks)/useSessionsData";

function normalize(s: any) {
  return String(s || "")
    .toLowerCase()
    .trim();
}

function sessionMatchesQuery(s: SessionDTO, q: string) {
  const query = normalize(q);
  if (!query) return true;

  const hay = [s.skill, s.level, s.status, s.note, s.feedback, s.scheduledAt]
    .map((x) => normalize(x))
    .join(" | ");

  return hay.includes(query);
}

export default function SessionsScreen() {
  const router = useRouter();

  const [scope, setScope] = useState<Scope>("upcoming");
  const [statusFilter, setStatusFilter] = useState<StatusFilter>("all");
  const [query, setQuery] = useState("");

  const {
    token,
    currentUserId,
    sessions,
    loading,
    loadingList,
    refreshing,
    errorText,
    load,
    onRefresh,
  } = useSessionsData(scope);

  // 1) search filter (NEW ✅)
  const searchedSessions = useMemo(() => {
    const q = query.trim();
    if (!q) return sessions;
    return (Array.isArray(sessions) ? sessions : []).filter((s) =>
      sessionMatchesQuery(s, q)
    );
  }, [sessions, query]);

  // 2) status filter (existing ✅)
  const filteredSessions = useMemo(
    () => filterSessionsByStatus(searchedSessions, statusFilter),
    [searchedSessions, statusFilter]
  );

  // 3) grouped rows (existing ✅)
  const rows = useMemo<Row[]>(
    () => buildGroupedRows(filteredSessions),
    [filteredSessions]
  );

  const empty = useMemo(
    () => !loading && !errorText && filteredSessions.length === 0,
    [loading, errorText, filteredSessions.length]
  );

  const onChanged = useCallback(async () => {
    await load({ silent: true, listOnly: true });
  }, [load]);

  const renderRow = useRowRenderer({
    token,
    currentUserId,
    onChanged,
  });

  const keyExtractor = useCallback((r: Row) => r.key, []);

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: "#020617",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>
          Loading sessions…
        </Text>
      </View>
    );
  }

  if (empty && !errorText) {
    const msg =
      scope === "upcoming"
        ? "No upcoming sessions yet."
        : scope === "past"
        ? "No past sessions yet."
        : "No sessions yet.";

    const hint = query.trim()
      ? "Try clearing search or changing filters."
      : statusFilter !== "all"
      ? `Try switching the status filter (currently: ${statusFilter}).`
      : "When you request a session from a mentor, it’ll show up here.";

    return (
      <View style={{ flex: 1, backgroundColor: "#020617" }}>
        <SessionsHeader
          scope={scope}
          setScope={setScope}
          statusFilter={statusFilter}
          setStatusFilter={setStatusFilter}
          sessions={sessions}
          filteredCount={filteredSessions.length}
          loadingList={loadingList}
          errorText={errorText}
          onRetry={() => load({ silent: true, listOnly: true })}
          query={query}
          setQuery={setQuery}
          // ✅ safest: route موجود عندك حسب الكود السابق
          onFindMentor={() => router.push("/find-mentor" as any)}
          // ✅ خليها اختياري… إذا عندك روت جاهز مررّه
          // onRequestSession={() => router.push("/sessions/request" as any)}
        />

        <View style={{ paddingHorizontal: 16, paddingTop: 12 }}>
          <View
            style={{
              backgroundColor: "#0B1120",
              borderWidth: 1,
              borderColor: "#1E293B",
              borderRadius: 14,
              padding: 14,
            }}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>{msg}</Text>
            <Text style={{ color: "#94A3B8", marginTop: 6 }}>{hint}</Text>

            <View style={{ height: 12 }} />

            <View style={{ borderRadius: 999, overflow: "hidden" }}>
              <Text
                onPress={() => router.push("/find-mentor" as any)}
                style={{
                  textAlign: "center",
                  paddingVertical: 10,
                  backgroundColor: "#F97316",
                  borderWidth: 1,
                  borderColor: "#FB923C",
                  color: "#111827",
                  fontWeight: "900",
                }}
              >
                Find a mentor
              </Text>
            </View>
          </View>
        </View>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, backgroundColor: "#020617" }}>
      <FlatList
        data={rows}
        keyExtractor={keyExtractor}
        renderItem={renderRow}
        ListHeaderComponent={
          <SessionsHeader
            scope={scope}
            setScope={setScope}
            statusFilter={statusFilter}
            setStatusFilter={setStatusFilter}
            sessions={sessions}
            filteredCount={filteredSessions.length}
            loadingList={loadingList}
            errorText={errorText}
            onRetry={() => load({ silent: true, listOnly: true })}
            query={query}
            setQuery={setQuery}
            onFindMentor={() => router.push("/find-mentor" as any)}
            // onRequestSession={() => router.push("/sessions/request" as any)}
          />
        }
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
          />
        }
        contentContainerStyle={{ paddingBottom: 20 }}
        keyboardShouldPersistTaps="handled"
      />
    </View>
  );
}
</file>

<file path="app/weekly-availability/components.tsx">
// app/weekly-availability/components.tsx
import React, { useMemo } from "react";
import { Text, TouchableOpacity, View } from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { styles } from "./styles";

type DaySelectorProps = {
  selectedDay: number;
  onSelect: (dayIndex: number) => void;
  onLongPressDay?: (dayIndex: number) => void;
  dayNames: string[]; // ["Sun".."Sat"]
  todayIndex: number;
};

export const DaySelector: React.FC<DaySelectorProps> = ({
  selectedDay,
  onSelect,
  onLongPressDay,
  dayNames,
  todayIndex,
}) => {
  return (
    <View style={styles.daySelectorRow}>
      {dayNames.map((d, idx) => {
        const isSelected = idx === selectedDay;
        const isToday = idx === todayIndex;

        return (
          <TouchableOpacity
            key={`${d}-${idx}`}
            style={[
              styles.dayChip,
              isToday && styles.dayChipToday,
              isSelected && styles.dayChipSelected,
            ]}
            onPress={() => onSelect(idx)}
            onLongPress={() => onLongPressDay?.(idx)}
            delayLongPress={250}
            activeOpacity={0.85}
            accessibilityRole="button"
            accessibilityLabel={`Select ${d}`}
          >
            <Text
              style={[
                styles.dayChipText,
                isToday && styles.dayChipTextToday,
                isSelected && styles.dayChipTextSelected,
              ]}
            >
              {d}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

// ====================== Day Card ======================

type DayAvailabilityCardProps = {
  dayIndex: number;
  dayLabel: string;
  slots: AvailabilitySlot[];
  totalMinutesForDay: number;

  collapsed: boolean;
  onToggleCollapsed: (dayIndex: number) => void;

  onRemoveSlot: (slot: AvailabilitySlot) => void;
  onEditSlot: (slot: AvailabilitySlot) => void;
  onClearDay: (dayIndex: number) => void;

  onCopyDay: (dayIndex: number) => void;

  onQuickAdd?: (dayIndex: number, from: string, to: string) => void;

  highlightSlotKey?: string | null; // `${from}-${to}`
};

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

export const DayAvailabilityCard: React.FC<DayAvailabilityCardProps> = ({
  dayIndex,
  dayLabel,
  slots,
  totalMinutesForDay,
  collapsed,
  onToggleCollapsed,
  onRemoveSlot,
  onEditSlot,
  onClearDay,
  onCopyDay,
  onQuickAdd,
  highlightSlotKey,
}) => {
  const dayHasSlots = slots.length > 0;

  const daySub = useMemo(() => {
    if (!dayHasSlots) return "No slots yet";
    return `${slots.length} slot${
      slots.length === 1 ? "" : "s"
    } · ${minutesToHuman(totalMinutesForDay)}`;
  }, [dayHasSlots, slots.length, totalMinutesForDay]);

  const showQuickForEmpty = !dayHasSlots;

  return (
    <View style={styles.dayCard}>
      {/* Header */}
      <View style={styles.dayHeaderRow}>
        <TouchableOpacity
          onPress={() => onToggleCollapsed(dayIndex)}
          activeOpacity={0.85}
          style={{ flex: 1 }}
          accessibilityRole="button"
          accessibilityLabel={`Toggle ${dayLabel}`}
        >
          <Text style={styles.dayName}>
            {dayLabel}{" "}
            <Text style={{ color: "#64748B", fontSize: 12, fontWeight: "900" }}>
              {collapsed ? "▸" : "▾"}
            </Text>
          </Text>
          <Text style={styles.daySubText}>{daySub}</Text>
        </TouchableOpacity>

        <View style={styles.dayHeaderActions}>
          {dayHasSlots ? (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          ) : (
            <>
              <TouchableOpacity
                onPress={() => onCopyDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.copyDayText}>Copy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={() => onClearDay(dayIndex)}
                activeOpacity={0.85}
                accessibilityRole="button"
              >
                <Text style={styles.clearDayText}>Clear</Text>
              </TouchableOpacity>
            </>
          )}
        </View>
      </View>

      {/* Body */}
      {collapsed ? (
        <Text style={styles.daySlotsEmptyText}>
          {dayHasSlots ? "Collapsed" : "Collapsed (empty)"}
        </Text>
      ) : (
        <>
          {/* Empty state quick actions */}
          {showQuickForEmpty && onQuickAdd && (
            <View style={{ marginTop: 6 }}>
              <Text style={styles.daySlotsEmptyText}>
                Add something quick to get started:
              </Text>

              <View style={styles.quickRow}>
                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "18:00", "20:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>18:00–20:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "20:00", "22:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>20:00–22:00</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.quickChip}
                  onPress={() => onQuickAdd(dayIndex, "10:00", "14:00")}
                  activeOpacity={0.85}
                >
                  <Text style={styles.quickChipText}>10:00–14:00</Text>
                </TouchableOpacity>
              </View>
            </View>
          )}

          {/* Slots */}
          {dayHasSlots ? (
            <View style={[styles.slotChipRow, { marginTop: 10 }]}>
              {slots.map((slot, idx) => {
                const key = `${slot.from}-${slot.to}`;
                const isHighlight = highlightSlotKey === key;

                return (
                  <TouchableOpacity
                    key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                    style={[
                      styles.slotChip,
                      isHighlight && {
                        borderColor: "#60A5FA",
                        backgroundColor: "#0B1120",
                      },
                    ]}
                    onPress={() => onEditSlot(slot)}
                    activeOpacity={0.85}
                    accessibilityRole="button"
                    accessibilityLabel={`Edit ${slot.from} to ${slot.to}`}
                  >
                    <Text style={styles.slotChipText}>
                      {slot.from} – {slot.to}
                    </Text>

                    <TouchableOpacity
                      onPress={() => onRemoveSlot(slot)}
                      activeOpacity={0.85}
                      accessibilityRole="button"
                      accessibilityLabel={`Remove ${slot.from} to ${slot.to}`}
                    >
                      <Text style={styles.slotRemoveText}>Remove</Text>
                    </TouchableOpacity>
                  </TouchableOpacity>
                );
              })}
            </View>
          ) : (
            !onQuickAdd && (
              <Text style={[styles.daySlotsEmptyText, { marginTop: 6 }]}>
                No slots.
              </Text>
            )
          )}
        </>
      )}
    </View>
  );
};

// ====================== SaveBar ======================

type SaveBarProps = {
  hasChanges: boolean;
  saving: boolean;
  onSave: () => void;
  onDiscard: () => void;
};

export const SaveBar: React.FC<SaveBarProps> = ({
  hasChanges,
  saving,
  onSave,
  onDiscard,
}) => {
  if (!hasChanges) return null;

  return (
    <View style={styles.saveBarSticky}>
      <View style={styles.saveRow}>
        <Text style={styles.saveHint}>
          You have unsaved changes. Save to update your profile.
        </Text>

        <TouchableOpacity
          style={styles.discardButton}
          onPress={onDiscard}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.discardText}>Discard</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.saveButton, saving && styles.saveButtonDisabled]}
          onPress={onSave}
          activeOpacity={0.85}
          disabled={saving}
        >
          <Text style={styles.saveText}>{saving ? "Saving…" : "Save"}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};
</file>

<file path="app/weekly-availability/index.tsx">
// app/weekly-availability/index.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Pressable,
  ScrollView,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import type { AvailabilitySlot } from "../../lib/api";
import { getMe, updateProfile } from "../../lib/api";
import {
  getPendingWeeklyAvailability,
  getWeeklyLastSavedAt,
  markWeeklyAvailabilitySynced,
  setPendingWeeklyAvailability,
  clearPendingWeeklyAvailability,
} from "../../lib/availabilityStorage";
import SaveBar from "./SaveBar";
import TimeField from "./TimeField";

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function isValidSlot(s: AvailabilitySlot) {
  return timeToMinutes(s.to) > timeToMinutes(s.from);
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  const diff = Date.now() - ts;
  if (diff < 60_000) return "Just now";
  if (diff < 60 * 60_000) return `${Math.floor(diff / 60_000)}m ago`;
  if (diff < 24 * 60 * 60_000) return `${Math.floor(diff / (60 * 60_000))}h ago`;
  return new Date(ts).toLocaleDateString();
}

function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  // clean + sort for stable comparisons
  const clean = (Array.isArray(slots) ? slots : [])
    .map((s) => ({
      dayOfWeek: Number((s as any)?.dayOfWeek ?? 0),
      from: String((s as any)?.from ?? "18:00"),
      to: String((s as any)?.to ?? "19:00"),
    }))
    .filter((s) => s.dayOfWeek >= 0 && s.dayOfWeek <= 6);

  clean.sort((a, b) => a.dayOfWeek - b.dayOfWeek || timeToMinutes(a.from) - timeToMinutes(b.from));
  return clean;
}

function slotsEqual(a: AvailabilitySlot[], b: AvailabilitySlot[]) {
  const A = normalizeSlots(a);
  const B = normalizeSlots(b);
  if (A.length !== B.length) return false;
  for (let i = 0; i < A.length; i++) {
    if (A[i].dayOfWeek !== B[i].dayOfWeek) return false;
    if (A[i].from !== B[i].from) return false;
    if (A[i].to !== B[i].to) return false;
  }
  return true;
}

export default function WeeklyAvailabilityScreen() {
  const router = useRouter();
  const mountedRef = useRef(true);

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  const [selectedDay, setSelectedDay] = useState<number>(0);

  const [serverSlots, setServerSlots] = useState<AvailabilitySlot[]>([]);
  const [draftSlots, setDraftSlots] = useState<AvailabilitySlot[]>([]);

  const [restorePrompt, setRestorePrompt] = useState<null | {
    updatedAtISO: string;
    slots: AvailabilitySlot[];
  }>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  const lastSavedText = useMemo(() => formatLastUpdated(lastSavedAt), [lastSavedAt]);

  const dirty = useMemo(() => !slotsEqual(serverSlots, draftSlots), [serverSlots, draftSlots]);

  const daySlots = useMemo(
    () => draftSlots.filter((s) => Number(s.dayOfWeek) === Number(selectedDay)),
    [draftSlots, selectedDay]
  );

  useEffect(() => {
    mountedRef.current = true;

    (async () => {
      try {
        setLoading(true);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const [me, pending, ts] = await Promise.all([
          getMe(token),
          getPendingWeeklyAvailability(),
          getWeeklyLastSavedAt(),
        ]);

        const userFromApi: any = (me as any)?.user ?? me;
        const slotsFromApi = normalizeSlots(userFromApi?.availabilitySlots ?? []);

        if (!mountedRef.current) return;

        setServerSlots(slotsFromApi);
        setDraftSlots(slotsFromApi);
        setLastSavedAt(ts);

        if (pending?.slots?.length) {
          const pendingSlots = normalizeSlots(pending.slots);
          // show restore only if it differs from server
          if (!slotsEqual(pendingSlots, slotsFromApi)) {
            setRestorePrompt({
              updatedAtISO: pending.updatedAtISO,
              slots: pendingSlots,
            });
          } else {
            // pending same as server -> cleanup
            await clearPendingWeeklyAvailability();
          }
        }
      } catch (e: any) {
        console.log("weekly availability load error:", e);
        Alert.alert(
          "Couldn’t load availability",
          e?.message || "Please try again."
        );
      } finally {
        if (mountedRef.current) setLoading(false);
      }
    })();

    return () => {
      mountedRef.current = false;
    };
  }, [router]);

  // Auto store pending draft when user changes (simple, safe)
  useEffect(() => {
    if (loading) return;
    if (!dirty) return;
    setPendingWeeklyAvailability(draftSlots, "user-edit");
  }, [draftSlots, dirty, loading]);

  const addSlot = () => {
    setDraftSlots((prev) =>
      normalizeSlots([
        ...prev,
        { dayOfWeek: selectedDay, from: "18:00", to: "19:00" },
      ])
    );
  };

  const updateSlot = (idxInDay: number, patch: Partial<AvailabilitySlot>) => {
    // map daySlots index to actual index in draftSlots
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.map((s) => {
        if (
          Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
          s.from === target.from &&
          s.to === target.to
        ) {
          return { ...s, ...patch };
        }
        return s;
      });
      return normalizeSlots(next);
    });
  };

  const removeSlot = (idxInDay: number) => {
    const target = daySlots[idxInDay];
    if (!target) return;

    setDraftSlots((prev) => {
      const next = prev.filter(
        (s) =>
          !(
            Number(s.dayOfWeek) === Number(target.dayOfWeek) &&
            s.from === target.from &&
            s.to === target.to
          )
      );
      return normalizeSlots(next);
    });
  };

  const restorePending = async () => {
    if (!restorePrompt) return;
    setDraftSlots(restorePrompt.slots);
    setRestorePrompt(null);
  };

  const discardPending = async () => {
    setRestorePrompt(null);
    await clearPendingWeeklyAvailability();
  };

  const discardChanges = () => {
    setDraftSlots(serverSlots);
  };

  const save = async () => {
    const invalid = draftSlots.some((s) => !isValidSlot(s));
    if (invalid) {
      Alert.alert(
        "Fix time slots",
        "Make sure every slot has From earlier than To."
      );
      return;
    }

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      await updateProfile(token, {
        availabilitySlots: normalizeSlots(draftSlots),
      } as any);

      if (!mountedRef.current) return;

      const normalized = normalizeSlots(draftSlots);
      setServerSlots(normalized);
      setDraftSlots(normalized);

      await markWeeklyAvailabilitySynced();
      const ts = await getWeeklyLastSavedAt();
      setLastSavedAt(ts);

      Alert.alert("Saved ✅", "Your weekly availability has been updated.");
    } catch (e: any) {
      console.log("weekly availability save error:", e);
      Alert.alert(
        "Save failed",
        e?.message || "Couldn’t save. Please try again."
      );
    } finally {
      if (mountedRef.current) setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={{ flex: 1, backgroundColor: "#020617", alignItems: "center", justifyContent: "center" }}>
        <ActivityIndicator size="large" />
        <Text style={{ color: "#9CA3AF", marginTop: 12 }}>Loading availability…</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <View style={{ flex: 1 }}>
        <ScrollView
          contentContainerStyle={{ padding: 16, paddingBottom: 110 }}
          keyboardShouldPersistTaps="handled"
        >
          {/* Header */}
          <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
            <TouchableOpacity onPress={() => router.back()} activeOpacity={0.85}>
              <Text style={{ color: "#60A5FA", fontWeight: "900" }}>← Back</Text>
            </TouchableOpacity>

            <Text style={{ color: "#94A3B8", fontSize: 12, fontWeight: "800" }}>
              Last saved: {lastSavedText}
            </Text>
          </View>

          <Text style={{ color: "#F9FAFB", fontSize: 22, fontWeight: "900", marginTop: 10 }}>
            Weekly availability
          </Text>
          <Text style={{ color: "#94A3B8", marginTop: 6, lineHeight: 18, fontSize: 12 }}>
            Add 1–2 time slots (evenings/weekend). Better mentor matches when your schedule is clear.
          </Text>

          {/* Restore pending banner */}
          {restorePrompt && (
            <View
              style={{
                marginTop: 12,
                backgroundColor: "#0B1120",
                borderWidth: 1,
                borderColor: "#1E293B",
                borderRadius: 14,
                padding: 12,
              }}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 13 }}>
                Restore unsaved changes?
              </Text>
              <Text style={{ color: "#94A3B8", fontSize: 12, marginTop: 4, lineHeight: 16 }}>
                Found a previous edit from {new Date(restorePrompt.updatedAtISO).toLocaleString()}.
              </Text>

              <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                <Pressable
                  onPress={restorePending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#22C55E",
                      borderRadius: 999,
                      paddingVertical: 10,
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#022C22", fontWeight: "900" }}>Restore</Text>
                </Pressable>

                <Pressable
                  onPress={discardPending}
                  style={({ pressed }) => [
                    {
                      flex: 1,
                      backgroundColor: "#020617",
                      borderRadius: 999,
                      paddingVertical: 10,
                      borderWidth: 1,
                      borderColor: "#334155",
                      alignItems: "center",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>Discard</Text>
                </Pressable>
              </View>
            </View>
          )}

          {/* Day selector */}
          <View style={{ flexDirection: "row", gap: 8, flexWrap: "wrap", marginTop: 14 }}>
            {dayNames.map((d, idx) => {
              const active = idx === selectedDay;
              return (
                <Pressable
                  key={d}
                  onPress={() => setSelectedDay(idx)}
                  style={({ pressed }) => [
                    {
                      paddingHorizontal: 12,
                      paddingVertical: 8,
                      borderRadius: 999,
                      borderWidth: 1,
                      borderColor: active ? "#F97316" : "#1E293B",
                      backgroundColor: active ? "#0B1120" : "#020617",
                    },
                    pressed ? { opacity: 0.9 } : null,
                  ]}
                >
                  <Text style={{ color: active ? "#FED7AA" : "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                    {d}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          {/* Slots for selected day */}
          <View style={{ marginTop: 14 }}>
            <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
              <Text style={{ color: "#F9FAFB", fontWeight: "900", fontSize: 14 }}>
                {dayNames[selectedDay]} slots
              </Text>

              <TouchableOpacity onPress={addSlot} activeOpacity={0.85}>
                <Text style={{ color: "#60A5FA", fontWeight: "900" }}>+ Add</Text>
              </TouchableOpacity>
            </View>

            {daySlots.length === 0 ? (
              <View
                style={{
                  marginTop: 10,
                  backgroundColor: "#020617",
                  borderWidth: 1,
                  borderColor: "#111827",
                  borderRadius: 14,
                  padding: 12,
                }}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "800" }}>No slots yet</Text>
                <Text style={{ color: "#64748B", marginTop: 4, fontSize: 12, lineHeight: 16 }}>
                  Tap “Add” to create your first slot for this day.
                </Text>
              </View>
            ) : (
              <View style={{ marginTop: 10, gap: 10 }}>
                {daySlots.map((slot, idx) => {
                  const ok = isValidSlot(slot);
                  return (
                    <View
                      key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                      style={{
                        backgroundColor: "#0B1120",
                        borderWidth: 1,
                        borderColor: ok ? "#1E293B" : "#FCA5A5",
                        borderRadius: 14,
                        padding: 12,
                      }}
                    >
                      <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
                        <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                          Slot #{idx + 1} {ok ? "" : " (Fix time)"}
                        </Text>

                        <Pressable
                          onPress={() => removeSlot(idx)}
                          style={({ pressed }) => [
                            {
                              paddingHorizontal: 10,
                              paddingVertical: 6,
                              borderRadius: 999,
                              borderWidth: 1,
                              borderColor: "#334155",
                              backgroundColor: "#020617",
                            },
                            pressed ? { opacity: 0.85 } : null,
                          ]}
                        >
                          <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>Remove</Text>
                        </Pressable>
                      </View>

                      <View style={{ flexDirection: "row", gap: 10, marginTop: 10 }}>
                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            From
                          </Text>
                          <TimeField
                            value={slot.from}
                            onChange={(v: string) => updateSlot(idx, { from: v })}
                          />
                        </View>

                        <View style={{ flex: 1 }}>
                          <Text style={{ color: "#94A3B8", fontSize: 11, fontWeight: "900", marginBottom: 6 }}>
                            To
                          </Text>
                          <TimeField
                            value={slot.to}
                            onChange={(v: string) => updateSlot(idx, { to: v })}
                          />
                        </View>
                      </View>

                      {!ok && (
                        <Text style={{ color: "#FCA5A5", marginTop: 10, fontWeight: "900", fontSize: 12 }}>
                          “To” must be later than “From”.
                        </Text>
                      )}
                    </View>
                  );
                })}
              </View>
            )}
          </View>

          {/* Small reset button (non-intrusive) */}
          {dirty && (
            <Pressable
              onPress={discardChanges}
              style={({ pressed }) => [
                {
                  marginTop: 16,
                  alignSelf: "flex-start",
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  borderRadius: 999,
                  borderWidth: 1,
                  borderColor: "#334155",
                  backgroundColor: "#020617",
                },
                pressed ? { opacity: 0.9 } : null,
              ]}
            >
              <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
                Reset to last saved
              </Text>
            </Pressable>
          )}
        </ScrollView>

        <SaveBar
          visible={dirty}
          saving={saving}
          onSave={save}
          onDiscard={discardChanges}
          lastSavedText={lastSavedText}
        />
      </View>
    </KeyboardAvoidingView>
  );
}
</file>

<file path="app/weekly-availability/TimeField.tsx">
// app/weekly-availability/TimeField.tsx
import React, { useEffect, useState } from "react";
import { Platform, StyleSheet, Text, TextInput, View } from "react-native";

type Props = {
  label?: string;
  value: string;
  onChange: (v: string) => void;
  placeholder?: string;
  disabled?: boolean;
};

function normalizeTimeInput(raw: string): string {
  let s = raw.replace(/[^\d:]/g, "");

  const digitsOnly = s.replace(/:/g, "");
  if (!s.includes(":") && digitsOnly.length >= 3) {
    const hh = digitsOnly.slice(0, 2);
    const mm = digitsOnly.slice(2, 4);
    s = `${hh}:${mm}`;
  }

  if (s.length > 5) s = s.slice(0, 5);

  if (s.includes(":")) {
    const [hhRaw = "", mmRaw = ""] = s.split(":");
    const hh = hhRaw.slice(0, 2);
    const mm = mmRaw.slice(0, 2);
    s = `${hh}:${mm}`;
  }

  return s;
}

function isValidPartialTime(v: string): boolean {
  if (v === "") return true;
  if (!/^\d{0,2}(:\d{0,2})?$/.test(v)) return false;

  const [hhStr, mmStr] = v.split(":");
  if (hhStr.length > 0) {
    const hh = Number(hhStr);
    if (!Number.isFinite(hh) || hh > 23) return false;
  }
  if (mmStr !== undefined && mmStr.length > 0) {
    const mm = Number(mmStr);
    if (!Number.isFinite(mm) || mm > 59) return false;
  }
  return true;
}

export default function TimeField({
  label,
  value,
  onChange,
  placeholder = "HH:MM",
  disabled = false,
}: Props) {
  const [local, setLocal] = useState<string>(value ?? "");

  // ✅ الصحيح: side-effect -> useEffect
  useEffect(() => {
    setLocal(value ?? "");
  }, [value]);

  const onTextChange = (txt: string) => {
    const normalized = normalizeTimeInput(txt);
    if (!isValidPartialTime(normalized)) return;

    setLocal(normalized);
    onChange(normalized);
  };

  return (
    <View style={styles.wrap}>
      {label ? <Text style={styles.label}>{label}</Text> : null}

      <TextInput
        value={local}
        onChangeText={onTextChange}
        placeholder={placeholder}
        editable={!disabled}
        keyboardType={Platform.select({
          ios: "numbers-and-punctuation",
          android: "numeric",
          default: "numeric",
        })}
        style={[styles.input, disabled && styles.inputDisabled]}
        placeholderTextColor="#64748B"
        maxLength={5}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    width: "100%",
  },
  label: {
    color: "#94A3B8",
    fontSize: 11,
    fontWeight: "900",
    marginBottom: 6,
  },
  input: {
    borderWidth: 1,
    borderColor: "#1F2937",
    backgroundColor: "#0B1220",
    color: "#E5E7EB",
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 12,
    fontSize: 14,
    fontWeight: "700",
  },
  inputDisabled: {
    opacity: 0.6,
  },
});
</file>

<file path="app/weekly-availability/useWeeklyAvailability.ts">
// app/weekly-availability/useWeeklyAvailability.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  AvailabilitySlot,
  getMe,
  updateWeeklyAvailability,
} from "../../lib/api";

/**
 * Local key for "last saved" timestamp (used by Home + Weekly Availability)
 */
const WEEKLY_AVAIL_LAST_SAVED_KEY = "weeklyAvailability_lastSavedAt_v1";

/**
 * Sort slots by day, then time
 */
export function sortAvailability(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return [...slots].sort((a, b) => {
    if (a.dayOfWeek !== b.dayOfWeek) return a.dayOfWeek - b.dayOfWeek;
    return a.from.localeCompare(b.from);
  });
}

/**
 * Normalize + validate slots coming from API or UI
 */
function normalizeSlots(slots: AvailabilitySlot[]): AvailabilitySlot[] {
  return sortAvailability(
    (Array.isArray(slots) ? slots : [])
      .filter(
        (s) =>
          typeof s?.dayOfWeek === "number" &&
          s.dayOfWeek >= 0 &&
          s.dayOfWeek <= 6 &&
          typeof s?.from === "string" &&
          typeof s?.to === "string" &&
          s.from.trim() &&
          s.to.trim()
      )
      .map((s) => ({
        dayOfWeek: s.dayOfWeek,
        from: s.from.trim(),
        to: s.to.trim(),
      }))
  );
}

/**
 * Stable deep-equality key
 */
function slotsKey(slots: AvailabilitySlot[]): string {
  return normalizeSlots(slots)
    .map((s) => `${s.dayOfWeek}|${s.from}|${s.to}`)
    .join(";");
}

async function readLastSavedAt(): Promise<number | null> {
  try {
    const raw = await AsyncStorage.getItem(WEEKLY_AVAIL_LAST_SAVED_KEY);
    if (!raw) return null;
    const n = Number(raw);
    return Number.isFinite(n) ? n : null;
  } catch {
    return null;
  }
}

async function writeLastSavedAt(ts: number): Promise<void> {
  try {
    await AsyncStorage.setItem(WEEKLY_AVAIL_LAST_SAVED_KEY, String(ts));
  } catch {
    // ignore
  }
}

export type UserProfile = {
  _id: string;
  fullName: string;
  email: string;
  availabilitySlots?: AvailabilitySlot[];
  skillsToLearn?: any[];
  skillsToTeach?: any[];
};

type UseWeeklyAvailabilityResult = {
  user: UserProfile | null;
  availability: AvailabilitySlot[];
  loading: boolean;
  saving: boolean;
  errorText: string | null;
  hasChanges: boolean;
  lastSavedAt: number | null;

  reload: () => Promise<void>;
  save: () => Promise<boolean>;

  updateAvailability: (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => void;

  setErrorText: (t: string | null) => void;
};

export function useWeeklyAvailability(): UseWeeklyAvailabilityResult {
  const router = useRouter();

  const [user, setUser] = useState<UserProfile | null>(null);
  const [availability, setAvailability] = useState<AvailabilitySlot[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [lastSavedAt, setLastSavedAt] = useState<number | null>(null);

  /**
   * Baseline snapshot to detect unsaved changes
   */
  const baselineKeyRef = useRef<string>("");

  const hasChanges = useMemo(() => {
    return slotsKey(availability) !== baselineKeyRef.current;
  }, [availability]);

  /**
   * Load profile + availability
   */
  const reload = useCallback(async () => {
    try {
      setLoading(true);
      setErrorText(null);

      // load lastSavedAt (fast + local)
      const savedTs = await readLastSavedAt();
      setLastSavedAt(savedTs);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        // ✅ keep consistent with your auth group routes
        router.replace("/(auth)/login" as any);
        return;
      }

      const data = (await getMe(token)) as UserProfile;
      const normalized = normalizeSlots(data.availabilitySlots || []);

      setUser(data);
      setAvailability(normalized);
      baselineKeyRef.current = slotsKey(normalized);

      // If user already has availability from backend but no local timestamp yet,
      // set a helpful baseline timestamp once (not critical, but improves UX).
      if (!savedTs && normalized.length > 0) {
        const now = Date.now();
        setLastSavedAt(now);
        await writeLastSavedAt(now);
      }
    } catch (err: any) {
      console.log("weekly-availability / load error:", err);
      setErrorText(
        err?.message || "We couldn’t load your availability. Please try again."
      );
    } finally {
      setLoading(false);
    }
  }, [router]);

  useEffect(() => {
    reload();
  }, [reload]);

  /**
   * Safe updater wrapper (always normalizes)
   */
  const updateAvailability = (
    updater: (prev: AvailabilitySlot[]) => AvailabilitySlot[]
  ) => {
    setAvailability((prev) => normalizeSlots(updater(prev)));
  };

  /**
   * Save changes to backend
   */
  const save = useCallback(async () => {
    // ✅ prevents double taps + saves only when needed
    if (saving || !hasChanges) return false;

    try {
      setSaving(true);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return false;
      }

      const normalized = normalizeSlots(availability);

      const updated = (await updateWeeklyAvailability(
        token,
        normalized
      )) as UserProfile;

      const updatedNormalized = normalizeSlots(updated.availabilitySlots || []);

      setUser(updated);
      setAvailability(updatedNormalized);
      baselineKeyRef.current = slotsKey(updatedNormalized);

      // ✅ write "last saved" timestamp for Home + other screens
      const now = Date.now();
      setLastSavedAt(now);
      await writeLastSavedAt(now);

      return true;
    } catch (err: any) {
      console.log("weekly-availability / save error:", err);
      setErrorText(
        err?.message || "Something went wrong while saving your availability."
      );
      return false;
    } finally {
      setSaving(false);
    }
  }, [availability, hasChanges, router, saving]);

  return {
    user,
    availability,
    loading,
    saving,
    errorText,
    hasChanges,
    lastSavedAt,

    reload,
    save,
    updateAvailability,
    setErrorText,
  };
}
</file>

<file path="app/(tabs)/_layout.tsx">
import { Tabs } from "expo-router";
import { Text } from "react-native";

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarStyle: {
          backgroundColor: "#020617",
          borderTopColor: "#0B1120",
        },
        tabBarActiveTintColor: "#F97316",
        tabBarInactiveTintColor: "#94A3B8",
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}>🏠</Text>
          ),
        }}
      />

      <Tabs.Screen
        name="explore"
        options={{
          title: "Explore",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}>🧭</Text>
          ),
        }}
      />

      <Tabs.Screen
        name="chats"
        options={{
          title: "Chats",
          tabBarIcon: ({ color }) => (
            <Text style={{ color, fontSize: 16 }}>💬</Text>
          ),
        }}
      />
    </Tabs>
  );
}
</file>

<file path="app/(tabs)/index.tsx">
import HomeScreen from "../screens/HomeScreen";

export default function TabHome() {
  return <HomeScreen />;
}
</file>

<file path="app/find-mentor.tsx">
// app/find-mentor.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import React, { useEffect, useMemo, useState } from "react";
import {
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";

import type { MatchingMode } from "../lib/api";
import {
  AvailabilitySlot,
  MentorMatch,
  SkillLearn,
  getMe,
  getMentorMatches,
} from "../lib/api";

// ✅ chat: open conversation directly from results
import { getOrCreateConversation } from "../lib/chat/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points: number;
  xp: number;
  streak: number;
  skillsToLearn?: SkillLearn[];
  availabilitySlots?: AvailabilitySlot[];
};

type LevelOption = "Beginner" | "Intermediate" | "Advanced";

const LEVELS: { value: LevelOption; label: string }[] = [
  { value: "Beginner", label: "Beginner" },
  { value: "Intermediate", label: "Intermediate" },
  { value: "Advanced", label: "Advanced" },
];

const MODES: { value: MatchingMode; label: string; hint: string }[] = [
  { value: "local", label: "Local", hint: "Fast, no API key needed" },
  { value: "openai", label: "OpenAI", hint: "Semantic embeddings (needs key)" },
  { value: "hybrid", label: "Hybrid", hint: "OpenAI → fallback to Local" },
];

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

export default function FindMentorScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loadingUser, setLoadingUser] = useState(true);
  const [loadingMatches, setLoadingMatches] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [selectedSkill, setSelectedSkill] = useState<string>("");
  const [customSkill, setCustomSkill] = useState<string>("");
  const [selectedLevel, setSelectedLevel] = useState<LevelOption>("Beginner");
  const [useMyAvailability, setUseMyAvailability] = useState<boolean>(true);
  const [mode, setMode] = useState<MatchingMode>("local");

  const [matches, setMatches] = useState<MentorMatch[]>([]);
  const [hasSearched, setHasSearched] = useState(false);

  // ---- Load current user ----
  useEffect(() => {
    let isMounted = true;

    async function load() {
      try {
        setErrorText(null);

        const token = await AsyncStorage.getItem("token");
        if (!token) {
          router.replace("/(auth)/login" as any);
          return;
        }

        const data = (await getMe(token)) as any;
        const userFromApi: User = (data?.user ?? data) as User;

        if (!isMounted) return;

        setUser(userFromApi);

        const skills = userFromApi.skillsToLearn ?? [];
        if (skills.length > 0 && skills[0]?.name) {
          setSelectedSkill(skills[0].name);
        }
      } catch (err: any) {
        console.log("FindMentor / getMe error:", err);
        if (isMounted) {
          setErrorText(
            err?.message ||
              "We couldn’t load your profile. Please go back and try again."
          );
        }
      } finally {
        if (isMounted) setLoadingUser(false);
      }
    }

    load();
    return () => {
      isMounted = false;
    };
  }, [router]);

  const learningSkills = useMemo(() => {
    const arr = user?.skillsToLearn ?? [];
    return arr
      .map((s) => ({
        name: String(s?.name || "").trim(),
        level: String((s as any)?.level || "Not specified").trim(),
      }))
      .filter((s) => !!s.name);
  }, [user?.skillsToLearn]);

  const availabilitySlots = useMemo(
    () => user?.availabilitySlots ?? [],
    [user?.availabilitySlots]
  );

  const effectiveSkill = useMemo(() => {
    if (customSkill.trim()) return customSkill.trim();
    return selectedSkill.trim();
  }, [customSkill, selectedSkill]);

  const canSearch = !!effectiveSkill && !loadingMatches && !loadingUser;

  const handleSearch = async () => {
    if (!canSearch) return;

    try {
      setErrorText(null);
      setLoadingMatches(true);
      setHasSearched(true);
      setMatches([]);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        router.replace("/(auth)/login" as any);
        return;
      }

      const payload = {
        skill: effectiveSkill,
        level: selectedLevel,
        availabilitySlots: useMyAvailability ? availabilitySlots : [],
        mode,
      };

      const res = await getMentorMatches(token, payload);
      setMatches(res.results ?? []);
    } catch (err: any) {
      console.log("getMentorMatches error:", err);
      setErrorText(
        err?.message ||
          "Something went wrong while searching for mentors. Please try again."
      );
    } finally {
      setLoadingMatches(false);
    }
  };

  const handleBack = () => router.back();

  // ✅ NEW: open mentor profile
  const openMentorProfile = (mentorId: string) => {
    router.push({ pathname: "/mentor/[id]", params: { id: mentorId } } as any);
  };

  // ✅ NEW: open chat directly
  const openMentorChat = async (mentorId: string) => {
    const token = await AsyncStorage.getItem("token");
    if (!token) {
      router.replace("/(auth)/login" as any);
      return;
    }

    const conversationId = await getOrCreateConversation(token, mentorId);

    // ✅ هذا هو الحل
    if (!conversationId || typeof conversationId !== "string") {
      console.warn("Invalid conversationId, aborting navigation");
      return;
    }

    router.push({
      pathname: "/(tabs)/chats/[conversationId]",
      params: { conversationId },
    });
  };

  const requestSession = (m: MentorMatch) => {
    router.push({
      pathname: "/sessions/request",
      params: {
        mentorId: m.mentorId,
        mentorName: m.fullName,
        skill: m.mainMatchedSkill?.name,
        level: m.mainMatchedSkill?.level,
      },
    } as any);
  };

  if (loadingUser && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your profile…</Text>
      </View>
    );
  }

  const noLearningSkills = learningSkills.length === 0;

  return (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#020617" }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.container}
        keyboardShouldPersistTaps="handled"
      >
        {/* Header */}
        <View style={styles.headerRow}>
          <TouchableOpacity onPress={handleBack} activeOpacity={0.85}>
            <Text style={styles.backText}>← Back</Text>
          </TouchableOpacity>
        </View>

        <Text style={styles.title}>Find a mentor</Text>
        <Text style={styles.subtitle}>
          Pick a skill you want help with and we’ll look for people who can
          teach you.
        </Text>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>Something went wrong</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
          </View>
        )}

        {/* 0. Matching mode */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>0. Matching mode</Text>
          <Text style={styles.sectionDescription}>
            Switch matching method with one tap (no code changes).
          </Text>

          <View style={styles.levelRow}>
            {MODES.map((opt) => {
              const active = mode === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setMode(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>

          <Text style={styles.modeHint}>
            Current: <Text style={styles.modeHintStrong}>{mode}</Text> —{" "}
            {MODES.find((m) => m.value === mode)?.hint}
          </Text>
        </View>

        {/* 1. Skill selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>1. Choose a skill</Text>
          <Text style={styles.sectionDescription}>
            Start with one of your learning goals, or type a custom skill.
          </Text>

          {noLearningSkills ? (
            <View style={styles.infoBox}>
              <Text style={styles.infoTitle}>No learning skills found</Text>
              <Text style={styles.infoBody}>
                You don’t have any learning goals yet. Go back to your dashboard
                and add some skills you want to learn.
              </Text>
            </View>
          ) : (
            <>
              <Text style={styles.label}>From your learning list</Text>
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.chipsRow}
              >
                {learningSkills.map((skillObj) => {
                  const active = selectedSkill === skillObj.name;
                  return (
                    <TouchableOpacity
                      key={skillObj.name}
                      onPress={() => setSelectedSkill(skillObj.name)}
                      style={[
                        styles.skillChip,
                        active && styles.skillChipActive,
                      ]}
                      activeOpacity={0.85}
                    >
                      <Text
                        style={[
                          styles.skillChipText,
                          active && styles.skillChipTextActive,
                        ]}
                      >
                        {skillObj.name}
                        {skillObj.level && skillObj.level !== "Not specified"
                          ? ` · ${skillObj.level}`
                          : ""}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </ScrollView>
            </>
          )}

          <Text style={[styles.label, { marginTop: 10 }]}>
            Or type a custom skill
          </Text>
          <TextInput
            style={styles.input}
            placeholder="e.g. React Native, Public speaking"
            placeholderTextColor="#6b7280"
            value={customSkill}
            onChangeText={setCustomSkill}
          />

          <View style={styles.currentSkillBox}>
            <Text style={styles.currentSkillLabel}>Current search skill:</Text>
            <Text style={styles.currentSkillValue}>
              {effectiveSkill || "Not selected yet"}
            </Text>
          </View>
        </View>

        {/* 2. Level selection */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>2. Your level</Text>
          <Text style={styles.sectionDescription}>
            This helps us prioritize mentors who match your current experience.
          </Text>

          <View style={styles.levelRow}>
            {LEVELS.map((opt) => {
              const active = selectedLevel === opt.value;
              return (
                <TouchableOpacity
                  key={opt.value}
                  style={[styles.levelChip, active && styles.levelChipActive]}
                  onPress={() => setSelectedLevel(opt.value)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.levelChipText,
                      active && styles.levelChipTextActive,
                    ]}
                  >
                    {opt.label}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>

        {/* 3. Availability usage */}
        <View style={styles.card}>
          <Text style={styles.sectionTitle}>3. Availability</Text>
          <Text style={styles.sectionDescription}>
            We can use your weekly availability to prioritize mentors who are
            free at similar times.
          </Text>

          <TouchableOpacity
            style={styles.toggleRow}
            onPress={() => setUseMyAvailability((prev) => !prev)}
            activeOpacity={0.85}
          >
            <View
              style={[
                styles.toggleOuter,
                useMyAvailability && styles.toggleOuterOn,
              ]}
            >
              <View
                style={[
                  styles.toggleInner,
                  useMyAvailability && styles.toggleInnerOn,
                ]}
              />
            </View>
            <Text style={styles.toggleLabel}>
              Use my weekly availability from dashboard
            </Text>
          </TouchableOpacity>

          {useMyAvailability && availabilitySlots.length > 0 && (
            <View style={styles.availabilityPreview}>
              {availabilitySlots.slice(0, 3).map((slot, idx) => (
                <Text key={idx} style={styles.availabilityLine}>
                  {dayNames[slot.dayOfWeek] ?? `Day ${slot.dayOfWeek}`}:{" "}
                  {slot.from} – {slot.to}
                </Text>
              ))}
              {availabilitySlots.length > 3 && (
                <Text style={styles.availabilityMore}>
                  + {availabilitySlots.length - 3} more…
                </Text>
              )}
            </View>
          )}

          {useMyAvailability && availabilitySlots.length === 0 && (
            <Text style={styles.noAvailabilityText}>
              You don’t have any availability set yet. You can still search for
              mentors, but results won’t be filtered by time.
            </Text>
          )}
        </View>

        {/* Search button */}
        <TouchableOpacity
          style={[
            styles.searchButton,
            (!canSearch || loadingMatches) && styles.searchButtonDisabled,
          ]}
          onPress={handleSearch}
          disabled={!canSearch}
          activeOpacity={0.85}
        >
          {loadingMatches ? (
            <ActivityIndicator color="#ffffff" />
          ) : (
            <Text style={styles.searchButtonText}>Search for mentors</Text>
          )}
        </TouchableOpacity>

        {/* Results */}
        <View style={styles.resultsSection}>
          <Text style={styles.resultsTitle}>Results</Text>

          {!hasSearched && (
            <Text style={styles.resultsHint}>
              Start by selecting a skill and tapping “Search for mentors”.
            </Text>
          )}

          {hasSearched && !loadingMatches && matches.length === 0 && (
            <Text style={styles.resultsHint}>
              No mentors found yet for this skill. Try another skill or relax
              your filters.
            </Text>
          )}

          {matches.map((m) => (
            <TouchableOpacity
              key={m.mentorId}
              activeOpacity={0.92}
              onPress={() => openMentorProfile(m.mentorId)}
              style={styles.matchCardClickable}
            >
              <View style={styles.matchHeaderRow}>
                <Text style={styles.matchName}>{m.fullName}</Text>
                <Text style={styles.matchScore}>
                  {Math.round(m.matchScore * 100)}%
                </Text>
              </View>

              {m.mainMatchedSkill && (
                <Text style={styles.matchSkillLine}>
                  Best match:{" "}
                  <Text style={styles.matchSkillHighlight}>
                    {m.mainMatchedSkill.name} ({m.mainMatchedSkill.level})
                  </Text>{" "}
                  · similarity{" "}
                  {Math.round(m.mainMatchedSkill.similarityScore * 100)}%
                </Text>
              )}

              {m.skillsToTeach && m.skillsToTeach.length > 0 && (
                <View style={styles.matchSkillsList}>
                  <Text style={styles.matchSkillsLabel}>Teaches:</Text>
                  <Text style={styles.matchSkillsValue}>
                    {m.skillsToTeach
                      .slice(0, 3)
                      .map((s) => s.name)
                      .join(", ")}
                    {m.skillsToTeach.length > 3
                      ? ` +${m.skillsToTeach.length - 3} more`
                      : ""}
                  </Text>
                </View>
              )}

              {m.availabilitySlots && m.availabilitySlots.length > 0 && (
                <Text style={styles.matchAvailability}>
                  Example availability:{" "}
                  {dayNames[m.availabilitySlots[0].dayOfWeek] ??
                    `Day ${m.availabilitySlots[0].dayOfWeek}`}{" "}
                  · {m.availabilitySlots[0].from} – {m.availabilitySlots[0].to}
                </Text>
              )}

              {/* actions */}
              <View style={styles.actionsRow}>
                <TouchableOpacity
                  style={[styles.actionBtn, styles.actionSecondary]}
                  activeOpacity={0.85}
                  onPress={() => openMentorProfile(m.mentorId)}
                >
                  <Text style={styles.actionSecondaryText}>View profile</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.actionBtn, styles.actionPrimary]}
                  activeOpacity={0.85}
                  onPress={() => openMentorChat(m.mentorId)}
                >
                  <Text style={styles.actionPrimaryText}>Message</Text>
                </TouchableOpacity>
              </View>

              <TouchableOpacity
                style={styles.matchActionButton}
                activeOpacity={0.85}
                onPress={() => requestSession(m)}
              >
                <Text style={styles.matchActionText}>Request session</Text>
              </TouchableOpacity>

              <Text style={styles.tapHint}>
                Tip: tap anywhere on this card to open profile
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        <View style={{ height: 24 }} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 14,
  },
  container: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 32,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  backText: {
    fontSize: 14,
    color: "#60A5FA",
  },
  title: {
    fontSize: 22,
    fontWeight: "700",
    color: "#F9FAFB",
    marginTop: 4,
  },
  subtitle: {
    fontSize: 13,
    color: "#9CA3AF",
    marginTop: 4,
    marginBottom: 14,
  },
  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 14,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: {
    color: "#FECACA",
    fontSize: 12,
  },
  card: {
    backgroundColor: "#020617",
    borderRadius: 16,
    padding: 14,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 14,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    color: "#F9FAFB",
    marginBottom: 4,
  },
  sectionDescription: {
    fontSize: 12,
    color: "#94A3B8",
    marginBottom: 10,
  },
  label: {
    fontSize: 12,
    color: "#CBD5F5",
    marginBottom: 4,
  },
  chipsRow: {
    flexDirection: "row",
    gap: 8,
    paddingVertical: 4,
  },
  skillChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
  },
  skillChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  skillChipText: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  skillChipTextActive: {
    color: "#F9FAFB",
    fontWeight: "600",
  },
  input: {
    marginTop: 2,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: "#4b5563",
    backgroundColor: "#020617",
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 13,
    color: "#f9fafb",
  },
  currentSkillBox: {
    marginTop: 10,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  currentSkillLabel: {
    color: "#94A3B8",
    fontSize: 11,
    marginBottom: 2,
  },
  currentSkillValue: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "500",
  },
  infoBox: {
    marginTop: 4,
    marginBottom: 8,
    padding: 10,
    borderRadius: 10,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  infoTitle: {
    color: "#F9FAFB",
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 2,
  },
  infoBody: {
    color: "#9CA3AF",
    fontSize: 12,
  },
  levelRow: {
    flexDirection: "row",
    gap: 8,
    marginTop: 6,
  },
  levelChip: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#1E293B",
    backgroundColor: "#020617",
    alignItems: "center",
  },
  levelChipActive: {
    backgroundColor: "#1D4ED8",
    borderColor: "#1D4ED8",
  },
  levelChipText: {
    color: "#E5E7EB",
    fontSize: 13,
  },
  levelChipTextActive: {
    fontWeight: "600",
  },
  toggleRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
  },
  toggleOuter: {
    width: 38,
    height: 22,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#6B7280",
    padding: 2,
    justifyContent: "center",
  },
  toggleOuterOn: {
    borderColor: "#22C55E",
    backgroundColor: "#022C22",
  },
  toggleInner: {
    width: 16,
    height: 16,
    borderRadius: 999,
    backgroundColor: "#6B7280",
    alignSelf: "flex-start",
  },
  toggleInnerOn: {
    backgroundColor: "#22C55E",
    alignSelf: "flex-end",
  },
  toggleLabel: {
    marginLeft: 8,
    color: "#CBD5F5",
    fontSize: 12,
    flex: 1,
  },
  availabilityPreview: {
    marginTop: 8,
    padding: 8,
    borderRadius: 8,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#111827",
  },
  availabilityLine: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  availabilityMore: {
    color: "#9CA3AF",
    fontSize: 11,
    marginTop: 4,
  },
  noAvailabilityText: {
    marginTop: 8,
    color: "#9CA3AF",
    fontSize: 12,
  },
  searchButton: {
    marginTop: 4,
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  searchButtonDisabled: {
    opacity: 0.7,
  },
  searchButtonText: {
    color: "#ffffff",
    fontWeight: "600",
    fontSize: 15,
  },
  resultsSection: {
    marginTop: 18,
  },
  resultsTitle: {
    color: "#F9FAFB",
    fontSize: 16,
    fontWeight: "600",
    marginBottom: 4,
  },
  resultsHint: {
    color: "#9CA3AF",
    fontSize: 12,
  },

  // ✅ clickable card
  matchCardClickable: {
    marginTop: 10,
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#1E293B",
  },

  matchHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 4,
  },
  matchName: {
    color: "#F9FAFB",
    fontSize: 15,
    fontWeight: "600",
  },
  matchScore: {
    color: "#F97316",
    fontSize: 14,
    fontWeight: "700",
  },
  matchSkillLine: {
    color: "#CBD5F5",
    fontSize: 12,
    marginTop: 4,
  },
  matchSkillHighlight: {
    color: "#FDE68A",
    fontWeight: "600",
  },
  matchSkillsList: {
    marginTop: 6,
  },
  matchSkillsLabel: {
    color: "#94A3B8",
    fontSize: 11,
  },
  matchSkillsValue: {
    color: "#E5E7EB",
    fontSize: 12,
  },
  matchAvailability: {
    marginTop: 6,
    color: "#9CA3AF",
    fontSize: 11,
  },

  actionsRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 10,
  },
  actionBtn: {
    flex: 1,
    borderRadius: 999,
    paddingVertical: 9,
    alignItems: "center",
  },
  actionPrimary: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
  },
  actionPrimaryText: {
    color: "#111827",
    fontSize: 12,
    fontWeight: "800",
  },
  actionSecondary: {
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  actionSecondaryText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  matchActionButton: {
    marginTop: 10,
    borderRadius: 999,
    paddingVertical: 9,
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#4B5563",
    backgroundColor: "#020617",
  },
  matchActionText: {
    color: "#E5E7EB",
    fontSize: 12,
    fontWeight: "700",
  },

  tapHint: {
    marginTop: 8,
    color: "#64748B",
    fontSize: 11,
  },

  modeHint: {
    marginTop: 10,
    color: "#9CA3AF",
    fontSize: 12,
  },
  modeHintStrong: {
    color: "#F9FAFB",
    fontWeight: "700",
  },
});
</file>

<file path="app/login.tsx">
export { default } from "./(auth)/login";
</file>

<file path="app/sessions/components/SessionCard.tsx">
// app/sessions/components/SessionCard.tsx
import { useRouter } from "expo-router";
import React, { useMemo, useState } from "react";
import {
  ActivityIndicator,
  Alert,
  Linking,
  Modal,
  Pressable,
  Share,
  Text,
  TextInput,
  View,
} from "react-native";

import type { SessionDTO, SessionStatus } from "../api/sessionsApi";
import { rateSession, updateSessionStatus } from "../api/sessionsApi";
import { formatSessionDateTime, statusBadge } from "../utils/formatSession";

// ✅ Chat (get/create conversation)
import { getOrCreateConversation } from "../../../lib/chat/api";

type Props = {
  session: SessionDTO;
  token: string | null;
  currentUserId: string | null;
  onChanged: () => Promise<void>;
};

function clampInt(v: number, min: number, max: number) {
  const n = Math.floor(v);
  if (!Number.isFinite(n)) return min;
  return Math.max(min, Math.min(max, n));
}

function toMs(iso?: string | null) {
  if (!iso) return null;
  const d = new Date(iso);
  const t = d.getTime();
  if (Number.isNaN(t)) return null;
  return t;
}

function isTimeReached(iso: string) {
  const t = toMs(iso);
  if (!t) return false;
  return t <= Date.now();
}

function prettyStatus(s: SessionStatus) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function pad2(n: number) {
  return String(n).padStart(2, "0");
}

function countdownLabel(scheduledAtIso?: string | null) {
  const t = toMs(scheduledAtIso);
  if (!t) return null;

  const now = Date.now();
  const diff = t - now;

  const abs = Math.abs(diff);
  const mins = Math.floor(abs / 60000);
  const hrs = Math.floor(mins / 60);
  const days = Math.floor(hrs / 24);

  const mLeft = mins % 60;
  const hLeft = hrs % 24;

  const fmt =
    days > 0
      ? `${days}d ${pad2(hLeft)}h`
      : hrs > 0
      ? `${hrs}h ${pad2(mLeft)}m`
      : `${Math.max(0, mins)}m`;

  if (diff > 0) return { kind: "upcoming" as const, text: `Starts in ${fmt}` };
  if (diff <= 0 && abs <= 2 * 60 * 60 * 1000)
    return { kind: "now" as const, text: `Started` };
  return { kind: "past" as const, text: `Ended` };
}

function buildGoogleCalendarUrl(opts: {
  title: string;
  startIso: string;
  details?: string;
  location?: string;
}) {
  // Google Calendar needs YYYYMMDDTHHMMSSZ format (UTC)
  const toGCal = (iso: string) => {
    const d = new Date(iso);
    const t = d.getTime();
    if (Number.isNaN(t)) return null;
    // toISOString => 2026-01-01T12:00:00.000Z
    return d.toISOString().replace(/[-:]/g, "").replace(".000Z", "Z");
  };

  const start = toGCal(opts.startIso);
  if (!start) return null;

  // assume 60 minutes duration (safe default)
  const endDate = new Date(new Date(opts.startIso).getTime() + 60 * 60 * 1000);
  const end = endDate.toISOString().replace(/[-:]/g, "").replace(".000Z", "Z");

  const q = new URLSearchParams();
  q.set("action", "TEMPLATE");
  q.set("text", opts.title);
  q.set("dates", `${start}/${end}`);
  if (opts.details) q.set("details", opts.details);
  if (opts.location) q.set("location", opts.location);

  return `https://calendar.google.com/calendar/render?${q.toString()}`;
}

// ✅ IMPORTANT: normalize ids to strings (prevents [object Object] issues)
function extractId(v: any) {
  if (!v) return "";
  if (typeof v === "string") return v.trim();
  if (typeof v === "object") return String(v?._id ?? v?.id ?? "").trim();
  return String(v).trim();
}

function safeText(v: any) {
  if (v === null || v === undefined) return "";
  if (typeof v === "string") return v;
  try {
    if (typeof v === "object") {
      const id = extractId(v);
      if (id) return id;
      return JSON.stringify(v);
    }
    return String(v);
  } catch {
    return String(v);
  }
}

export default function SessionCard({
  session,
  token,
  currentUserId,
  onChanged,
}: Props) {
  const router = useRouter();

  const [busy, setBusy] = useState(false);

  const [rateOpen, setRateOpen] = useState(false);
  const [rating, setRating] = useState<number>(5);
  const [feedback, setFeedback] = useState<string>("");

  const [detailsOpen, setDetailsOpen] = useState(false);

  const badge = useMemo(() => statusBadge(session.status), [session.status]);
  const when = useMemo(
    () => formatSessionDateTime(session.scheduledAt),
    [session.scheduledAt]
  );

  // ✅ FIX: compare normalized ids (session.mentorId might be object from API)
  const mentorIdStr = useMemo(
    () => extractId((session as any).mentorId),
    [session]
  );
  const learnerIdStr = useMemo(
    () => extractId((session as any).learnerId),
    [session]
  );

  const isMentor = !!currentUserId && currentUserId === mentorIdStr;
  const isLearner = !!currentUserId && currentUserId === learnerIdStr;

  const peerId = useMemo(() => {
    if (!currentUserId) return "";
    return isMentor ? learnerIdStr : mentorIdStr;
  }, [currentUserId, isMentor, learnerIdStr, mentorIdStr]);

  const timeReached = useMemo(
    () => isTimeReached(session.scheduledAt),
    [session.scheduledAt]
  );

  const timeBadge = useMemo(
    () => countdownLabel(session.scheduledAt),
    [session.scheduledAt]
  );

  // ✅ Rules
  const canAcceptReject = isMentor && session.status === "requested";
  const canCancel =
    (isMentor || isLearner) &&
    (session.status === "requested" || session.status === "accepted");

  // ✅ Complete فقط بعد وقت الجلسة
  const canComplete = isMentor && session.status === "accepted" && timeReached;

  // ✅ Rating بعد completion + غير مكرر
  const canRate =
    (isMentor || isLearner) &&
    session.status === "completed" &&
    !session.rating;

  const canMessage = (isMentor || isLearner) && !!token && !!currentUserId;

  const roleLabel = useMemo(() => {
    if (isMentor) return "You are the mentor";
    if (isLearner) return "You are the learner";
    return "Session";
  }, [isLearner, isMentor]);

  const handleShare = async () => {
    try {
      const txt =
        `Session\n` +
        `Skill: ${session.skill}${
          session.level ? ` · ${session.level}` : ""
        }\n` +
        `When: ${when}\n` +
        `Status: ${session.status}\n` +
        (session.note ? `Note: ${session.note}\n` : "") +
        `Session ID: ${session._id}`;

      await Share.share({ message: txt });
    } catch {
      /* silent */
    }
  };

  const handleAddToCalendar = async () => {
    const title = `SkillBridge • ${session.skill}${
      session.level ? ` (${session.level})` : ""
    }`;

    const details =
      `Status: ${session.status}\n` +
      (session.note ? `Note: ${session.note}\n` : "") +
      `Session ID: ${session._id}`;

    const url = buildGoogleCalendarUrl({
      title,
      startIso: session.scheduledAt,
      details,
    });

    if (!url) {
      Alert.alert("Calendar", "Could not generate calendar event (bad date).");
      return;
    }

    try {
      const ok = await Linking.canOpenURL(url);
      if (!ok) {
        Alert.alert("Calendar", "Could not open calendar on this device.");
        return;
      }
      await Linking.openURL(url);
    } catch {
      Alert.alert("Calendar", "Failed to open calendar. Please try again.");
    }
  };

  const handleMessage = async () => {
    try {
      if (!token || !currentUserId) {
        Alert.alert("Not logged in", "Please login again.");
        return;
      }

      if (!peerId) {
        Alert.alert("Chat unavailable", "Could not find the other user.");
        return;
      }

      setBusy(true);

      const conversationId = await getOrCreateConversation(token, peerId);

      if (!conversationId) {
        Alert.alert("Chat failed", "Could not create a conversation.");
        return;
      }

      router.push({
        pathname: "/(tabs)/chats/[conversationId]",
        params: {
          conversationId,
          peerId,
        },
      } as any);
    } catch (e: any) {
      Alert.alert("Chat failed", e?.message || "Please try again.");
    } finally {
      setBusy(false);
    }
  };

  const setStatus = async (next: SessionStatus) => {
    if (!token) {
      Alert.alert("Not logged in", "Please login again.");
      return;
    }

    const title =
      next === "cancelled"
        ? "Cancel session?"
        : next === "rejected"
        ? "Reject request?"
        : `${prettyStatus(next)}?`;

    const body =
      next === "cancelled"
        ? "This will cancel the session for both sides."
        : next === "rejected"
        ? "This will reject the learner request."
        : `Are you sure you want to set this session to "${next}"?`;

    Alert.alert(title, body, [
      { text: "No", style: "cancel" },
      {
        text: "Yes",
        style:
          next === "rejected" || next === "cancelled"
            ? "destructive"
            : "default",
        onPress: async () => {
          try {
            setBusy(true);
            await updateSessionStatus(token, session._id, next);
            await onChanged();
          } catch (e: any) {
            Alert.alert("Update failed", e?.message || "Please try again.");
          } finally {
            setBusy(false);
          }
        },
      },
    ]);
  };

  const submitRating = async () => {
    if (!token) {
      Alert.alert("Not logged in", "Please login again.");
      return;
    }

    try {
      setBusy(true);
      await rateSession(token, session._id, {
        rating: clampInt(rating, 1, 5),
        feedback: feedback.trim(),
      });
      setRateOpen(false);
      setFeedback("");
      setRating(5);
      await onChanged();
      Alert.alert("Thanks ✅", "Your rating was submitted.");
    } catch (e: any) {
      Alert.alert("Rating failed", e?.message || "Please try again.");
    } finally {
      setBusy(false);
    }
  };

  const explainCompleteLocked = () => {
    Alert.alert(
      "Complete is locked",
      "You can complete the session only after the scheduled time is reached."
    );
  };

  return (
    <View
      style={{
        backgroundColor: "#0B1120",
        borderWidth: 1,
        borderColor: "#1E293B",
        borderRadius: 14,
        padding: 12,
      }}
    >
      {/* Header */}
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
          gap: 10,
        }}
      >
        <View style={{ flex: 1 }}>
          <Text style={{ color: "#F9FAFB", fontWeight: "900", fontSize: 14 }}>
            {session.skill} {session.level ? `· ${session.level}` : ""}
          </Text>

          <View style={{ flexDirection: "row", gap: 10, marginTop: 4 }}>
            <Text
              style={{
                color: "#64748B",
                fontSize: 11,
                fontWeight: "800",
              }}
            >
              {roleLabel}
            </Text>

            {timeBadge ? (
              <Text
                style={{
                  color:
                    timeBadge.kind === "upcoming"
                      ? "#93C5FD"
                      : timeBadge.kind === "now"
                      ? "#FDE68A"
                      : "#94A3B8",
                  fontSize: 11,
                  fontWeight: "900",
                }}
              >
                • {timeBadge.text}
              </Text>
            ) : null}
          </View>
        </View>

        <View
          style={{
            paddingHorizontal: 10,
            paddingVertical: 6,
            borderRadius: 999,
            backgroundColor: badge.bg,
            borderWidth: 1,
            borderColor: badge.border,
          }}
        >
          <Text style={{ color: badge.text, fontWeight: "900", fontSize: 12 }}>
            {badge.label}
          </Text>
        </View>
      </View>

      <Text style={{ color: "#94A3B8", marginTop: 10, fontSize: 12 }}>
        Scheduled: {when}
      </Text>

      {!!session.note && (
        <Text style={{ color: "#CBD5E1", marginTop: 6, fontSize: 12 }}>
          Note: {session.note}
        </Text>
      )}

      {/* Rating summary (if already rated) */}
      {session.status === "completed" && session.rating ? (
        <View style={{ marginTop: 10 }}>
          <Text style={{ color: "#FDE68A", fontWeight: "900", fontSize: 12 }}>
            Rated: {"⭐".repeat(Math.max(1, Math.min(5, session.rating)))} (
            {session.rating}/5)
          </Text>
          {!!session.feedback && (
            <Text style={{ color: "#94A3B8", marginTop: 4, fontSize: 12 }}>
              Feedback: {session.feedback}
            </Text>
          )}
        </View>
      ) : null}

      {/* Top quick actions */}
      <View
        style={{
          flexDirection: "row",
          flexWrap: "wrap",
          gap: 8,
          marginTop: 12,
        }}
      >
        <ActionBtn
          label={detailsOpen ? "Hide details" : "Details"}
          kind="neutral"
          disabled={busy}
          onPress={() => setDetailsOpen((v) => !v)}
        />

        <ActionBtn
          label="Calendar"
          kind="neutral"
          disabled={busy}
          onPress={handleAddToCalendar}
        />

        <ActionBtn
          label="Share"
          kind="neutral"
          disabled={busy}
          onPress={handleShare}
        />
      </View>

      {/* Details */}
      {detailsOpen ? (
        <View
          style={{
            marginTop: 12,
            padding: 12,
            borderRadius: 12,
            borderWidth: 1,
            borderColor: "#111827",
            backgroundColor: "#020617",
            gap: 10,
          }}
        >
          <DetailRow k="Status" v={prettyStatus(session.status)} />
          <DetailRow k="When" v={safeText(when)} />
          {!!peerId && <DetailRow k="Peer ID" v={safeText(peerId)} />}
          <DetailRow k="Mentor ID" v={safeText(mentorIdStr)} />
          <DetailRow k="Learner ID" v={safeText(learnerIdStr)} />
          <DetailRow k="Session ID" v={safeText(session._id)} />
          {!!session.createdAt && (
            <DetailRow
              k="Created"
              v={formatSessionDateTime(session.createdAt)}
            />
          )}
          {!!session.updatedAt && (
            <DetailRow
              k="Updated"
              v={formatSessionDateTime(session.updatedAt)}
            />
          )}
        </View>
      ) : null}

      {/* Actions */}
      <View
        style={{
          flexDirection: "row",
          flexWrap: "wrap",
          gap: 8,
          marginTop: 12,
        }}
      >
        {busy ? (
          <View style={{ flexDirection: "row", alignItems: "center", gap: 8 }}>
            <ActivityIndicator />
            <Text style={{ color: "#94A3B8", fontWeight: "900" }}>
              Working…
            </Text>
          </View>
        ) : null}

        {canMessage && (
          <ActionBtn
            label="Message"
            kind="neutral"
            disabled={busy}
            onPress={handleMessage}
          />
        )}

        {canAcceptReject && (
          <>
            <ActionBtn
              label="Accept"
              kind="good"
              disabled={busy}
              onPress={() => setStatus("accepted")}
            />
            <ActionBtn
              label="Reject"
              kind="bad"
              disabled={busy}
              onPress={() => setStatus("rejected")}
            />
          </>
        )}

        {canCancel && (
          <ActionBtn
            label="Cancel"
            kind="neutral"
            disabled={busy}
            onPress={() => setStatus("cancelled")}
          />
        )}

        {/* ✅ Complete disabled (practical) */}
        {isMentor && session.status === "accepted" && !timeReached ? (
          <ActionBtn
            label="Complete (after time)"
            kind="neutral"
            disabled={busy}
            onPress={explainCompleteLocked}
          />
        ) : null}

        {canComplete && (
          <ActionBtn
            label="Complete"
            kind="primary"
            disabled={busy}
            onPress={() => setStatus("completed")}
          />
        )}

        {canRate && (
          <ActionBtn
            label="Rate session"
            kind="primary"
            disabled={busy}
            onPress={() => setRateOpen(true)}
          />
        )}
      </View>

      {/* Rate Modal */}
      <Modal
        visible={rateOpen}
        transparent
        animationType="fade"
        onRequestClose={() => setRateOpen(false)}
      >
        <View
          style={{
            flex: 1,
            backgroundColor: "rgba(0,0,0,0.55)",
            justifyContent: "center",
            padding: 16,
          }}
        >
          <View
            style={{
              backgroundColor: "#0B1120",
              borderRadius: 16,
              borderWidth: 1,
              borderColor: "#1E293B",
              padding: 14,
            }}
          >
            <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 16 }}>
              Rate this session
            </Text>

            <Text style={{ color: "#94A3B8", marginTop: 6, fontSize: 12 }}>
              Give a quick rating and optional feedback.
            </Text>

            <View
              style={{
                flexDirection: "row",
                gap: 8,
                marginTop: 12,
                flexWrap: "wrap",
              }}
            >
              {[1, 2, 3, 4, 5].map((n) => {
                const active = n <= rating;
                return (
                  <Pressable
                    key={n}
                    onPress={() => setRating(n)}
                    style={({ pressed }) => [
                      {
                        paddingHorizontal: 10,
                        paddingVertical: 10,
                        borderRadius: 12,
                        borderWidth: 1,
                        borderColor: active ? "#F97316" : "#334155",
                        backgroundColor: active ? "#111827" : "#020617",
                      },
                      pressed ? { opacity: 0.9 } : null,
                    ]}
                  >
                    <Text
                      style={{
                        color: active ? "#FED7AA" : "#94A3B8",
                        fontWeight: "900",
                      }}
                    >
                      ⭐ {n}
                    </Text>
                  </Pressable>
                );
              })}
            </View>

            <TextInput
              value={feedback}
              onChangeText={setFeedback}
              placeholder="Optional feedback…"
              placeholderTextColor="#64748B"
              multiline
              style={{
                marginTop: 12,
                minHeight: 90,
                borderRadius: 12,
                borderWidth: 1,
                borderColor: "#1F2937",
                backgroundColor: "#020617",
                color: "#E5E7EB",
                paddingHorizontal: 12,
                paddingVertical: 10,
                textAlignVertical: "top",
                fontWeight: "700",
              }}
            />

            <View style={{ flexDirection: "row", gap: 10, marginTop: 12 }}>
              <Pressable
                onPress={() => setRateOpen(false)}
                disabled={busy}
                style={({ pressed }) => [
                  {
                    flex: 1,
                    borderRadius: 999,
                    paddingVertical: 12,
                    alignItems: "center",
                    borderWidth: 1,
                    borderColor: "#334155",
                    backgroundColor: "#020617",
                    opacity: busy ? 0.7 : 1,
                  },
                  pressed ? { opacity: 0.9 } : null,
                ]}
              >
                <Text style={{ color: "#E5E7EB", fontWeight: "900" }}>
                  Cancel
                </Text>
              </Pressable>

              <Pressable
                onPress={submitRating}
                disabled={busy}
                style={({ pressed }) => [
                  {
                    flex: 1,
                    borderRadius: 999,
                    paddingVertical: 12,
                    alignItems: "center",
                    borderWidth: 1,
                    borderColor: "#FB923C",
                    backgroundColor: "#F97316",
                    opacity: busy ? 0.7 : 1,
                  },
                  pressed ? { opacity: 0.92 } : null,
                ]}
              >
                <Text style={{ color: "#111827", fontWeight: "900" }}>
                  {busy ? "Submitting…" : "Submit"}
                </Text>
              </Pressable>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

function DetailRow({ k, v }: { k: string; v: string }) {
  return (
    <View style={{ gap: 4 }}>
      <Text style={{ color: "#94A3B8", fontWeight: "800", fontSize: 12 }}>
        {k}
      </Text>
      <Text style={{ color: "#E5E7EB", fontWeight: "900", fontSize: 12 }}>
        {v || "—"}
      </Text>
    </View>
  );
}

function ActionBtn({
  label,
  onPress,
  kind,
  disabled,
}: {
  label: string;
  onPress: () => void;
  kind: "primary" | "good" | "bad" | "neutral";
  disabled?: boolean;
}) {
  const styleByKind =
    kind === "good"
      ? { bg: "#22C55E", text: "#022C22", border: "#16A34A" }
      : kind === "bad"
      ? { bg: "#B91C1C", text: "#FEE2E2", border: "#EF4444" }
      : kind === "primary"
      ? { bg: "#F97316", text: "#111827", border: "#FB923C" }
      : { bg: "#020617", text: "#E5E7EB", border: "#334155" };

  return (
    <Pressable
      onPress={onPress}
      disabled={!!disabled}
      style={({ pressed }) => [
        {
          paddingHorizontal: 12,
          paddingVertical: 10,
          borderRadius: 999,
          borderWidth: 1,
          borderColor: styleByKind.border,
          backgroundColor: styleByKind.bg,
          opacity: disabled ? 0.6 : 1,
        },
        pressed && !disabled ? { opacity: 0.9 } : null,
      ]}
    >
      <Text
        style={{ color: styleByKind.text, fontWeight: "900", fontSize: 12 }}
      >
        {label}
      </Text>
    </Pressable>
  );
}
</file>

<file path="app/signup.tsx">

</file>

<file path="app/screens/HomeScreen.tsx">
// app/screens/homescreen.tsx
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useFocusEffect, useRouter } from "expo-router";
import React, { useCallback, useMemo, useRef, useState } from "react";
import {
  ActivityIndicator,
  RefreshControl,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";

import type { AvailabilitySlot, SkillLearn, SkillTeach } from "../../lib/api";
import { getMe } from "../../lib/api";
import { getProfileCompletionStatus } from "../../lib/profileCompletion";
import {
  formatTimeAgo,
  readSectionStatus,
  SectionStatus,
} from "../../lib/sectionStatus";
import ProfileStatusCard from "./components/ProfileStatusCard";

import {
  getChatInbox,
  getInboxCache,
  setInboxCache,
  type ChatInboxItem,
} from "../../lib/chat/api";

type User = {
  _id: string;
  fullName: string;
  email: string;
  points?: number;
  xp?: number;
  streak?: number;
  skillsToLearn?: SkillLearn[];
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] as const;

function getInitials(name?: string) {
  if (!name) return "?";
  const parts = name.trim().split(/\s+/);
  if (parts.length === 1) return parts[0][0]?.toUpperCase() ?? "?";
  return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
}

function getLevelFromXp(xp?: number) {
  const val = xp ?? 0;
  const level = Math.floor(val / 100);
  const progress = val % 100;
  return { level, progress };
}

function timeToMinutes(t: string) {
  const [h, m] = String(t || "0:0")
    .split(":")
    .map((x) => Number(x));
  return (h || 0) * 60 + (m || 0);
}

function calcTotalMinutes(slots: AvailabilitySlot[]) {
  return slots.reduce((sum, s) => {
    const a = timeToMinutes(s.from);
    const b = timeToMinutes(s.to);
    return sum + Math.max(0, b - a);
  }, 0);
}

function minutesToHuman(totalMin: number): string {
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m}m`;
  if (m === 0) return `${h}h`;
  return `${h}h ${m}m`;
}

function formatLastUpdated(ts: number | null): string {
  if (!ts) return "Not saved yet";
  return formatTimeAgo(ts);
}

function availabilityLabelFromMinutes(min: number) {
  if (min >= 600) return "🟢 Excellent";
  if (min >= 240) return "🟡 Good";
  if (min > 0) return "🔴 Low";
  return "Not set";
}

// ===== Inbox helpers =====
function inboxTime(iso?: string | null) {
  if (!iso) return "";
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleTimeString(undefined, {
    hour: "2-digit",
    minute: "2-digit",
  });
}

function inboxInitials(name?: string) {
  const n = String(name || "").trim();
  if (!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  if (parts.length === 1) return (parts[0][0] || "?").toUpperCase();
  return `${parts[0][0] || ""}${
    parts[parts.length - 1][0] || ""
  }`.toUpperCase();
}

export default function HomeScreen() {
  const router = useRouter();

  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [sectionStatus, setSectionStatus] = useState<SectionStatus>({
    weeklyAvailabilityLastSavedAt: null,
    learnHasPendingSync: false,
    teachHasPendingSync: false,
    updatedAt: Date.now(),
  });

  // ===== Inbox state =====
  const [inbox, setInbox] = useState<ChatInboxItem[]>([]);
  const [inboxLoading, setInboxLoading] = useState(true);

  const mountedRef = useRef(true);

  const goLogin = useCallback(() => {
    router.replace("/(auth)/login" as any);
  }, [router]);

  const loadInbox = useCallback(async (token: string) => {
    try {
      setInboxLoading(true);

      // ✅ fast boot: cache
      const cached = await getInboxCache();
      if (mountedRef.current && cached?.length) {
        setInbox(cached);
        setInboxLoading(false);
      }

      // ✅ fresh fetch
      const list = await getChatInbox(token);
      if (!mountedRef.current) return;

      const sorted = (Array.isArray(list) ? list : []).slice().sort((a, b) => {
        const ta = a.lastMessageAt ? new Date(a.lastMessageAt).getTime() : 0;
        const tb = b.lastMessageAt ? new Date(b.lastMessageAt).getTime() : 0;
        return tb - ta;
      });

      setInbox(sorted);
      void setInboxCache(sorted);
    } catch {
      // silent
    } finally {
      if (mountedRef.current) setInboxLoading(false);
    }
  }, []);

  const loadUser = useCallback(async () => {
    try {
      setErrorText(null);

      // ✅ One place to read cross-section state
      const st = await readSectionStatus();
      if (mountedRef.current) setSectionStatus(st);

      const token = await AsyncStorage.getItem("token");
      if (!token) {
        goLogin();
        return;
      }

      // ✅ load inbox in parallel (no blocking)
      void loadInbox(token);

      const me: any = await getMe(token);
      const userFromApi: User = (me?.user ?? me) as User;

      if (!mountedRef.current) return;
      setUser(userFromApi);
    } catch (err: any) {
      console.log("Home / getMe error:", err);
      if (!mountedRef.current) return;
      setErrorText(
        err?.message || "We couldn’t load your profile. Please pull to refresh."
      );
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setRefreshing(false);
    }
  }, [goLogin, loadInbox]);

  useFocusEffect(
    useCallback(() => {
      mountedRef.current = true;
      loadUser();
      return () => {
        mountedRef.current = false;
      };
    }, [loadUser])
  );

  const onRefresh = () => {
    setRefreshing(true);
    loadUser();
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem("token");
    goLogin();
  };

  const handleFindMentor = () => router.push("/find-mentor" as any);
  const handleGoAvailability = () => router.push("/weekly-availability" as any);
  const handleGoTeach = () => router.push("/manage-skills-to-teach" as any);
  const handleGoLearn = () => router.push("/manage-skills-to-learn" as any);
  const handleGoSessions = () => router.push("/sessions" as any);

  // ✅ HOOKS BEFORE ANY EARLY RETURN
  const profileStatus = useMemo(() => getProfileCompletionStatus(user), [user]);

  const xp = user?.xp ?? 0;
  const points = user?.points ?? 0;
  const streak = user?.streak ?? 0;
  const { level, progress } = getLevelFromXp(xp);

  const slots = user?.availabilitySlots ?? [];
  const totalMin = useMemo(() => calcTotalMinutes(slots), [slots]);
  const daysSet = useMemo(
    () => new Set(slots.map((s) => s.dayOfWeek)).size,
    [slots]
  );
  const qualityLabel = availabilityLabelFromMinutes(totalMin);
  const lastUpdatedText = formatLastUpdated(
    sectionStatus.weeklyAvailabilityLastSavedAt
  );

  const bestDay = useMemo(() => {
    if (!slots.length) return null;

    const minutesByDay: number[] = [0, 0, 0, 0, 0, 0, 0];

    for (const s of slots) {
      const d = Number(s.dayOfWeek);
      if (d < 0 || d > 6) continue;

      const val = Math.max(0, timeToMinutes(s.to) - timeToMinutes(s.from));
      minutesByDay[d] += val;
    }

    let bestIdx = -1;
    let bestMin = 0;

    for (let i = 0; i < 7; i++) {
      if (minutesByDay[i] > bestMin) {
        bestMin = minutesByDay[i];
        bestIdx = i;
      }
    }

    if (bestIdx === -1 || bestMin <= 0) return null;
    return `${dayNames[bestIdx]} · ${minutesToHuman(bestMin)}`;
  }, [slots]);

  // ✅ NOW safe to early return
  if (loading && !user && !errorText) {
    return (
      <View style={styles.loadingScreen}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading your dashboard…</Text>
      </View>
    );
  }

  const pendingChips = [
    sectionStatus.learnHasPendingSync ? "Learn: pending sync" : null,
    sectionStatus.teachHasPendingSync ? "Teach: pending sync" : null,
  ].filter(Boolean) as string[];

  return (
    <View style={styles.root}>
      <ScrollView
        style={styles.scroll}
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor="#F97316"
            colors={["#F97316"]}
          />
        }
      >
        {/* ===== Top hero card ===== */}
        <View style={styles.heroCard}>
          <View style={styles.heroRow}>
            <View style={{ flex: 1 }}>
              <Text style={styles.greeting}>
                {user ? "Welcome back" : "Welcome to SkillSwap"}
              </Text>
              <Text style={styles.name}>
                {user?.fullName || "SkillSwap user"}
              </Text>
              <Text style={styles.tagline}>
                See your progress, grow your skills, and connect with other
                learners.
              </Text>
            </View>

            <View style={styles.avatar}>
              <Text style={styles.avatarText}>
                {getInitials(user?.fullName)}
              </Text>
            </View>
          </View>

          <View style={styles.heroBottomRow}>
            <View style={styles.levelColumn}>
              <Text style={styles.levelLabel}>Level</Text>
              <Text style={styles.levelValue}>{level}</Text>
            </View>

            <View style={styles.progressColumn}>
              <View style={styles.progressHeader}>
                <Text style={styles.progressLabel}>XP progress</Text>
                <Text style={styles.progressValue}>{progress}/100</Text>
              </View>

              <View style={styles.progressBarBackground}>
                <View
                  style={[
                    styles.progressBarFill,
                    { width: `${Math.min(progress, 100)}%` },
                  ]}
                />
              </View>
            </View>

            {streak > 0 && (
              <View style={styles.streakBadge}>
                <Text style={styles.streakEmoji}>🔥</Text>
                <Text style={styles.streakText}>{streak}-day streak</Text>
              </View>
            )}
          </View>

          {pendingChips.length > 0 && (
            <View
              style={{
                flexDirection: "row",
                gap: 8,
                flexWrap: "wrap",
                marginTop: 10,
              }}
            >
              {pendingChips.map((t) => (
                <View key={t} style={styles.pendingChip}>
                  <Text style={styles.pendingChipText}>{t}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        {errorText && (
          <View style={styles.errorBox}>
            <Text style={styles.errorTitle}>We couldn’t refresh your data</Text>
            <Text style={styles.errorBody}>{errorText}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={loadUser}
              activeOpacity={0.85}
            >
              <Text style={styles.retryText}>Try again</Text>
            </TouchableOpacity>
          </View>
        )}

        <ProfileStatusCard status={profileStatus} />

        {/* ===== Stats row ===== */}
        <View style={styles.statsRow}>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>XP</Text>
            <Text style={styles.statValue}>{xp}</Text>
            <Text style={styles.statHint}>Earned by learning from others</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>Points</Text>
            <Text style={styles.statValue}>{points}</Text>
            <Text style={styles.statHint}>Earned by teaching others</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statLabel}>Streak</Text>
            <Text style={styles.statValue}>{streak}</Text>
            <Text style={styles.statHint}>Active days in a row</Text>
          </View>
        </View>

        {/* ===== Quick actions ===== */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Quick actions</Text>
          <Text style={styles.sectionSubtitle}>
            Start from one of these common actions.
          </Text>

          <View style={styles.quickRow}>
            <TouchableOpacity
              style={[styles.quickCard, styles.quickPrimary]}
              onPress={handleFindMentor}
              activeOpacity={0.85}
            >
              <Text style={styles.quickEmoji}>🧑‍🏫</Text>
              <Text style={styles.quickTitle}>Find a mentor</Text>
              <Text style={styles.quickText}>
                Discover people who can help you with your learning goals.
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.quickCard, styles.quickSecondary]}
              onPress={handleGoSessions}
              activeOpacity={0.85}
            >
              <Text style={styles.quickEmoji}>📅</Text>
              <Text style={styles.quickTitle}>My sessions</Text>
              <Text style={styles.quickText}>
                View requests, accept/reject, and manage upcoming sessions.
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* ===== Messages (Inbox preview) ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Messages</Text>
            <TouchableOpacity
              activeOpacity={0.85}
              onPress={() => router.push("/(tabs)/chats" as any)}
            >
              <Text style={styles.sectionAction}>View all</Text>
            </TouchableOpacity>
          </View>

          <View style={styles.inboxCard}>
            {inboxLoading ? (
              <View style={{ paddingVertical: 10 }}>
                <ActivityIndicator />
                <Text
                  style={{ color: "#94A3B8", marginTop: 8, fontWeight: "800" }}
                >
                  Loading messages…
                </Text>
              </View>
            ) : inbox.length === 0 ? (
              <View>
                <Text style={styles.inboxEmptyTitle}>No messages yet</Text>
                <Text style={styles.inboxEmptyBody}>
                  Start by opening any mentor profile and pressing “Message”.
                </Text>

                <TouchableOpacity
                  style={styles.inboxCta}
                  onPress={handleFindMentor}
                  activeOpacity={0.85}
                >
                  <Text style={styles.inboxCtaText}>Find mentors</Text>
                </TouchableOpacity>
              </View>
            ) : (
              <View style={{ gap: 10 }}>
                {inbox.slice(0, 3).map((c) => {
                  const name = c.peer?.fullName || "Unknown user";
                  const last = c.lastMessageText?.trim()
                    ? c.lastMessageText
                    : "Say hi 👋";
                  const time = inboxTime(c.lastMessageAt);
                  const unread = Number(c.unreadCount || 0);

                  return (
                    <TouchableOpacity
                      key={c.id}
                      activeOpacity={0.88}
                      onPress={() =>
                        router.push({
                          pathname: "/(tabs)/chats/[conversationId]",
                          params: {
                            conversationId: c.id,
                            peerName: c.peer?.fullName || "Chat",
                            peerId: c.peer?.id || "",
                          },
                        } as any)
                      }
                      style={styles.inboxRow}
                    >
                      <View style={styles.inboxAvatar}>
                        <Text style={styles.inboxAvatarText}>
                          {inboxInitials(name)}
                        </Text>
                      </View>

                      <View style={{ flex: 1 }}>
                        <View style={styles.inboxTopLine}>
                          <Text style={styles.inboxName} numberOfLines={1}>
                            {name}
                          </Text>

                          <View
                            style={{
                              flexDirection: "row",
                              alignItems: "center",
                              gap: 8,
                            }}
                          >
                            {!!unread && (
                              <View style={styles.inboxBadge}>
                                <Text style={styles.inboxBadgeText}>
                                  {unread > 99 ? "99+" : String(unread)}
                                </Text>
                              </View>
                            )}
                            {!!time && (
                              <Text style={styles.inboxTime}>{time}</Text>
                            )}
                          </View>
                        </View>

                        <Text style={styles.inboxLast} numberOfLines={1}>
                          {last}
                        </Text>
                      </View>
                    </TouchableOpacity>
                  );
                })}
              </View>
            )}
          </View>
        </View>

        {/* ===== Skills learn ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Skills you want to learn</Text>
            <TouchableOpacity activeOpacity={0.85} onPress={handleGoLearn}>
              <Text style={styles.sectionAction}>Manage</Text>
            </TouchableOpacity>
          </View>

          {user?.skillsToLearn?.length ? (
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.horizontalChips}
            >
              {user.skillsToLearn.map((skill, idx) => (
                <View key={`${skill.name}-${idx}`} style={styles.chip}>
                  <Text style={styles.chipText}>
                    {skill.name}
                    {skill.level && skill.level !== "Not specified"
                      ? ` · ${skill.level}`
                      : ""}
                  </Text>
                </View>
              ))}
            </ScrollView>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No learning goals yet</Text>
              <Text style={styles.emptyText}>
                Add a few skills you’re interested in, so we can match you with
                the right mentors.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoLearn}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>Add learning goals</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Skills teach ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Skills you can teach</Text>
            <TouchableOpacity activeOpacity={0.85} onPress={handleGoTeach}>
              <Text style={styles.sectionAction}>Manage</Text>
            </TouchableOpacity>
          </View>

          {user?.skillsToTeach?.length ? (
            <View style={styles.teachList}>
              {user.skillsToTeach.map((skill, idx) => (
                <View key={`${skill.name}-${idx}`} style={styles.teachCard}>
                  <View style={{ flex: 1 }}>
                    <Text style={styles.teachName}>{skill.name}</Text>
                    <Text style={styles.teachLevel}>
                      Level: {skill.level || "Not specified"}
                    </Text>
                  </View>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>Nothing to teach yet</Text>
              <Text style={styles.emptyText}>
                Add at least one skill you feel comfortable teaching. This will
                unlock more ways to earn points.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoTeach}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>Add teaching skills</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Availability ===== */}
        <View style={styles.section}>
          <View style={styles.sectionHeaderRow}>
            <Text style={styles.sectionTitle}>Your weekly availability</Text>
            <TouchableOpacity
              activeOpacity={0.85}
              onPress={handleGoAvailability}
            >
              <Text style={styles.sectionAction}>
                {slots.length ? "Edit" : "Set now"}
              </Text>
            </TouchableOpacity>
          </View>

          <View style={styles.availSummaryCard}>
            <Text style={styles.availSummaryTop}>
              {qualityLabel} · {daysSet} day{daysSet === 1 ? "" : "s"} ·{" "}
              {minutesToHuman(totalMin)} total
            </Text>
            <Text style={styles.availSummaryBottom}>
              {bestDay ? `Best: ${bestDay} · ` : ""}
              Last saved: {lastUpdatedText}
            </Text>
          </View>

          {slots.length ? (
            <View style={styles.availabilityList}>
              {slots.slice(0, 4).map((slot, idx) => (
                <View
                  key={`${slot.dayOfWeek}-${slot.from}-${slot.to}-${idx}`}
                  style={styles.availabilityRow}
                >
                  <Text style={styles.availabilityDay}>
                    {dayNames[slot.dayOfWeek] || "Day"}
                  </Text>
                  <Text style={styles.availabilityTime}>
                    {slot.from} – {slot.to}
                  </Text>
                </View>
              ))}

              {slots.length > 4 && (
                <TouchableOpacity
                  onPress={handleGoAvailability}
                  activeOpacity={0.85}
                  style={styles.availMoreBtn}
                >
                  <Text style={styles.availMoreText}>
                    View all ({slots.length}) →
                  </Text>
                </TouchableOpacity>
              )}
            </View>
          ) : (
            <View style={styles.emptyCard}>
              <Text style={styles.emptyTitle}>No availability set</Text>
              <Text style={styles.emptyText}>
                Set 1–2 time slots (evenings/weekend) to improve mentor matches.
              </Text>
              <TouchableOpacity
                style={styles.primaryCta}
                onPress={handleGoAvailability}
                activeOpacity={0.85}
              >
                <Text style={styles.primaryCtaText}>
                  Set availability (2 mins)
                </Text>
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* ===== Footer ===== */}
        <View style={styles.footerRow}>
          <Text style={styles.footerHint}>
            Availability saved: {lastUpdatedText}
          </Text>
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
            activeOpacity={0.85}
          >
            <Text style={styles.logoutText}>Sign out</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#020617" },
  scroll: { flex: 1 },
  scrollContent: { paddingHorizontal: 16, paddingTop: 20, paddingBottom: 32 },

  loadingScreen: {
    flex: 1,
    backgroundColor: "#020617",
    alignItems: "center",
    justifyContent: "center",
  },
  loadingText: { marginTop: 12, color: "#9CA3AF", fontSize: 14 },

  heroCard: {
    backgroundColor: "#020617",
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    borderColor: "#1E293B",
    marginBottom: 12,
  },
  heroRow: { flexDirection: "row", alignItems: "center", marginBottom: 12 },
  greeting: { color: "#9CA3AF", fontSize: 13 },
  name: { color: "#F9FAFB", fontSize: 22, fontWeight: "700", marginTop: 2 },
  tagline: { color: "#64748B", fontSize: 12, marginTop: 6 },

  avatar: {
    width: 50,
    height: 50,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1F2937",
    alignItems: "center",
    justifyContent: "center",
    marginLeft: 12,
  },
  avatarText: { color: "#F97316", fontSize: 18, fontWeight: "700" },

  heroBottomRow: { flexDirection: "row", alignItems: "center", marginTop: 4 },
  levelColumn: { width: 64, alignItems: "flex-start" },
  levelLabel: { color: "#94A3B8", fontSize: 11 },
  levelValue: {
    color: "#E5E7EB",
    fontSize: 20,
    fontWeight: "700",
    marginTop: 2,
  },

  progressColumn: { flex: 1, marginHorizontal: 12 },
  progressHeader: { flexDirection: "row", justifyContent: "space-between" },
  progressLabel: { color: "#94A3B8", fontSize: 11 },
  progressValue: { color: "#CBD5F5", fontSize: 11 },
  progressBarBackground: {
    marginTop: 6,
    height: 8,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    overflow: "hidden",
  },
  progressBarFill: { height: "100%", backgroundColor: "#F97316" },

  streakBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#F97316",
    flexDirection: "row",
    alignItems: "center",
  },
  streakEmoji: { marginRight: 4 },
  streakText: { color: "#FED7AA", fontSize: 11, fontWeight: "600" },

  pendingChip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#334155",
    backgroundColor: "#0B1120",
  },
  pendingChipText: { color: "#E5E7EB", fontSize: 11, fontWeight: "800" },

  errorBox: {
    backgroundColor: "#451A1A",
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: "#FCA5A5",
    marginBottom: 16,
  },
  errorTitle: {
    color: "#FECACA",
    fontWeight: "600",
    marginBottom: 4,
    fontSize: 13,
  },
  errorBody: { color: "#FECACA", fontSize: 12, marginBottom: 8 },
  retryButton: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#B91C1C",
  },
  retryText: { color: "#FEE2E2", fontSize: 12, fontWeight: "500" },

  statsRow: { flexDirection: "row", gap: 8, marginBottom: 18 },
  statCard: {
    flex: 1,
    backgroundColor: "#020617",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  statLabel: { color: "#94A3B8", fontSize: 11, marginBottom: 4 },
  statValue: { color: "#F9FAFB", fontSize: 18, fontWeight: "700" },
  statHint: { color: "#64748B", fontSize: 10, marginTop: 4 },

  section: { marginBottom: 20 },
  sectionHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  sectionTitle: { color: "#F9FAFB", fontSize: 16, fontWeight: "600" },
  sectionSubtitle: { color: "#64748B", fontSize: 12, marginBottom: 8 },
  sectionAction: { color: "#60A5FA", fontSize: 13, fontWeight: "500" },

  quickRow: { flexDirection: "row", gap: 10, marginTop: 6 },
  quickCard: { flex: 1, borderRadius: 16, padding: 12, borderWidth: 1 },
  quickPrimary: { backgroundColor: "#0F172A", borderColor: "#1D4ED8" },
  quickSecondary: { backgroundColor: "#020617", borderColor: "#4B5563" },
  quickEmoji: { fontSize: 20, marginBottom: 6 },
  quickTitle: {
    color: "#F9FAFB",
    fontSize: 14,
    fontWeight: "600",
    marginBottom: 4,
  },
  quickText: { color: "#9CA3AF", fontSize: 12 },

  // ===== Inbox styles =====
  inboxCard: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#111827",
    borderRadius: 16,
    padding: 12,
  },
  inboxRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    backgroundColor: "#020617",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 14,
    padding: 10,
  },
  inboxAvatar: {
    width: 40,
    height: 40,
    borderRadius: 999,
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    alignItems: "center",
    justifyContent: "center",
  },
  inboxAvatarText: { color: "#F97316", fontWeight: "900", fontSize: 14 },
  inboxTopLine: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 10,
  },
  inboxName: { color: "#E5E7EB", fontWeight: "900", maxWidth: 210 },
  inboxLast: { color: "#94A3B8", marginTop: 4, fontSize: 12 },
  inboxTime: { color: "#64748B", fontSize: 11, fontWeight: "800" },
  inboxBadge: {
    backgroundColor: "#F97316",
    borderWidth: 1,
    borderColor: "#FB923C",
    paddingHorizontal: 8,
    height: 18,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  inboxBadgeText: { color: "#111827", fontWeight: "900", fontSize: 10 },
  inboxEmptyTitle: { color: "#E5E7EB", fontWeight: "900" },
  inboxEmptyBody: { color: "#94A3B8", marginTop: 6 },
  inboxCta: {
    marginTop: 10,
    alignSelf: "flex-start",
    backgroundColor: "#F97316",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
  },
  inboxCtaText: { color: "#ffffff", fontWeight: "900" },

  // ===== rest =====
  horizontalChips: { paddingVertical: 4, paddingRight: 4, gap: 8 },
  chip: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "#0F172A",
    borderWidth: 1,
    borderColor: "#1E293B",
    marginRight: 8,
  },
  chipText: { color: "#E5E7EB", fontSize: 12 },

  emptyCard: {
    backgroundColor: "#020617",
    borderRadius: 14,
    padding: 12,
    borderWidth: 1,
    borderColor: "#111827",
  },
  emptyTitle: {
    color: "#E5E7EB",
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 4,
  },
  emptyText: { color: "#64748B", fontSize: 12 },

  teachList: { gap: 8 },
  teachCard: {
    backgroundColor: "#020617",
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    borderColor: "#1E293B",
  },
  teachName: { color: "#F9FAFB", fontSize: 14, fontWeight: "600" },
  teachLevel: { color: "#9CA3AF", fontSize: 12, marginTop: 2 },

  availSummaryCard: {
    backgroundColor: "#0B1120",
    borderWidth: 1,
    borderColor: "#1E293B",
    borderRadius: 12,
    padding: 10,
    marginBottom: 10,
  },
  availSummaryTop: { color: "#E5E7EB", fontSize: 12, fontWeight: "600" },
  availSummaryBottom: { color: "#94A3B8", fontSize: 11, marginTop: 4 },

  availabilityList: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "#111827",
    backgroundColor: "#020617",
    paddingVertical: 4,
  },
  availabilityRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: "#020617",
  },
  availabilityDay: { color: "#E5E7EB", fontSize: 13 },
  availabilityTime: { color: "#9CA3AF", fontSize: 13 },

  availMoreBtn: {
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderTopWidth: 1,
    borderTopColor: "#0B1120",
  },
  availMoreText: { color: "#60A5FA", fontSize: 12, fontWeight: "600" },

  primaryCta: {
    marginTop: 10,
    borderRadius: 999,
    paddingVertical: 10,
    alignItems: "center",
    backgroundColor: "#F97316",
  },
  primaryCtaText: { color: "#ffffff", fontWeight: "700", fontSize: 13 },

  footerRow: {
    marginTop: 8,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  footerHint: { color: "#6B7280", fontSize: 11 },
  logoutButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "#4B5563",
  },
  logoutText: { color: "#E5E7EB", fontSize: 12 },
});
</file>

<file path="lib/api.ts">
// lib/api.ts
import Constants from "expo-constants";
import { Platform } from "react-native";

function getDevHostFromExpo(): string | null {
  // Expo dev host (often available in dev mode)
  const anyConst = Constants as any;

  // common places across SDKs
  const debuggerHost: string | undefined = anyConst?.debuggerHost;
  const hostUri: string | undefined = anyConst?.expoConfig?.hostUri;

  const raw = debuggerHost || hostUri || "";
  if (!raw) return null;

  // examples:
  // "192.168.1.50:8081"
  // "exp://192.168.1.50:8081"
  // "http://192.168.1.50:8081"
  const cleaned = raw
    .replace("exp://", "")
    .replace("http://", "")
    .replace("https://", "");
  const host = cleaned.split(":")[0]?.trim();
  return host || null;
}

function resolveApiUrl(): string {
  const envUrlRaw = (process.env.EXPO_PUBLIC_API_URL || "").trim();

  // In Web we can safely use localhost if server is on same machine
  if (Platform.OS === "web") {
    // Prefer explicit env if provided
    if (envUrlRaw) return envUrlRaw;

    const host =
      (typeof window !== "undefined" && window.location?.hostname) || "localhost";
    return `http://${host}:4000`;
  }

  // Native (Android/iOS)
  // If user mistakenly set localhost in env, it breaks real devices.
  // We'll ignore localhost env on native and auto-resolve correctly.
  const envIsLocalhost =
    envUrlRaw.includes("localhost") || envUrlRaw.includes("127.0.0.1");

  if (envUrlRaw && !envIsLocalhost) {
    return envUrlRaw;
  }

  const hostFromExpo = getDevHostFromExpo();

  // Android emulator special-case
  if (Platform.OS === "android") {
    if (!hostFromExpo) return "http://10.0.2.2:4000";
    if (hostFromExpo === "localhost" || hostFromExpo === "127.0.0.1") {
      return "http://10.0.2.2:4000";
    }
    return `http://${hostFromExpo}:4000`;
  }

  // iOS simulator / real device
  if (hostFromExpo) return `http://${hostFromExpo}:4000`;

  // Last fallback
  return "http://localhost:4000";
}

export const API_URL = resolveApiUrl();
console.log("🔗 API_URL resolved to:", API_URL);

async function handleResponse(res: Response) {
  const text = await res.text();

  let data: any = null;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    console.log("API ERROR =>", {
      url: res.url,
      status: res.status,
      rawBody: text,
      parsed: data,
    });

    const message =
      (data && (data as any).error) ||
      (data && (data as any).message) ||
      (typeof data === "string" && data) ||
      `Request failed with status ${res.status}`;

    throw new Error(message);
  }

  return data;
}

// ---------- AUTH ----------
export async function signup(params: {
  fullName: string;
  email: string;
  password: string;
}) {
  const res = await fetch(`${API_URL}/auth/signup`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

export async function login(params: { email: string; password: string }) {
  const res = await fetch(`${API_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return handleResponse(res);
}

// ---------- TYPES ----------
export type AvailabilitySlot = { dayOfWeek: number; from: string; to: string };
export type SkillTeach = { name: string; level: string };
export type SkillLearn = { name: string; level: string };

export type MentorMatch = {
  mentorId: string;
  fullName: string;
  matchScore: number;
  mainMatchedSkill?: { name: string; level: string; similarityScore: number };
  skillsToTeach?: SkillTeach[];
  availabilitySlots?: AvailabilitySlot[];
};

export type MatchingMode = "local" | "openai" | "hybrid";

export type MatchingStatus = {
  openaiAvailable: boolean;
  reason: "OK" | "NO_KEY" | "ERROR" | string;
  recommendedMode: "local" | "hybrid";
};

export type MatchingMeta = {
  requestedMode: MatchingMode | null;
  modeUsed: MatchingMode | null;
  fallbackUsed: boolean;
  message?: string;
};

// ---------- USER ----------
export async function getMe(token: string) {
  const res = await fetch(`${API_URL}/api/me`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}

// ---------- PROFILE UPDATE ----------
export async function updateProfile(
  token: string,
  partial: {
    skillsToLearn?: SkillLearn[];
    skillsToTeach?: SkillTeach[];
    availabilitySlots?: AvailabilitySlot[];
  }
) {
  const res = await fetch(`${API_URL}/api/me/profile`, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(partial),
  });

  return handleResponse(res);
}

export async function updateWeeklyAvailability(
  token: string,
  availabilitySlots: AvailabilitySlot[]
) {
  return updateProfile(token, { availabilitySlots });
}

export async function updateSkillsToTeach(token: string, skillsToTeach: SkillTeach[]) {
  return updateProfile(token, { skillsToTeach });
}

export async function updateSkillsToLearn(token: string, skillsToLearn: SkillLearn[]) {
  return updateProfile(token, { skillsToLearn });
}

// ---------- MATCHING STATUS ----------
export async function getMatchingStatus(): Promise<MatchingStatus> {
  const res = await fetch(`${API_URL}/api/matching/status`, { method: "GET" });
  return handleResponse(res);
}

// ---------- MATCHING ----------
export async function getMentorMatches(
  token: string,
  params: {
    skill: string;
    level: "Beginner" | "Intermediate" | "Advanced";
    availabilitySlots?: AvailabilitySlot[];
    mode?: MatchingMode;
  }
): Promise<{ results: MentorMatch[]; meta?: MatchingMeta }> {
  const res = await fetch(`${API_URL}/api/matches/mentors`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({
      skill: params.skill,
      level: params.level,
      availabilitySlots: params.availabilitySlots ?? [],
      mode: params.mode,
    }),
  });

  return handleResponse(res);
}

// ---------- PUBLIC USER PROFILE (Mentor) ----------
export type PublicUserProfile = {
  id: string;
  fullName: string;
  points: number;
  xp: number;
  streak: number;
  avgRating: number;
  ratingCount: number;
  skillsToTeach: SkillTeach[];
  availabilitySlots: AvailabilitySlot[];
  preferences?: { communicationModes?: string[]; languages?: string[] };
};

export async function getPublicUserProfile(token: string, userId: string): Promise<PublicUserProfile> {
  const res = await fetch(`${API_URL}/api/users/${userId}`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleResponse(res);
}
</file>

</files>
